/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_fp__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_fp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_fp__);
/* harmony export (immutable) */ __webpack_exports__["g"] = getZones;
/* harmony export (immutable) */ __webpack_exports__["h"] = filterZonesByNumber;
/* harmony export (immutable) */ __webpack_exports__["d"] = maxNum;
/* harmony export (immutable) */ __webpack_exports__["e"] = minNum;
/* unused harmony export getDifference */
/* harmony export (immutable) */ __webpack_exports__["f"] = flatten;
/* unused harmony export journeyToKey */
/* unused harmony export getDailyCap */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCap; });
/* harmony export (immutable) */ __webpack_exports__["c"] = getSingleFare;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return met; });


/**
 * Gets Zones
 * @function
 * @param {string} napTan - The naptan of the station we're looking for.
 * @param {object} stations - An object containing stations with napTans as keys.
 * @returns {array}
 * @description Uses the napTan ID to figure out what zone that station is in via station.json
 */
function getZones(napTan, stations) {
  return stations[napTan].zones;
}

/**
 * filters a nested array based on its length 
 * @function
 * @param {number} num - either 1 (for single zone) or 2 (dual zone)
 * @param {nested array} zones - the nested array of arrays (of zones)
 * @returns {nested array} - nested array of all array of zones from stations that only have one zone associated with it (if num = 1) or...
 * @description - zones refers to global allZones / used to filter the station zones by the number of zones it has (dual zone or single zone)
 */
function filterZonesByNumber(num, zones) {
  return zones.filter(function (zone) {
    return zone.length === num;
  });
}

/**
 * Compares Numbers
 * @function
 * @param {array} numbers - the array of number(s)
 * @param {object} operator - what javascript operator passing through (e.g. Math.max)
 * @returns {number} - the single number after all calculations (reduces to one number)
 * @description Associated with minNum and maxNum: where arrayZones refers to zonesFromSingleStations.
 Loops through the array of zones and applies the operator
 */
function compareNumbers(arrayNumbers, operator) {
  return arrayNumbers.reduce(function (a, b) {
    return operator(a, b);
  });
}

function maxNum(arrayZones) {
  return compareNumbers(arrayZones, Math.max);
}

function minNum(arrayZones) {
  return compareNumbers(arrayZones, Math.min);
}

/**
 * Get difference between 2 numbers
 * @function
 * @param {numbers} a,b - the two numbers comparing against
 * @returns {number} - the difference between the 2 numbers (discarding negative numbers)
 * @description
 */
function getDifference(a, b) {
  return Math.abs(a - b);
  // return a - b;
}

/**
 * Flattens a nested array
 * @function
 * @param {array} array that is an array within another array
 * @returns {number} - flattens the array so just one array
 * @description
 */
function flatten(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(b);
  });
}

/**
 * Sort an array of 2 zones chronologically and adds '-'
 * @function
 * @param {array} journey - the array of the 2 zones of that journey
 * @returns {string} - 'x-y'
 * @description - used to get the fares from the json file
 */
function journeyToKey(journey) {
  return journey.sort().join('-');
}

function zoneToJourney(zone) {
  return journeyToKey([1, zone]);
}

/**
 * Gets the daily cap cost
 * @function
 * @param {number} - the (maximum) zone
 * @param {object} dailyCaps - looks at the dailyCaps object in the fares.json file
 * @returns {number} - gets the daily cap between zones 1 and the zone parameter (as daily caps always starts at zone 1)
 * @description
 */
function getDailyCap(maxZonesofar, dailyCaps, type) {
  return dailyCaps[journeyToKey([1, maxZonesofar])][type];
}

var getCap = __WEBPACK_IMPORTED_MODULE_0_lodash_fp___default.a.curry(function (zone, type, caps) {
  return caps[zoneToJourney(zone)][type];
});

/**
 * Gets the single fare
 * @function
 * @param {array} journey - the array of the 2 zones travelling between
 * @param {object} singleFares - looks at the singleFares object in the fares.json file
 * @returns {number} - gets the single fare between those two zones
 * @description
 */
function getSingleFare(journey, singleFares, type) {
  // debugger;
  return singleFares[journeyToKey(journey)][type];
}

/**
 * Determines if a numeric target has been met or surpassed
 * @function
 * @param {number} target - target value to compare against
 * @param {number} value - the value to compare against the target
 * @description
 */
var met = __WEBPACK_IMPORTED_MODULE_0_lodash_fp___default.a.curry(function (target, value) {
  return value >= target;
});

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_utility__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__splitOrFullFare__ = __webpack_require__(13);
/* unused harmony export default */




// /**
//  * Calculates the extension fare (or none) of a journey
//  * @function
//  * @param {object} see below
//  * @param {singleFares} uses the singleFares json data
//  * @returns {number} - returns the extension fare for the journey
//  * @description
//
// 	FOR DAILY CAPS: ALWAYS START AT 1 SO MOST OF THIS CODE TOO COMPLEX: but would still work
// 	FOR WEEKLY CAPS: this works out fare without any daily caps or mix daily and weekly where there are no gap zones (so between 1 and max zone of either daily or weekly cap) -- unless you add in MaxDaily
//  // this is overly complicated for daily caps (as only deals with zone 1 to x) but still works. RELIES ON THE FACT DAILY ALWAYS STARTS AT 1
//  */

function extensionFares() {
	var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var singleFares = arguments[1];

	var maxDaily = options.maxDaily || null;
	// by default: just one travelcard (weekly without daily or just daily cap) for either oyster or contactless, or oyster with weekly cap (doesn't cut off daily section of the journey)

	var zones = options.zones,
	    type = options.type,
	    minTravelcard = options.minTravelcard,
	    maxTravelcard = options.maxTravelcard;
	// same as var minSingle = options.minSingle;

	var finalCondition = null;
	var minSingle = zones[0];
	var maxSingle = zones[1];
	var minChargedZone = minSingle;

	if (maxDaily) {
		// If contactless, daily and weekly combo (hence adding in maxDaily as argument_
		if (maxDaily >= minTravelcard - 1) {
			// if no gap zones between max daily and min travelcard
			minTravelcard = 1; // since anytime daily caps always start at zone 1
			maxTravelcard = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* maxNum */])([maxDaily, maxTravelcard]); // max travelcard is whichever is largest max daily or max travelcard
			// else if contactless, daily and weekly combo, and there are gap zones between max daily and min travelcard, have a min charged zone (not charge the daily cap - the front)
		} else {
			// IF difference bw min weekly and max daily cap > 1 -- THEN THERE ARE GAP ZONES
			minChargedZone = minSingle <= maxDaily ? maxDaily + 1 : minSingle;
			finalCondition = minSingle <= maxDaily && maxSingle <= maxDaily;
		}
	}

	// if min single isnt within travelcard zones but max single is(NB not needed for daily cap) - charge front
	if (minSingle < minTravelcard && minTravelcard <= maxSingle && maxSingle <= maxTravelcard) {
		// debugger;
		return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* getSingleFare */])([minChargedZone, minTravelcard - 1], singleFares, type);

		//if min single within travelcard zones but max single isnt - charge end
	} else if (minTravelcard <= minSingle && minSingle <= maxTravelcard && maxSingle > maxTravelcard) {
		// debugger;
		return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* getSingleFare */])([maxTravelcard + 1, maxSingle], singleFares, type);

		//if min single less than min travelcard and max single more than max travelcard (NB not needed for daily cap) - charge front and end
	} else if (minSingle < minTravelcard && maxSingle > maxTravelcard) {
		// debugger;
		return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__splitOrFullFare__["a" /* default */])(minChargedZone, maxSingle, minTravelcard, maxTravelcard, singleFares, type);

		// both single zones within travelcard zones
	} else if (minTravelcard <= minSingle && minSingle <= maxTravelcard && minTravelcard <= maxSingle && maxSingle <= maxTravelcard || finalCondition) {
		// debugger;
		return 0;
		// both single zones are outside travelcard zones
	}

	return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* getSingleFare */])([minChargedZone, maxSingle], singleFares, type);
	// ELSE min single and max single both > max weekly zone (or both < min daily) OR min single zone > min gap zone && max single zone < max gap zone
}

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets fares.json file
 */
var fetchFareData = function () {
	var data = null;

	return function () {
		if (data) {
			console.log('oh! we are getting the cached data!');
			return Promise.resolve(data);
		}

		return fetch('/data/fares.json').then(function (resp) {
			data = resp.json();
			return data;
		});
	};
}();

// Gets station.json - listing what zones each station is
var fetchStationsData = function () {
	var data = null;

	return function () {
		if (data) {
			console.log('oh! we are getting the cached data!');
			return Promise.resolve(data);
		}

		return fetch('/data/stations.json').then(function (resp) {
			data = resp.json();
			return data;
		});
	};
}();

//Fetches the json file from TFL API
var fetchJourneyData = function fetchJourneyData(from, to) {
	return fetch('https://api.tfl.gov.uk/journey/journeyresults/' + from + '/to/' + to + '?app_id=8acd79a9&app_key=d433a2d6d9a9c8e8b1b4a6dd4371c69b').then(function (e) {
		return e.json();
	});
};

/* harmony default export */ __webpack_exports__["a"] = {
	fares: fetchFareData,
	stations: fetchStationsData,
	journey: fetchJourneyData
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(10).runInContext();
module.exports = __webpack_require__(7)(_, _);

/***/ }),
/* 4 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_getData__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility_utility__ = __webpack_require__(0);
/* unused harmony export default */
//The complete function in order to get the minimum and maximum zones of that journey (taking into consideration dual zones)
// stations is the .json file from fetchStationsData() function
// Need to make it so that it generates it after each journey




function getSingleJourneyZones(from, to, stations) {
	return __WEBPACK_IMPORTED_MODULE_0__utility_getData__["a" /* default */].journey(from, to).then(function (journey) {
		var journey = journey.journeys[0]; // selecting only the first journey from the API
		var legs = journey.legs; //To look at each leg of the journey

		// The array of zones associated with all stations of that journey
		var allZones = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(legs.map(function (leg) {
			var tempZones = [];

			//Gets the zones of the departurePoints and adds them to allZones array
			if (leg.departurePoint && leg.departurePoint.naptanId) {
				tempZones.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["g" /* getZones */])(leg.departurePoint.naptanId, stations));
			}

			//Gets the zones of the StopPoint and adds them to allZones array
			if (leg.path.stopPoints && leg.path.stopPoints.length > 0) {
				leg.path.stopPoints.forEach(function (stopPoint) {
					if (stopPoint.id) {
						tempZones.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["g" /* getZones */])(stopPoint.id, stations));
					}
				});
			}

			return tempZones;
		}));

		//Filters all the stations and split them into zonesFromSingleStations and zonesFromDualStations
		// var zonesFromSingleStations = flatten(filterZonesByNumber(1, allZones));
		var zonesFromSingleStations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["h" /* filterZonesByNumber */])(1, allZones);
		var zonesFromDualStations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["h" /* filterZonesByNumber */])(2, allZones); //NB this is an array within an array
		var finalMaxZone = null;
		var finalMinZone = null;

		if (zonesFromSingleStations.length === 0) {
			//for dual zones to dual zones **ASSUMING CAN ONLY TRAVEL FROM THE SAME DUAL ZONES (2/3 to 2/3 and not 2/3 to 3/4)**
			finalMaxZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(zonesFromDualStations));
			finalMinZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(zonesFromDualStations));
			//**NEED TO ADD A FLAG HERE to say that it is dual to dual zone & what zones (so that can manipulate and pick zones from closest to weekly capped zone rather than min zone)
		} else {
			zonesFromSingleStations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["h" /* filterZonesByNumber */])(1, allZones));

			//Calculates the max and min Zones of all the zones that are from stations without any dual zones.
			var singleMax = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["d" /* maxNum */])(zonesFromSingleStations);
			var singleMin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])(zonesFromSingleStations);

			//For each zonesFromDualStations: picks the most appropriate zone and appends to dualZones array 
			// --> Going from 2/3 to 2/3 â€”> charges same single 2, 3 or 2-3 (1.70) but should pick zone based on weekly (could be 3) or cap (always smallest: 2)
			var dualZones = zonesFromDualStations.map(function (z) {
				return z.reduce(function (a, b) {
					if (getDifference(a, singleMin) < getDifference(b, singleMin)) {
						return a;
					}
					return b;
				});
			});

			//Adds dualZones to singleMax into an array and calculates the max and min zone of both
			finalMaxZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["d" /* maxNum */])([singleMax].concat(dualZones));
			finalMinZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])([singleMin].concat(dualZones));
		}

		return [finalMinZone, finalMaxZone];
	});
}

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_fp__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_fp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_fp__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_treis__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_treis___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_treis__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utility_utility__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__extensionFares__ = __webpack_require__(1);
/* harmony export (immutable) */ __webpack_exports__["a"] = oysterDayTotal;
/**
 * Calculates the oyster total fare for the day
 * @function
 * @param {journey} zones and off peak or on peak
 * @param {json data} uses the singleFares json data
 * @returns {number} - returns the total fare
 * @description
 */

// and single fare is calculated uusing extensionFare function instead
// Need set an alert for when reach a Zones 1-4 or Zones 1-6 daily cap, but only travel at off-peak times.








function oysterDayTotal() {
  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var singleFares = arguments[1];
  var journeys = data.journeys,
      dailyCaps = data.dailyCaps;


  var getDailyCap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utility_utility__["a" /* getCap */])(__WEBPACK_IMPORTED_MODULE_0_lodash_fp___default.a, __WEBPACK_IMPORTED_MODULE_0_lodash_fp___default.a, dailyCaps); // WTF
  var capMet = __WEBPACK_IMPORTED_MODULE_0_lodash_fp___default.a.compose(__WEBPACK_IMPORTED_MODULE_2__utility_utility__["b" /* met */], getDailyCap); //WTF

  var totals = journeys.reduce(function (a, b) {

    // if (maxTravelcard) { for weekly

    //   const singleFare = extensionFares({
    //     zones: b.zones,
    //     minTravelcard, //since same naming, shorthand for "minTravelcard": minTravelcard;
    //     maxTravelcard,
    //     type: b.type,
    //   }, singleFares);

    // } else {

    var singleFare = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utility_utility__["c" /* getSingleFare */])(b.zones, singleFares, b.type); //b.zones = an array
    // }

    var maxZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utility_utility__["d" /* maxNum */])([].concat(a.maxZone, b.zones));
    //     FOR WEEKLY
    // if ((maxTravelcard) && (maxZone <= maxTravelcard) && (maxZone >= (minTravelcard - 1))) {
    //   maxZone = minTravelcard -1; //(ie only compares against daily cap of minSingle to zoneDaily - removes overlap with weekly)
    // }

    var metDailyCap = capMet(maxZone, 'anytime'); //true or false

    var peakTotal = a.peakTotal + singleFare;
    var offPeakTotal = a.offPeakTotal + singleFare;

    //if OFF peak travel and the OFF PEAK daily cap for current maximum zone is reached, then the cum total is overriden by the relevant maximum zone daily cap fare
    // if (b.type === 'offPeak' && metDailyCap(offPeakTotal)) {
    //   debugger;
    //   offPeakTotal = getDailyCap(maxZone, 'offPeak'); //and set an alert to say off daily cap reached????!!! (but could be overridden after)
    // }

    //if the daily cap for the current maximum zone is reached, then the cum total is overriden by the relevant maximum zone daily cap fare

    if (metDailyCap(peakTotal)) {
      peakTotal = getDailyCap(maxZone, 'anytime');
    }

    return {
      peakTotal: peakTotal,
      offPeakTotal: offPeakTotal,
      maxZone: maxZone
    };
  }, {
    peakTotal: 0,
    offPeakTotal: 0,
    maxZone: null
  });

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utility_utility__["e" /* minNum */])([totals.peakTotal, totals.offPeakTotal]);
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var mapping = __webpack_require__(8),
    fallbackHolder = __webpack_require__(9);

/** Built-in value reference. */
var push = Array.prototype.push;

/**
 * Creates a function, with an arity of `n`, that invokes `func` with the
 * arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} n The arity of the new function.
 * @returns {Function} Returns the new function.
 */
function baseArity(func, n) {
  return n == 2 ? function (a, b) {
    return func.apply(undefined, arguments);
  } : function (a) {
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that invokes `func`, with up to `n` arguments, ignoring
 * any additional arguments.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @param {number} n The arity cap.
 * @returns {Function} Returns the new function.
 */
function baseAry(func, n) {
  return n == 2 ? function (a, b) {
    return func(a, b);
  } : function (a) {
    return func(a);
  };
}

/**
 * Creates a clone of `array`.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the cloned array.
 */
function cloneArray(array) {
  var length = array ? array.length : 0,
      result = Array(length);

  while (length--) {
    result[length] = array[length];
  }
  return result;
}

/**
 * Creates a function that clones a given object using the assignment `func`.
 *
 * @private
 * @param {Function} func The assignment function.
 * @returns {Function} Returns the new cloner function.
 */
function createCloner(func) {
  return function (object) {
    return func({}, object);
  };
}

/**
 * A specialized version of `_.spread` which flattens the spread array into
 * the arguments of the invoked `func`.
 *
 * @private
 * @param {Function} func The function to spread arguments over.
 * @param {number} start The start position of the spread.
 * @returns {Function} Returns the new function.
 */
function flatSpread(func, start) {
  return function () {
    var length = arguments.length,
        lastIndex = length - 1,
        args = Array(length);

    while (length--) {
      args[length] = arguments[length];
    }
    var array = args[start],
        otherArgs = args.slice(0, start);

    if (array) {
      push.apply(otherArgs, array);
    }
    if (start != lastIndex) {
      push.apply(otherArgs, args.slice(start + 1));
    }
    return func.apply(this, otherArgs);
  };
}

/**
 * Creates a function that wraps `func` and uses `cloner` to clone the first
 * argument it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} cloner The function to clone arguments.
 * @returns {Function} Returns the new immutable function.
 */
function wrapImmutable(func, cloner) {
  return function () {
    var length = arguments.length;
    if (!length) {
      return;
    }
    var args = Array(length);
    while (length--) {
      args[length] = arguments[length];
    }
    var result = args[0] = cloner.apply(undefined, args);
    func.apply(undefined, args);
    return result;
  };
}

/**
 * The base implementation of `convert` which accepts a `util` object of methods
 * required to perform conversions.
 *
 * @param {Object} util The util object.
 * @param {string} name The name of the function to convert.
 * @param {Function} func The function to convert.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.cap=true] Specify capping iteratee arguments.
 * @param {boolean} [options.curry=true] Specify currying.
 * @param {boolean} [options.fixed=true] Specify fixed arity.
 * @param {boolean} [options.immutable=true] Specify immutable operations.
 * @param {boolean} [options.rearg=true] Specify rearranging arguments.
 * @returns {Function|Object} Returns the converted function or object.
 */
function baseConvert(util, name, func, options) {
  var setPlaceholder,
      isLib = typeof name == 'function',
      isObj = name === Object(name);

  if (isObj) {
    options = func;
    func = name;
    name = undefined;
  }
  if (func == null) {
    throw new TypeError();
  }
  options || (options = {});

  var config = {
    'cap': 'cap' in options ? options.cap : true,
    'curry': 'curry' in options ? options.curry : true,
    'fixed': 'fixed' in options ? options.fixed : true,
    'immutable': 'immutable' in options ? options.immutable : true,
    'rearg': 'rearg' in options ? options.rearg : true
  };

  var forceCurry = 'curry' in options && options.curry,
      forceFixed = 'fixed' in options && options.fixed,
      forceRearg = 'rearg' in options && options.rearg,
      placeholder = isLib ? func : fallbackHolder,
      pristine = isLib ? func.runInContext() : undefined;

  var helpers = isLib ? func : {
    'ary': util.ary,
    'assign': util.assign,
    'clone': util.clone,
    'curry': util.curry,
    'forEach': util.forEach,
    'isArray': util.isArray,
    'isFunction': util.isFunction,
    'iteratee': util.iteratee,
    'keys': util.keys,
    'rearg': util.rearg,
    'toInteger': util.toInteger,
    'toPath': util.toPath
  };

  var ary = helpers.ary,
      assign = helpers.assign,
      clone = helpers.clone,
      curry = helpers.curry,
      each = helpers.forEach,
      isArray = helpers.isArray,
      isFunction = helpers.isFunction,
      keys = helpers.keys,
      rearg = helpers.rearg,
      toInteger = helpers.toInteger,
      toPath = helpers.toPath;

  var aryMethodKeys = keys(mapping.aryMethod);

  var wrappers = {
    'castArray': function castArray(_castArray) {
      return function () {
        var value = arguments[0];
        return isArray(value) ? _castArray(cloneArray(value)) : _castArray.apply(undefined, arguments);
      };
    },
    'iteratee': function iteratee(_iteratee) {
      return function () {
        var func = arguments[0],
            arity = arguments[1],
            result = _iteratee(func, arity),
            length = result.length;

        if (config.cap && typeof arity == 'number') {
          arity = arity > 2 ? arity - 2 : 1;
          return length && length <= arity ? result : baseAry(result, arity);
        }
        return result;
      };
    },
    'mixin': function mixin(_mixin) {
      return function (source) {
        var func = this;
        if (!isFunction(func)) {
          return _mixin(func, Object(source));
        }
        var pairs = [];
        each(keys(source), function (key) {
          if (isFunction(source[key])) {
            pairs.push([key, func.prototype[key]]);
          }
        });

        _mixin(func, Object(source));

        each(pairs, function (pair) {
          var value = pair[1];
          if (isFunction(value)) {
            func.prototype[pair[0]] = value;
          } else {
            delete func.prototype[pair[0]];
          }
        });
        return func;
      };
    },
    'nthArg': function nthArg(_nthArg) {
      return function (n) {
        var arity = n < 0 ? 1 : toInteger(n) + 1;
        return curry(_nthArg(n), arity);
      };
    },
    'rearg': function rearg(_rearg) {
      return function (func, indexes) {
        var arity = indexes ? indexes.length : 0;
        return curry(_rearg(func, indexes), arity);
      };
    },
    'runInContext': function runInContext(_runInContext) {
      return function (context) {
        return baseConvert(util, _runInContext(context), options);
      };
    }
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Casts `func` to a function with an arity capped iteratee if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @returns {Function} Returns the cast function.
   */
  function castCap(name, func) {
    if (config.cap) {
      var indexes = mapping.iterateeRearg[name];
      if (indexes) {
        return iterateeRearg(func, indexes);
      }
      var n = !isLib && mapping.iterateeAry[name];
      if (n) {
        return iterateeAry(func, n);
      }
    }
    return func;
  }

  /**
   * Casts `func` to a curried function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castCurry(name, func, n) {
    return forceCurry || config.curry && n > 1 ? curry(func, n) : func;
  }

  /**
   * Casts `func` to a fixed arity function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the cast function.
   */
  function castFixed(name, func, n) {
    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {
      var data = mapping.methodSpread[name],
          start = data && data.start;

      return start === undefined ? ary(func, n) : flatSpread(func, start);
    }
    return func;
  }

  /**
   * Casts `func` to an rearged function if needed.
   *
   * @private
   * @param {string} name The name of the function to inspect.
   * @param {Function} func The function to inspect.
   * @param {number} n The arity of `func`.
   * @returns {Function} Returns the cast function.
   */
  function castRearg(name, func, n) {
    return config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]) ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n]) : func;
  }

  /**
   * Creates a clone of `object` by `path`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {Array|string} path The path to clone by.
   * @returns {Object} Returns the cloned object.
   */
  function cloneByPath(object, path) {
    path = toPath(path);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        result = clone(Object(object)),
        nested = result;

    while (nested != null && ++index < length) {
      var key = path[index],
          value = nested[key];

      if (value != null) {
        nested[path[index]] = clone(index == lastIndex ? value : Object(value));
      }
      nested = nested[key];
    }
    return result;
  }

  /**
   * Converts `lodash` to an immutable auto-curried iteratee-first data-last
   * version with conversion `options` applied.
   *
   * @param {Object} [options] The options object. See `baseConvert` for more details.
   * @returns {Function} Returns the converted `lodash`.
   */
  function convertLib(options) {
    return _.runInContext.convert(options)(undefined);
  }

  /**
   * Create a converter function for `func` of `name`.
   *
   * @param {string} name The name of the function to convert.
   * @param {Function} func The function to convert.
   * @returns {Function} Returns the new converter function.
   */
  function createConverter(name, func) {
    var realName = mapping.aliasToReal[name] || name,
        methodName = mapping.remap[realName] || realName,
        oldOptions = options;

    return function (options) {
      var newUtil = isLib ? pristine : helpers,
          newFunc = isLib ? pristine[methodName] : func,
          newOptions = assign(assign({}, oldOptions), options);

      return baseConvert(newUtil, realName, newFunc, newOptions);
    };
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`
   * arguments, ignoring any additional arguments.
   *
   * @private
   * @param {Function} func The function to cap iteratee arguments for.
   * @param {number} n The arity cap.
   * @returns {Function} Returns the new function.
   */
  function iterateeAry(func, n) {
    return overArg(func, function (func) {
      return typeof func == 'function' ? baseAry(func, n) : func;
    });
  }

  /**
   * Creates a function that wraps `func` to invoke its iteratee with arguments
   * arranged according to the specified `indexes` where the argument value at
   * the first index is provided as the first argument, the argument value at
   * the second index is provided as the second argument, and so on.
   *
   * @private
   * @param {Function} func The function to rearrange iteratee arguments for.
   * @param {number[]} indexes The arranged argument indexes.
   * @returns {Function} Returns the new function.
   */
  function iterateeRearg(func, indexes) {
    return overArg(func, function (func) {
      var n = indexes.length;
      return baseArity(rearg(baseAry(func, n), indexes), n);
    });
  }

  /**
   * Creates a function that invokes `func` with its first argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function () {
      var length = arguments.length;
      if (!length) {
        return func();
      }
      var args = Array(length);
      while (length--) {
        args[length] = arguments[length];
      }
      var index = config.rearg ? 0 : length - 1;
      args[index] = transform(args[index]);
      return func.apply(undefined, args);
    };
  }

  /**
   * Creates a function that wraps `func` and applys the conversions
   * rules by `name`.
   *
   * @private
   * @param {string} name The name of the function to wrap.
   * @param {Function} func The function to wrap.
   * @returns {Function} Returns the converted function.
   */
  function wrap(name, func) {
    var result,
        realName = mapping.aliasToReal[name] || name,
        wrapped = func,
        wrapper = wrappers[realName];

    if (wrapper) {
      wrapped = wrapper(func);
    } else if (config.immutable) {
      if (mapping.mutate.array[realName]) {
        wrapped = wrapImmutable(func, cloneArray);
      } else if (mapping.mutate.object[realName]) {
        wrapped = wrapImmutable(func, createCloner(func));
      } else if (mapping.mutate.set[realName]) {
        wrapped = wrapImmutable(func, cloneByPath);
      }
    }
    each(aryMethodKeys, function (aryKey) {
      each(mapping.aryMethod[aryKey], function (otherName) {
        if (realName == otherName) {
          var data = mapping.methodSpread[realName],
              afterRearg = data && data.afterRearg;

          result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);

          result = castCap(realName, result);
          result = castCurry(realName, result, aryKey);
          return false;
        }
      });
      return !result;
    });

    result || (result = wrapped);
    if (result == func) {
      result = forceCurry ? curry(result, 1) : function () {
        return func.apply(this, arguments);
      };
    }
    result.convert = createConverter(realName, func);
    if (mapping.placeholder[realName]) {
      setPlaceholder = true;
      result.placeholder = func.placeholder = placeholder;
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  if (!isObj) {
    return wrap(name, func);
  }
  var _ = func;

  // Convert methods by ary cap.
  var pairs = [];
  each(aryMethodKeys, function (aryKey) {
    each(mapping.aryMethod[aryKey], function (key) {
      var func = _[mapping.remap[key] || key];
      if (func) {
        pairs.push([key, wrap(key, func)]);
      }
    });
  });

  // Convert remaining methods.
  each(keys(_), function (key) {
    var func = _[key];
    if (typeof func == 'function') {
      var length = pairs.length;
      while (length--) {
        if (pairs[length][0] == key) {
          return;
        }
      }
      func.convert = createConverter(key, func);
      pairs.push([key, func]);
    }
  });

  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.
  each(pairs, function (pair) {
    _[pair[0]] = pair[1];
  });

  _.convert = convertLib;
  if (setPlaceholder) {
    _.placeholder = placeholder;
  }
  // Assign aliases.
  each(keys(_), function (key) {
    each(mapping.realToAlias[key] || [], function (alias) {
      _[alias] = _[key];
    });
  });

  return _;
}

module.exports = baseConvert;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

/** Used to map aliases to their real names. */
exports.aliasToReal = {

  // Lodash aliases.
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'entries': 'toPairs',
  'entriesIn': 'toPairsIn',
  'extend': 'assignIn',
  'extendAll': 'assignInAll',
  'extendAllWith': 'assignInAllWith',
  'extendWith': 'assignInWith',
  'first': 'head',

  // Methods that are curried variants of others.
  'conforms': 'conformsTo',
  'matches': 'isMatch',
  'property': 'get',

  // Ramda aliases.
  '__': 'placeholder',
  'F': 'stubFalse',
  'T': 'stubTrue',
  'all': 'every',
  'allPass': 'overEvery',
  'always': 'constant',
  'any': 'some',
  'anyPass': 'overSome',
  'apply': 'spread',
  'assoc': 'set',
  'assocPath': 'set',
  'complement': 'negate',
  'compose': 'flowRight',
  'contains': 'includes',
  'dissoc': 'unset',
  'dissocPath': 'unset',
  'dropLast': 'dropRight',
  'dropLastWhile': 'dropRightWhile',
  'equals': 'isEqual',
  'identical': 'eq',
  'indexBy': 'keyBy',
  'init': 'initial',
  'invertObj': 'invert',
  'juxt': 'over',
  'omitAll': 'omit',
  'nAry': 'ary',
  'path': 'get',
  'pathEq': 'matchesProperty',
  'pathOr': 'getOr',
  'paths': 'at',
  'pickAll': 'pick',
  'pipe': 'flow',
  'pluck': 'map',
  'prop': 'get',
  'propEq': 'matchesProperty',
  'propOr': 'getOr',
  'props': 'at',
  'symmetricDifference': 'xor',
  'symmetricDifferenceBy': 'xorBy',
  'symmetricDifferenceWith': 'xorWith',
  'takeLast': 'takeRight',
  'takeLastWhile': 'takeRightWhile',
  'unapply': 'rest',
  'unnest': 'flatten',
  'useWith': 'overArgs',
  'where': 'conformsTo',
  'whereEq': 'isMatch',
  'zipObj': 'zipObject'
};

/** Used to map ary to method names. */
exports.aryMethod = {
  '1': ['assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create', 'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow', 'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll', 'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome', 'rest', 'reverse', 'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart', 'uniqueId', 'words', 'zipAll'],
  '2': ['add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith', 'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith', 'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN', 'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference', 'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq', 'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex', 'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach', 'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get', 'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection', 'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy', 'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty', 'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit', 'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial', 'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll', 'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove', 'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex', 'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy', 'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight', 'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars', 'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith', 'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject', 'zipObjectDeep'],
  '3': ['assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith', 'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr', 'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith', 'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth', 'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd', 'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight', 'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy', 'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy', 'xorWith', 'zipWith'],
  '4': ['fill', 'setWith', 'updateWith']
};

/** Used to map ary to rearg configs. */
exports.aryRearg = {
  '2': [1, 0],
  '3': [2, 0, 1],
  '4': [3, 2, 0, 1]
};

/** Used to map method names to their iteratee ary. */
exports.iterateeAry = {
  'dropRightWhile': 1,
  'dropWhile': 1,
  'every': 1,
  'filter': 1,
  'find': 1,
  'findFrom': 1,
  'findIndex': 1,
  'findIndexFrom': 1,
  'findKey': 1,
  'findLast': 1,
  'findLastFrom': 1,
  'findLastIndex': 1,
  'findLastIndexFrom': 1,
  'findLastKey': 1,
  'flatMap': 1,
  'flatMapDeep': 1,
  'flatMapDepth': 1,
  'forEach': 1,
  'forEachRight': 1,
  'forIn': 1,
  'forInRight': 1,
  'forOwn': 1,
  'forOwnRight': 1,
  'map': 1,
  'mapKeys': 1,
  'mapValues': 1,
  'partition': 1,
  'reduce': 2,
  'reduceRight': 2,
  'reject': 1,
  'remove': 1,
  'some': 1,
  'takeRightWhile': 1,
  'takeWhile': 1,
  'times': 1,
  'transform': 2
};

/** Used to map method names to iteratee rearg configs. */
exports.iterateeRearg = {
  'mapKeys': [1],
  'reduceRight': [1, 0]
};

/** Used to map method names to rearg configs. */
exports.methodRearg = {
  'assignInAllWith': [1, 0],
  'assignInWith': [1, 2, 0],
  'assignAllWith': [1, 0],
  'assignWith': [1, 2, 0],
  'differenceBy': [1, 2, 0],
  'differenceWith': [1, 2, 0],
  'getOr': [2, 1, 0],
  'intersectionBy': [1, 2, 0],
  'intersectionWith': [1, 2, 0],
  'isEqualWith': [1, 2, 0],
  'isMatchWith': [2, 1, 0],
  'mergeAllWith': [1, 0],
  'mergeWith': [1, 2, 0],
  'padChars': [2, 1, 0],
  'padCharsEnd': [2, 1, 0],
  'padCharsStart': [2, 1, 0],
  'pullAllBy': [2, 1, 0],
  'pullAllWith': [2, 1, 0],
  'rangeStep': [1, 2, 0],
  'rangeStepRight': [1, 2, 0],
  'setWith': [3, 1, 2, 0],
  'sortedIndexBy': [2, 1, 0],
  'sortedLastIndexBy': [2, 1, 0],
  'unionBy': [1, 2, 0],
  'unionWith': [1, 2, 0],
  'updateWith': [3, 1, 2, 0],
  'xorBy': [1, 2, 0],
  'xorWith': [1, 2, 0],
  'zipWith': [1, 2, 0]
};

/** Used to map method names to spread configs. */
exports.methodSpread = {
  'assignAll': { 'start': 0 },
  'assignAllWith': { 'start': 0 },
  'assignInAll': { 'start': 0 },
  'assignInAllWith': { 'start': 0 },
  'defaultsAll': { 'start': 0 },
  'defaultsDeepAll': { 'start': 0 },
  'invokeArgs': { 'start': 2 },
  'invokeArgsMap': { 'start': 2 },
  'mergeAll': { 'start': 0 },
  'mergeAllWith': { 'start': 0 },
  'partial': { 'start': 1 },
  'partialRight': { 'start': 1 },
  'without': { 'start': 1 },
  'zipAll': { 'start': 0 }
};

/** Used to identify methods which mutate arrays or objects. */
exports.mutate = {
  'array': {
    'fill': true,
    'pull': true,
    'pullAll': true,
    'pullAllBy': true,
    'pullAllWith': true,
    'pullAt': true,
    'remove': true,
    'reverse': true
  },
  'object': {
    'assign': true,
    'assignAll': true,
    'assignAllWith': true,
    'assignIn': true,
    'assignInAll': true,
    'assignInAllWith': true,
    'assignInWith': true,
    'assignWith': true,
    'defaults': true,
    'defaultsAll': true,
    'defaultsDeep': true,
    'defaultsDeepAll': true,
    'merge': true,
    'mergeAll': true,
    'mergeAllWith': true,
    'mergeWith': true
  },
  'set': {
    'set': true,
    'setWith': true,
    'unset': true,
    'update': true,
    'updateWith': true
  }
};

/** Used to track methods with placeholder support */
exports.placeholder = {
  'bind': true,
  'bindKey': true,
  'curry': true,
  'curryRight': true,
  'partial': true,
  'partialRight': true
};

/** Used to map real names to their aliases. */
exports.realToAlias = function () {
  var hasOwnProperty = Object.prototype.hasOwnProperty,
      object = exports.aliasToReal,
      result = {};

  for (var key in object) {
    var value = object[key];
    if (hasOwnProperty.call(result, value)) {
      result[value].push(key);
    } else {
      result[value] = [key];
    }
  }
  return result;
}();

/** Used to map method names to other names. */
exports.remap = {
  'assignAll': 'assign',
  'assignAllWith': 'assignWith',
  'assignInAll': 'assignIn',
  'assignInAllWith': 'assignInWith',
  'curryN': 'curry',
  'curryRightN': 'curryRight',
  'defaultsAll': 'defaults',
  'defaultsDeepAll': 'defaultsDeep',
  'findFrom': 'find',
  'findIndexFrom': 'findIndex',
  'findLastFrom': 'findLast',
  'findLastIndexFrom': 'findLastIndex',
  'getOr': 'get',
  'includesFrom': 'includes',
  'indexOfFrom': 'indexOf',
  'invokeArgs': 'invoke',
  'invokeArgsMap': 'invokeMap',
  'lastIndexOfFrom': 'lastIndexOf',
  'mergeAll': 'merge',
  'mergeAllWith': 'mergeWith',
  'padChars': 'pad',
  'padCharsEnd': 'padEnd',
  'padCharsStart': 'padStart',
  'propertyOf': 'get',
  'rangeStep': 'range',
  'rangeStepRight': 'rangeRight',
  'restFrom': 'rest',
  'spreadFrom': 'spread',
  'trimChars': 'trim',
  'trimCharsEnd': 'trimEnd',
  'trimCharsStart': 'trimStart',
  'zipAll': 'zip'
};

/** Used to track methods that skip fixing their arity. */
exports.skipFixed = {
  'castArray': true,
  'flow': true,
  'flowRight': true,
  'iteratee': true,
  'mixin': true,
  'rearg': true,
  'runInContext': true
};

/** Used to track methods that skip rearranging arguments. */
exports.skipRearg = {
  'add': true,
  'assign': true,
  'assignIn': true,
  'bind': true,
  'bindKey': true,
  'concat': true,
  'difference': true,
  'divide': true,
  'eq': true,
  'gt': true,
  'gte': true,
  'isEqual': true,
  'lt': true,
  'lte': true,
  'matchesProperty': true,
  'merge': true,
  'multiply': true,
  'overArgs': true,
  'partial': true,
  'partialRight': true,
  'propertyOf': true,
  'random': true,
  'range': true,
  'rangeRight': true,
  'subtract': true,
  'zip': true,
  'zipObject': true,
  'zipObjectDeep': true
};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * The default argument placeholder value for methods.
 *
 * @type {Object}
 */
module.exports = {};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function () {
  function n(n, t) {
    return n.set(t[0], t[1]), n;
  }function t(n, t) {
    return n.add(t), n;
  }function r(n, t, r) {
    switch (r.length) {case 0:
        return n.call(t);case 1:
        return n.call(t, r[0]);case 2:
        return n.call(t, r[0], r[1]);case 3:
        return n.call(t, r[0], r[1], r[2]);}return n.apply(t, r);
  }function e(n, t, r, e) {
    for (var u = -1, i = null == n ? 0 : n.length; ++u < i;) {
      var o = n[u];t(e, o, r(o), n);
    }return e;
  }function u(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length; ++r < e && false !== t(n[r], r, n);) {}return n;
  }function i(n, t) {
    for (var r = null == n ? 0 : n.length; r-- && false !== t(n[r], r, n);) {}
    return n;
  }function o(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length; ++r < e;) {
      if (!t(n[r], r, n)) return false;
    }return true;
  }function f(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length, u = 0, i = []; ++r < e;) {
      var o = n[r];t(o, r, n) && (i[u++] = o);
    }return i;
  }function c(n, t) {
    return !(null == n || !n.length) && -1 < d(n, t, 0);
  }function a(n, t, r) {
    for (var e = -1, u = null == n ? 0 : n.length; ++e < u;) {
      if (r(t, n[e])) return true;
    }return false;
  }function l(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length, u = Array(e); ++r < e;) {
      u[r] = t(n[r], r, n);
    }return u;
  }function s(n, t) {
    for (var r = -1, e = t.length, u = n.length; ++r < e;) {
      n[u + r] = t[r];
    }return n;
  }function h(n, t, r, e) {
    var u = -1,
        i = null == n ? 0 : n.length;for (e && i && (r = n[++u]); ++u < i;) {
      r = t(r, n[u], u, n);
    }return r;
  }function p(n, t, r, e) {
    var u = null == n ? 0 : n.length;for (e && u && (r = n[--u]); u--;) {
      r = t(r, n[u], u, n);
    }return r;
  }function _(n, t) {
    for (var r = -1, e = null == n ? 0 : n.length; ++r < e;) {
      if (t(n[r], r, n)) return true;
    }return false;
  }function v(n, t, r) {
    var e;return r(n, function (n, r, u) {
      if (t(n, r, u)) return e = r, false;
    }), e;
  }function g(n, t, r, e) {
    var u = n.length;for (r += e ? 1 : -1; e ? r-- : ++r < u;) {
      if (t(n[r], r, n)) return r;
    }return -1;
  }function d(n, t, r) {
    if (t === t) n: {
      --r;for (var e = n.length; ++r < e;) {
        if (n[r] === t) {
          n = r;break n;
        }
      }n = -1;
    } else n = g(n, b, r);return n;
  }function y(n, t, r, e) {
    --r;for (var u = n.length; ++r < u;) {
      if (e(n[r], t)) return r;
    }return -1;
  }function b(n) {
    return n !== n;
  }function x(n, t) {
    var r = null == n ? 0 : n.length;return r ? k(n, t) / r : P;
  }function j(n) {
    return function (t) {
      return null == t ? F : t[n];
    };
  }function w(n) {
    return function (t) {
      return null == n ? F : n[t];
    };
  }function m(n, t, r, e, u) {
    return u(n, function (n, u, i) {
      r = e ? (e = false, n) : t(r, n, u, i);
    }), r;
  }function A(n, t) {
    var r = n.length;for (n.sort(t); r--;) {
      n[r] = n[r].c;
    }return n;
  }function k(n, t) {
    for (var r, e = -1, u = n.length; ++e < u;) {
      var i = t(n[e]);i !== F && (r = r === F ? i : r + i);
    }return r;
  }function E(n, t) {
    for (var r = -1, e = Array(n); ++r < n;) {
      e[r] = t(r);
    }return e;
  }function O(n, t) {
    return l(t, function (t) {
      return [t, n[t]];
    });
  }function S(n) {
    return function (t) {
      return n(t);
    };
  }function I(n, t) {
    return l(t, function (t) {
      return n[t];
    });
  }function R(n, t) {
    return n.has(t);
  }function z(n, t) {
    for (var r = -1, e = n.length; ++r < e && -1 < d(t, n[r], 0);) {}return r;
  }function W(n, t) {
    for (var r = n.length; r-- && -1 < d(t, n[r], 0);) {}return r;
  }function B(n) {
    return "\\" + Tn[n];
  }function L(n) {
    var t = -1,
        r = Array(n.size);return n.forEach(function (n, e) {
      r[++t] = [e, n];
    }), r;
  }function U(n, t) {
    return function (r) {
      return n(t(r));
    };
  }function C(n, t) {
    for (var r = -1, e = n.length, u = 0, i = []; ++r < e;) {
      var o = n[r];o !== t && "__lodash_placeholder__" !== o || (n[r] = "__lodash_placeholder__", i[u++] = r);
    }return i;
  }function D(n) {
    var t = -1,
        r = Array(n.size);return n.forEach(function (n) {
      r[++t] = n;
    }), r;
  }function M(n) {
    var t = -1,
        r = Array(n.size);return n.forEach(function (n) {
      r[++t] = [n, n];
    }), r;
  }function T(n) {
    if (Bn.test(n)) {
      for (var t = zn.lastIndex = 0; zn.test(n);) {
        ++t;
      }n = t;
    } else n = tt(n);return n;
  }function $(n) {
    return Bn.test(n) ? n.match(zn) || [] : n.split("");
  }var F,
      N = 1 / 0,
      P = NaN,
      Z = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]],
      q = /\b__p\+='';/g,
      V = /\b(__p\+=)''\+/g,
      K = /(__e\(.*?\)|\b__t\))\+'';/g,
      G = /&(?:amp|lt|gt|quot|#39);/g,
      H = /[&<>"']/g,
      J = RegExp(G.source),
      Y = RegExp(H.source),
      Q = /<%-([\s\S]+?)%>/g,
      X = /<%([\s\S]+?)%>/g,
      nn = /<%=([\s\S]+?)%>/g,
      tn = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      rn = /^\w*$/,
      en = /^\./,
      un = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      on = /[\\^$.*+?()[\]{}|]/g,
      fn = RegExp(on.source),
      cn = /^\s+|\s+$/g,
      an = /^\s+/,
      ln = /\s+$/,
      sn = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      hn = /\{\n\/\* \[wrapped with (.+)\] \*/,
      pn = /,? & /,
      _n = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      vn = /\\(\\)?/g,
      gn = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      dn = /\w*$/,
      yn = /^[-+]0x[0-9a-f]+$/i,
      bn = /^0b[01]+$/i,
      xn = /^\[object .+?Constructor\]$/,
      jn = /^0o[0-7]+$/i,
      wn = /^(?:0|[1-9]\d*)$/,
      mn = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      An = /($^)/,
      kn = /['\n\r\u2028\u2029\\]/g,
      En = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",
      On = "(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])" + En,
      Sn = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",
      In = RegExp("['\u2019]", "g"),
      Rn = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g"),
      zn = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + Sn + En, "g"),
      Wn = RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+", On].join("|"), "g"),
      Bn = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),
      Ln = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      Un = "Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),
      Cn = {};
  Cn["[object Float32Array]"] = Cn["[object Float64Array]"] = Cn["[object Int8Array]"] = Cn["[object Int16Array]"] = Cn["[object Int32Array]"] = Cn["[object Uint8Array]"] = Cn["[object Uint8ClampedArray]"] = Cn["[object Uint16Array]"] = Cn["[object Uint32Array]"] = true, Cn["[object Arguments]"] = Cn["[object Array]"] = Cn["[object ArrayBuffer]"] = Cn["[object Boolean]"] = Cn["[object DataView]"] = Cn["[object Date]"] = Cn["[object Error]"] = Cn["[object Function]"] = Cn["[object Map]"] = Cn["[object Number]"] = Cn["[object Object]"] = Cn["[object RegExp]"] = Cn["[object Set]"] = Cn["[object String]"] = Cn["[object WeakMap]"] = false;
  var Dn = {};Dn["[object Arguments]"] = Dn["[object Array]"] = Dn["[object ArrayBuffer]"] = Dn["[object DataView]"] = Dn["[object Boolean]"] = Dn["[object Date]"] = Dn["[object Float32Array]"] = Dn["[object Float64Array]"] = Dn["[object Int8Array]"] = Dn["[object Int16Array]"] = Dn["[object Int32Array]"] = Dn["[object Map]"] = Dn["[object Number]"] = Dn["[object Object]"] = Dn["[object RegExp]"] = Dn["[object Set]"] = Dn["[object String]"] = Dn["[object Symbol]"] = Dn["[object Uint8Array]"] = Dn["[object Uint8ClampedArray]"] = Dn["[object Uint16Array]"] = Dn["[object Uint32Array]"] = true, Dn["[object Error]"] = Dn["[object Function]"] = Dn["[object WeakMap]"] = false;var Mn,
      Tn = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" },
      $n = parseFloat,
      Fn = parseInt,
      Nn = (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global && global.Object === Object && global,
      Pn = (typeof self === "undefined" ? "undefined" : _typeof(self)) == "object" && self && self.Object === Object && self,
      Zn = Nn || Pn || Function("return this")(),
      qn = ( false ? "undefined" : _typeof(exports)) == "object" && exports && !exports.nodeType && exports,
      Vn = qn && ( false ? "undefined" : _typeof(module)) == "object" && module && !module.nodeType && module,
      Kn = Vn && Vn.exports === qn,
      Gn = Kn && Nn.process;
  n: {
    try {
      Mn = Gn && Gn.binding && Gn.binding("util");break n;
    } catch (n) {}Mn = void 0;
  }var Hn = Mn && Mn.isArrayBuffer,
      Jn = Mn && Mn.isDate,
      Yn = Mn && Mn.isMap,
      Qn = Mn && Mn.isRegExp,
      Xn = Mn && Mn.isSet,
      nt = Mn && Mn.isTypedArray,
      tt = j("length"),
      rt = w({ "\xc0": "A", "\xc1": "A", "\xc2": "A", "\xc3": "A", "\xc4": "A", "\xc5": "A", "\xe0": "a", "\xe1": "a", "\xe2": "a", "\xe3": "a", "\xe4": "a", "\xe5": "a", "\xc7": "C", "\xe7": "c", "\xd0": "D", "\xf0": "d", "\xc8": "E", "\xc9": "E", "\xca": "E", "\xcb": "E", "\xe8": "e", "\xe9": "e", "\xea": "e", "\xeb": "e", "\xcc": "I", "\xcd": "I", "\xce": "I",
    "\xcf": "I", "\xec": "i", "\xed": "i", "\xee": "i", "\xef": "i", "\xd1": "N", "\xf1": "n", "\xd2": "O", "\xd3": "O", "\xd4": "O", "\xd5": "O", "\xd6": "O", "\xd8": "O", "\xf2": "o", "\xf3": "o", "\xf4": "o", "\xf5": "o", "\xf6": "o", "\xf8": "o", "\xd9": "U", "\xda": "U", "\xdb": "U", "\xdc": "U", "\xf9": "u", "\xfa": "u", "\xfb": "u", "\xfc": "u", "\xdd": "Y", "\xfd": "y", "\xff": "y", "\xc6": "Ae", "\xe6": "ae", "\xde": "Th", "\xfe": "th", "\xdf": "ss", "\u0100": "A", "\u0102": "A", "\u0104": "A", "\u0101": "a", "\u0103": "a", "\u0105": "a", "\u0106": "C", "\u0108": "C", "\u010A": "C",
    "\u010C": "C", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u010E": "D", "\u0110": "D", "\u010F": "d", "\u0111": "d", "\u0112": "E", "\u0114": "E", "\u0116": "E", "\u0118": "E", "\u011A": "E", "\u0113": "e", "\u0115": "e", "\u0117": "e", "\u0119": "e", "\u011B": "e", "\u011C": "G", "\u011E": "G", "\u0120": "G", "\u0122": "G", "\u011D": "g", "\u011F": "g", "\u0121": "g", "\u0123": "g", "\u0124": "H", "\u0126": "H", "\u0125": "h", "\u0127": "h", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u012E": "I", "\u0130": "I", "\u0129": "i", "\u012B": "i", "\u012D": "i",
    "\u012F": "i", "\u0131": "i", "\u0134": "J", "\u0135": "j", "\u0136": "K", "\u0137": "k", "\u0138": "k", "\u0139": "L", "\u013B": "L", "\u013D": "L", "\u013F": "L", "\u0141": "L", "\u013A": "l", "\u013C": "l", "\u013E": "l", "\u0140": "l", "\u0142": "l", "\u0143": "N", "\u0145": "N", "\u0147": "N", "\u014A": "N", "\u0144": "n", "\u0146": "n", "\u0148": "n", "\u014B": "n", "\u014C": "O", "\u014E": "O", "\u0150": "O", "\u014D": "o", "\u014F": "o", "\u0151": "o", "\u0154": "R", "\u0156": "R", "\u0158": "R", "\u0155": "r", "\u0157": "r", "\u0159": "r", "\u015A": "S", "\u015C": "S",
    "\u015E": "S", "\u0160": "S", "\u015B": "s", "\u015D": "s", "\u015F": "s", "\u0161": "s", "\u0162": "T", "\u0164": "T", "\u0166": "T", "\u0163": "t", "\u0165": "t", "\u0167": "t", "\u0168": "U", "\u016A": "U", "\u016C": "U", "\u016E": "U", "\u0170": "U", "\u0172": "U", "\u0169": "u", "\u016B": "u", "\u016D": "u", "\u016F": "u", "\u0171": "u", "\u0173": "u", "\u0174": "W", "\u0175": "w", "\u0176": "Y", "\u0177": "y", "\u0178": "Y", "\u0179": "Z", "\u017B": "Z", "\u017D": "Z", "\u017A": "z", "\u017C": "z", "\u017E": "z", "\u0132": "IJ", "\u0133": "ij", "\u0152": "Oe", "\u0153": "oe",
    "\u0149": "'n", "\u017F": "s" }),
      et = w({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }),
      ut = w({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }),
      it = function w(En) {
    function On(n) {
      if (xu(n) && !af(n) && !(n instanceof Mn)) {
        if (n instanceof zn) return n;if (ci.call(n, "__wrapped__")) return Pe(n);
      }return new zn(n);
    }function Sn() {}function zn(n, t) {
      this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = F;
    }function Mn(n) {
      this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = [];
    }function Tn(n) {
      var t = -1,
          r = null == n ? 0 : n.length;for (this.clear(); ++t < r;) {
        var e = n[t];this.set(e[0], e[1]);
      }
    }function Nn(n) {
      var t = -1,
          r = null == n ? 0 : n.length;for (this.clear(); ++t < r;) {
        var e = n[t];this.set(e[0], e[1]);
      }
    }function Pn(n) {
      var t = -1,
          r = null == n ? 0 : n.length;for (this.clear(); ++t < r;) {
        var e = n[t];this.set(e[0], e[1]);
      }
    }function qn(n) {
      var t = -1,
          r = null == n ? 0 : n.length;for (this.__data__ = new Pn(); ++t < r;) {
        this.add(n[t]);
      }
    }function Vn(n) {
      this.size = (this.__data__ = new Nn(n)).size;
    }function Gn(n, t) {
      var r,
          e = af(n),
          u = !e && cf(n),
          i = !e && !u && sf(n),
          o = !e && !u && !i && gf(n),
          u = (e = e || u || i || o) ? E(n.length, ri) : [],
          f = u.length;for (r in n) {
        !t && !ci.call(n, r) || e && ("length" == r || i && ("offset" == r || "parent" == r) || o && ("buffer" == r || "byteLength" == r || "byteOffset" == r) || Re(r, f)) || u.push(r);
      }return u;
    }function tt(n) {
      var t = n.length;return t ? n[cr(0, t - 1)] : F;
    }function ot(n, t) {
      return Te(Mr(n), gt(t, 0, n.length));
    }function ft(n) {
      return Te(Mr(n));
    }function ct(n, t, r) {
      (r === F || hu(n[t], r)) && (r !== F || t in n) || _t(n, t, r);
    }function at(n, t, r) {
      var e = n[t];ci.call(n, t) && hu(e, r) && (r !== F || t in n) || _t(n, t, r);
    }function lt(n, t) {
      for (var r = n.length; r--;) {
        if (hu(n[r][0], t)) return r;
      }return -1;
    }function st(n, t, r, e) {
      return oo(n, function (n, u, i) {
        t(e, n, r(n), i);
      }), e;
    }function ht(n, t) {
      return n && Tr(t, Lu(t), n);
    }function pt(n, t) {
      return n && Tr(t, Uu(t), n);
    }function _t(n, t, r) {
      "__proto__" == t && Ei ? Ei(n, t, { configurable: true, enumerable: true, value: r, writable: true }) : n[t] = r;
    }function vt(n, t) {
      for (var r = -1, e = t.length, u = Hu(e), i = null == n; ++r < e;) {
        u[r] = i ? F : Wu(n, t[r]);
      }return u;
    }function gt(n, t, r) {
      return n === n && (r !== F && (n = n <= r ? n : r), t !== F && (n = n >= t ? n : t)), n;
    }function dt(n, t, r, e, i, o) {
      var f,
          c = 1 & t,
          a = 2 & t,
          l = 4 & t;if (r && (f = i ? r(n, e, i, o) : r(n)), f !== F) return f;if (!bu(n)) return n;if (e = af(n)) {
        if (f = Ee(n), !c) return Mr(n, f);
      } else {
        var s = yo(n),
            h = "[object Function]" == s || "[object GeneratorFunction]" == s;if (sf(n)) return Wr(n, c);if ("[object Object]" == s || "[object Arguments]" == s || h && !i) {
          if (f = a || h ? {} : Oe(n), !c) return a ? Fr(n, pt(f, n)) : $r(n, ht(f, n));
        } else {
          if (!Dn[s]) return i ? n : {};f = Se(n, s, dt, c);
        }
      }if (o || (o = new Vn()), i = o.get(n)) return i;o.set(n, f);var a = l ? a ? ye : de : a ? Uu : Lu,
          p = e ? F : a(n);return u(p || n, function (e, u) {
        p && (u = e, e = n[u]), at(f, u, dt(e, t, r, u, n, o));
      }), f;
    }function yt(n) {
      var t = Lu(n);return function (r) {
        return bt(r, n, t);
      };
    }function bt(n, t, r) {
      var e = r.length;if (null == n) return !e;for (n = ni(n); e--;) {
        var u = r[e],
            i = t[u],
            o = n[u];if (o === F && !(u in n) || !i(o)) return false;
      }return true;
    }function xt(n, t, r) {
      if (typeof n != "function") throw new ei("Expected a function");return jo(function () {
        n.apply(F, r);
      }, t);
    }function jt(n, t, r, e) {
      var u = -1,
          i = c,
          o = true,
          f = n.length,
          s = [],
          h = t.length;
      if (!f) return s;r && (t = l(t, S(r))), e ? (i = a, o = false) : 200 <= t.length && (i = R, o = false, t = new qn(t));n: for (; ++u < f;) {
        var p = n[u],
            _ = null == r ? p : r(p),
            p = e || 0 !== p ? p : 0;if (o && _ === _) {
          for (var v = h; v--;) {
            if (t[v] === _) continue n;
          }s.push(p);
        } else i(t, _, e) || s.push(p);
      }return s;
    }function wt(n, t) {
      var r = true;return oo(n, function (n, e, u) {
        return r = !!t(n, e, u);
      }), r;
    }function mt(n, t, r) {
      for (var e = -1, u = n.length; ++e < u;) {
        var i = n[e],
            o = t(i);if (null != o && (f === F ? o === o && !Au(o) : r(o, f))) var f = o,
            c = i;
      }return c;
    }function At(n, t) {
      var r = [];return oo(n, function (n, e, u) {
        t(n, e, u) && r.push(n);
      }), r;
    }function kt(n, t, r, e, u) {
      var i = -1,
          o = n.length;for (r || (r = Ie), u || (u = []); ++i < o;) {
        var f = n[i];0 < t && r(f) ? 1 < t ? kt(f, t - 1, r, e, u) : s(u, f) : e || (u[u.length] = f);
      }return u;
    }function Et(n, t) {
      return n && co(n, t, Lu);
    }function Ot(n, t) {
      return n && ao(n, t, Lu);
    }function St(n, t) {
      return f(t, function (t) {
        return gu(n[t]);
      });
    }function It(n, t) {
      t = Rr(t, n);for (var r = 0, e = t.length; null != n && r < e;) {
        n = n[$e(t[r++])];
      }return r && r == e ? n : F;
    }function Rt(n, t, r) {
      return t = t(n), af(n) ? t : s(t, r(n));
    }function zt(n) {
      if (null == n) n = n === F ? "[object Undefined]" : "[object Null]";else if (ki && ki in ni(n)) {
        var t = ci.call(n, ki),
            r = n[ki];try {
          n[ki] = F;var e = true;
        } catch (n) {}var u = si.call(n);e && (t ? n[ki] = r : delete n[ki]), n = u;
      } else n = si.call(n);return n;
    }function Wt(n, t) {
      return n > t;
    }function Bt(n, t) {
      return null != n && ci.call(n, t);
    }function Lt(n, t) {
      return null != n && t in ni(n);
    }function Ut(n, t, r) {
      for (var e = r ? a : c, u = n[0].length, i = n.length, o = i, f = Hu(i), s = 1 / 0, h = []; o--;) {
        var p = n[o];o && t && (p = l(p, S(t))), s = Mi(p.length, s), f[o] = !r && (t || 120 <= u && 120 <= p.length) ? new qn(o && p) : F;
      }var p = n[0],
          _ = -1,
          v = f[0];n: for (; ++_ < u && h.length < s;) {
        var g = p[_],
            d = t ? t(g) : g,
            g = r || 0 !== g ? g : 0;
        if (v ? !R(v, d) : !e(h, d, r)) {
          for (o = i; --o;) {
            var y = f[o];if (y ? !R(y, d) : !e(n[o], d, r)) continue n;
          }v && v.push(d), h.push(g);
        }
      }return h;
    }function Ct(n, t, r) {
      var e = {};return Et(n, function (n, u, i) {
        t(e, r(n), u, i);
      }), e;
    }function Dt(n, t, e) {
      return t = Rr(t, n), n = 2 > t.length ? n : It(n, vr(t, 0, -1)), t = null == n ? n : n[$e(Ge(t))], null == t ? F : r(t, n, e);
    }function Mt(n) {
      return xu(n) && "[object Arguments]" == zt(n);
    }function Tt(n) {
      return xu(n) && "[object ArrayBuffer]" == zt(n);
    }function $t(n) {
      return xu(n) && "[object Date]" == zt(n);
    }function Ft(n, t, r, e, u) {
      if (n === t) t = true;else if (null == n || null == t || !xu(n) && !xu(t)) t = n !== n && t !== t;else n: {
        var i = af(n),
            o = af(t),
            f = i ? "[object Array]" : yo(n),
            c = o ? "[object Array]" : yo(t),
            f = "[object Arguments]" == f ? "[object Object]" : f,
            c = "[object Arguments]" == c ? "[object Object]" : c,
            a = "[object Object]" == f,
            o = "[object Object]" == c;if ((c = f == c) && sf(n)) {
          if (!sf(t)) {
            t = false;break n;
          }i = true, a = false;
        }if (c && !a) u || (u = new Vn()), t = i || gf(n) ? _e(n, t, r, e, Ft, u) : ve(n, t, f, r, e, Ft, u);else {
          if (!(1 & r) && (i = a && ci.call(n, "__wrapped__"), f = o && ci.call(t, "__wrapped__"), i || f)) {
            n = i ? n.value() : n, t = f ? t.value() : t, u || (u = new Vn()), t = Ft(n, t, r, e, u);break n;
          }if (c) {
            t: if (u || (u = new Vn()), i = 1 & r, f = de(n), o = f.length, c = de(t).length, o == c || i) {
              for (a = o; a--;) {
                var l = f[a];if (!(i ? l in t : ci.call(t, l))) {
                  t = false;break t;
                }
              }if ((c = u.get(n)) && u.get(t)) t = c == t;else {
                c = true, u.set(n, t), u.set(t, n);for (var s = i; ++a < o;) {
                  var l = f[a],
                      h = n[l],
                      p = t[l];if (e) var _ = i ? e(p, h, l, t, n, u) : e(h, p, l, n, t, u);if (_ === F ? h !== p && !Ft(h, p, r, e, u) : !_) {
                    c = false;break;
                  }s || (s = "constructor" == l);
                }c && !s && (r = n.constructor, e = t.constructor, r != e && "constructor" in n && "constructor" in t && !(typeof r == "function" && r instanceof r && typeof e == "function" && e instanceof e) && (c = false)), u.delete(n), u.delete(t), t = c;
              }
            } else t = false;
          } else t = false;
        }
      }return t;
    }function Nt(n) {
      return xu(n) && "[object Map]" == yo(n);
    }function Pt(n, t, r, e) {
      var u = r.length,
          i = u,
          o = !e;if (null == n) return !i;for (n = ni(n); u--;) {
        var f = r[u];if (o && f[2] ? f[1] !== n[f[0]] : !(f[0] in n)) return false;
      }for (; ++u < i;) {
        var f = r[u],
            c = f[0],
            a = n[c],
            l = f[1];if (o && f[2]) {
          if (a === F && !(c in n)) return false;
        } else {
          if (f = new Vn(), e) var s = e(a, l, c, n, t, f);if (s === F ? !Ft(l, a, 3, e, f) : !s) return false;
        }
      }return true;
    }function Zt(n) {
      return !(!bu(n) || li && li in n) && (gu(n) ? _i : xn).test(Fe(n));
    }function qt(n) {
      return xu(n) && "[object RegExp]" == zt(n);
    }function Vt(n) {
      return xu(n) && "[object Set]" == yo(n);
    }function Kt(n) {
      return xu(n) && yu(n.length) && !!Cn[zt(n)];
    }function Gt(n) {
      return typeof n == "function" ? n : null == n ? Nu : (typeof n === "undefined" ? "undefined" : _typeof(n)) == "object" ? af(n) ? Xt(n[0], n[1]) : Qt(n) : Vu(n);
    }function Ht(n) {
      if (!Le(n)) return Ci(n);var t,
          r = [];for (t in ni(n)) {
        ci.call(n, t) && "constructor" != t && r.push(t);
      }return r;
    }function Jt(n, t) {
      return n < t;
    }function Yt(n, t) {
      var r = -1,
          e = pu(n) ? Hu(n.length) : [];return oo(n, function (n, u, i) {
        e[++r] = t(n, u, i);
      }), e;
    }function Qt(n) {
      var t = me(n);return 1 == t.length && t[0][2] ? Ue(t[0][0], t[0][1]) : function (r) {
        return r === n || Pt(r, n, t);
      };
    }function Xt(n, t) {
      return We(n) && t === t && !bu(t) ? Ue($e(n), t) : function (r) {
        var e = Wu(r, n);return e === F && e === t ? Bu(r, n) : Ft(t, e, 3);
      };
    }function nr(n, t, r, e, u) {
      n !== t && co(t, function (i, o) {
        if (bu(i)) {
          u || (u = new Vn());var f = u,
              c = n[o],
              a = t[o],
              l = f.get(a);if (l) ct(n, o, l);else {
            var l = e ? e(c, a, o + "", n, t, f) : F,
                s = l === F;if (s) {
              var h = af(a),
                  p = !h && sf(a),
                  _ = !h && !p && gf(a),
                  l = a;h || p || _ ? af(c) ? l = c : _u(c) ? l = Mr(c) : p ? (s = false, l = Wr(a, true)) : _ ? (s = false, l = Lr(a, true)) : l = [] : wu(a) || cf(a) ? (l = c, cf(c) ? l = Ru(c) : (!bu(c) || r && gu(c)) && (l = Oe(a))) : s = false;
            }s && (f.set(a, l), nr(l, a, r, e, f), f.delete(a)), ct(n, o, l);
          }
        } else f = e ? e(n[o], i, o + "", n, t, u) : F, f === F && (f = i), ct(n, o, f);
      }, Uu);
    }function tr(n, t) {
      var r = n.length;if (r) return t += 0 > t ? r : 0, Re(t, r) ? n[t] : F;
    }function rr(n, t, r) {
      var e = -1;return t = l(t.length ? t : [Nu], S(je())), n = Yt(n, function (n) {
        return { a: l(t, function (t) {
            return t(n);
          }), b: ++e, c: n };
      }), A(n, function (n, t) {
        var e;n: {
          e = -1;for (var u = n.a, i = t.a, o = u.length, f = r.length; ++e < o;) {
            var c = Ur(u[e], i[e]);if (c) {
              e = e >= f ? c : c * ("desc" == r[e] ? -1 : 1);
              break n;
            }
          }e = n.b - t.b;
        }return e;
      });
    }function er(n, t) {
      return ur(n, t, function (t, r) {
        return Bu(n, r);
      });
    }function ur(n, t, r) {
      for (var e = -1, u = t.length, i = {}; ++e < u;) {
        var o = t[e],
            f = It(n, o);r(f, o) && pr(i, Rr(o, n), f);
      }return i;
    }function ir(n) {
      return function (t) {
        return It(t, n);
      };
    }function or(n, t, r, e) {
      var u = e ? y : d,
          i = -1,
          o = t.length,
          f = n;for (n === t && (t = Mr(t)), r && (f = l(n, S(r))); ++i < o;) {
        for (var c = 0, a = t[i], a = r ? r(a) : a; -1 < (c = u(f, a, c, e));) {
          f !== n && wi.call(f, c, 1), wi.call(n, c, 1);
        }
      }return n;
    }function fr(n, t) {
      for (var r = n ? t.length : 0, e = r - 1; r--;) {
        var u = t[r];
        if (r == e || u !== i) {
          var i = u;Re(u) ? wi.call(n, u, 1) : mr(n, u);
        }
      }
    }function cr(n, t) {
      return n + zi(Fi() * (t - n + 1));
    }function ar(n, t) {
      var r = "";if (!n || 1 > t || 9007199254740991 < t) return r;do {
        t % 2 && (r += n), (t = zi(t / 2)) && (n += n);
      } while (t);return r;
    }function lr(n, t) {
      return wo(Ce(n, t, Nu), n + "");
    }function sr(n) {
      return tt(Du(n));
    }function hr(n, t) {
      var r = Du(n);return Te(r, gt(t, 0, r.length));
    }function pr(n, t, r, e) {
      if (!bu(n)) return n;t = Rr(t, n);for (var u = -1, i = t.length, o = i - 1, f = n; null != f && ++u < i;) {
        var c = $e(t[u]),
            a = r;if (u != o) {
          var l = f[c],
              a = e ? e(l, c, f) : F;
          a === F && (a = bu(l) ? l : Re(t[u + 1]) ? [] : {});
        }at(f, c, a), f = f[c];
      }return n;
    }function _r(n) {
      return Te(Du(n));
    }function vr(n, t, r) {
      var e = -1,
          u = n.length;for (0 > t && (t = -t > u ? 0 : u + t), r = r > u ? u : r, 0 > r && (r += u), u = t > r ? 0 : r - t >>> 0, t >>>= 0, r = Hu(u); ++e < u;) {
        r[e] = n[e + t];
      }return r;
    }function gr(n, t) {
      var r;return oo(n, function (n, e, u) {
        return r = t(n, e, u), !r;
      }), !!r;
    }function dr(n, t, r) {
      var e = 0,
          u = null == n ? e : n.length;if (typeof t == "number" && t === t && 2147483647 >= u) {
        for (; e < u;) {
          var i = e + u >>> 1,
              o = n[i];null !== o && !Au(o) && (r ? o <= t : o < t) ? e = i + 1 : u = i;
        }return u;
      }return yr(n, t, Nu, r);
    }function yr(n, t, r, e) {
      t = r(t);for (var u = 0, i = null == n ? 0 : n.length, o = t !== t, f = null === t, c = Au(t), a = t === F; u < i;) {
        var l = zi((u + i) / 2),
            s = r(n[l]),
            h = s !== F,
            p = null === s,
            _ = s === s,
            v = Au(s);(o ? e || _ : a ? _ && (e || h) : f ? _ && h && (e || !p) : c ? _ && h && !p && (e || !v) : p || v ? 0 : e ? s <= t : s < t) ? u = l + 1 : i = l;
      }return Mi(i, 4294967294);
    }function br(n, t) {
      for (var r = -1, e = n.length, u = 0, i = []; ++r < e;) {
        var o = n[r],
            f = t ? t(o) : o;if (!r || !hu(f, c)) {
          var c = f;i[u++] = 0 === o ? 0 : o;
        }
      }return i;
    }function xr(n) {
      return typeof n == "number" ? n : Au(n) ? P : +n;
    }function jr(n) {
      if (typeof n == "string") return n;
      if (af(n)) return l(n, jr) + "";if (Au(n)) return uo ? uo.call(n) : "";var t = n + "";return "0" == t && 1 / n == -N ? "-0" : t;
    }function wr(n, t, r) {
      var e = -1,
          u = c,
          i = n.length,
          o = true,
          f = [],
          l = f;if (r) o = false, u = a;else if (200 <= i) {
        if (u = t ? null : po(n)) return D(u);o = false, u = R, l = new qn();
      } else l = t ? [] : f;n: for (; ++e < i;) {
        var s = n[e],
            h = t ? t(s) : s,
            s = r || 0 !== s ? s : 0;if (o && h === h) {
          for (var p = l.length; p--;) {
            if (l[p] === h) continue n;
          }t && l.push(h), f.push(s);
        } else u(l, h, r) || (l !== f && l.push(h), f.push(s));
      }return f;
    }function mr(n, t) {
      return t = Rr(t, n), n = 2 > t.length ? n : It(n, vr(t, 0, -1)), null == n || delete n[$e(Ge(t))];
    }function Ar(n, t, r, e) {
      for (var u = n.length, i = e ? u : -1; (e ? i-- : ++i < u) && t(n[i], i, n);) {}return r ? vr(n, e ? 0 : i, e ? i + 1 : u) : vr(n, e ? i + 1 : 0, e ? u : i);
    }function kr(n, t) {
      var r = n;return r instanceof Mn && (r = r.value()), h(t, function (n, t) {
        return t.func.apply(t.thisArg, s([n], t.args));
      }, r);
    }function Er(n, t, r) {
      var e = n.length;if (2 > e) return e ? wr(n[0]) : [];for (var u = -1, i = Hu(e); ++u < e;) {
        for (var o = n[u], f = -1; ++f < e;) {
          f != u && (i[u] = jt(i[u] || o, n[f], t, r));
        }
      }return wr(kt(i, 1), t, r);
    }function Or(n, t, r) {
      for (var e = -1, u = n.length, i = t.length, o = {}; ++e < u;) {
        r(o, n[e], e < i ? t[e] : F);
      }return o;
    }function Sr(n) {
      return _u(n) ? n : [];
    }function Ir(n) {
      return typeof n == "function" ? n : Nu;
    }function Rr(n, t) {
      return af(n) ? n : We(n, t) ? [n] : mo(zu(n));
    }function zr(n, t, r) {
      var e = n.length;return r = r === F ? e : r, !t && r >= e ? n : vr(n, t, r);
    }function Wr(n, t) {
      if (t) return n.slice();var r = n.length,
          r = yi ? yi(r) : new n.constructor(r);return n.copy(r), r;
    }function Br(n) {
      var t = new n.constructor(n.byteLength);return new di(t).set(new di(n)), t;
    }function Lr(n, t) {
      return new n.constructor(t ? Br(n.buffer) : n.buffer, n.byteOffset, n.length);
    }function Ur(n, t) {
      if (n !== t) {
        var r = n !== F,
            e = null === n,
            u = n === n,
            i = Au(n),
            o = t !== F,
            f = null === t,
            c = t === t,
            a = Au(t);if (!f && !a && !i && n > t || i && o && c && !f && !a || e && o && c || !r && c || !u) return 1;if (!e && !i && !a && n < t || a && r && u && !e && !i || f && r && u || !o && u || !c) return -1;
      }return 0;
    }function Cr(n, t, r, e) {
      var u = -1,
          i = n.length,
          o = r.length,
          f = -1,
          c = t.length,
          a = Di(i - o, 0),
          l = Hu(c + a);for (e = !e; ++f < c;) {
        l[f] = t[f];
      }for (; ++u < o;) {
        (e || u < i) && (l[r[u]] = n[u]);
      }for (; a--;) {
        l[f++] = n[u++];
      }return l;
    }function Dr(n, t, r, e) {
      var u = -1,
          i = n.length,
          o = -1,
          f = r.length,
          c = -1,
          a = t.length,
          l = Di(i - f, 0),
          s = Hu(l + a);
      for (e = !e; ++u < l;) {
        s[u] = n[u];
      }for (l = u; ++c < a;) {
        s[l + c] = t[c];
      }for (; ++o < f;) {
        (e || u < i) && (s[l + r[o]] = n[u++]);
      }return s;
    }function Mr(n, t) {
      var r = -1,
          e = n.length;for (t || (t = Hu(e)); ++r < e;) {
        t[r] = n[r];
      }return t;
    }function Tr(n, t, r, e) {
      var u = !r;r || (r = {});for (var i = -1, o = t.length; ++i < o;) {
        var f = t[i],
            c = e ? e(r[f], n[f], f, r, n) : F;c === F && (c = n[f]), u ? _t(r, f, c) : at(r, f, c);
      }return r;
    }function $r(n, t) {
      return Tr(n, vo(n), t);
    }function Fr(n, t) {
      return Tr(n, go(n), t);
    }function Nr(n, t) {
      return function (r, u) {
        var i = af(r) ? e : st,
            o = t ? t() : {};return i(r, n, je(u, 2), o);
      };
    }function Pr(n) {
      return lr(function (t, r) {
        var e = -1,
            u = r.length,
            i = 1 < u ? r[u - 1] : F,
            o = 2 < u ? r[2] : F,
            i = 3 < n.length && typeof i == "function" ? (u--, i) : F;for (o && ze(r[0], r[1], o) && (i = 3 > u ? F : i, u = 1), t = ni(t); ++e < u;) {
          (o = r[e]) && n(t, o, e, i);
        }return t;
      });
    }function Zr(n, t) {
      return function (r, e) {
        if (null == r) return r;if (!pu(r)) return n(r, e);for (var u = r.length, i = t ? u : -1, o = ni(r); (t ? i-- : ++i < u) && false !== e(o[i], i, o);) {}return r;
      };
    }function qr(n) {
      return function (t, r, e) {
        var u = -1,
            i = ni(t);e = e(t);for (var o = e.length; o--;) {
          var f = e[n ? o : ++u];if (false === r(i[f], f, i)) break;
        }return t;
      };
    }function Vr(n, t, r) {
      function e() {
        return (this && this !== Zn && this instanceof e ? i : n).apply(u ? r : this, arguments);
      }var u = 1 & t,
          i = Hr(n);return e;
    }function Kr(n) {
      return function (t) {
        t = zu(t);var r = Bn.test(t) ? $(t) : F,
            e = r ? r[0] : t.charAt(0);return t = r ? zr(r, 1).join("") : t.slice(1), e[n]() + t;
      };
    }function Gr(n) {
      return function (t) {
        return h($u(Tu(t).replace(In, "")), n, "");
      };
    }function Hr(n) {
      return function () {
        var t = arguments;switch (t.length) {case 0:
            return new n();case 1:
            return new n(t[0]);case 2:
            return new n(t[0], t[1]);case 3:
            return new n(t[0], t[1], t[2]);case 4:
            return new n(t[0], t[1], t[2], t[3]);case 5:
            return new n(t[0], t[1], t[2], t[3], t[4]);case 6:
            return new n(t[0], t[1], t[2], t[3], t[4], t[5]);case 7:
            return new n(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);}var r = io(n.prototype),
            t = n.apply(r, t);return bu(t) ? t : r;
      };
    }function Jr(n, t, e) {
      function u() {
        for (var o = arguments.length, f = Hu(o), c = o, a = xe(u); c--;) {
          f[c] = arguments[c];
        }return c = 3 > o && f[0] !== a && f[o - 1] !== a ? [] : C(f, a), o -= c.length, o < e ? fe(n, t, Xr, u.placeholder, F, f, c, F, F, e - o) : r(this && this !== Zn && this instanceof u ? i : n, this, f);
      }var i = Hr(n);return u;
    }function Yr(n) {
      return function (t, r, e) {
        var u = ni(t);if (!pu(t)) {
          var i = je(r, 3);t = Lu(t), r = function r(n) {
            return i(u[n], n, u);
          };
        }return r = n(t, r, e), -1 < r ? u[i ? t[r] : r] : F;
      };
    }function Qr(n) {
      return ge(function (t) {
        var r = t.length,
            e = r,
            u = zn.prototype.thru;for (n && t.reverse(); e--;) {
          var i = t[e];if (typeof i != "function") throw new ei("Expected a function");if (u && !o && "wrapper" == be(i)) var o = new zn([], true);
        }for (e = o ? e : r; ++e < r;) {
          var i = t[e],
              u = be(i),
              f = "wrapper" == u ? _o(i) : F,
              o = f && Be(f[0]) && 424 == f[1] && !f[4].length && 1 == f[9] ? o[be(f[0])].apply(o, f[3]) : 1 == i.length && Be(i) ? o[u]() : o.thru(i);
        }return function () {
          var n = arguments,
              e = n[0];if (o && 1 == n.length && af(e)) return o.plant(e).value();for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r;) {
            n = t[u].call(this, n);
          }return n;
        };
      });
    }function Xr(n, t, r, e, u, i, o, f, c, a) {
      function l() {
        for (var d = arguments.length, y = Hu(d), b = d; b--;) {
          y[b] = arguments[b];
        }if (_) {
          var x,
              j = xe(l),
              b = y.length;for (x = 0; b--;) {
            y[b] === j && ++x;
          }
        }if (e && (y = Cr(y, e, u, _)), i && (y = Dr(y, i, o, _)), d -= x, _ && d < a) return j = C(y, j), fe(n, t, Xr, l.placeholder, r, y, j, f, c, a - d);if (j = h ? r : this, b = p ? j[n] : n, d = y.length, f) {
          x = y.length;for (var w = Mi(f.length, x), m = Mr(y); w--;) {
            var A = f[w];y[w] = Re(A, x) ? m[A] : F;
          }
        } else v && 1 < d && y.reverse();return s && c < d && (y.length = c), this && this !== Zn && this instanceof l && (b = g || Hr(b)), b.apply(j, y);
      }var s = 128 & t,
          h = 1 & t,
          p = 2 & t,
          _ = 24 & t,
          v = 512 & t,
          g = p ? F : Hr(n);return l;
    }function ne(n, t) {
      return function (r, e) {
        return Ct(r, n, t(e));
      };
    }function te(n, t) {
      return function (r, e) {
        var u;if (r === F && e === F) return t;if (r !== F && (u = r), e !== F) {
          if (u === F) return e;typeof r == "string" || typeof e == "string" ? (r = jr(r), e = jr(e)) : (r = xr(r), e = xr(e)), u = n(r, e);
        }return u;
      };
    }function re(n) {
      return ge(function (t) {
        return t = l(t, S(je())), lr(function (e) {
          var u = this;return n(t, function (n) {
            return r(n, u, e);
          });
        });
      });
    }function ee(n, t) {
      t = t === F ? " " : jr(t);var r = t.length;return 2 > r ? r ? ar(t, n) : t : (r = ar(t, Ri(n / T(t))), Bn.test(t) ? zr($(r), 0, n).join("") : r.slice(0, n));
    }function ue(n, t, e, u) {
      function i() {
        for (var t = -1, c = arguments.length, a = -1, l = u.length, s = Hu(l + c), h = this && this !== Zn && this instanceof i ? f : n; ++a < l;) {
          s[a] = u[a];
        }for (; c--;) {
          s[a++] = arguments[++t];
        }return r(h, o ? e : this, s);
      }var o = 1 & t,
          f = Hr(n);return i;
    }function ie(n) {
      return function (t, r, e) {
        e && typeof e != "number" && ze(t, r, e) && (r = e = F), t = Eu(t), r === F ? (r = t, t = 0) : r = Eu(r), e = e === F ? t < r ? 1 : -1 : Eu(e);var u = -1;r = Di(Ri((r - t) / (e || 1)), 0);for (var i = Hu(r); r--;) {
          i[n ? r : ++u] = t, t += e;
        }return i;
      };
    }function oe(n) {
      return function (t, r) {
        return typeof t == "string" && typeof r == "string" || (t = Iu(t), r = Iu(r)), n(t, r);
      };
    }function fe(n, t, r, e, u, i, o, f, c, a) {
      var l = 8 & t,
          s = l ? o : F;o = l ? F : o;var h = l ? i : F;return i = l ? F : i, t = (t | (l ? 32 : 64)) & ~(l ? 64 : 32), 4 & t || (t &= -4), u = [n, t, u, h, s, i, o, f, c, a], r = r.apply(F, u), Be(n) && xo(r, u), r.placeholder = e, De(r, n, t);
    }function ce(n) {
      var t = Xu[n];return function (n, r) {
        if (n = Iu(n), r = null == r ? 0 : Mi(Ou(r), 292)) {
          var e = (zu(n) + "e").split("e"),
              e = t(e[0] + "e" + (+e[1] + r)),
              e = (zu(e) + "e").split("e");return +(e[0] + "e" + (+e[1] - r));
        }return t(n);
      };
    }function ae(n) {
      return function (t) {
        var r = yo(t);return "[object Map]" == r ? L(t) : "[object Set]" == r ? M(t) : O(t, n(t));
      };
    }function le(n, t, r, e, u, i, o, f) {
      var c = 2 & t;if (!c && typeof n != "function") throw new ei("Expected a function");var a = e ? e.length : 0;if (a || (t &= -97, e = u = F), o = o === F ? o : Di(Ou(o), 0), f = f === F ? f : Ou(f), a -= u ? u.length : 0, 64 & t) {
        var l = e,
            s = u;e = u = F;
      }var h = c ? F : _o(n);return i = [n, t, r, e, u, l, s, i, o, f], h && (r = i[1], n = h[1], t = r | n, e = 128 == n && 8 == r || 128 == n && 256 == r && i[7].length <= h[8] || 384 == n && h[7].length <= h[8] && 8 == r, 131 > t || e) && (1 & n && (i[2] = h[2], t |= 1 & r ? 0 : 4), (r = h[3]) && (e = i[3], i[3] = e ? Cr(e, r, h[4]) : r, i[4] = e ? C(i[3], "__lodash_placeholder__") : h[4]), (r = h[5]) && (e = i[5], i[5] = e ? Dr(e, r, h[6]) : r, i[6] = e ? C(i[5], "__lodash_placeholder__") : h[6]), (r = h[7]) && (i[7] = r), 128 & n && (i[8] = null == i[8] ? h[8] : Mi(i[8], h[8])), null == i[9] && (i[9] = h[9]), i[0] = h[0], i[1] = t), n = i[0], t = i[1], r = i[2], e = i[3], u = i[4], f = i[9] = i[9] === F ? c ? 0 : n.length : Di(i[9] - a, 0), !f && 24 & t && (t &= -25), De((h ? lo : xo)(t && 1 != t ? 8 == t || 16 == t ? Jr(n, t, f) : 32 != t && 33 != t || u.length ? Xr.apply(F, i) : ue(n, t, r, e) : Vr(n, t, r), i), n, t);
    }function se(n, t, r, e) {
      return n === F || hu(n, ii[r]) && !ci.call(e, r) ? t : n;
    }function he(n, t, r, e, u, i) {
      return bu(n) && bu(t) && (i.set(t, n), nr(n, t, F, he, i), i.delete(t)), n;
    }function pe(n) {
      return wu(n) ? F : n;
    }function _e(n, t, r, e, u, i) {
      var o = 1 & r,
          f = n.length,
          c = t.length;if (f != c && !(o && c > f)) return false;if ((c = i.get(n)) && i.get(t)) return c == t;var c = -1,
          a = true,
          l = 2 & r ? new qn() : F;
      for (i.set(n, t), i.set(t, n); ++c < f;) {
        var s = n[c],
            h = t[c];if (e) var p = o ? e(h, s, c, t, n, i) : e(s, h, c, n, t, i);if (p !== F) {
          if (p) continue;a = false;break;
        }if (l) {
          if (!_(t, function (n, t) {
            if (!R(l, t) && (s === n || u(s, n, r, e, i))) return l.push(t);
          })) {
            a = false;break;
          }
        } else if (s !== h && !u(s, h, r, e, i)) {
          a = false;break;
        }
      }return i.delete(n), i.delete(t), a;
    }function ve(n, t, r, e, u, i, o) {
      switch (r) {case "[object DataView]":
          if (n.byteLength != t.byteLength || n.byteOffset != t.byteOffset) break;n = n.buffer, t = t.buffer;case "[object ArrayBuffer]":
          if (n.byteLength != t.byteLength || !i(new di(n), new di(t))) break;
          return true;case "[object Boolean]":case "[object Date]":case "[object Number]":
          return hu(+n, +t);case "[object Error]":
          return n.name == t.name && n.message == t.message;case "[object RegExp]":case "[object String]":
          return n == t + "";case "[object Map]":
          var f = L;case "[object Set]":
          if (f || (f = D), n.size != t.size && !(1 & e)) break;return (r = o.get(n)) ? r == t : (e |= 2, o.set(n, t), t = _e(f(n), f(t), e, u, i, o), o.delete(n), t);case "[object Symbol]":
          if (eo) return eo.call(n) == eo.call(t);}return false;
    }function ge(n) {
      return wo(Ce(n, F, Ve), n + "");
    }function de(n) {
      return Rt(n, Lu, vo);
    }function ye(n) {
      return Rt(n, Uu, go);
    }function be(n) {
      for (var t = n.name + "", r = Ji[t], e = ci.call(Ji, t) ? r.length : 0; e--;) {
        var u = r[e],
            i = u.func;if (null == i || i == n) return u.name;
      }return t;
    }function xe(n) {
      return (ci.call(On, "placeholder") ? On : n).placeholder;
    }function je() {
      var n = On.iteratee || Pu,
          n = n === Pu ? Gt : n;return arguments.length ? n(arguments[0], arguments[1]) : n;
    }function we(n, t) {
      var r = n.__data__,
          e = typeof t === "undefined" ? "undefined" : _typeof(t);return ("string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
    }function me(n) {
      for (var t = Lu(n), r = t.length; r--;) {
        var e = t[r],
            u = n[e];t[r] = [e, u, u === u && !bu(u)];
      }return t;
    }function Ae(n, t) {
      var r = null == n ? F : n[t];return Zt(r) ? r : F;
    }function ke(n, t, r) {
      t = Rr(t, n);for (var e = -1, u = t.length, i = false; ++e < u;) {
        var o = $e(t[e]);if (!(i = null != n && r(n, o))) break;n = n[o];
      }return i || ++e != u ? i : (u = null == n ? 0 : n.length, !!u && yu(u) && Re(o, u) && (af(n) || cf(n)));
    }function Ee(n) {
      var t = n.length,
          r = n.constructor(t);return t && "string" == typeof n[0] && ci.call(n, "index") && (r.index = n.index, r.input = n.input), r;
    }function Oe(n) {
      return typeof n.constructor != "function" || Le(n) ? {} : io(bi(n));
    }function Se(r, e, u, i) {
      var o = r.constructor;switch (e) {case "[object ArrayBuffer]":
          return Br(r);case "[object Boolean]":case "[object Date]":
          return new o(+r);case "[object DataView]":
          return e = i ? Br(r.buffer) : r.buffer, new r.constructor(e, r.byteOffset, r.byteLength);case "[object Float32Array]":case "[object Float64Array]":case "[object Int8Array]":case "[object Int16Array]":case "[object Int32Array]":case "[object Uint8Array]":case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":case "[object Uint32Array]":
          return Lr(r, i);case "[object Map]":
          return e = i ? u(L(r), 1) : L(r), h(e, n, new r.constructor());case "[object Number]":case "[object String]":
          return new o(r);case "[object RegExp]":
          return e = new r.constructor(r.source, dn.exec(r)), e.lastIndex = r.lastIndex, e;case "[object Set]":
          return e = i ? u(D(r), 1) : D(r), h(e, t, new r.constructor());case "[object Symbol]":
          return eo ? ni(eo.call(r)) : {};}
    }function Ie(n) {
      return af(n) || cf(n) || !!(mi && n && n[mi]);
    }function Re(n, t) {
      return t = null == t ? 9007199254740991 : t, !!t && (typeof n == "number" || wn.test(n)) && -1 < n && 0 == n % 1 && n < t;
    }function ze(n, t, r) {
      if (!bu(r)) return false;var e = typeof t === "undefined" ? "undefined" : _typeof(t);return !!("number" == e ? pu(r) && Re(t, r.length) : "string" == e && t in r) && hu(r[t], n);
    }function We(n, t) {
      if (af(n)) return false;var r = typeof n === "undefined" ? "undefined" : _typeof(n);return !("number" != r && "symbol" != r && "boolean" != r && null != n && !Au(n)) || rn.test(n) || !tn.test(n) || null != t && n in ni(t);
    }function Be(n) {
      var t = be(n),
          r = On[t];return typeof r == "function" && t in Mn.prototype && (n === r || (t = _o(r), !!t && n === t[0]));
    }function Le(n) {
      var t = n && n.constructor;
      return n === (typeof t == "function" && t.prototype || ii);
    }function Ue(n, t) {
      return function (r) {
        return null != r && r[n] === t && (t !== F || n in ni(r));
      };
    }function Ce(n, t, e) {
      return t = Di(t === F ? n.length - 1 : t, 0), function () {
        for (var u = arguments, i = -1, o = Di(u.length - t, 0), f = Hu(o); ++i < o;) {
          f[i] = u[t + i];
        }for (i = -1, o = Hu(t + 1); ++i < t;) {
          o[i] = u[i];
        }return o[t] = e(f), r(n, this, o);
      };
    }function De(n, t, r) {
      var e = t + "";t = wo;var u,
          i = Ne;return u = (u = e.match(hn)) ? u[1].split(pn) : [], r = i(u, r), (i = r.length) && (u = i - 1, r[u] = (1 < i ? "& " : "") + r[u], r = r.join(2 < i ? ", " : " "), e = e.replace(sn, "{\n/* [wrapped with " + r + "] */\n")), t(n, e);
    }function Me(n) {
      var t = 0,
          r = 0;return function () {
        var e = Ti(),
            u = 16 - (e - r);if (r = e, 0 < u) {
          if (800 <= ++t) return arguments[0];
        } else t = 0;return n.apply(F, arguments);
      };
    }function Te(n, t) {
      var r = -1,
          e = n.length,
          u = e - 1;for (t = t === F ? e : t; ++r < t;) {
        var e = cr(r, u),
            i = n[e];n[e] = n[r], n[r] = i;
      }return n.length = t, n;
    }function $e(n) {
      if (typeof n == "string" || Au(n)) return n;var t = n + "";return "0" == t && 1 / n == -N ? "-0" : t;
    }function Fe(n) {
      if (null != n) {
        try {
          return fi.call(n);
        } catch (n) {}return n + "";
      }return "";
    }function Ne(n, t) {
      return u(Z, function (r) {
        var e = "_." + r[0];t & r[1] && !c(n, e) && n.push(e);
      }), n.sort();
    }function Pe(n) {
      if (n instanceof Mn) return n.clone();var t = new zn(n.__wrapped__, n.__chain__);return t.__actions__ = Mr(n.__actions__), t.__index__ = n.__index__, t.__values__ = n.__values__, t;
    }function Ze(n, t, r) {
      var e = null == n ? 0 : n.length;return e ? (r = null == r ? 0 : Ou(r), 0 > r && (r = Di(e + r, 0)), g(n, je(t, 3), r)) : -1;
    }function qe(n, t, r) {
      var e = null == n ? 0 : n.length;if (!e) return -1;var u = e - 1;return r !== F && (u = Ou(r), u = 0 > r ? Di(e + u, 0) : Mi(u, e - 1)), g(n, je(t, 3), u, true);
    }function Ve(n) {
      return (null == n ? 0 : n.length) ? kt(n, 1) : [];
    }function Ke(n) {
      return n && n.length ? n[0] : F;
    }function Ge(n) {
      var t = null == n ? 0 : n.length;return t ? n[t - 1] : F;
    }function He(n, t) {
      return n && n.length && t && t.length ? or(n, t) : n;
    }function Je(n) {
      return null == n ? n : Ni.call(n);
    }function Ye(n) {
      if (!n || !n.length) return [];var t = 0;return n = f(n, function (n) {
        if (_u(n)) return t = Di(n.length, t), true;
      }), E(t, function (t) {
        return l(n, j(t));
      });
    }function Qe(n, t) {
      if (!n || !n.length) return [];var e = Ye(n);return null == t ? e : l(e, function (n) {
        return r(t, F, n);
      });
    }function Xe(n) {
      return n = On(n), n.__chain__ = true, n;
    }function nu(n, t) {
      return t(n);
    }function tu() {
      return this;
    }function ru(n, t) {
      return (af(n) ? u : oo)(n, je(t, 3));
    }function eu(n, t) {
      return (af(n) ? i : fo)(n, je(t, 3));
    }function uu(n, t) {
      return (af(n) ? l : Yt)(n, je(t, 3));
    }function iu(n, t, r) {
      return t = r ? F : t, t = n && null == t ? n.length : t, le(n, 128, F, F, F, F, t);
    }function ou(n, t) {
      var r;if (typeof t != "function") throw new ei("Expected a function");return n = Ou(n), function () {
        return 0 < --n && (r = t.apply(this, arguments)), 1 >= n && (t = F), r;
      };
    }function fu(n, t, r) {
      return t = r ? F : t, n = le(n, 8, F, F, F, F, F, t), n.placeholder = fu.placeholder, n;
    }function cu(n, t, r) {
      return t = r ? F : t, n = le(n, 16, F, F, F, F, F, t), n.placeholder = cu.placeholder, n;
    }function au(n, t, r) {
      function e(t) {
        var r = c,
            e = a;return c = a = F, _ = t, s = n.apply(e, r);
      }function u(n) {
        var r = n - p;return n -= _, p === F || r >= t || 0 > r || g && n >= l;
      }function i() {
        var n = Jo();if (u(n)) return o(n);var r,
            e = jo;r = n - _, n = t - (n - p), r = g ? Mi(n, l - r) : n, h = e(i, r);
      }function o(n) {
        return h = F, d && c ? e(n) : (c = a = F, s);
      }function f() {
        var n = Jo(),
            r = u(n);if (c = arguments, a = this, p = n, r) {
          if (h === F) return _ = n = p, h = jo(i, t), v ? e(n) : s;if (g) return h = jo(i, t), e(p);
        }return h === F && (h = jo(i, t)), s;
      }var c,
          a,
          l,
          s,
          h,
          p,
          _ = 0,
          v = false,
          g = false,
          d = true;if (typeof n != "function") throw new ei("Expected a function");return t = Iu(t) || 0, bu(r) && (v = !!r.leading, l = (g = "maxWait" in r) ? Di(Iu(r.maxWait) || 0, t) : l, d = "trailing" in r ? !!r.trailing : d), f.cancel = function () {
        h !== F && ho(h), _ = 0, c = p = a = h = F;
      }, f.flush = function () {
        return h === F ? s : o(Jo());
      }, f;
    }function lu(n, t) {
      function r() {
        var e = arguments,
            u = t ? t.apply(this, e) : e[0],
            i = r.cache;return i.has(u) ? i.get(u) : (e = n.apply(this, e), r.cache = i.set(u, e) || i, e);
      }if (typeof n != "function" || null != t && typeof t != "function") throw new ei("Expected a function");return r.cache = new (lu.Cache || Pn)(), r;
    }function su(n) {
      if (typeof n != "function") throw new ei("Expected a function");return function () {
        var t = arguments;switch (t.length) {case 0:
            return !n.call(this);case 1:
            return !n.call(this, t[0]);case 2:
            return !n.call(this, t[0], t[1]);case 3:
            return !n.call(this, t[0], t[1], t[2]);}return !n.apply(this, t);
      };
    }function hu(n, t) {
      return n === t || n !== n && t !== t;
    }function pu(n) {
      return null != n && yu(n.length) && !gu(n);
    }function _u(n) {
      return xu(n) && pu(n);
    }function vu(n) {
      if (!xu(n)) return false;var t = zt(n);return "[object Error]" == t || "[object DOMException]" == t || typeof n.message == "string" && typeof n.name == "string" && !wu(n);
    }function gu(n) {
      return !!bu(n) && (n = zt(n), "[object Function]" == n || "[object GeneratorFunction]" == n || "[object AsyncFunction]" == n || "[object Proxy]" == n);
    }function du(n) {
      return typeof n == "number" && n == Ou(n);
    }function yu(n) {
      return typeof n == "number" && -1 < n && 0 == n % 1 && 9007199254740991 >= n;
    }function bu(n) {
      var t = typeof n === "undefined" ? "undefined" : _typeof(n);return null != n && ("object" == t || "function" == t);
    }function xu(n) {
      return null != n && (typeof n === "undefined" ? "undefined" : _typeof(n)) == "object";
    }function ju(n) {
      return typeof n == "number" || xu(n) && "[object Number]" == zt(n);
    }function wu(n) {
      return !(!xu(n) || "[object Object]" != zt(n)) && (n = bi(n), null === n || (n = ci.call(n, "constructor") && n.constructor, typeof n == "function" && n instanceof n && fi.call(n) == hi));
    }function mu(n) {
      return typeof n == "string" || !af(n) && xu(n) && "[object String]" == zt(n);
    }function Au(n) {
      return (typeof n === "undefined" ? "undefined" : _typeof(n)) == "symbol" || xu(n) && "[object Symbol]" == zt(n);
    }function ku(n) {
      if (!n) return [];if (pu(n)) return mu(n) ? $(n) : Mr(n);
      if (Ai && n[Ai]) {
        n = n[Ai]();for (var t, r = []; !(t = n.next()).done;) {
          r.push(t.value);
        }return r;
      }return t = yo(n), ("[object Map]" == t ? L : "[object Set]" == t ? D : Du)(n);
    }function Eu(n) {
      return n ? (n = Iu(n), n === N || n === -N ? 1.7976931348623157e308 * (0 > n ? -1 : 1) : n === n ? n : 0) : 0 === n ? n : 0;
    }function Ou(n) {
      n = Eu(n);var t = n % 1;return n === n ? t ? n - t : n : 0;
    }function Su(n) {
      return n ? gt(Ou(n), 0, 4294967295) : 0;
    }function Iu(n) {
      if (typeof n == "number") return n;if (Au(n)) return P;if (bu(n) && (n = typeof n.valueOf == "function" ? n.valueOf() : n, n = bu(n) ? n + "" : n), typeof n != "string") return 0 === n ? n : +n;
      n = n.replace(cn, "");var t = bn.test(n);return t || jn.test(n) ? Fn(n.slice(2), t ? 2 : 8) : yn.test(n) ? P : +n;
    }function Ru(n) {
      return Tr(n, Uu(n));
    }function zu(n) {
      return null == n ? "" : jr(n);
    }function Wu(n, t, r) {
      return n = null == n ? F : It(n, t), n === F ? r : n;
    }function Bu(n, t) {
      return null != n && ke(n, t, Lt);
    }function Lu(n) {
      return pu(n) ? Gn(n) : Ht(n);
    }function Uu(n) {
      if (pu(n)) n = Gn(n, true);else if (bu(n)) {
        var t,
            r = Le(n),
            e = [];for (t in n) {
          ("constructor" != t || !r && ci.call(n, t)) && e.push(t);
        }n = e;
      } else {
        if (t = [], null != n) for (r in ni(n)) {
          t.push(r);
        }n = t;
      }return n;
    }function Cu(n, t) {
      if (null == n) return {};var r = l(ye(n), function (n) {
        return [n];
      });return t = je(t), ur(n, r, function (n, r) {
        return t(n, r[0]);
      });
    }function Du(n) {
      return null == n ? [] : I(n, Lu(n));
    }function Mu(n) {
      return Nf(zu(n).toLowerCase());
    }function Tu(n) {
      return (n = zu(n)) && n.replace(mn, rt).replace(Rn, "");
    }function $u(n, t, r) {
      return n = zu(n), t = r ? F : t, t === F ? Ln.test(n) ? n.match(Wn) || [] : n.match(_n) || [] : n.match(t) || [];
    }function Fu(n) {
      return function () {
        return n;
      };
    }function Nu(n) {
      return n;
    }function Pu(n) {
      return Gt(typeof n == "function" ? n : dt(n, 1));
    }function Zu(n, t, r) {
      var e = Lu(t),
          i = St(t, e);null != r || bu(t) && (i.length || !e.length) || (r = t, t = n, n = this, i = St(t, Lu(t)));var o = !(bu(r) && "chain" in r && !r.chain),
          f = gu(n);return u(i, function (r) {
        var e = t[r];n[r] = e, f && (n.prototype[r] = function () {
          var t = this.__chain__;if (o || t) {
            var r = n(this.__wrapped__);return (r.__actions__ = Mr(this.__actions__)).push({ func: e, args: arguments, thisArg: n }), r.__chain__ = t, r;
          }return e.apply(n, s([this.value()], arguments));
        });
      }), n;
    }function qu() {}function Vu(n) {
      return We(n) ? j($e(n)) : ir(n);
    }function Ku() {
      return [];
    }function Gu() {
      return false;
    }En = null == En ? Zn : it.defaults(Zn.Object(), En, it.pick(Zn, Un));var Hu = En.Array,
        Ju = En.Date,
        Yu = En.Error,
        Qu = En.Function,
        Xu = En.Math,
        ni = En.Object,
        ti = En.RegExp,
        ri = En.String,
        ei = En.TypeError,
        ui = Hu.prototype,
        ii = ni.prototype,
        oi = En["__core-js_shared__"],
        fi = Qu.prototype.toString,
        ci = ii.hasOwnProperty,
        ai = 0,
        li = function () {
      var n = /[^.]+$/.exec(oi && oi.keys && oi.keys.IE_PROTO || "");return n ? "Symbol(src)_1." + n : "";
    }(),
        si = ii.toString,
        hi = fi.call(ni),
        pi = Zn._,
        _i = ti("^" + fi.call(ci).replace(on, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
        vi = Kn ? En.Buffer : F,
        gi = En.Symbol,
        di = En.Uint8Array,
        yi = vi ? vi.f : F,
        bi = U(ni.getPrototypeOf, ni),
        xi = ni.create,
        ji = ii.propertyIsEnumerable,
        wi = ui.splice,
        mi = gi ? gi.isConcatSpreadable : F,
        Ai = gi ? gi.iterator : F,
        ki = gi ? gi.toStringTag : F,
        Ei = function () {
      try {
        var n = Ae(ni, "defineProperty");return n({}, "", {}), n;
      } catch (n) {}
    }(),
        Oi = En.clearTimeout !== Zn.clearTimeout && En.clearTimeout,
        Si = Ju && Ju.now !== Zn.Date.now && Ju.now,
        Ii = En.setTimeout !== Zn.setTimeout && En.setTimeout,
        Ri = Xu.ceil,
        zi = Xu.floor,
        Wi = ni.getOwnPropertySymbols,
        Bi = vi ? vi.isBuffer : F,
        Li = En.isFinite,
        Ui = ui.join,
        Ci = U(ni.keys, ni),
        Di = Xu.max,
        Mi = Xu.min,
        Ti = Ju.now,
        $i = En.parseInt,
        Fi = Xu.random,
        Ni = ui.reverse,
        Pi = Ae(En, "DataView"),
        Zi = Ae(En, "Map"),
        qi = Ae(En, "Promise"),
        Vi = Ae(En, "Set"),
        Ki = Ae(En, "WeakMap"),
        Gi = Ae(ni, "create"),
        Hi = Ki && new Ki(),
        Ji = {},
        Yi = Fe(Pi),
        Qi = Fe(Zi),
        Xi = Fe(qi),
        no = Fe(Vi),
        to = Fe(Ki),
        ro = gi ? gi.prototype : F,
        eo = ro ? ro.valueOf : F,
        uo = ro ? ro.toString : F,
        io = function () {
      function n() {}return function (t) {
        return bu(t) ? xi ? xi(t) : (n.prototype = t, t = new n(), n.prototype = F, t) : {};
      };
    }();On.templateSettings = { escape: Q, evaluate: X, interpolate: nn, variable: "", imports: { _: On } }, On.prototype = Sn.prototype, On.prototype.constructor = On, zn.prototype = io(Sn.prototype), zn.prototype.constructor = zn, Mn.prototype = io(Sn.prototype), Mn.prototype.constructor = Mn, Tn.prototype.clear = function () {
      this.__data__ = Gi ? Gi(null) : {}, this.size = 0;
    }, Tn.prototype.delete = function (n) {
      return n = this.has(n) && delete this.__data__[n], this.size -= n ? 1 : 0, n;
    }, Tn.prototype.get = function (n) {
      var t = this.__data__;return Gi ? (n = t[n], "__lodash_hash_undefined__" === n ? F : n) : ci.call(t, n) ? t[n] : F;
    }, Tn.prototype.has = function (n) {
      var t = this.__data__;return Gi ? t[n] !== F : ci.call(t, n);
    }, Tn.prototype.set = function (n, t) {
      var r = this.__data__;return this.size += this.has(n) ? 0 : 1, r[n] = Gi && t === F ? "__lodash_hash_undefined__" : t, this;
    }, Nn.prototype.clear = function () {
      this.__data__ = [], this.size = 0;
    }, Nn.prototype.delete = function (n) {
      var t = this.__data__;return n = lt(t, n), !(0 > n) && (n == t.length - 1 ? t.pop() : wi.call(t, n, 1), --this.size, true);
    }, Nn.prototype.get = function (n) {
      var t = this.__data__;return n = lt(t, n), 0 > n ? F : t[n][1];
    }, Nn.prototype.has = function (n) {
      return -1 < lt(this.__data__, n);
    }, Nn.prototype.set = function (n, t) {
      var r = this.__data__,
          e = lt(r, n);return 0 > e ? (++this.size, r.push([n, t])) : r[e][1] = t, this;
    }, Pn.prototype.clear = function () {
      this.size = 0, this.__data__ = { hash: new Tn(), map: new (Zi || Nn)(), string: new Tn() };
    }, Pn.prototype.delete = function (n) {
      return n = we(this, n).delete(n), this.size -= n ? 1 : 0, n;
    }, Pn.prototype.get = function (n) {
      return we(this, n).get(n);
    }, Pn.prototype.has = function (n) {
      return we(this, n).has(n);
    }, Pn.prototype.set = function (n, t) {
      var r = we(this, n),
          e = r.size;return r.set(n, t), this.size += r.size == e ? 0 : 1, this;
    }, qn.prototype.add = qn.prototype.push = function (n) {
      return this.__data__.set(n, "__lodash_hash_undefined__"), this;
    }, qn.prototype.has = function (n) {
      return this.__data__.has(n);
    }, Vn.prototype.clear = function () {
      this.__data__ = new Nn(), this.size = 0;
    }, Vn.prototype.delete = function (n) {
      var t = this.__data__;return n = t.delete(n), this.size = t.size, n;
    }, Vn.prototype.get = function (n) {
      return this.__data__.get(n);
    }, Vn.prototype.has = function (n) {
      return this.__data__.has(n);
    }, Vn.prototype.set = function (n, t) {
      var r = this.__data__;if (r instanceof Nn) {
        var e = r.__data__;if (!Zi || 199 > e.length) return e.push([n, t]), this.size = ++r.size, this;r = this.__data__ = new Pn(e);
      }return r.set(n, t), this.size = r.size, this;
    };var oo = Zr(Et),
        fo = Zr(Ot, true),
        co = qr(),
        ao = qr(true),
        lo = Hi ? function (n, t) {
      return Hi.set(n, t), n;
    } : Nu,
        so = Ei ? function (n, t) {
      return Ei(n, "toString", { configurable: true, enumerable: false, value: Fu(t), writable: true });
    } : Nu,
        ho = Oi || function (n) {
      return Zn.clearTimeout(n);
    },
        po = Vi && 1 / D(new Vi([, -0]))[1] == N ? function (n) {
      return new Vi(n);
    } : qu,
        _o = Hi ? function (n) {
      return Hi.get(n);
    } : qu,
        vo = Wi ? function (n) {
      return null == n ? [] : (n = ni(n), f(Wi(n), function (t) {
        return ji.call(n, t);
      }));
    } : Ku,
        go = Wi ? function (n) {
      for (var t = []; n;) {
        s(t, vo(n)), n = bi(n);
      }return t;
    } : Ku,
        yo = zt;(Pi && "[object DataView]" != yo(new Pi(new ArrayBuffer(1))) || Zi && "[object Map]" != yo(new Zi()) || qi && "[object Promise]" != yo(qi.resolve()) || Vi && "[object Set]" != yo(new Vi()) || Ki && "[object WeakMap]" != yo(new Ki())) && (yo = function yo(n) {
      var t = zt(n);if (n = (n = "[object Object]" == t ? n.constructor : F) ? Fe(n) : "") switch (n) {case Yi:
          return "[object DataView]";case Qi:
          return "[object Map]";case Xi:
          return "[object Promise]";case no:
          return "[object Set]";case to:
          return "[object WeakMap]";}return t;
    });var bo = oi ? gu : Gu,
        xo = Me(lo),
        jo = Ii || function (n, t) {
      return Zn.setTimeout(n, t);
    },
        wo = Me(so),
        mo = function (n) {
      n = lu(n, function (n) {
        return 500 === t.size && t.clear(), n;
      });var t = n.cache;return n;
    }(function (n) {
      var t = [];return en.test(n) && t.push(""), n.replace(un, function (n, r, e, u) {
        t.push(e ? u.replace(vn, "$1") : r || n);
      }), t;
    }),
        Ao = lr(function (n, t) {
      return _u(n) ? jt(n, kt(t, 1, _u, true)) : [];
    }),
        ko = lr(function (n, t) {
      var r = Ge(t);return _u(r) && (r = F), _u(n) ? jt(n, kt(t, 1, _u, true), je(r, 2)) : [];
    }),
        Eo = lr(function (n, t) {
      var r = Ge(t);return _u(r) && (r = F), _u(n) ? jt(n, kt(t, 1, _u, true), F, r) : [];
    }),
        Oo = lr(function (n) {
      var t = l(n, Sr);return t.length && t[0] === n[0] ? Ut(t) : [];
    }),
        So = lr(function (n) {
      var t = Ge(n),
          r = l(n, Sr);return t === Ge(r) ? t = F : r.pop(), r.length && r[0] === n[0] ? Ut(r, je(t, 2)) : [];
    }),
        Io = lr(function (n) {
      var t = Ge(n),
          r = l(n, Sr);return (t = typeof t == "function" ? t : F) && r.pop(), r.length && r[0] === n[0] ? Ut(r, F, t) : [];
    }),
        Ro = lr(He),
        zo = ge(function (n, t) {
      var r = null == n ? 0 : n.length,
          e = vt(n, t);return fr(n, l(t, function (n) {
        return Re(n, r) ? +n : n;
      }).sort(Ur)), e;
    }),
        Wo = lr(function (n) {
      return wr(kt(n, 1, _u, true));
    }),
        Bo = lr(function (n) {
      var t = Ge(n);return _u(t) && (t = F), wr(kt(n, 1, _u, true), je(t, 2));
    }),
        Lo = lr(function (n) {
      var t = Ge(n),
          t = typeof t == "function" ? t : F;return wr(kt(n, 1, _u, true), F, t);
    }),
        Uo = lr(function (n, t) {
      return _u(n) ? jt(n, t) : [];
    }),
        Co = lr(function (n) {
      return Er(f(n, _u));
    }),
        Do = lr(function (n) {
      var t = Ge(n);return _u(t) && (t = F), Er(f(n, _u), je(t, 2));
    }),
        Mo = lr(function (n) {
      var t = Ge(n),
          t = typeof t == "function" ? t : F;return Er(f(n, _u), F, t);
    }),
        To = lr(Ye),
        $o = lr(function (n) {
      var t = n.length,
          t = 1 < t ? n[t - 1] : F,
          t = typeof t == "function" ? (n.pop(), t) : F;return Qe(n, t);
    }),
        Fo = ge(function (n) {
      function t(t) {
        return vt(t, n);
      }var r = n.length,
          e = r ? n[0] : 0,
          u = this.__wrapped__;return !(1 < r || this.__actions__.length) && u instanceof Mn && Re(e) ? (u = u.slice(e, +e + (r ? 1 : 0)), u.__actions__.push({ func: nu, args: [t], thisArg: F }), new zn(u, this.__chain__).thru(function (n) {
        return r && !n.length && n.push(F), n;
      })) : this.thru(t);
    }),
        No = Nr(function (n, t, r) {
      ci.call(n, r) ? ++n[r] : _t(n, r, 1);
    }),
        Po = Yr(Ze),
        Zo = Yr(qe),
        qo = Nr(function (n, t, r) {
      ci.call(n, r) ? n[r].push(t) : _t(n, r, [t]);
    }),
        Vo = lr(function (n, t, e) {
      var u = -1,
          i = typeof t == "function",
          o = pu(n) ? Hu(n.length) : [];return oo(n, function (n) {
        o[++u] = i ? r(t, n, e) : Dt(n, t, e);
      }), o;
    }),
        Ko = Nr(function (n, t, r) {
      _t(n, r, t);
    }),
        Go = Nr(function (n, t, r) {
      n[r ? 0 : 1].push(t);
    }, function () {
      return [[], []];
    }),
        Ho = lr(function (n, t) {
      if (null == n) return [];var r = t.length;return 1 < r && ze(n, t[0], t[1]) ? t = [] : 2 < r && ze(t[0], t[1], t[2]) && (t = [t[0]]), rr(n, kt(t, 1), []);
    }),
        Jo = Si || function () {
      return Zn.Date.now();
    },
        Yo = lr(function (n, t, r) {
      var e = 1;if (r.length) var u = C(r, xe(Yo)),
          e = 32 | e;return le(n, e, t, r, u);
    }),
        Qo = lr(function (n, t, r) {
      var e = 3;if (r.length) var u = C(r, xe(Qo)),
          e = 32 | e;return le(t, e, n, r, u);
    }),
        Xo = lr(function (n, t) {
      return xt(n, 1, t);
    }),
        nf = lr(function (n, t, r) {
      return xt(n, Iu(t) || 0, r);
    });lu.Cache = Pn;var tf = lr(function (n, t) {
      t = 1 == t.length && af(t[0]) ? l(t[0], S(je())) : l(kt(t, 1), S(je()));var e = t.length;return lr(function (u) {
        for (var i = -1, o = Mi(u.length, e); ++i < o;) {
          u[i] = t[i].call(this, u[i]);
        }return r(n, this, u);
      });
    }),
        rf = lr(function (n, t) {
      return le(n, 32, F, t, C(t, xe(rf)));
    }),
        ef = lr(function (n, t) {
      return le(n, 64, F, t, C(t, xe(ef)));
    }),
        uf = ge(function (n, t) {
      return le(n, 256, F, F, F, t);
    }),
        of = oe(Wt),
        ff = oe(function (n, t) {
      return n >= t;
    }),
        cf = Mt(function () {
      return arguments;
    }()) ? Mt : function (n) {
      return xu(n) && ci.call(n, "callee") && !ji.call(n, "callee");
    },
        af = Hu.isArray,
        lf = Hn ? S(Hn) : Tt,
        sf = Bi || Gu,
        hf = Jn ? S(Jn) : $t,
        pf = Yn ? S(Yn) : Nt,
        _f = Qn ? S(Qn) : qt,
        vf = Xn ? S(Xn) : Vt,
        gf = nt ? S(nt) : Kt,
        df = oe(Jt),
        yf = oe(function (n, t) {
      return n <= t;
    }),
        bf = Pr(function (n, t) {
      if (Le(t) || pu(t)) Tr(t, Lu(t), n);else for (var r in t) {
        ci.call(t, r) && at(n, r, t[r]);
      }
    }),
        xf = Pr(function (n, t) {
      Tr(t, Uu(t), n);
    }),
        jf = Pr(function (n, t, r, e) {
      Tr(t, Uu(t), n, e);
    }),
        wf = Pr(function (n, t, r, e) {
      Tr(t, Lu(t), n, e);
    }),
        mf = ge(vt),
        Af = lr(function (n) {
      return n.push(F, se), r(jf, F, n);
    }),
        kf = lr(function (n) {
      return n.push(F, he), r(Rf, F, n);
    }),
        Ef = ne(function (n, t, r) {
      n[t] = r;
    }, Fu(Nu)),
        Of = ne(function (n, t, r) {
      ci.call(n, t) ? n[t].push(r) : n[t] = [r];
    }, je),
        Sf = lr(Dt),
        If = Pr(function (n, t, r) {
      nr(n, t, r);
    }),
        Rf = Pr(function (n, t, r, e) {
      nr(n, t, r, e);
    }),
        zf = ge(function (n, t) {
      var r = {};if (null == n) return r;var e = false;t = l(t, function (t) {
        return t = Rr(t, n), e || (e = 1 < t.length), t;
      }), Tr(n, ye(n), r), e && (r = dt(r, 7, pe));for (var u = t.length; u--;) {
        mr(r, t[u]);
      }return r;
    }),
        Wf = ge(function (n, t) {
      return null == n ? {} : er(n, t);
    }),
        Bf = ae(Lu),
        Lf = ae(Uu),
        Uf = Gr(function (n, t, r) {
      return t = t.toLowerCase(), n + (r ? Mu(t) : t);
    }),
        Cf = Gr(function (n, t, r) {
      return n + (r ? "-" : "") + t.toLowerCase();
    }),
        Df = Gr(function (n, t, r) {
      return n + (r ? " " : "") + t.toLowerCase();
    }),
        Mf = Kr("toLowerCase"),
        Tf = Gr(function (n, t, r) {
      return n + (r ? "_" : "") + t.toLowerCase();
    }),
        $f = Gr(function (n, t, r) {
      return n + (r ? " " : "") + Nf(t);
    }),
        Ff = Gr(function (n, t, r) {
      return n + (r ? " " : "") + t.toUpperCase();
    }),
        Nf = Kr("toUpperCase"),
        Pf = lr(function (n, t) {
      try {
        return r(n, F, t);
      } catch (n) {
        return vu(n) ? n : new Yu(n);
      }
    }),
        Zf = ge(function (n, t) {
      return u(t, function (t) {
        t = $e(t), _t(n, t, Yo(n[t], n));
      }), n;
    }),
        qf = Qr(),
        Vf = Qr(true),
        Kf = lr(function (n, t) {
      return function (r) {
        return Dt(r, n, t);
      };
    }),
        Gf = lr(function (n, t) {
      return function (r) {
        return Dt(n, r, t);
      };
    }),
        Hf = re(l),
        Jf = re(o),
        Yf = re(_),
        Qf = ie(),
        Xf = ie(true),
        nc = te(function (n, t) {
      return n + t;
    }, 0),
        tc = ce("ceil"),
        rc = te(function (n, t) {
      return n / t;
    }, 1),
        ec = ce("floor"),
        uc = te(function (n, t) {
      return n * t;
    }, 1),
        ic = ce("round"),
        oc = te(function (n, t) {
      return n - t;
    }, 0);return On.after = function (n, t) {
      if (typeof t != "function") throw new ei("Expected a function");return n = Ou(n), function () {
        if (1 > --n) return t.apply(this, arguments);
      };
    }, On.ary = iu, On.assign = bf, On.assignIn = xf, On.assignInWith = jf, On.assignWith = wf, On.at = mf, On.before = ou, On.bind = Yo, On.bindAll = Zf, On.bindKey = Qo, On.castArray = function () {
      if (!arguments.length) return [];var n = arguments[0];return af(n) ? n : [n];
    }, On.chain = Xe, On.chunk = function (n, t, r) {
      if (t = (r ? ze(n, t, r) : t === F) ? 1 : Di(Ou(t), 0), r = null == n ? 0 : n.length, !r || 1 > t) return [];for (var e = 0, u = 0, i = Hu(Ri(r / t)); e < r;) {
        i[u++] = vr(n, e, e += t);
      }return i;
    }, On.compact = function (n) {
      for (var t = -1, r = null == n ? 0 : n.length, e = 0, u = []; ++t < r;) {
        var i = n[t];i && (u[e++] = i);
      }return u;
    }, On.concat = function () {
      var n = arguments.length;if (!n) return [];for (var t = Hu(n - 1), r = arguments[0]; n--;) {
        t[n - 1] = arguments[n];
      }return s(af(r) ? Mr(r) : [r], kt(t, 1));
    }, On.cond = function (n) {
      var t = null == n ? 0 : n.length,
          e = je();return n = t ? l(n, function (n) {
        if ("function" != typeof n[1]) throw new ei("Expected a function");return [e(n[0]), n[1]];
      }) : [], lr(function (e) {
        for (var u = -1; ++u < t;) {
          var i = n[u];if (r(i[0], this, e)) return r(i[1], this, e);
        }
      });
    }, On.conforms = function (n) {
      return yt(dt(n, 1));
    }, On.constant = Fu, On.countBy = No, On.create = function (n, t) {
      var r = io(n);return null == t ? r : ht(r, t);
    }, On.curry = fu, On.curryRight = cu, On.debounce = au, On.defaults = Af, On.defaultsDeep = kf, On.defer = Xo, On.delay = nf, On.difference = Ao, On.differenceBy = ko, On.differenceWith = Eo, On.drop = function (n, t, r) {
      var e = null == n ? 0 : n.length;
      return e ? (t = r || t === F ? 1 : Ou(t), vr(n, 0 > t ? 0 : t, e)) : [];
    }, On.dropRight = function (n, t, r) {
      var e = null == n ? 0 : n.length;return e ? (t = r || t === F ? 1 : Ou(t), t = e - t, vr(n, 0, 0 > t ? 0 : t)) : [];
    }, On.dropRightWhile = function (n, t) {
      return n && n.length ? Ar(n, je(t, 3), true, true) : [];
    }, On.dropWhile = function (n, t) {
      return n && n.length ? Ar(n, je(t, 3), true) : [];
    }, On.fill = function (n, t, r, e) {
      var u = null == n ? 0 : n.length;if (!u) return [];for (r && typeof r != "number" && ze(n, t, r) && (r = 0, e = u), u = n.length, r = Ou(r), 0 > r && (r = -r > u ? 0 : u + r), e = e === F || e > u ? u : Ou(e), 0 > e && (e += u), e = r > e ? 0 : Su(e); r < e;) {
        n[r++] = t;
      }return n;
    }, On.filter = function (n, t) {
      return (af(n) ? f : At)(n, je(t, 3));
    }, On.flatMap = function (n, t) {
      return kt(uu(n, t), 1);
    }, On.flatMapDeep = function (n, t) {
      return kt(uu(n, t), N);
    }, On.flatMapDepth = function (n, t, r) {
      return r = r === F ? 1 : Ou(r), kt(uu(n, t), r);
    }, On.flatten = Ve, On.flattenDeep = function (n) {
      return (null == n ? 0 : n.length) ? kt(n, N) : [];
    }, On.flattenDepth = function (n, t) {
      return null != n && n.length ? (t = t === F ? 1 : Ou(t), kt(n, t)) : [];
    }, On.flip = function (n) {
      return le(n, 512);
    }, On.flow = qf, On.flowRight = Vf, On.fromPairs = function (n) {
      for (var t = -1, r = null == n ? 0 : n.length, e = {}; ++t < r;) {
        var u = n[t];e[u[0]] = u[1];
      }return e;
    }, On.functions = function (n) {
      return null == n ? [] : St(n, Lu(n));
    }, On.functionsIn = function (n) {
      return null == n ? [] : St(n, Uu(n));
    }, On.groupBy = qo, On.initial = function (n) {
      return (null == n ? 0 : n.length) ? vr(n, 0, -1) : [];
    }, On.intersection = Oo, On.intersectionBy = So, On.intersectionWith = Io, On.invert = Ef, On.invertBy = Of, On.invokeMap = Vo, On.iteratee = Pu, On.keyBy = Ko, On.keys = Lu, On.keysIn = Uu, On.map = uu, On.mapKeys = function (n, t) {
      var r = {};return t = je(t, 3), Et(n, function (n, e, u) {
        _t(r, t(n, e, u), n);
      }), r;
    }, On.mapValues = function (n, t) {
      var r = {};return t = je(t, 3), Et(n, function (n, e, u) {
        _t(r, e, t(n, e, u));
      }), r;
    }, On.matches = function (n) {
      return Qt(dt(n, 1));
    }, On.matchesProperty = function (n, t) {
      return Xt(n, dt(t, 1));
    }, On.memoize = lu, On.merge = If, On.mergeWith = Rf, On.method = Kf, On.methodOf = Gf, On.mixin = Zu, On.negate = su, On.nthArg = function (n) {
      return n = Ou(n), lr(function (t) {
        return tr(t, n);
      });
    }, On.omit = zf, On.omitBy = function (n, t) {
      return Cu(n, su(je(t)));
    }, On.once = function (n) {
      return ou(2, n);
    }, On.orderBy = function (n, t, r, e) {
      return null == n ? [] : (af(t) || (t = null == t ? [] : [t]), r = e ? F : r, af(r) || (r = null == r ? [] : [r]), rr(n, t, r));
    }, On.over = Hf, On.overArgs = tf, On.overEvery = Jf, On.overSome = Yf, On.partial = rf, On.partialRight = ef, On.partition = Go, On.pick = Wf, On.pickBy = Cu, On.property = Vu, On.propertyOf = function (n) {
      return function (t) {
        return null == n ? F : It(n, t);
      };
    }, On.pull = Ro, On.pullAll = He, On.pullAllBy = function (n, t, r) {
      return n && n.length && t && t.length ? or(n, t, je(r, 2)) : n;
    }, On.pullAllWith = function (n, t, r) {
      return n && n.length && t && t.length ? or(n, t, F, r) : n;
    }, On.pullAt = zo, On.range = Qf, On.rangeRight = Xf, On.rearg = uf, On.reject = function (n, t) {
      return (af(n) ? f : At)(n, su(je(t, 3)));
    }, On.remove = function (n, t) {
      var r = [];if (!n || !n.length) return r;var e = -1,
          u = [],
          i = n.length;for (t = je(t, 3); ++e < i;) {
        var o = n[e];t(o, e, n) && (r.push(o), u.push(e));
      }return fr(n, u), r;
    }, On.rest = function (n, t) {
      if (typeof n != "function") throw new ei("Expected a function");return t = t === F ? t : Ou(t), lr(n, t);
    }, On.reverse = Je, On.sampleSize = function (n, t, r) {
      return t = (r ? ze(n, t, r) : t === F) ? 1 : Ou(t), (af(n) ? ot : hr)(n, t);
    }, On.set = function (n, t, r) {
      return null == n ? n : pr(n, t, r);
    }, On.setWith = function (n, t, r, e) {
      return e = typeof e == "function" ? e : F, null == n ? n : pr(n, t, r, e);
    }, On.shuffle = function (n) {
      return (af(n) ? ft : _r)(n);
    }, On.slice = function (n, t, r) {
      var e = null == n ? 0 : n.length;return e ? (r && typeof r != "number" && ze(n, t, r) ? (t = 0, r = e) : (t = null == t ? 0 : Ou(t), r = r === F ? e : Ou(r)), vr(n, t, r)) : [];
    }, On.sortBy = Ho, On.sortedUniq = function (n) {
      return n && n.length ? br(n) : [];
    }, On.sortedUniqBy = function (n, t) {
      return n && n.length ? br(n, je(t, 2)) : [];
    }, On.split = function (n, t, r) {
      return r && typeof r != "number" && ze(n, t, r) && (t = r = F), r = r === F ? 4294967295 : r >>> 0, r ? (n = zu(n)) && (typeof t == "string" || null != t && !_f(t)) && (t = jr(t), !t && Bn.test(n)) ? zr($(n), 0, r) : n.split(t, r) : [];
    }, On.spread = function (n, t) {
      if (typeof n != "function") throw new ei("Expected a function");return t = null == t ? 0 : Di(Ou(t), 0), lr(function (e) {
        var u = e[t];return e = zr(e, 0, t), u && s(e, u), r(n, this, e);
      });
    }, On.tail = function (n) {
      var t = null == n ? 0 : n.length;return t ? vr(n, 1, t) : [];
    }, On.take = function (n, t, r) {
      return n && n.length ? (t = r || t === F ? 1 : Ou(t), vr(n, 0, 0 > t ? 0 : t)) : [];
    }, On.takeRight = function (n, t, r) {
      var e = null == n ? 0 : n.length;return e ? (t = r || t === F ? 1 : Ou(t), t = e - t, vr(n, 0 > t ? 0 : t, e)) : [];
    }, On.takeRightWhile = function (n, t) {
      return n && n.length ? Ar(n, je(t, 3), false, true) : [];
    }, On.takeWhile = function (n, t) {
      return n && n.length ? Ar(n, je(t, 3)) : [];
    }, On.tap = function (n, t) {
      return t(n), n;
    }, On.throttle = function (n, t, r) {
      var e = true,
          u = true;if (typeof n != "function") throw new ei("Expected a function");return bu(r) && (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), au(n, t, { leading: e, maxWait: t, trailing: u });
    }, On.thru = nu, On.toArray = ku, On.toPairs = Bf, On.toPairsIn = Lf, On.toPath = function (n) {
      return af(n) ? l(n, $e) : Au(n) ? [n] : Mr(mo(zu(n)));
    }, On.toPlainObject = Ru, On.transform = function (n, t, r) {
      var e = af(n),
          i = e || sf(n) || gf(n);if (t = je(t, 4), null == r) {
        var o = n && n.constructor;r = i ? e ? new o() : [] : bu(n) && gu(o) ? io(bi(n)) : {};
      }return (i ? u : Et)(n, function (n, e, u) {
        return t(r, n, e, u);
      }), r;
    }, On.unary = function (n) {
      return iu(n, 1);
    }, On.union = Wo, On.unionBy = Bo, On.unionWith = Lo, On.uniq = function (n) {
      return n && n.length ? wr(n) : [];
    }, On.uniqBy = function (n, t) {
      return n && n.length ? wr(n, je(t, 2)) : [];
    }, On.uniqWith = function (n, t) {
      return t = typeof t == "function" ? t : F, n && n.length ? wr(n, F, t) : [];
    }, On.unset = function (n, t) {
      return null == n || mr(n, t);
    }, On.unzip = Ye, On.unzipWith = Qe, On.update = function (n, t, r) {
      return null == n ? n : pr(n, t, Ir(r)(It(n, t)), void 0);
    }, On.updateWith = function (n, t, r, e) {
      return e = typeof e == "function" ? e : F, null != n && (n = pr(n, t, Ir(r)(It(n, t)), e)), n;
    }, On.values = Du, On.valuesIn = function (n) {
      return null == n ? [] : I(n, Uu(n));
    }, On.without = Uo, On.words = $u, On.wrap = function (n, t) {
      return rf(Ir(t), n);
    }, On.xor = Co, On.xorBy = Do, On.xorWith = Mo, On.zip = To, On.zipObject = function (n, t) {
      return Or(n || [], t || [], at);
    }, On.zipObjectDeep = function (n, t) {
      return Or(n || [], t || [], pr);
    }, On.zipWith = $o, On.entries = Bf, On.entriesIn = Lf, On.extend = xf, On.extendWith = jf, Zu(On, On), On.add = nc, On.attempt = Pf, On.camelCase = Uf, On.capitalize = Mu, On.ceil = tc, On.clamp = function (n, t, r) {
      return r === F && (r = t, t = F), r !== F && (r = Iu(r), r = r === r ? r : 0), t !== F && (t = Iu(t), t = t === t ? t : 0), gt(Iu(n), t, r);
    }, On.clone = function (n) {
      return dt(n, 4);
    }, On.cloneDeep = function (n) {
      return dt(n, 5);
    }, On.cloneDeepWith = function (n, t) {
      return t = typeof t == "function" ? t : F, dt(n, 5, t);
    }, On.cloneWith = function (n, t) {
      return t = typeof t == "function" ? t : F, dt(n, 4, t);
    }, On.conformsTo = function (n, t) {
      return null == t || bt(n, t, Lu(t));
    }, On.deburr = Tu, On.defaultTo = function (n, t) {
      return null == n || n !== n ? t : n;
    }, On.divide = rc, On.endsWith = function (n, t, r) {
      n = zu(n), t = jr(t);var e = n.length,
          e = r = r === F ? e : gt(Ou(r), 0, e);return r -= t.length, 0 <= r && n.slice(r, e) == t;
    }, On.eq = hu, On.escape = function (n) {
      return (n = zu(n)) && Y.test(n) ? n.replace(H, et) : n;
    }, On.escapeRegExp = function (n) {
      return (n = zu(n)) && fn.test(n) ? n.replace(on, "\\$&") : n;
    }, On.every = function (n, t, r) {
      var e = af(n) ? o : wt;return r && ze(n, t, r) && (t = F), e(n, je(t, 3));
    }, On.find = Po, On.findIndex = Ze, On.findKey = function (n, t) {
      return v(n, je(t, 3), Et);
    }, On.findLast = Zo, On.findLastIndex = qe, On.findLastKey = function (n, t) {
      return v(n, je(t, 3), Ot);
    }, On.floor = ec, On.forEach = ru, On.forEachRight = eu, On.forIn = function (n, t) {
      return null == n ? n : co(n, je(t, 3), Uu);
    }, On.forInRight = function (n, t) {
      return null == n ? n : ao(n, je(t, 3), Uu);
    }, On.forOwn = function (n, t) {
      return n && Et(n, je(t, 3));
    }, On.forOwnRight = function (n, t) {
      return n && Ot(n, je(t, 3));
    }, On.get = Wu, On.gt = of, On.gte = ff, On.has = function (n, t) {
      return null != n && ke(n, t, Bt);
    }, On.hasIn = Bu, On.head = Ke, On.identity = Nu, On.includes = function (n, t, r, e) {
      return n = pu(n) ? n : Du(n), r = r && !e ? Ou(r) : 0, e = n.length, 0 > r && (r = Di(e + r, 0)), mu(n) ? r <= e && -1 < n.indexOf(t, r) : !!e && -1 < d(n, t, r);
    }, On.indexOf = function (n, t, r) {
      var e = null == n ? 0 : n.length;return e ? (r = null == r ? 0 : Ou(r), 0 > r && (r = Di(e + r, 0)), d(n, t, r)) : -1;
    }, On.inRange = function (n, t, r) {
      return t = Eu(t), r === F ? (r = t, t = 0) : r = Eu(r), n = Iu(n), n >= Mi(t, r) && n < Di(t, r);
    }, On.invoke = Sf, On.isArguments = cf, On.isArray = af, On.isArrayBuffer = lf, On.isArrayLike = pu, On.isArrayLikeObject = _u, On.isBoolean = function (n) {
      return true === n || false === n || xu(n) && "[object Boolean]" == zt(n);
    }, On.isBuffer = sf, On.isDate = hf, On.isElement = function (n) {
      return xu(n) && 1 === n.nodeType && !wu(n);
    }, On.isEmpty = function (n) {
      if (null == n) return true;if (pu(n) && (af(n) || typeof n == "string" || typeof n.splice == "function" || sf(n) || gf(n) || cf(n))) return !n.length;var t = yo(n);if ("[object Map]" == t || "[object Set]" == t) return !n.size;if (Le(n)) return !Ht(n).length;for (var r in n) {
        if (ci.call(n, r)) return false;
      }return true;
    }, On.isEqual = function (n, t) {
      return Ft(n, t);
    }, On.isEqualWith = function (n, t, r) {
      var e = (r = typeof r == "function" ? r : F) ? r(n, t) : F;return e === F ? Ft(n, t, F, r) : !!e;
    }, On.isError = vu, On.isFinite = function (n) {
      return typeof n == "number" && Li(n);
    }, On.isFunction = gu, On.isInteger = du, On.isLength = yu, On.isMap = pf, On.isMatch = function (n, t) {
      return n === t || Pt(n, t, me(t));
    }, On.isMatchWith = function (n, t, r) {
      return r = typeof r == "function" ? r : F, Pt(n, t, me(t), r);
    }, On.isNaN = function (n) {
      return ju(n) && n != +n;
    }, On.isNative = function (n) {
      if (bo(n)) throw new Yu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
      return Zt(n);
    }, On.isNil = function (n) {
      return null == n;
    }, On.isNull = function (n) {
      return null === n;
    }, On.isNumber = ju, On.isObject = bu, On.isObjectLike = xu, On.isPlainObject = wu, On.isRegExp = _f, On.isSafeInteger = function (n) {
      return du(n) && -9007199254740991 <= n && 9007199254740991 >= n;
    }, On.isSet = vf, On.isString = mu, On.isSymbol = Au, On.isTypedArray = gf, On.isUndefined = function (n) {
      return n === F;
    }, On.isWeakMap = function (n) {
      return xu(n) && "[object WeakMap]" == yo(n);
    }, On.isWeakSet = function (n) {
      return xu(n) && "[object WeakSet]" == zt(n);
    }, On.join = function (n, t) {
      return null == n ? "" : Ui.call(n, t);
    }, On.kebabCase = Cf, On.last = Ge, On.lastIndexOf = function (n, t, r) {
      var e = null == n ? 0 : n.length;if (!e) return -1;var u = e;if (r !== F && (u = Ou(r), u = 0 > u ? Di(e + u, 0) : Mi(u, e - 1)), t === t) {
        for (r = u + 1; r-- && n[r] !== t;) {}n = r;
      } else n = g(n, b, u, true);return n;
    }, On.lowerCase = Df, On.lowerFirst = Mf, On.lt = df, On.lte = yf, On.max = function (n) {
      return n && n.length ? mt(n, Nu, Wt) : F;
    }, On.maxBy = function (n, t) {
      return n && n.length ? mt(n, je(t, 2), Wt) : F;
    }, On.mean = function (n) {
      return x(n, Nu);
    }, On.meanBy = function (n, t) {
      return x(n, je(t, 2));
    }, On.min = function (n) {
      return n && n.length ? mt(n, Nu, Jt) : F;
    }, On.minBy = function (n, t) {
      return n && n.length ? mt(n, je(t, 2), Jt) : F;
    }, On.stubArray = Ku, On.stubFalse = Gu, On.stubObject = function () {
      return {};
    }, On.stubString = function () {
      return "";
    }, On.stubTrue = function () {
      return true;
    }, On.multiply = uc, On.nth = function (n, t) {
      return n && n.length ? tr(n, Ou(t)) : F;
    }, On.noConflict = function () {
      return Zn._ === this && (Zn._ = pi), this;
    }, On.noop = qu, On.now = Jo, On.pad = function (n, t, r) {
      n = zu(n);var e = (t = Ou(t)) ? T(n) : 0;return !t || e >= t ? n : (t = (t - e) / 2, ee(zi(t), r) + n + ee(Ri(t), r));
    }, On.padEnd = function (n, t, r) {
      n = zu(n);var e = (t = Ou(t)) ? T(n) : 0;return t && e < t ? n + ee(t - e, r) : n;
    }, On.padStart = function (n, t, r) {
      n = zu(n);var e = (t = Ou(t)) ? T(n) : 0;return t && e < t ? ee(t - e, r) + n : n;
    }, On.parseInt = function (n, t, r) {
      return r || null == t ? t = 0 : t && (t = +t), $i(zu(n).replace(an, ""), t || 0);
    }, On.random = function (n, t, r) {
      if (r && typeof r != "boolean" && ze(n, t, r) && (t = r = F), r === F && (typeof t == "boolean" ? (r = t, t = F) : typeof n == "boolean" && (r = n, n = F)), n === F && t === F ? (n = 0, t = 1) : (n = Eu(n), t === F ? (t = n, n = 0) : t = Eu(t)), n > t) {
        var e = n;n = t, t = e;
      }return r || n % 1 || t % 1 ? (r = Fi(), Mi(n + r * (t - n + $n("1e-" + ((r + "").length - 1))), t)) : cr(n, t);
    }, On.reduce = function (n, t, r) {
      var e = af(n) ? h : m,
          u = 3 > arguments.length;return e(n, je(t, 4), r, u, oo);
    }, On.reduceRight = function (n, t, r) {
      var e = af(n) ? p : m,
          u = 3 > arguments.length;return e(n, je(t, 4), r, u, fo);
    }, On.repeat = function (n, t, r) {
      return t = (r ? ze(n, t, r) : t === F) ? 1 : Ou(t), ar(zu(n), t);
    }, On.replace = function () {
      var n = arguments,
          t = zu(n[0]);return 3 > n.length ? t : t.replace(n[1], n[2]);
    }, On.result = function (n, t, r) {
      t = Rr(t, n);var e = -1,
          u = t.length;for (u || (u = 1, n = F); ++e < u;) {
        var i = null == n ? F : n[$e(t[e])];i === F && (e = u, i = r), n = gu(i) ? i.call(n) : i;
      }return n;
    }, On.round = ic, On.runInContext = w, On.sample = function (n) {
      return (af(n) ? tt : sr)(n);
    }, On.size = function (n) {
      if (null == n) return 0;if (pu(n)) return mu(n) ? T(n) : n.length;var t = yo(n);return "[object Map]" == t || "[object Set]" == t ? n.size : Ht(n).length;
    }, On.snakeCase = Tf, On.some = function (n, t, r) {
      var e = af(n) ? _ : gr;return r && ze(n, t, r) && (t = F), e(n, je(t, 3));
    }, On.sortedIndex = function (n, t) {
      return dr(n, t);
    }, On.sortedIndexBy = function (n, t, r) {
      return yr(n, t, je(r, 2));
    }, On.sortedIndexOf = function (n, t) {
      var r = null == n ? 0 : n.length;if (r) {
        var e = dr(n, t);if (e < r && hu(n[e], t)) return e;
      }return -1;
    }, On.sortedLastIndex = function (n, t) {
      return dr(n, t, true);
    }, On.sortedLastIndexBy = function (n, t, r) {
      return yr(n, t, je(r, 2), true);
    }, On.sortedLastIndexOf = function (n, t) {
      if (null == n ? 0 : n.length) {
        var r = dr(n, t, true) - 1;if (hu(n[r], t)) return r;
      }return -1;
    }, On.startCase = $f, On.startsWith = function (n, t, r) {
      return n = zu(n), r = null == r ? 0 : gt(Ou(r), 0, n.length), t = jr(t), n.slice(r, r + t.length) == t;
    }, On.subtract = oc, On.sum = function (n) {
      return n && n.length ? k(n, Nu) : 0;
    }, On.sumBy = function (n, t) {
      return n && n.length ? k(n, je(t, 2)) : 0;
    }, On.template = function (n, t, r) {
      var e = On.templateSettings;r && ze(n, t, r) && (t = F), n = zu(n), t = jf({}, t, e, se), r = jf({}, t.imports, e.imports, se);var u,
          i,
          o = Lu(r),
          f = I(r, o),
          c = 0;r = t.interpolate || An;var a = "__p+='";r = ti((t.escape || An).source + "|" + r.source + "|" + (r === nn ? gn : An).source + "|" + (t.evaluate || An).source + "|$", "g");var l = "sourceURL" in t ? "//# sourceURL=" + t.sourceURL + "\n" : "";if (n.replace(r, function (t, r, e, o, f, l) {
        return e || (e = o), a += n.slice(c, l).replace(kn, B), r && (u = true, a += "'+__e(" + r + ")+'"), f && (i = true, a += "';" + f + ";\n__p+='"), e && (a += "'+((__t=(" + e + "))==null?'':__t)+'"), c = l + t.length, t;
      }), a += "';", (t = t.variable) || (a = "with(obj){" + a + "}"), a = (i ? a.replace(q, "") : a).replace(V, "$1").replace(K, "$1;"), a = "function(" + (t || "obj") + "){" + (t ? "" : "obj||(obj={});") + "var __t,__p=''" + (u ? ",__e=_.escape" : "") + (i ? ",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}" : ";") + a + "return __p}", t = Pf(function () {
        return Qu(o, l + "return " + a).apply(F, f);
      }), t.source = a, vu(t)) throw t;return t;
    }, On.times = function (n, t) {
      if (n = Ou(n), 1 > n || 9007199254740991 < n) return [];
      var r = 4294967295,
          e = Mi(n, 4294967295);for (t = je(t), n -= 4294967295, e = E(e, t); ++r < n;) {
        t(r);
      }return e;
    }, On.toFinite = Eu, On.toInteger = Ou, On.toLength = Su, On.toLower = function (n) {
      return zu(n).toLowerCase();
    }, On.toNumber = Iu, On.toSafeInteger = function (n) {
      return n ? gt(Ou(n), -9007199254740991, 9007199254740991) : 0 === n ? n : 0;
    }, On.toString = zu, On.toUpper = function (n) {
      return zu(n).toUpperCase();
    }, On.trim = function (n, t, r) {
      return (n = zu(n)) && (r || t === F) ? n.replace(cn, "") : n && (t = jr(t)) ? (n = $(n), r = $(t), t = z(n, r), r = W(n, r) + 1, zr(n, t, r).join("")) : n;
    }, On.trimEnd = function (n, t, r) {
      return (n = zu(n)) && (r || t === F) ? n.replace(ln, "") : n && (t = jr(t)) ? (n = $(n), t = W(n, $(t)) + 1, zr(n, 0, t).join("")) : n;
    }, On.trimStart = function (n, t, r) {
      return (n = zu(n)) && (r || t === F) ? n.replace(an, "") : n && (t = jr(t)) ? (n = $(n), t = z(n, $(t)), zr(n, t).join("")) : n;
    }, On.truncate = function (n, t) {
      var r = 30,
          e = "...";if (bu(t)) var u = "separator" in t ? t.separator : u,
          r = "length" in t ? Ou(t.length) : r,
          e = "omission" in t ? jr(t.omission) : e;n = zu(n);var i = n.length;if (Bn.test(n)) var o = $(n),
          i = o.length;if (r >= i) return n;if (i = r - T(e), 1 > i) return e;
      if (r = o ? zr(o, 0, i).join("") : n.slice(0, i), u === F) return r + e;if (o && (i += r.length - i), _f(u)) {
        if (n.slice(i).search(u)) {
          var f = r;for (u.global || (u = ti(u.source, zu(dn.exec(u)) + "g")), u.lastIndex = 0; o = u.exec(f);) {
            var c = o.index;
          }r = r.slice(0, c === F ? i : c);
        }
      } else n.indexOf(jr(u), i) != i && (u = r.lastIndexOf(u), -1 < u && (r = r.slice(0, u)));return r + e;
    }, On.unescape = function (n) {
      return (n = zu(n)) && J.test(n) ? n.replace(G, ut) : n;
    }, On.uniqueId = function (n) {
      var t = ++ai;return zu(n) + t;
    }, On.upperCase = Ff, On.upperFirst = Nf, On.each = ru, On.eachRight = eu, On.first = Ke, Zu(On, function () {
      var n = {};return Et(On, function (t, r) {
        ci.call(On.prototype, r) || (n[r] = t);
      }), n;
    }(), { chain: false }), On.VERSION = "4.17.4", u("bind bindKey curry curryRight partial partialRight".split(" "), function (n) {
      On[n].placeholder = On;
    }), u(["drop", "take"], function (n, t) {
      Mn.prototype[n] = function (r) {
        r = r === F ? 1 : Di(Ou(r), 0);var e = this.__filtered__ && !t ? new Mn(this) : this.clone();return e.__filtered__ ? e.__takeCount__ = Mi(r, e.__takeCount__) : e.__views__.push({ size: Mi(r, 4294967295), type: n + (0 > e.__dir__ ? "Right" : "") }), e;
      }, Mn.prototype[n + "Right"] = function (t) {
        return this.reverse()[n](t).reverse();
      };
    }), u(["filter", "map", "takeWhile"], function (n, t) {
      var r = t + 1,
          e = 1 == r || 3 == r;Mn.prototype[n] = function (n) {
        var t = this.clone();return t.__iteratees__.push({ iteratee: je(n, 3), type: r }), t.__filtered__ = t.__filtered__ || e, t;
      };
    }), u(["head", "last"], function (n, t) {
      var r = "take" + (t ? "Right" : "");Mn.prototype[n] = function () {
        return this[r](1).value()[0];
      };
    }), u(["initial", "tail"], function (n, t) {
      var r = "drop" + (t ? "" : "Right");Mn.prototype[n] = function () {
        return this.__filtered__ ? new Mn(this) : this[r](1);
      };
    }), Mn.prototype.compact = function () {
      return this.filter(Nu);
    }, Mn.prototype.find = function (n) {
      return this.filter(n).head();
    }, Mn.prototype.findLast = function (n) {
      return this.reverse().find(n);
    }, Mn.prototype.invokeMap = lr(function (n, t) {
      return typeof n == "function" ? new Mn(this) : this.map(function (r) {
        return Dt(r, n, t);
      });
    }), Mn.prototype.reject = function (n) {
      return this.filter(su(je(n)));
    }, Mn.prototype.slice = function (n, t) {
      n = Ou(n);var r = this;return r.__filtered__ && (0 < n || 0 > t) ? new Mn(r) : (0 > n ? r = r.takeRight(-n) : n && (r = r.drop(n)), t !== F && (t = Ou(t), r = 0 > t ? r.dropRight(-t) : r.take(t - n)), r);
    }, Mn.prototype.takeRightWhile = function (n) {
      return this.reverse().takeWhile(n).reverse();
    }, Mn.prototype.toArray = function () {
      return this.take(4294967295);
    }, Et(Mn.prototype, function (n, t) {
      var r = /^(?:filter|find|map|reject)|While$/.test(t),
          e = /^(?:head|last)$/.test(t),
          u = On[e ? "take" + ("last" == t ? "Right" : "") : t],
          i = e || /^find/.test(t);u && (On.prototype[t] = function () {
        function t(n) {
          return n = u.apply(On, s([n], f)), e && h ? n[0] : n;
        }var o = this.__wrapped__,
            f = e ? [1] : arguments,
            c = o instanceof Mn,
            a = f[0],
            l = c || af(o);
        l && r && typeof a == "function" && 1 != a.length && (c = l = false);var h = this.__chain__,
            p = !!this.__actions__.length,
            a = i && !h,
            c = c && !p;return !i && l ? (o = c ? o : new Mn(this), o = n.apply(o, f), o.__actions__.push({ func: nu, args: [t], thisArg: F }), new zn(o, h)) : a && c ? n.apply(this, f) : (o = this.thru(t), a ? e ? o.value()[0] : o.value() : o);
      });
    }), u("pop push shift sort splice unshift".split(" "), function (n) {
      var t = ui[n],
          r = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru",
          e = /^(?:pop|shift)$/.test(n);On.prototype[n] = function () {
        var n = arguments;if (e && !this.__chain__) {
          var u = this.value();return t.apply(af(u) ? u : [], n);
        }return this[r](function (r) {
          return t.apply(af(r) ? r : [], n);
        });
      };
    }), Et(Mn.prototype, function (n, t) {
      var r = On[t];if (r) {
        var e = r.name + "";(Ji[e] || (Ji[e] = [])).push({ name: t, func: r });
      }
    }), Ji[Xr(F, 2).name] = [{ name: "wrapper", func: F }], Mn.prototype.clone = function () {
      var n = new Mn(this.__wrapped__);return n.__actions__ = Mr(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = Mr(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = Mr(this.__views__), n;
    }, Mn.prototype.reverse = function () {
      if (this.__filtered__) {
        var n = new Mn(this);n.__dir__ = -1, n.__filtered__ = true;
      } else n = this.clone(), n.__dir__ *= -1;return n;
    }, Mn.prototype.value = function () {
      var n,
          t = this.__wrapped__.value(),
          r = this.__dir__,
          e = af(t),
          u = 0 > r,
          i = e ? t.length : 0;n = i;for (var o = this.__views__, f = 0, c = -1, a = o.length; ++c < a;) {
        var l = o[c],
            s = l.size;switch (l.type) {case "drop":
            f += s;break;case "dropRight":
            n -= s;break;case "take":
            n = Mi(n, f + s);break;case "takeRight":
            f = Di(f, n - s);}
      }if (n = { start: f, end: n }, o = n.start, f = n.end, n = f - o, o = u ? f : o - 1, f = this.__iteratees__, c = f.length, a = 0, l = Mi(n, this.__takeCount__), !e || !u && i == n && l == n) return kr(t, this.__actions__);e = [];n: for (; n-- && a < l;) {
        for (o += r, u = -1, i = t[o]; ++u < c;) {
          var h = f[u],
              s = h.type,
              h = (0, h.iteratee)(i);if (2 == s) i = h;else if (!h) {
            if (1 == s) continue n;break n;
          }
        }e[a++] = i;
      }return e;
    }, On.prototype.at = Fo, On.prototype.chain = function () {
      return Xe(this);
    }, On.prototype.commit = function () {
      return new zn(this.value(), this.__chain__);
    }, On.prototype.next = function () {
      this.__values__ === F && (this.__values__ = ku(this.value()));
      var n = this.__index__ >= this.__values__.length;return { done: n, value: n ? F : this.__values__[this.__index__++] };
    }, On.prototype.plant = function (n) {
      for (var t, r = this; r instanceof Sn;) {
        var e = Pe(r);e.__index__ = 0, e.__values__ = F, t ? u.__wrapped__ = e : t = e;var u = e,
            r = r.__wrapped__;
      }return u.__wrapped__ = n, t;
    }, On.prototype.reverse = function () {
      var n = this.__wrapped__;return n instanceof Mn ? (this.__actions__.length && (n = new Mn(this)), n = n.reverse(), n.__actions__.push({ func: nu, args: [Je], thisArg: F }), new zn(n, this.__chain__)) : this.thru(Je);
    }, On.prototype.toJSON = On.prototype.valueOf = On.prototype.value = function () {
      return kr(this.__wrapped__, this.__actions__);
    }, On.prototype.first = On.prototype.head, Ai && (On.prototype[Ai] = tu), On;
  }();"function" == "function" && _typeof(__webpack_require__(4)) == "object" && __webpack_require__(4) ? (Zn._ = it, !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    return it;
  }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : Vn ? ((Vn.exports = it)._ = it, qn._ = it) : Zn._ = it;
}).call(this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), __webpack_require__(12)(module)))

/***/ }),
/* 11 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_utility__ = __webpack_require__(0);
/* harmony export (immutable) */ __webpack_exports__["a"] = splitOrFullFare;
/**
 * If min single less than min travelcard and max single more than max travelcard - calculates whichever is cheaper:
 * 	either two split singles or full fare without travelcard
 * @function
 * @param {numbers} minChargedZone - the min zone that will charge between this min chargable zone to min travelcard - 1 (as single) and  max chargeable zone (to charge beween max travelcard +1 to max chargeable zone)
 * @returns {number} - returns the cheapest fare
 * @description
 */



function splitOrFullFare(minChargedZone, maxSingle, minTravelcard, maxTravelcard, singleFares, type) {
	return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["e" /* minNum */])([__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* getSingleFare */])([minChargedZone, maxSingle], singleFares, type), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* getSingleFare */])([minChargedZone, minTravelcard - 1], singleFares, type) + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* getSingleFare */])([maxTravelcard + 1, maxSingle], singleFares, type)]);
}

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_utility__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility_getData__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__partials_getSingleJourneyZones__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__partials_extensionFares__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__partials_oysterDayTotal__ = __webpack_require__(6);







// TO DO
// Off peak vs on peak singles (esp including out of zone 1 to zone 1 in evening is offpeak exception)
// Offpeak daily cap discounts - keep track when daily cap reached but only travelled off peak (if going to do off peak oyster cum totals then would know this)
// possibility of altering oyster so reflects off peak -- then could add  the Railcard or Gold card discount to your Oyster and 1-8  zones or to 9 without watford
// CAN DO APPRENTICE, 18+ STUDENT, 16+ ZIP, JOB CENTRE ON OYSTER - as no diff bw off peak / on peak daily caps
// NB Weekly capping is always anytime & daily capping always starts at zone 1

// getData.stations().then(function (stations) {
// 	getSingleJourneyZones('1000029', '1000138', stations).then((resp) => {
// 		// console.log(resp);
// 	});
// });

__WEBPACK_IMPORTED_MODULE_1__utility_getData__["a" /* default */].fares().then(function (fareData) {
  var singleFares = fareData.singleFares;
  var dailyCaps = fareData.dailyCaps;

  var journeys = [{
    zones: [1, 6],
    dualZoneOverlap: false,
    type: "anytime"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }];

  console.log(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__partials_oysterDayTotal__["a" /* default */])({
    journeys: journeys,
    dailyCaps: dailyCaps, //JSON
    minTravelcard: 2,
    maxTravelcard: 3
  }, singleFares));
});
// //---------------------------------
// // - CONTACTLESS Cheapest Fare = with daily caps
// 	//The array of all combination prices to be reduce to cheapest one
// 	let conAllFares = [];

// 	// for without any daily caps, only singles added together
// 	let conFares = null;
// 	journeys.forEach(function(journey) {
// 		conFares += getSingleFare(journey.zones, singleFares);
// 	});
// 	conAllFares.push(conFares);

// 	// 	Then for each Zone range (from Zone 1-3 until Zone 1 to max) repeat same calculation.
// 	 let conMaxZone = maxNum(flatten(journeys.map(j => j.zones)));
// 	 for (let i = 2; i <= conMaxZone; i++) {
// 	 	//console.log('for daily cap 1 to ' + i);
// 	 	let conCumTotal = getDailyCap(i, dailyCaps);
// 	 	 for (let x = 0; x < journeys.length; x++) {
// 	 	 	//adding extension fares to cumTotal
// 	 		conCumTotal += extensionFares(1, i, journeys[x][0], journeys[x][1], singleFares);
// 	 	 };
// 	 	conAllFares.push(conCumTotal);
// 	 }

// 	// 	---> Compare all the possibilities and select the cheapest (including total single).
// 	return minNum(conAllFares);
// 	//this returns the final contactless daily fare
// });

//CONTACTLESS
//For just daily caps OR weekly cap without daily cap: use extension fares without max daily
//For combo of daily cap and weekly cap: use extension fares with max daily cap
//
// OFF PEAK DAILY and WEEKLY: For off peak daily cap combos: if off peak, use extension fares to calculate using both daily and weekly caps
// --- whilst if peak travel then use extension fares with only weekly travel card caps and add to total
// ANYTIME DAILY and WEEKLY: use the extension fare to calculate all fares with daily anytime cap and weekly cap (current set up)

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//  Ramda v0.18.0
//  https://github.com/ramda/ramda
//  (c) 2013-2015 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function () {

    'use strict';

    /**
       * A special placeholder value used to specify "gaps" within curried functions,
       * allowing partial application of any combination of arguments,
       * regardless of their positions.
       *
       * If `g` is a curried ternary function and `_` is `R.__`, the following are equivalent:
       *
       *   - `g(1, 2, 3)`
       *   - `g(_, 2, 3)(1)`
       *   - `g(_, _, 3)(1)(2)`
       *   - `g(_, _, 3)(1, 2)`
       *   - `g(_, 2, _)(1, 3)`
       *   - `g(_, 2)(1)(3)`
       *   - `g(_, 2)(1, 3)`
       *   - `g(_, 2)(_, 3)(1)`
       *
       * @constant
       * @memberOf R
       * @since v0.6.0
       * @category Function
       * @example
       *
       *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
       *      greet('Alice'); //=> 'Hello, Alice!'
       */

    var __ = { '@@functional/placeholder': true };

    // jshint unused:vars
    var _arity = function _arity(n, fn) {
        // jshint unused:vars
        switch (n) {
            case 0:
                return function () {
                    return fn.apply(this, arguments);
                };
            case 1:
                return function (a0) {
                    return fn.apply(this, arguments);
                };
            case 2:
                return function (a0, a1) {
                    return fn.apply(this, arguments);
                };
            case 3:
                return function (a0, a1, a2) {
                    return fn.apply(this, arguments);
                };
            case 4:
                return function (a0, a1, a2, a3) {
                    return fn.apply(this, arguments);
                };
            case 5:
                return function (a0, a1, a2, a3, a4) {
                    return fn.apply(this, arguments);
                };
            case 6:
                return function (a0, a1, a2, a3, a4, a5) {
                    return fn.apply(this, arguments);
                };
            case 7:
                return function (a0, a1, a2, a3, a4, a5, a6) {
                    return fn.apply(this, arguments);
                };
            case 8:
                return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                    return fn.apply(this, arguments);
                };
            case 9:
                return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                    return fn.apply(this, arguments);
                };
            case 10:
                return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return fn.apply(this, arguments);
                };
            default:
                throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _arrayFromIterator = function _arrayFromIterator(iter) {
        var list = [];
        var next;
        while (!(next = iter.next()).done) {
            list.push(next.value);
        }
        return list;
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0,
            len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0) {
                return f1;
            } else if (a != null && a['@@functional/placeholder'] === true) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            var n = arguments.length;
            if (n === 0) {
                return f2;
            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
                return f2;
            } else if (n === 1) {
                return _curry1(function (b) {
                    return fn(a, b);
                });
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return f2;
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
                return _curry1(function (a) {
                    return fn(a, b);
                });
            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
                return _curry1(function (b) {
                    return fn(a, b);
                });
            } else {
                return fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            var n = arguments.length;
            if (n === 0) {
                return f3;
            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 1) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
                return _curry2(function (a, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2) {
                return _curry1(function (c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return _curry2(function (a, b) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return _curry2(function (a, c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
                return _curry1(function (a) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
                return _curry1(function (b) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
                return _curry1(function (c) {
                    return fn(a, b, c);
                });
            } else {
                return fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @return {array} An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (result == null || result['@@functional/placeholder'] !== true) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    var _filter = function _filter(fn, list) {
        var idx = 0,
            len = list.length,
            result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * @private
     * @param {Function} fn The strategy for extracting function names from an object
     * @return {Function} A function that takes an object and returns an array of function names.
     */
    var _functionsWith = function _functionsWith(fn) {
        return function (obj) {
            return _filter(function (key) {
                return typeof obj[key] === 'function';
            }, fn(obj));
        };
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    var _isArguments = function () {
        var toString = Object.prototype.toString;
        return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
            return toString.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
            return _has('callee', x);
        };
    }();

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isObject = function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
    };

    var _isRegExp = function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);
        while (idx < len) {
            result[idx] = fn(functor[idx]);
            idx += 1;
        }
        return result;
    };

    var _of = function _of(x) {
        return [x];
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    // \b matches word boundary; [\b] matches backspace
    var _quote = function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
        .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
            case 1:
                return _slice(args, 0, args.length);
            case 2:
                return _slice(args, from, args.length);
            default:
                var list = [];
                var idx = 0;
                var len = Math.max(0, Math.min(args.length, to) - from);
                while (idx < len) {
                    list[idx] = args[from + idx];
                    idx += 1;
                }
                return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xfBase = {
        init: function init() {
            return this.xf['@@transducer/init']();
        },
        result: function result(_result) {
            return this.xf['@@transducer/result'](_result);
        }
    };

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    /**
     * Adds two numbers. Equivalent to `a + b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return a + b;
    });

    /**
     * Applies a function to the value at the given index of an array,
     * returning a new copy of the array with the element at the given
     * index replaced with the result of the function application.
     * @see R.update
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator)
     * in other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns `true` if both arguments are `true`; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if both arguments are `true`, `false` otherwise
     * @see R.both
     * @example
     *
     *      R.and(true, true); //=> true
     *      R.and(true, false); //=> false
     *      R.and(false, true); //=> false
     *      R.and(false, false); //=> false
     */
    var and = _curry2(function and(a, b) {
        return a && b;
    });

    /**
     * Returns a new list containing the contents of the given list, followed by the given
     * element.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should
     * be a bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value.  Note that this copies and flattens
     * prototype properties onto the new object as well.  All non-primitive
     * properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes
     * required to create the given path, and placing the specific value at the
     * tail end of that path.  Note that this copies and flattens prototype
     * properties onto the new object as well.  All non-primitive properties
     * are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
            case 0:
                return obj;
            case 1:
                return assoc(path[0], val, obj);
            default:
                return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @see R.partial
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * Makes a comparator function out of a function that reports whether the first element is less than the second.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator((a, b) => a.age < b.age);
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the
     * arguments to `fn` are applied to each of the predicates in turn
     * until one returns a "truthy" value, at which point `fn` returns the
     * result of applying its arguments to the corresponding transformer.
     * If none of the predicates matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0Â°C')],
     *        [R.equals(100), R.always('water boils at 100Â°C')],
     *        [R.T,           temp => 'nothing special happens at ' + temp + 'Â°C']
     *      ]);
     *      fn(0); //=> 'water freezes at 0Â°C'
     *      fn(50); //=> 'nothing special happens at 50Â°C'
     *      fn(100); //=> 'water boils at 100Â°C'
     */
    var cond = _curry1(function cond(pairs) {
        return function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        };
    });

    /**
     * Returns `true` if the `x` is found in the `list`, using `pred` as an
     * equality predicate for `x`.
     *
     * @func
     * @memberOf R
     * @since v0.1.5
     * @category List
     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {*} x The item to find
     * @param {Array} list The list to iterate over
     * @return {Boolean} `true` if `x` is in `list`, else `false`.
     * @deprecated since v0.18.0
     * @example
     *
     *      var absEq = (a, b) => Math.abs(a) === Math.abs(b);
     *      R.containsWith(absEq, 5, [1, 2, 3]); //=> false
     *      R.containsWith(absEq, 5, [4, 5, 6]); //=> true
     *      R.containsWith(absEq, 5, [-1, -2, -3]); //=> false
     *      R.containsWith(absEq, 5, [-4, -5, -6]); //=> true
     */
    var containsWith = _curry3(_containsWith);

    /**
     * Counts the elements of a list according to how many match each value
     * of a key generated by the supplied function. Returns an object
     * mapping the keys produced by `fn` to the number of occurrences in
     * the list. Note that all keys are coerced to strings because of how
     * JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = _curry2(function countBy(fn, list) {
        var counts = {};
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            var key = fn(list[idx]);
            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
            idx += 1;
        }
        return counts;
    });

    /**
     * Returns a curried equivalent of the provided function, with the
     * specified arity. The curried function has two unusual capabilities.
     * First, its arguments needn't be provided one at a time. If `g` is
     * `R.curryN(3, f)`, the following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`,
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not `null`, `undefined` or `NaN`
     * otherwise the first argument is returned.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = R.defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     *      defaultTo42(parseInt('string')); //=> 42
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
     * Duplication is determined according to the value returned by applying the supplied predicate to two list
     * elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @see R.difference
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @example
     *
     *      function cmp(x, y) => x.a === y.a;
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        var containsPred = containsWith(pred);
        while (idx < firstLen) {
            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the
     * given path. Note that this copies and flattens prototype properties
     * onto the new object as well.  All non-primitive properties are copied
     * by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
            case 0:
                return obj;
            case 1:
                return dissoc(path[0], obj);
            default:
                var head = path[0];
                var tail = _slice(path, 1);
                return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function, skipping
     * elements while the predicate function returns `true`. The predicate function
     * is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile
     * @example
     *
     *      var lteThree = x => x <= 3;
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
     */
    var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    });

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments.
     * Other types are supported if they define `<Type>.empty` and/or
     * `<Type>.prototype.empty`.
     *
     * Dispatches to the `empty` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    // else
    var empty = _curry1(function empty(x) {
        return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
            return arguments;
        }() : // else
        void 0;
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`, according to the
     * `transformation` functions. All non-primitive properties are copied by reference.
     *
     * A `transformation` function will not be invoked if its corresponding key does not exist in
     * the evolved object.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var transformation,
            key,
            type,
            result = {};
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation === 'undefined' ? 'undefined' : _typeof(transformation);
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs, R.pair
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0,
            len = pairs.length,
            out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the first argument is greater than the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has
     * a property with the specified name
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good as a default
     * or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse` function depending
     * upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Logic
     * @see R.unless, R.when
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @example
     *
     *      var incCount = R.ifElse(
     *        R.has('count'),
     *        R.over(R.lensProp('count'), R.inc),
     *        R.assoc('count', 1)
     *      );
     *      incCount({});           //=> { count: 1 }
     *      incCount({ count: 1 }); //=> { count: 2 }
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`.  _Note
     * that this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`.  _Note  that this
     * is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * See if an object (`val`) is an instance of the supplied constructor.
     * This function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own
     * properties of the supplied object.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop,
                ks = [],
                nIdx;
            for (prop in obj) {
                if (_has(prop, obj)) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the
     * properties of the supplied object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop,
            ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it applies a
     * function to each element of a list, passing an accumulating parameter from left to
     * right, and returning a final value of this accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should return
     * a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0,
            len = list.length,
            result = [],
            tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [tuple[0], result];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it applies a
     * function to each element of a list, passing an accumulating parameter from right
     * to left, and returning a final value of this accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to the
     * left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should return
     * a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = (a, b) => [a + b, a + b];
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1,
            result = [],
            tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [tuple[0], result];
    });

    /**
     * Tests a regular expression against a String. Note that this function
     * will return an empty array when there are no matches. This differs
     * from [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @see R.test
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the `%`
     * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces
     * the larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.maxBy(square, -3, 2); //=> -3
     *
     *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
     *      R.reduce(R.maxBy(square), 0, []); //=> 0
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of `a`
     * merged with the own properties of object `b`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(a, b) {
        var result = {};
        var ks = keys(a);
        var idx = 0;
        while (idx < ks.length) {
            result[ks[idx]] = a[ks[idx]];
            idx += 1;
        }
        ks = keys(b);
        idx = 0;
        while (idx < ks.length) {
            result[ks[idx]] = b[ks[idx]];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces
     * the smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      //  square :: Number -> Number
     *      var square = n => n * n;
     *
     *      R.minBy(square, -3, 2); //=> 2
     *
     *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
     *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder.
     * Note that this function preserves the JavaScript-style behavior for
     * modulo. For mathematical modulo see `mathMod`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
     * parameters. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = (a, b) => [a, b];
     *
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
            case 0:
                return function () {
                    return fn.call(this);
                };
            case 1:
                return function (a0) {
                    return fn.call(this, a0);
                };
            case 2:
                return function (a0, a1) {
                    return fn.call(this, a0, a1);
                };
            case 3:
                return function (a0, a1, a2) {
                    return fn.call(this, a0, a1, a2);
                };
            case 4:
                return function (a0, a1, a2, a3) {
                    return fn.call(this, a0, a1, a2, a3);
                };
            case 5:
                return function (a0, a1, a2, a3, a4) {
                    return fn.call(this, a0, a1, a2, a3, a4);
                };
            case 6:
                return function (a0, a1, a2, a3, a4, a5) {
                    return fn.call(this, a0, a1, a2, a3, a4, a5);
                };
            case 7:
                return function (a0, a1, a2, a3, a4, a5, a6) {
                    return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
                };
            case 8:
                return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                    return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
                };
            case 9:
                return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                    return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
                };
            case 10:
                return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
                };
            default:
                throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string.
     * If n is negative the element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth('abc', 2); //=> 'c'
     *      R.nth('abc', 3); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.objOf('must'),
     *        R.map(R.objOf('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var objOf = _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(_of);

    /**
     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
     * `fn` can only ever be called once, no matter how many times the returned function is
     * invoked. The first value calculated is returned in subsequent invocations.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(x => x + 1);
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false,
            result;
        return function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        };
    });

    /**
     * Returns `true` if one or both of its arguments are `true`. Returns `false`
     * if both arguments are `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig * -> * -> *
     * @param {Boolean} a A boolean value
     * @param {Boolean} b A boolean value
     * @return {Boolean} `true` if one or both arguments are `true`, `false` otherwise
     * @see R.either
     * @example
     *
     *      R.or(true, true); //=> true
     *      R.or(true, false); //=> true
     *      R.or(false, true); //=> true
     *      R.or(false, false); //=> false
     */
    var or = _curry2(function or(a, b) {
        return a || b;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the result of applying the given function to
     * the focused value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    var over = function () {
        var Identity = function Identity(x) {
            return {
                value: x,
                map: function map(f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig a -> b -> (a,b)
     * @param {*} fst
     * @param {*} snd
     * @return {Array}
     * @see R.createMapEntry, R.of
     * @example
     *
     *      pair('foo', 'bar'); //=> ['foo', 'bar']
     */
    var pair = _curry2(function pair(fst, snd) {
        return [fst, snd];
    });

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        if (obj == null) {
            return;
        } else {
            var val = obj;
            var idx = 0;
            while (val != null && idx < paths.length) {
                val = val[paths[idx]];
                idx += 1;
            }
            return val;
        }
    });

    /**
     * If the given, non-null object has a value at the given path, returns
     * the value at that path. Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Object
     * @sig a -> [String] -> Object -> a
     * @param {*} d The default value.
     * @param {Array} p The path to use.
     * @return {*} The data at `path` of the supplied object or the default value.
     * @example
     *
     *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
     */
    var pathOr = _curry3(function pathOr(d, p, obj) {
        return defaultTo(d, path(p, obj));
    });

    /**
     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
     * property is ignored.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit, R.props
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that
     * satisfy the supplied predicate.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick
     * @example
     *
     *      var isUpperCase = (val, key) => key.toUpperCase() === key;
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the contents of the
     * list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property.
     * Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq
     * @see R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to`
     * (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling the iterator
     * function and passing it an accumulator value and the current value from the array, and
     * then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = (acc, pair) => acc.concat(pair);
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the
     * reduce and transduce functions.  The returned value
     * should be considered a black box: the internal structure is not
     * guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above.  For instance, it is not currently supported by reduceIndexed,
     * reduceRight, or reduceRightIndexed.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category List
     * @see R.reduce, R.transduce
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements.  _Note that this is not destructive_: it returns a
     * copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list or string with the elements or characters in reverse
     * order.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {Array|String} list
     * @return {Array|String}
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     *
     *      R.reverse('abc');      //=> 'cba'
     *      R.reverse('ab');       //=> 'ba'
     *      R.reverse('a');        //=> 'a'
     *      R.reverse('');         //=> ''
     */
    var reverse = _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values from the left
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0,
            len = list.length,
            result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(R.prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Subtracts two numbers. Equivalent to `a - b` but curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return a - b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing each value
     * to the supplied predicate function, and terminating when the predicate function returns
     * `false`. Excludes the element that caused the predicate function to fail. The predicate
     * function is passed one argument: *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile
     * @example
     *
     *      var isNotOne = x => x !== 1;
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = x => console.log('x is ' + x);
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Calls an input function `n` times, returning an array containing the results of those
     * function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
     * gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @since v0.2.3
     * @category List
     * @sig (i -> a) -> i -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var list = new Array(len);
        var idx = 0;
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays.
     * Only the object's own properties are used.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [prop, obj[prop]];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays.
     * The object's own properties and prototype properties are used.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [prop, obj[prop]];
        }
        return pairs;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || ws.trim() || !zeroWidth.trim()) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * Gives a single-word string description of the (native) type of a value, returning such
     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
     * Object types any further, reporting them all as 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns
     * a function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function
     * which takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
     * parameter. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = a => b => c => d => a + b + c + d;
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      uncurriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns either false
     * to stop iteration or an array of length 2 containing the value to add to the resulting
     * list and the seed to be used in the next call to the iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = n => n > 50 ? false : [-n, n + 10];
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original list, based
     * upon the value returned by applying the supplied predicate to two list elements. Prefers
     * the first item if two items compare equal based on the predicate.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = R.eqBy(String);
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0,
            len = list.length;
        var result = [],
            item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Tests the final argument by passing it to the given predicate function.
     * If the predicate is not satisfied, the function will return the
     * result of calling the `whenFalseFn` function with the same argument. If the
     * predicate is satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @see R.ifElse, R.when
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred        A predicate function
     * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
     *                               to a falsy value.
     * @param {*}        x           An object to test with the `pred` function and
     *                               pass to `whenFalseFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
     * @example
     *
     *      // coerceArray :: (a|[a]) -> [a]
     *      var coerceArray = R.unless(R.isArrayLike, R.of);
     *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
     *      coerceArray(1);         //=> [1]
     */
    var unless = _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
    });

    /**
     * Returns a new copy of the array with the element at the
     * provided index replaced with the given value.
     * @see R.adjust
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across
     * different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties,
     * of the supplied object.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop,
            vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    var view = function () {
        var Const = function Const(x) {
            return {
                value: x,
                map: function map() {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            return lens(Const)(x).value;
        });
    }();

    /**
     * Tests the final argument by passing it to the given predicate function.
     * If the predicate is satisfied, the function will return the result
     * of calling the `whenTrueFn` function with the same argument. If the predicate
     * is not satisfied, the argument is returned as is.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Logic
     * @see R.ifElse, R.unless
     * @sig (a -> Boolean) -> (a -> a) -> a -> a
     * @param {Function} pred       A predicate function
     * @param {Function} whenTrueFn A function to invoke when the `condition`
     *                              evaluates to a truthy value.
     * @param {*}        x          An object to test with the `pred` function and
     *                              pass to `whenTrueFn` if necessary.
     * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
     * @example
     *
     *      // truncate :: String -> String
     *      var truncate = R.when(
     *        R.propSatisfies(R.gt(R.__, 10), 'length'),
     *        R.pipe(R.take(10), R.append('â€¦'), R.join(''))
     *      );
     *      truncate('12345');         //=> '12345'
     *      truncate('0123456789ABC'); //=> '0123456789â€¦'
     */
    var when = _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of
     * the test object. `where` returns true if all the predicates return true,
     * false otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the parameters, or do
     * other processing either before the internal function is called or with its results.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = name => 'Hello ' + name;
     *
     *      var shoutedGreet = R.wrap(greet, (gr, name) => gr(name).toUpperCase());
     *
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible
     * pair from the lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [a[idx], b[j]];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up
     * equally-positioned items from both lists.  The returned list is
     * truncated to the length of the shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [a[idx], b[idx]];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0,
            len = keys.length,
            out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to
     * each equally-positioned pair in the lists. The returned list is
     * truncated to the length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = (x, y) => {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [],
            idx = 0,
            len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig * -> Boolean
     * @param {*}
     * @return {Boolean}
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    var _aperture = function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    };

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it will
     * default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = _clone(value[key], refFrom, refTo);
            }
            return copiedValue;
        };
        switch (type(value)) {
            case 'Object':
                return copy({});
            case 'Array':
                return copy([]);
            case 'Date':
                return new Date(value);
            case 'RegExp':
                return _cloneRegExp(value);
            default:
                return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        });
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a  function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    // Values of other types are only equal if identical.
    var _equals = function _equals(a, b, stackA, stackB) {
        if (identical(a, b)) {
            return true;
        }
        if (type(a) !== type(b)) {
            return false;
        }
        if (a == null || b == null) {
            return false;
        }
        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
            return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }
        switch (type(a)) {
            case 'Arguments':
            case 'Array':
            case 'Object':
                break;
            case 'Boolean':
            case 'Number':
            case 'String':
                if (!((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b)) && identical(a.valueOf(), b.valueOf()))) {
                    return false;
                }
                break;
            case 'Date':
                if (!identical(a.valueOf(), b.valueOf())) {
                    return false;
                }
                break;
            case 'RegExp':
                if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
                    return false;
                }
                break;
            case 'Map':
            case 'Set':
                if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
                    return false;
                }
                break;
            case 'Int8Array':
            case 'Uint8Array':
            case 'Uint8ClampedArray':
            case 'Int16Array':
            case 'Uint16Array':
            case 'Int32Array':
            case 'Uint32Array':
            case 'Float32Array':
            case 'Float64Array':
                break;
            case 'ArrayBuffer':
                break;
            default:
                // Values of other types are only equal if identical.
                return false;
        }
        var keysA = keys(a);
        if (keysA.length !== keys(b).length) {
            return false;
        }
        var idx = stackA.length - 1;
        while (idx >= 0) {
            if (stackA[idx] === a) {
                return stackB[idx] === b;
            }
            idx -= 1;
        }
        stackA.push(a);
        stackB.push(b);
        idx = keysA.length - 1;
        while (idx >= 0) {
            var key = keysA[idx];
            if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
                return false;
            }
            idx -= 1;
        }
        stackA.pop();
        stackB.pop();
        return true;
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive function
     * based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value,
                result = [],
                idx = 0,
                j,
                ilen = list.length,
                jlen;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0,
                len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xaperture = function () {
        function XAperture(n, xf) {
            this.xf = xf;
            this.pos = 0;
            this.full = false;
            this.acc = new Array(n);
        }
        XAperture.prototype['@@transducer/init'] = _xfBase.init;
        XAperture.prototype['@@transducer/result'] = _xfBase.result;
        XAperture.prototype['@@transducer/step'] = function (result, input) {
            this.store(input);
            return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };
        XAperture.prototype.store = function (input) {
            this.acc[this.pos] = input;
            this.pos += 1;
            if (this.pos === this.acc.length) {
                this.pos = 0;
                this.full = true;
            }
        };
        XAperture.prototype.getCopy = function () {
            return _concat(_slice(this.acc, this.pos), _slice(this.acc, 0, this.pos));
        };
        return _curry2(function _xaperture(n, xf) {
            return new XAperture(n, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [key, []];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new parameters
     * to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that more closely
     * resembles `Array.prototype.map`.  Note that this will only work for functions in which
     * the iteration callback function is the first parameter, and where the list is the last
     * parameter.  (This latter might be unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [idx, list]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if there are any
     * that don't.
     *
     * Dispatches to the `all` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * Returns `true` if at least one of elements of the list match the predicate, `false`
     * otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Returns a new list, composed of n-tuples of consecutive elements
     * If `n` is greater than the length of the list, an empty list is returned.
     *
     * Dispatches to the `aperture` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(_dispatchable('aperture', _xaperture, _aperture));

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
     * parameters. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @since v0.2.0
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and `Object`s, `Number`s,
     * `String`s, `Boolean`s and `Date`s. `Function`s are not copied, but assigned by their
     * reference. Dispatches to a `clone` method if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], []);
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @see R.pair, R.objOf
     * @deprecated since v0.18.0
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.createMapEntry('must'),
     *        R.map(R.createMapEntry('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var createMapEntry = objOf;

    /**
     * Returns a curried equivalent of the provided function. The curried
     * function has two unusual capabilities. First, its arguments needn't
     * be provided one at a time. If `f` is a ternary function and `g` is
     * `R.curry(f)`, the following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`,
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing each value
     * to the supplied predicate function, skipping elements while the predicate function returns
     * `true`. The predicate function is passed one argument: *(value)*.
     *
     * Dispatches to the `dropWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile
     * @example
     *
     *      var lteTwo = x => x <= 2;
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0,
            len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise.
     * Dispatches to an `equals` method if present. Handles cyclical data
     * structures.
     *
     * Dispatches to the `equals` method of both arguments, if present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
    });

    /**
     * Returns a new list containing only those items that match a given predicate function.
     * The predicate function is passed one argument: *(value)*.
     *
     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native
     * `Array.prototype.filter` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
     *
     * Dispatches to the `filter` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} The new filtered array.
     * @see R.reject
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     */
    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

    /**
     * Returns the first element of the list which matches the predicate, or `undefined` if no
     * element matches.
     *
     * Dispatches to the `find` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the predicate, or `-1`
     * if no element matches.
     *
     * Dispatches to the `findIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or `undefined` if no
     * element matches.
     *
     * Dispatches to the `findLast` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the predicate, or
     * `-1` if no element matches.
     *
     * Dispatches to the `findLastIndex` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
     * them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two arguments'
     * order is reversed.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = (a, b, c) => [].concat(a, b, c);
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each element in the
     * list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.forEach` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original
     * array. In some libraries this function is named `each`.
     *
     * Dispatches to the `forEach` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @example
     *
     *      var printXPlusFive = x => console.log(x + 5);
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Returns a list of function names of object's own functions
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {*} -> [String]
     * @param {Object} obj The objects with functions in it
     * @return {Array} A list of the object's own properties that map to functions.
     * @deprecated since v0.18.0
     * @example
     *
     *      R.functions(R); // returns list of ramda's own function names
     *
     *      var F = function() { this.x = function(){}; this.y = 1; }
     *      F.prototype.z = function() {};
     *      F.prototype.a = 100;
     *      R.functions(new F()); //=> ["x"]
     */
    var functions = _curry1(_functionsWith(keys));

    /**
     * Returns a list of function names of object's own and prototype functions
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Object
     * @sig {*} -> [String]
     * @param {Object} obj The objects with functions in it
     * @return {Array} A list of the object's own properties and prototype
     *         properties that map to functions.
     * @deprecated since v0.18.0
     * @example
     *
     *      R.functionsIn(R); // returns list of ramda's own and prototype function names
     *
     *      var F = function() { this.x = function(){}; this.y = 1; }
     *      F.prototype.z = function() {};
     *      F.prototype.a = 100;
     *      R.functionsIn(new F()); //=> ["x", "z"]
     */
    var functionsIn = _curry1(_functionsWith(keysIn));

    /**
     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
     * on each element, and grouping the results according to values returned.
     *
     * Dispatches to the `groupBy` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
        return _reduce(function (acc, elt) {
            var key = fn(elt);
            acc[key] = append(elt, acc[key] || (acc[key] = []));
            return acc;
        }, {}, list);
    }));

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @see R.tail, R.init, R.last
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.  Duplication is determined according
     * to the value returned by applying the supplied predicate to two list
     * elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @see R.intersection
     * @return {Array} A new list containing those elements common to both lists.
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var results = [],
            idx = 0;
        while (idx < list1.length) {
            if (_containsWith(pred, list1[idx], list2)) {
                results[results.length] = list1[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * Dispatches to the `intersperse` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * Same as R.invertObj, however this accounts for objects
     * with duplicate values by putting the values into an
     * array.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object
     * as values, and the values of the given object, which are
     * coerced to strings, as keys.
     * Note that the last key found is preferred when handling
     * the same value.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the given value is its type's empty value; `false`
     * otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Logic
     * @sig a -> Boolean
     * @param {*} x
     * @return {Boolean}
     * @see R.empty
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty({});          //=> true
     *      R.isEmpty({length: 0}); //=> false
     */
    var isEmpty = _curry1(function isEmpty(x) {
        return x != null && equals(x, empty(x));
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @see R.init, R.head, R.tail
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in
     * an array, or -1 if the item is not included in the array.
     * `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Returns a new list, constructed by applying the supplied function to every element of the
     * supplied list.
     *
     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
     * native `Array.prototype.map` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
     *
     * Dispatches to the `map` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * Map treats also treats functions as functors and will compose them together.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Functor f => (a -> b) -> f a -> f b
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @example
     *
     *      var double = x => x * 2;
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     *
     *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
     */
    var map = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
            case '[object Function]':
                return curryN(functor.length, function () {
                    return fn.call(this, functor.apply(this, arguments));
                });
            case '[object Object]':
                return _reduce(function (acc, key) {
                    acc[key] = fn(functor[key]);
                    return acc;
                }, {}, keys(functor));
            default:
                return _map(fn, functor);
        }
    }));

    /**
     * Map, but for objects. Creates an object with the same keys as `obj` and values
     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category Object
     * @sig (v -> v) -> {k: v} -> {k: v}
     * @param {Function} fn A function called for each property in `obj`. Its return value will
     * become a new property on the return object.
     * @param {Object} obj The object to iterate over.
     * @return {Object} A new object with the same keys as `obj` and values that are the result
     *         of running each property through `fn`.
     * @deprecated since v0.18.0
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var double = num => num * 2;
     *
     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }
     */
    var mapObj = _curry2(function mapObj(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key]);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Like `mapObj`, but passes additional arguments to the predicate function. The
     * predicate function is passed three arguments: *(value, key, obj)*.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Object
     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
     * @param {Function} fn A function called for each property in `obj`. Its return value will
     *        become a new property on the return object.
     * @param {Object} obj The object to iterate over.
     * @return {Object} A new object with the same keys as `obj` and values that are the result
     *         of running each property through `fn`.
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Returns `true` if no elements of the list match the predicate,
     * `false` otherwise.
     *
     * Dispatches to the `any` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      R.none(R.isNaN, [1, 2, 3]); //=> true
     *      R.none(R.isNaN, [1, 2, 3, NaN]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided initially followed by the arguments provided to `g`.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partialRight
     * @example
     *
     *      var multiply = (a, b) => a * b;
     *      var double = R.partial(multiply, [2]);
     *      double(2); //=> 4
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var sayHello = R.partial(greet, ['Hello']);
     *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = _createPartialApplicator(_concat);

    /**
     * Takes a function `f` and a list of arguments, and returns a function `g`.
     * When applied, `g` returns the result of applying `f` to the arguments
     * provided to `g` followed by the arguments provided initially.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
     * @param {Function} f
     * @param {Array} args
     * @return {Function}
     * @see R.partial
     * @example
     *
     *      var greet = (salutation, title, firstName, lastName) =>
     *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *
     *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = _createPartialApplicator(flip(_concat));

    /**
     * Takes a predicate and a list and returns the pair of lists of
     * elements which do and do not satisfy the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
     * @param {Function} pred A predicate to determine which array the element belongs to.
     * @param {Array} list The array to partition.
     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
     *         and second an array of elements that did not satisfy.
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     */
    var partition = _curry2(function partition(pred, list) {
        return _reduce(function (acc, elt) {
            var xs = acc[pred(elt) ? 0 : 1];
            xs[xs.length] = elt;
            return acc;
        }, [[], []], list);
    });

    /**
     * Determines whether a nested path on an object has a specific value,
     * in `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in the list supplied.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @see R.props
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is
     * @see R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling the iterator
     * function and passing it an accumulator value and the current value from the array, and
     * then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to
     * shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     * @see R.reduced
     *
     * Dispatches to the `reduce` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = (a, b) => a + b;
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Similar to `filter`, except that it keeps only values for which the given predicate
     * function returns falsy. The predicate function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} The new filtered array.
     * @see R.filter
     * @example
     *
     *      var isOdd = (n) => n % 2 === 1;
     *
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     */
    var reject = _curry2(function reject(fn, list) {
        return filter(_complement(fn), list);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @see R.head, R.init, R.last
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * Dispatches to the `take` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the first `n` elements of a given list, passing each value
     * to the supplied predicate function, and terminating when the predicate function returns
     * `false`. Excludes the element that caused the predicate function to fail. The predicate
     * function is passed one argument: *(value)*.
     *
     * Dispatches to the `takeWhile` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile
     * @example
     *
     *      var isNotFour = x => x !== 4;
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0,
            len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Initializes a transducer using supplied iterator function. Returns a single item by
     * iterating through the list, successively calling the transformed iterator function and
     * passing it an accumulator value and the current value from the array, and then passing
     * the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be wrapped as a
     * transformer to initialize the transducer. A transformer can be passed directly in place
     * of an iterator function.  In both cases, iteration may be stopped early with the
     * `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a transformer and can
     * be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator function, step,
     * 0-arity initial value function, init, and 1-arity result extraction function, result.
     * The step function is used as the iterator function in reduce. The result function is used
     * to convert the final accumulator into the return type and in most cases is R.identity.
     * The init function can be used to provide an initial accumulator, but is ignored by transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @see R.reduce, R.reduced, R.into
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
     * determined according to the value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Returns a new list containing only one copy of each element in the original list.
     * `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqWith(equals);

    /**
     * Accepts a function `fn` and a list of transformer functions and returns a new curried
     * function. When the new function is invoked, it calls the function `fn` with parameters
     * consisting of the result of calling each supplied handler on successive arguments to the
     * new function.
     *
     * If more arguments are passed to the returned function than transformer functions, those
     * arguments are passed directly to `fn` as additional parameters. If you expect additional
     * arguments that don't need to be transformed, although you can ignore them, it's best to
     * pass an identity function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {Array} transformers A list of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
     *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
     *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
     *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
     */
    var useWith = _curry2(function useWith(fn, transformers) {
        return curry(_arity(transformers.length, function () {
            var args = [],
                idx = 0;
            while (idx < transformers.length) {
                args.push(transformers[idx].call(this, arguments[idx]));
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, transformers.length)));
        }));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(mapObj(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function preservingReduced(xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function transducerResult(result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function transducerStep(result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function transducerResult(result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function transducerStep(result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    var _indexOf = function _indexOf(list, item, from) {
        var idx = from;
        while (idx < list.length) {
            if (equals(list[idx], item)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function transducerStep(xs, x) {
                return _concat(xs, [x]);
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function transducerStep(a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function transducerStep(result, input) {
                return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true
     * for a given list of arguments if every one of the provided predicates
     * is satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of
     * the highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.anyPass
     * @example
     *
     *      var isQueen = R.propEq('rank', 'Q');
     *      var isSpade = R.propEq('suit', 'â™ ï¸Ž');
     *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
     *
     *      isQueenOfSpades({rank: 'Q', suit: 'â™£ï¸Ž'}); //=> false
     *      isQueenOfSpades({rank: 'Q', suit: 'â™ ï¸Ž'}); //=> true
     */
    var allPass = _curry1(function allPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (!preds[idx].apply(this, arguments)) {
                    return false;
                }
                idx += 1;
            }
            return true;
        });
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms,
     * otherwise `false`.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @example
     *
     *      R.allUniq(['1', 1]); //=> true
     *      R.allUniq([1, 1]);   //=> false
     *      R.allUniq([[42], [42]]); //=> false
     */
    var allUniq = _curry1(function allUniq(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Takes a list of predicates and returns a predicate that returns true for
     * a given list of arguments if at least one of the provided predicates is
     * satisfied by those arguments.
     *
     * The function returned is a curried function whose arity matches that of
     * the highest-arity predicate.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} preds
     * @return {Function}
     * @see R.allPass
     * @example
     *
     *      var gte = R.anyPass([R.gt, R.equals]);
     *
     *      gte(3, 2); //=> true
     *      gte(2, 2); //=> true
     *      gte(2, 3); //=> false
     */
    var anyPass = _curry1(function anyPass(preds) {
        return curryN(reduce(max, 0, pluck('length', preds)), function () {
            var idx = 0;
            var len = preds.length;
            while (idx < len) {
                if (preds[idx].apply(this, arguments)) {
                    return true;
                }
                idx += 1;
            }
            return false;
        });
    });

    /**
     * ap applies a list of functions to a list of values.
     *
     * Dispatches to the `ap` method of the second argument, if present. Also treats
     * functions as applicatives.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    // else
    var ap = _curry2(function ap(applicative, fn) {
        return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? curryN(Math.max(applicative.length, fn.length), function () {
            return applicative.apply(this, arguments)(fn.apply(this, arguments));
        }) : // else
        _reduce(function (acc, f) {
            return _concat(acc, map(f, fn));
        }, [], applicative);
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right
     * branch produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call,
     *                              R.pipe(R.prop('indent'), indentN),
     *                              R.prop('value'));
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results.
     * `chain` is also known as `flatMap` in some libraries
     *
     * Dispatches to the `chain` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = n => [n, n];
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, monad) {
        if (typeof monad === 'function') {
            return function () {
                return monad.call(this, fn.apply(this, arguments)).apply(this, arguments);
            };
        }
        return _makeFlat(false)(map(fn, monad));
    }));

    /**
     * Turns a list of Functors into a Functor of a list, applying
     * a mapping function to the elements of the list along the way.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category List
     * @see R.commute
     * @sig Functor f => (a -> f b) -> (x -> f x) -> [a] -> f [b]
     * @param {Function} fn The transformation function
     * @param {Function} of A function that returns the data type to return
     * @param {Array} list An array of functors of the same type
     * @return {*}
     * @example
     *
     *      var add10 = R.map(R.add(10));
     *      R.commuteMap(add10, R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
     *      R.commuteMap(add10, R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
     *      R.commuteMap(add10, R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
     *      R.commuteMap(add10, Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     *
     *      var fetch = url => Future((rej, res) => http.get(url, res).on('error', rej));
     *      R.commuteMap(fetch, Future.of, [
     *        'http://ramdajs.com',
     *        'http://github.com/ramda'
     *      ]); //=> Future([IncomingMessage, IncomingMessage])
     */
    var commuteMap = _curry3(function commuteMap(fn, of, list) {
        function consF(acc, x) {
            return ap(map(prepend, fn(x)), acc);
        }
        return reduceRight(consF, of([]), list);
    });

    /**
     * Wraps a constructor function inside a curried function that can be called with the same
     * arguments and returns the same type. The arity of the function returned is specified
     * to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @since v0.4.0
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = () => {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
                case 1:
                    return new Fn($0);
                case 2:
                    return new Fn($0, $1);
                case 3:
                    return new Fn($0, $1, $2);
                case 4:
                    return new Fn($0, $1, $2, $3);
                case 5:
                    return new Fn($0, $1, $2, $3, $4);
                case 6:
                    return new Fn($0, $1, $2, $3, $4, $5);
                case 7:
                    return new Fn($0, $1, $2, $3, $4, $5, $6);
                case 8:
                    return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
                case 9:
                    return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
                case 10:
                    return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts a converging function and a list of branching functions and returns a new function.
     * When invoked, this new function is applied to some arguments, each branching
     * function is applied to those same arguments. The results of each branching
     * function are passed as arguments to the converging function to produce the return value.
     *
     * @func
     * @memberOf R
     * @since v0.4.2
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {Array} functions A list of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = (a, b) => a + b;
     *      var multiply = (a, b) => a * b;
     *      var subtract = (a, b) => a - b;
     *
     *      //â‰… multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, [add, subtract])(1, 2); //=> -3
     *
     *      var add3 = (a, b, c) => a + b + c;
     *      R.converge(add3, [multiply, add, subtract])(1, 2); //=> 4
     */
    var converge = _curry2(function converge(after, fns) {
        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * Dispatches to the `drop` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @see R.transduce
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    });

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements.
     * The first element in a series of equal element is the one being preserved.
     *
     * Dispatches to the `dropRepeatsWith` method of the second argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @example
     *
     *      var lengthEq = (x, y) => Math.abs(x) === Math.abs(y);
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Takes a function and two values in its domain and returns `true` if
     * the values map to the same value in the codomain; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.18.0
     * @category Relation
     * @sig (a -> b) -> a -> a -> Boolean
     * @param {Function} f
     * @param {*} x
     * @param {*} y
     * @return {Boolean}
     * @example
     *
     *      R.eqBy(Math.abs, 5, -5); //=> true
     */
    var eqBy = _curry3(function eqBy(f, x, y) {
        return equals(f(x), f(y));
    });

    /**
     * Reports whether two objects have the same value, in `R.equals` terms,
     * for the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Returns the position of the first occurrence of an item in an array,
     * or -1 if the item is not included in the array. `R.equals` is used to
     * determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category List
     * @see R.last, R.head, R.tail
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Transforms the items of the list with the transducer and appends the transformed items to
     * the accumulator using an appropriate iterator function based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated items will
     * be appended to arrays and concatenated to strings. Objects will be merged directly or 2-item
     * arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result extraction function
     * result. The step function is used as the iterator function in reduce. The result function is
     * used to convert the final accumulator into the return type and in most cases is R.identity.
     * The init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
    });

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms,
     * otherwise `false`.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @see R.allUniq
     * @deprecated since v0.18.0
     * @example
     *
     *      R.isSet(['1', 1]); //=> true
     *      R.isSet([1, 1]);   //=> false
     *      R.isSet([[42], [42]]); //=> false
     */
    var isSet = allUniq;

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (f) {
            return function (s) {
                return map(function (v) {
                    return setter(v, s);
                }, f(getter(s)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Object
     * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that many
     * lists (or other Functors).
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @see R.lift
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The function `fn` applicable to mappable objects.
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, () => R.reduce(R.add, 0, arguments)));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return reduce(merge, {}, list);
    });

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, [pickAll, identity]);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    /**
     * Shorthand for `R.chain(R.identity)`, which removes one level of nesting
     * from any [Chain](https://github.com/fantasyland/fantasy-land#chain).
     *
     * @func
     * @memberOf R
     * @since v0.3.0
     * @category List
     * @sig Chain c => c (c a) -> c a
     * @param {*} list
     * @return {*}
     * @see R.flatten, R.chain
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = chain(_identity);

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    // Function, RegExp, user-defined types
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function mapPairs(obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
            case '[object Arguments]':
                return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
            case '[object Array]':
                return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
                    return (/^\d+$/.test(k)
                    );
                }, keys(x)))).join(', ') + ']';
            case '[object Boolean]':
                return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
            case '[object Date]':
                return 'new Date(' + _quote(_toISOString(x)) + ')';
            case '[object Null]':
                return 'null';
            case '[object Number]':
                return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
            case '[object String]':
                return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
            case '[object Undefined]':
                return 'undefined';
            default:
                return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : // Function, RegExp, user-defined types
                '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Turns a list of Functors into a Functor of a list.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category List
     * @see R.commuteMap
     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
     * @param {Function} of A function that returns the data type to return
     * @param {Array} list An array of functors of the same type
     * @return {*}
     * @example
     *
     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     */
    var commute = commuteMap(identity);

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @see R.pipeK
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return compose.apply(this, prepend(identity, map(chain, arguments)));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called with the same
     * arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = config => {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms,
     * to at least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     * @see R.any
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements.
     * `R.equals` is used to determine equality.
     *
     * Dispatches to the `dropRepeats` method of the first argument, if present.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @see R.intersectionWith
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        return uniq(_filter(flip(_contains)(list1), list2));
    });

    /**
     * "lifts" a function of arity > 1 so that it may "map over" an Array or
     * other Functor.
     *
     * @func
     * @memberOf R
     * @since v0.7.0
     * @see R.liftN
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The function `fn` applicable to mappable objects.
     * @example
     *
     *      var madd3 = R.lift(R.curry((a, b, c) => a + b + c));
     *
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry((a, b, c, d, e) => a + b + c + d + e));
     *
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category Function
     * @see R.composeK
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the
     * elements of each list.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    /**
     * Returns a new list containing only one copy of each element in the
     * original list, based upon the value returned by applying the supplied
     * function to each list element. Prefers the first item if the supplied
     * function produces the same value on two items. `R.equals` is used for
     * comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var idx = 0,
            applied = [],
            result = [],
            appliedItem,
            item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (!_contains(appliedItem, applied)) {
                result.push(item);
                applied.push(appliedItem);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first
     * function if it is false-y and the result of the second function otherwise.
     *
     * `R.both` will work on all other applicatives as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = lift(and);

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * `R.complement` will work on all other functors as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = n => n % 2 === 0;
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = lift(not);

    /**
     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first
     * function if it is truth-y and the result of the second function otherwise.
     *
     * `R.either` will work on all other applicatives as well.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = x => x > 10;
     *      var even = x => x % 2 === 0;
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = lift(or);

    /**
     * Turns a named method with a specified arity into a function
     * that can be called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {Function} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each
     * element and concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn` for a given
     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
     * argument set will not result in an additional call to `fn`; instead, the cached result
     * for that set of arguments will be returned.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(n => {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        };
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category String
     * @sig (String | RegExp) -> String -> [String]
     * @param {String|RegExp} sep The pattern.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @since v0.12.0
     * @see R.match
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
            throw new TypeError('\u2018test\u2019 requires a value of type RegExp as its first argument; received ' + toString(pattern));
        }
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @since v0.9.0
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    /**
     * Returns the result of concatenating the given lists or strings.
     *
     * Dispatches to the `concat` method of the second argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a] -> [a]
     * @sig String -> String -> String
     * @param {Array|String} a
     * @param {Array|String} b
     * @return {Array|String}
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = flip(invoker(1, 'concat'));

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        allUniq: allUniq,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clone: clone,
        commute: commute,
        commuteMap: commuteMap,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        containsWith: containsWith,
        converge: converge,
        countBy: countBy,
        createMapEntry: createMapEntry,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqBy: eqBy,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        functions: functions,
        functionsIn: functionsIn,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        isSet: isSet,
        join: join,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObj: mapObj,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        objOf: objOf,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        pair: pair,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pathOr: pathOr,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitEvery: splitEvery,
        subtract: subtract,
        sum: sum,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        trim: trim,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unless: unless,
        unnest: unnest,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        when: when,
        where: where,
        whereEq: whereEq,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };

    /* TEST_ENTRY_POINT */

    if (( false ? 'undefined' : _typeof(exports)) === 'object') {
        module.exports = R;
    } else if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return R;
        }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        this.R = R;
    }
}).call(this);

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	return (/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g
	);
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var escapeStringRegexp = __webpack_require__(23);
var ansiStyles = __webpack_require__(19);
var stripAnsi = __webpack_require__(32);
var hasAnsi = __webpack_require__(25);
var supportsColor = __webpack_require__(22);
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\x1B[94m';
}

var styles = function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function get() {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
}();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function builder() {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function get() {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))

/***/ }),
/* 18 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function assembleStyles() {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\x1B[' + style[0] + 'm',
				close: '\x1B[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)(module)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));
    }
    return res;
};

var hasOwn = Object.prototype.hasOwnProperty;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function (xs, f, acc) {
    var hasAcc = arguments.length >= 3;
    if (hasAcc && xs.reduce) return xs.reduce(f, acc);
    if (xs.reduce) return xs.reduce(f);

    for (var i = 0; i < xs.length; i++) {
        if (!hasOwn.call(xs, i)) continue;
        if (!hasAcc) {
            acc = xs[i];
            hasAcc = true;
            continue;
        }
        acc = f(acc, xs[i], i);
    }
    return acc;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function hasFlag(flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

/***/ }),
/* 24 */
/***/ (function(module, exports) {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach(obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ansiRegex = __webpack_require__(16);
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

/***/ }),
/* 26 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function (arr, obj) {
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! JSON v3.3.0 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function (root) {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = "function" === "function" && __webpack_require__(4);

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context.
  // Rhino exports a `global` function instead.
  var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;
  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        _isProperty,
        _forEach,
        undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value,
            serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify,
              stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function value() {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" && stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" && stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function getDay(year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(_isProperty = objectProto.hasOwnProperty)) {
        _isProperty = function isProperty(property) {
          var members = {},
              constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            _isProperty = function isProperty(property) {
              // Capture and break the objectgs prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__,
                  result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            _isProperty = function isProperty(property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return _isProperty.call(this, property);
        };
      }

      // Internal: A set of primitive types used by `isHostType`.
      var PrimitiveTypes = {
        "boolean": 1,
        "number": 1,
        "string": 1,
        "undefined": 1
      };

      // Internal: Determines if the given object `property` value is a
      // non-primitive.
      var isHostType = function isHostType(object, property) {
        var type = _typeof(object[property]);
        return type == "object" ? !!object[property] : !PrimitiveTypes[type];
      };

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      _forEach = function forEach(object, callback) {
        var size = 0,
            Properties,
            members,
            property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function Properties() {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (_isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          _forEach = function forEach(object, callback) {
            var isFunction = getClass.call(object) == functionClass,
                property,
                length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && isHostType(object, "hasOwnProperty") ? object.hasOwnProperty : _isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          _forEach = function forEach(object, callback) {
            // Create a set of iterated properties.
            var members = {},
                isFunction = getClass.call(object) == functionClass,
                property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          _forEach = function forEach(object, callback) {
            var isFunction = getClass.call(object) == functionClass,
                property,
                isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || _isProperty.call(object, property = "constructor")) {
              callback(property);
            }
          };
        }
        return _forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function toPaddedString(width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function quote(value) {
          var result = '"',
              index = 0,
              length = value.length,
              useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8:case 9:case 10:case 12:case 13:case 34:case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !_isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              _forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (typeof filter == "function" || (typeof filter === "undefined" ? "undefined" : _typeof(filter)) == "object" && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function abort() {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function lex() {
          var source = Source,
              length = source.length,
              value,
              begin,
              position,
              isSigned,
              charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9:case 10:case 13:case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123:case 125:case 91:case 93:case 58:case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function get(value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function update(source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function walk(source, property, callback) {
          var value = source[property],
              length;
          if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              _forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (( false ? "undefined" : _typeof(exports)) == "object" && exports && !exports.nodeType && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, exports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON;
    var JSON3 = runInContext(root, root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function noConflict() {
        root.JSON = nativeJSON;
        return JSON3;
      }
    });

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return JSON3;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})(this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

var isFunction = function isFunction(fn) {
	return typeof fn === 'function' && !(fn instanceof RegExp) || toString.call(fn) === '[object Function]';
};

module.exports = function forEach(obj, fn) {
	if (!isFunction(fn)) {
		throw new TypeError('iterator must be a function');
	}
	var i,
	    k,
	    isString = typeof obj === 'string',
	    l = obj.length,
	    context = arguments.length > 2 ? arguments[2] : null;
	if (l === +l) {
		for (i = 0; i < l; i++) {
			if (context === null) {
				fn(isString ? obj.charAt(i) : obj[i], i, obj);
			} else {
				fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
			}
		}
	} else {
		for (k in obj) {
			if (hasOwn.call(obj, k)) {
				if (context === null) {
					fn(obj[k], k, obj);
				} else {
					fn.call(context, obj[k], k, obj);
				}
			}
		}
	}
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// modified from https://github.com/es-shims/es5-shim

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = Object.prototype.hasOwnProperty,
    toString = Object.prototype.toString,
    forEach = __webpack_require__(29),
    isArgs = __webpack_require__(31),
    hasDontEnumBug = !{ 'toString': null }.propertyIsEnumerable('toString'),
    hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype'),
    dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];

var keysShim = function keys(object) {
	var isObject = object !== null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object',
	    isFunction = toString.call(object) === '[object Function]',
	    isArguments = isArgs(object),
	    theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError("Object.keys called on a non-object");
	}

	if (isArguments) {
		forEach(object, function (value, index) {
			theKeys.push(index);
		});
	} else {
		var name,
		    skipProto = hasProtoEnumBug && isFunction;

		for (name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(name);
			}
		}
	}

	if (hasDontEnumBug) {
		var ctor = object.constructor,
		    skipConstructor = ctor && ctor.prototype === object;

		forEach(dontEnums, function (dontEnum) {
			if (!(skipConstructor && dontEnum === 'constructor') && has.call(object, dontEnum)) {
				theKeys.push(dontEnum);
			}
		});
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (!Object.keys) {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var toString = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toString.call(value);
	var isArguments = str === '[object Arguments]';
	if (!isArguments) {
		isArguments = str !== '[object Array]' && value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.length === 'number' && value.length >= 0 && toString.call(value.callee) === '[object Function]';
	}
	return isArguments;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ansiRegex = __webpack_require__(16)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var R = __webpack_require__(15);
var chalk = __webpack_require__(17);
var utils = __webpack_require__(37);
var str2color = __webpack_require__(36);
var getFnArgs = __webpack_require__(34);
var getFnName = __webpack_require__(35);
var inspect = utils.inspect;
var print = utils.print;

var mapTail = function mapTail(fn, arr) {
  return R.slice(0, 1, arr).concat(R.map(fn, R.tail(arr)));
};
var strRepeat = R.compose(R.join(''), R.repeat);
var lines = R.split('\n');
var unlines = R.join('\n');
var indentTailLines = function indentTailLines(n, str) {
  return unlines(mapTail(R.concat(strRepeat(' ', n)), lines(str)));
};

module.exports = function (name, fn) {
  if (typeof name === 'function') {
    fn = name;
    name = null;
  }

  return function () /* args */{
    if (name == null) name = getFnName(fn);
    name = name.toString();

    var prefix = name ? str2color(name) + ' ' : '';
    print(prefix + formatArgs(name, fn, arguments));
    var res = fn.apply(this, arguments);
    print(prefix + '=> ' + indentTailLines(name.length + 4, inspect(res)));
    return res;
  };
};

function formatArgs(name, fn, args) {
  var fnArgNames = getFnArgs(fn);
  var getArgPairs = function getArgPairs(i, val) {
    return [fnArgNames[i] || i.toString(), val];
  };

  var pairs = R.zipWith(getArgPairs, R.range(0, args.length), args);
  var argLines = R.map(R.apply(formatArg), pairs);
  var space = strRepeat(' ', name.length + 1);
  return unlines(mapTail(R.concat(space), argLines));

  function formatArg(argName, val) {
    var indentLevel = name.length + argName.length + 3;
    return R.join(': ', [chalk.green(argName), indentTailLines(indentLevel, inspect(val))]);
  }
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var R = __webpack_require__(15);

var parseStrs = R.compose(R.defaultTo([]), R.match(/([^\s,]+)/g));
var getParensContent = function getParensContent(str) {
  return R.slice(R.indexOf('(', str) + 1, R.indexOf(')', str), str);
};

module.exports = R.pipe(R.toString, getParensContent, parseStrs);

/***/ }),
/* 35 */
/***/ (function(module, exports) {

var CHAR = 'Î»';
var anonN = 0;

module.exports = function (fn) {
  return fn.name || CHAR + ++anonN;
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var bold = __webpack_require__(17).bold;

// deterministically color a string without reusing colors until all colors
// are used once
module.exports = function () {
  var COLORS = ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
  var unusedColors = COLORS.slice();
  var colorByStr = {};

  return function (str) {
    var color = colorByStr[str] || function () {
      if (unusedColors.length === 0) unusedColors = COLORS.slice();
      var color = strToElem(unusedColors, str);
      colorByStr[str] = color;
      unusedColors.splice(unusedColors.indexOf(color), 1);
      return color;
    }();

    return bold[color](str);
  };

  function strToElem(arr, str) {
    return arr[charCodeSum(str) % arr.length];
  }

  function charCodeSum(str) {
    return str.split('').reduce(function (sum, c) {
      return sum + c.charCodeAt();
    }, 0);
  }
}();

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var R = __webpack_require__(15);

exports.inspect = __webpack_require__(38);
exports.print = R.bind(console.log, console);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Module dependencies.
 */

var map = __webpack_require__(20);
var indexOf = __webpack_require__(26);
var isArray = __webpack_require__(27);
var forEach = __webpack_require__(24);
var reduce = __webpack_require__(21);
var getObjectKeys = __webpack_require__(30);
var JSON = __webpack_require__(28);

/**
 * Make sure `Object.keys` work for `undefined`
 * values that are still there, like `document.all`.
 * http://lists.w3.org/Archives/Public/public-html/2009Jun/0546.html
 *
 * @api private
 */

function objectKeys(val) {
  if (Object.keys) return Object.keys(val);
  return getObjectKeys(val);
}

/**
 * Module exports.
 */

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @license MIT (Â© Joyent)
 */
/* legacy: obj, showHidden, depth, colors*/

function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeNoColor(str, styleType) {
  return str;
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isUndefined(arg) {
  return arg === void 0;
}

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isNull(arg) {
  return arg === null;
}

function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function arrayToHash(array) {
  var hash = {};

  forEach(array, function (val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwn(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  forEach(keys, function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = objectKeys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden && Object.getOwnPropertyNames) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (indexOf(keys, 'message') >= 0 || indexOf(keys, 'description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = map(keys, function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = { value: value[key] };
  if (Object.getOwnPropertyDescriptor) {
    desc = Object.getOwnPropertyDescriptor(value, key) || desc;
  }
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwn(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = map(str.split('\n'), function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + map(str.split('\n'), function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = reduce(output, function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = objectKeys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWNmY2RhMjYzOWQwMzBjOTc0YTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxpdHkvX3V0aWxpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19leHRlbnNpb25GYXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbGl0eS9fZ2V0RGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9mcC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19nZXRTaW5nbGVKb3VybmV5Wm9uZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19veXN0ZXJEYXlUb3RhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9mcC9fYmFzZUNvbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZnAvX21hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZnAvcGxhY2Vob2xkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbG9kYXNoLm1pbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19zcGxpdE9yRnVsbEZhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL2Rpc3QvcmFtZGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY2hhbGsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FycmF5LW1hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FycmF5LXJlZHVjZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NoYWxrL34vc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZvcmVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXMtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vanNvbjMvbGliL2pzb24zLmpzIiwid2VicGFjazovLy8uL34vb2JqZWN0LWtleXMvZm9yZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L29iamVjdC1rZXlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vdHJlaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi90cmVpcy9saWIvZ2V0LWZuLWFyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi90cmVpcy9saWIvZ2V0LWZuLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi90cmVpcy9saWIvc3RyMmNvbG9yLmpzIiwid2VicGFjazovLy8uL34vdHJlaXMvbGliL3V0aWxzLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsLWluc3BlY3QvaW5kZXguanMiXSwibmFtZXMiOlsiZ2V0Wm9uZXMiLCJuYXBUYW4iLCJzdGF0aW9ucyIsInpvbmVzIiwiZmlsdGVyWm9uZXNCeU51bWJlciIsIm51bSIsImZpbHRlciIsInpvbmUiLCJsZW5ndGgiLCJjb21wYXJlTnVtYmVycyIsImFycmF5TnVtYmVycyIsIm9wZXJhdG9yIiwicmVkdWNlIiwiYSIsImIiLCJtYXhOdW0iLCJhcnJheVpvbmVzIiwiTWF0aCIsIm1heCIsIm1pbk51bSIsIm1pbiIsImdldERpZmZlcmVuY2UiLCJhYnMiLCJmbGF0dGVuIiwiYXJyIiwiY29uY2F0Iiwiam91cm5leVRvS2V5Iiwiam91cm5leSIsInNvcnQiLCJqb2luIiwiem9uZVRvSm91cm5leSIsImdldERhaWx5Q2FwIiwibWF4Wm9uZXNvZmFyIiwiZGFpbHlDYXBzIiwidHlwZSIsImdldENhcCIsIl8iLCJjdXJyeSIsImNhcHMiLCJnZXRTaW5nbGVGYXJlIiwic2luZ2xlRmFyZXMiLCJtZXQiLCJ0YXJnZXQiLCJ2YWx1ZSIsImV4dGVuc2lvbkZhcmVzIiwib3B0aW9ucyIsIm1heERhaWx5IiwibWluVHJhdmVsY2FyZCIsIm1heFRyYXZlbGNhcmQiLCJmaW5hbENvbmRpdGlvbiIsIm1pblNpbmdsZSIsIm1heFNpbmdsZSIsIm1pbkNoYXJnZWRab25lIiwic3BsaXRPckZ1bGxGYXJlIiwiZmV0Y2hGYXJlRGF0YSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmZXRjaCIsInRoZW4iLCJyZXNwIiwianNvbiIsImZldGNoU3RhdGlvbnNEYXRhIiwiZmV0Y2hKb3VybmV5RGF0YSIsImZyb20iLCJ0byIsImUiLCJmYXJlcyIsInJlcXVpcmUiLCJydW5JbkNvbnRleHQiLCJtb2R1bGUiLCJleHBvcnRzIiwiZ2V0U2luZ2xlSm91cm5leVpvbmVzIiwiZ2V0RGF0YSIsImpvdXJuZXlzIiwibGVncyIsImFsbFpvbmVzIiwibWFwIiwibGVnIiwidGVtcFpvbmVzIiwiZGVwYXJ0dXJlUG9pbnQiLCJuYXB0YW5JZCIsInB1c2giLCJwYXRoIiwic3RvcFBvaW50cyIsImZvckVhY2giLCJzdG9wUG9pbnQiLCJpZCIsInpvbmVzRnJvbVNpbmdsZVN0YXRpb25zIiwiem9uZXNGcm9tRHVhbFN0YXRpb25zIiwiZmluYWxNYXhab25lIiwiZmluYWxNaW5ab25lIiwic2luZ2xlTWF4Iiwic2luZ2xlTWluIiwiZHVhbFpvbmVzIiwieiIsIm95c3RlckRheVRvdGFsIiwiY2FwTWV0IiwiY29tcG9zZSIsInRvdGFscyIsInNpbmdsZUZhcmUiLCJtYXhab25lIiwibWV0RGFpbHlDYXAiLCJwZWFrVG90YWwiLCJvZmZQZWFrVG90YWwiLCJtYXBwaW5nIiwiZmFsbGJhY2tIb2xkZXIiLCJBcnJheSIsInByb3RvdHlwZSIsImJhc2VBcml0eSIsImZ1bmMiLCJuIiwiYXBwbHkiLCJ1bmRlZmluZWQiLCJhcmd1bWVudHMiLCJiYXNlQXJ5IiwiY2xvbmVBcnJheSIsImFycmF5IiwicmVzdWx0IiwiY3JlYXRlQ2xvbmVyIiwib2JqZWN0IiwiZmxhdFNwcmVhZCIsInN0YXJ0IiwibGFzdEluZGV4IiwiYXJncyIsIm90aGVyQXJncyIsInNsaWNlIiwid3JhcEltbXV0YWJsZSIsImNsb25lciIsImJhc2VDb252ZXJ0IiwidXRpbCIsIm5hbWUiLCJzZXRQbGFjZWhvbGRlciIsImlzTGliIiwiaXNPYmoiLCJPYmplY3QiLCJUeXBlRXJyb3IiLCJjb25maWciLCJjYXAiLCJmaXhlZCIsImltbXV0YWJsZSIsInJlYXJnIiwiZm9yY2VDdXJyeSIsImZvcmNlRml4ZWQiLCJmb3JjZVJlYXJnIiwicGxhY2Vob2xkZXIiLCJwcmlzdGluZSIsImhlbHBlcnMiLCJhcnkiLCJhc3NpZ24iLCJjbG9uZSIsImlzQXJyYXkiLCJpc0Z1bmN0aW9uIiwiaXRlcmF0ZWUiLCJrZXlzIiwidG9JbnRlZ2VyIiwidG9QYXRoIiwiZWFjaCIsImFyeU1ldGhvZEtleXMiLCJhcnlNZXRob2QiLCJ3cmFwcGVycyIsImNhc3RBcnJheSIsImFyaXR5IiwibWl4aW4iLCJzb3VyY2UiLCJwYWlycyIsImtleSIsInBhaXIiLCJudGhBcmciLCJpbmRleGVzIiwiY29udGV4dCIsImNhc3RDYXAiLCJpdGVyYXRlZVJlYXJnIiwiaXRlcmF0ZWVBcnkiLCJjYXN0Q3VycnkiLCJjYXN0Rml4ZWQiLCJza2lwRml4ZWQiLCJtZXRob2RTcHJlYWQiLCJjYXN0UmVhcmciLCJza2lwUmVhcmciLCJtZXRob2RSZWFyZyIsImFyeVJlYXJnIiwiY2xvbmVCeVBhdGgiLCJpbmRleCIsIm5lc3RlZCIsImNvbnZlcnRMaWIiLCJjb252ZXJ0IiwiY3JlYXRlQ29udmVydGVyIiwicmVhbE5hbWUiLCJhbGlhc1RvUmVhbCIsIm1ldGhvZE5hbWUiLCJyZW1hcCIsIm9sZE9wdGlvbnMiLCJuZXdVdGlsIiwibmV3RnVuYyIsIm5ld09wdGlvbnMiLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwid3JhcCIsIndyYXBwZWQiLCJ3cmFwcGVyIiwibXV0YXRlIiwic2V0IiwiYXJ5S2V5Iiwib3RoZXJOYW1lIiwiYWZ0ZXJSZWFyZyIsInJlYWxUb0FsaWFzIiwiYWxpYXMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ0IiwiYWRkIiwiciIsInUiLCJpIiwibyIsImYiLCJjIiwiZCIsImwiLCJzIiwiaCIsInAiLCJ2IiwiZyIsInkiLCJ4IiwiayIsIlAiLCJqIiwiRiIsInciLCJtIiwiQSIsIkUiLCJPIiwiUyIsIkkiLCJSIiwiaGFzIiwiVyIsIkIiLCJUbiIsIkwiLCJzaXplIiwiVSIsIkMiLCJEIiwiTSIsIlQiLCJCbiIsInRlc3QiLCJ6biIsInR0IiwiJCIsIm1hdGNoIiwic3BsaXQiLCJOIiwiTmFOIiwiWiIsInEiLCJWIiwiSyIsIkciLCJIIiwiSiIsIlJlZ0V4cCIsIlkiLCJRIiwiWCIsIm5uIiwidG4iLCJybiIsImVuIiwidW4iLCJvbiIsImZuIiwiY24iLCJhbiIsImxuIiwic24iLCJobiIsInBuIiwiX24iLCJ2biIsImduIiwiZG4iLCJ5biIsImJuIiwieG4iLCJqbiIsInduIiwibW4iLCJBbiIsImtuIiwiRW4iLCJPbiIsIlNuIiwiSW4iLCJSbiIsIlduIiwiTG4iLCJVbiIsIkNuIiwiRG4iLCJNbiIsIiRuIiwicGFyc2VGbG9hdCIsIkZuIiwicGFyc2VJbnQiLCJObiIsImdsb2JhbCIsIlBuIiwic2VsZiIsIlpuIiwiRnVuY3Rpb24iLCJxbiIsIm5vZGVUeXBlIiwiVm4iLCJLbiIsIkduIiwicHJvY2VzcyIsImJpbmRpbmciLCJIbiIsImlzQXJyYXlCdWZmZXIiLCJKbiIsImlzRGF0ZSIsIlluIiwiaXNNYXAiLCJRbiIsImlzUmVnRXhwIiwiWG4iLCJpc1NldCIsIm50IiwiaXNUeXBlZEFycmF5IiwicnQiLCJldCIsInV0IiwiaXQiLCJ4dSIsImFmIiwiY2kiLCJQZSIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwiX19kaXJfXyIsIl9fZmlsdGVyZWRfXyIsIl9faXRlcmF0ZWVzX18iLCJfX3Rha2VDb3VudF9fIiwiX192aWV3c19fIiwiY2xlYXIiLCJfX2RhdGFfXyIsImNmIiwic2YiLCJnZiIsInJpIiwiUmUiLCJjciIsIm90IiwiVGUiLCJNciIsImd0IiwiZnQiLCJjdCIsImh1IiwiX3QiLCJhdCIsImx0Iiwic3QiLCJvbyIsImh0IiwiVHIiLCJMdSIsInB0IiwiVXUiLCJFaSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInZ0IiwiSHUiLCJXdSIsImR0IiwiYnUiLCJFZSIsInlvIiwiV3IiLCJPZSIsIkZyIiwiJHIiLCJTZSIsImdldCIsInllIiwiZGUiLCJ5dCIsImJ0IiwibmkiLCJ4dCIsImVpIiwiam8iLCJqdCIsInd0IiwibXQiLCJBdSIsIkF0Iiwia3QiLCJJZSIsIkV0IiwiY28iLCJPdCIsImFvIiwiU3QiLCJndSIsIkl0IiwiUnIiLCIkZSIsIlJ0IiwienQiLCJraSIsInNpIiwiV3QiLCJCdCIsIkx0IiwiVXQiLCJNaSIsIkN0IiwiRHQiLCJ2ciIsIkdlIiwiTXQiLCJUdCIsIiR0IiwiRnQiLCJfZSIsInZlIiwiY29uc3RydWN0b3IiLCJkZWxldGUiLCJOdCIsIlB0IiwiWnQiLCJsaSIsIl9pIiwiRmUiLCJxdCIsIlZ0IiwiS3QiLCJ5dSIsIkd0IiwiTnUiLCJYdCIsIlF0IiwiVnUiLCJIdCIsIkxlIiwiQ2kiLCJKdCIsIll0IiwicHUiLCJtZSIsIlVlIiwiV2UiLCJCdSIsIm5yIiwiX3UiLCJMciIsInd1IiwiUnUiLCJ0ciIsInJyIiwiamUiLCJVciIsImVyIiwidXIiLCJwciIsImlyIiwib3IiLCJ3aSIsImZyIiwibXIiLCJ6aSIsIkZpIiwiYXIiLCJsciIsIndvIiwiQ2UiLCJzciIsIkR1IiwiaHIiLCJfciIsImdyIiwiZHIiLCJ5ciIsImJyIiwieHIiLCJqciIsInVvIiwid3IiLCJwbyIsIkFyIiwia3IiLCJ0aGlzQXJnIiwiRXIiLCJPciIsIlNyIiwiSXIiLCJtbyIsInp1IiwienIiLCJ5aSIsImNvcHkiLCJCciIsImJ5dGVMZW5ndGgiLCJkaSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJDciIsIkRpIiwiRHIiLCJ2byIsImdvIiwiTnIiLCJQciIsInplIiwiWnIiLCJxciIsIlZyIiwiSHIiLCJLciIsImNoYXJBdCIsIkdyIiwiJHUiLCJUdSIsInJlcGxhY2UiLCJpbyIsIkpyIiwieGUiLCJmZSIsIlhyIiwiWXIiLCJRciIsImdlIiwidGhydSIsInJldmVyc2UiLCJiZSIsIl9vIiwiQmUiLCJwbGFudCIsIm5lIiwidGUiLCJyZSIsImVlIiwiUmkiLCJ1ZSIsImllIiwiRXUiLCJvZSIsIkl1IiwieG8iLCJEZSIsImNlIiwiWHUiLCJPdSIsImFlIiwibGUiLCJsbyIsInNlIiwiaWkiLCJoZSIsInBlIiwibWVzc2FnZSIsImVvIiwiVmUiLCJKaSIsIlB1Iiwid2UiLCJBZSIsImtlIiwiaW5wdXQiLCJiaSIsImV4ZWMiLCJtaSIsIk5lIiwiTWUiLCJUaSIsImZpIiwiWmUiLCJxZSIsIktlIiwiSGUiLCJKZSIsIk5pIiwiWWUiLCJRZSIsIlhlIiwibnUiLCJ0dSIsInJ1IiwiZXUiLCJmbyIsInV1IiwiaXUiLCJvdSIsImZ1IiwiY3UiLCJhdSIsIkpvIiwibGVhZGluZyIsIm1heFdhaXQiLCJ0cmFpbGluZyIsImNhbmNlbCIsImhvIiwiZmx1c2giLCJsdSIsImNhY2hlIiwiQ2FjaGUiLCJzdSIsInZ1IiwiZHUiLCJqdSIsImhpIiwibXUiLCJrdSIsIkFpIiwibmV4dCIsImRvbmUiLCJTdSIsInZhbHVlT2YiLCJDdSIsIk11IiwiTmYiLCJ0b0xvd2VyQ2FzZSIsIkZ1IiwiWnUiLCJjaGFpbiIsInF1IiwiS3UiLCJHdSIsImRlZmF1bHRzIiwicGljayIsIkp1IiwiRGF0ZSIsIll1IiwiRXJyb3IiLCJRdSIsInRpIiwiU3RyaW5nIiwidWkiLCJvaSIsInRvU3RyaW5nIiwiYWkiLCJJRV9QUk9UTyIsInBpIiwidmkiLCJCdWZmZXIiLCJnaSIsIlN5bWJvbCIsIlVpbnQ4QXJyYXkiLCJnZXRQcm90b3R5cGVPZiIsInhpIiwiY3JlYXRlIiwiamkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInNwbGljZSIsImlzQ29uY2F0U3ByZWFkYWJsZSIsIml0ZXJhdG9yIiwidG9TdHJpbmdUYWciLCJPaSIsImNsZWFyVGltZW91dCIsIlNpIiwibm93IiwiSWkiLCJzZXRUaW1lb3V0IiwiY2VpbCIsImZsb29yIiwiV2kiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJCaSIsImlzQnVmZmVyIiwiTGkiLCJpc0Zpbml0ZSIsIlVpIiwiJGkiLCJyYW5kb20iLCJQaSIsIlppIiwicWkiLCJWaSIsIktpIiwiR2kiLCJIaSIsIllpIiwiUWkiLCJYaSIsIm5vIiwicm8iLCJ0ZW1wbGF0ZVNldHRpbmdzIiwiZXNjYXBlIiwiZXZhbHVhdGUiLCJpbnRlcnBvbGF0ZSIsInZhcmlhYmxlIiwiaW1wb3J0cyIsInBvcCIsImhhc2giLCJzdHJpbmciLCJzbyIsIkFycmF5QnVmZmVyIiwiYm8iLCJBbyIsImtvIiwiRW8iLCJPbyIsIlNvIiwiSW8iLCJSbyIsInpvIiwiV28iLCJCbyIsIkxvIiwiVW8iLCJDbyIsIkRvIiwiTW8iLCJUbyIsIiRvIiwiRm8iLCJObyIsIlBvIiwiWm8iLCJxbyIsIlZvIiwiS28iLCJHbyIsIkhvIiwiWW8iLCJRbyIsIlhvIiwibmYiLCJ0ZiIsInJmIiwiZWYiLCJ1ZiIsIm9mIiwiZmYiLCJsZiIsImhmIiwicGYiLCJfZiIsInZmIiwiZGYiLCJ5ZiIsImJmIiwieGYiLCJqZiIsIndmIiwibWYiLCJBZiIsImtmIiwiUmYiLCJFZiIsIk9mIiwiU2YiLCJJZiIsInpmIiwiV2YiLCJCZiIsIkxmIiwiVWYiLCJDZiIsIkRmIiwiTWYiLCJUZiIsIiRmIiwiRmYiLCJ0b1VwcGVyQ2FzZSIsIlBmIiwiWmYiLCJxZiIsIlZmIiwiS2YiLCJHZiIsIkhmIiwiSmYiLCJZZiIsIlFmIiwiWGYiLCJuYyIsInRjIiwicmMiLCJlYyIsInVjIiwiaWMiLCJvYyIsImFmdGVyIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYmVmb3JlIiwiYmluZCIsImJpbmRBbGwiLCJiaW5kS2V5IiwiY2h1bmsiLCJjb21wYWN0IiwiY29uZCIsImNvbmZvcm1zIiwiY29uc3RhbnQiLCJjb3VudEJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwiZGVmYXVsdHNEZWVwIiwiZGVmZXIiLCJkZWxheSIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlQnkiLCJkaWZmZXJlbmNlV2l0aCIsImRyb3AiLCJkcm9wUmlnaHQiLCJkcm9wUmlnaHRXaGlsZSIsImRyb3BXaGlsZSIsImZpbGwiLCJmbGF0TWFwIiwiZmxhdE1hcERlZXAiLCJmbGF0TWFwRGVwdGgiLCJmbGF0dGVuRGVlcCIsImZsYXR0ZW5EZXB0aCIsImZsaXAiLCJmbG93IiwiZmxvd1JpZ2h0IiwiZnJvbVBhaXJzIiwiZnVuY3Rpb25zIiwiZnVuY3Rpb25zSW4iLCJncm91cEJ5IiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlTWFwIiwia2V5QnkiLCJrZXlzSW4iLCJtYXBLZXlzIiwibWFwVmFsdWVzIiwibWF0Y2hlcyIsIm1hdGNoZXNQcm9wZXJ0eSIsIm1lbW9pemUiLCJtZXJnZSIsIm1lcmdlV2l0aCIsIm1ldGhvZCIsIm1ldGhvZE9mIiwibmVnYXRlIiwib21pdCIsIm9taXRCeSIsIm9uY2UiLCJvcmRlckJ5Iiwib3ZlciIsIm92ZXJBcmdzIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicGFydGl0aW9uIiwicGlja0J5IiwicHJvcGVydHkiLCJwcm9wZXJ0eU9mIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInJhbmdlIiwicmFuZ2VSaWdodCIsInJlamVjdCIsInJlbW92ZSIsInJlc3QiLCJzYW1wbGVTaXplIiwic2V0V2l0aCIsInNodWZmbGUiLCJzb3J0QnkiLCJzb3J0ZWRVbmlxIiwic29ydGVkVW5pcUJ5Iiwic3ByZWFkIiwidGFpbCIsInRha2UiLCJ0YWtlUmlnaHQiLCJ0YWtlUmlnaHRXaGlsZSIsInRha2VXaGlsZSIsInRhcCIsInRocm90dGxlIiwidG9BcnJheSIsInRvUGFpcnMiLCJ0b1BhaXJzSW4iLCJ0b1BsYWluT2JqZWN0IiwidW5hcnkiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnNldCIsInVuemlwIiwidW56aXBXaXRoIiwidXBkYXRlIiwidXBkYXRlV2l0aCIsInZhbHVlcyIsInZhbHVlc0luIiwid2l0aG91dCIsIndvcmRzIiwieG9yIiwieG9yQnkiLCJ4b3JXaXRoIiwiemlwIiwiemlwT2JqZWN0IiwiemlwT2JqZWN0RGVlcCIsInppcFdpdGgiLCJlbnRyaWVzIiwiZW50cmllc0luIiwiZXh0ZW5kIiwiZXh0ZW5kV2l0aCIsImF0dGVtcHQiLCJjYW1lbENhc2UiLCJjYXBpdGFsaXplIiwiY2xhbXAiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY2xvbmVXaXRoIiwiY29uZm9ybXNUbyIsImRlYnVyciIsImRlZmF1bHRUbyIsImRpdmlkZSIsImVuZHNXaXRoIiwiZXEiLCJlc2NhcGVSZWdFeHAiLCJldmVyeSIsImZpbmQiLCJmaW5kSW5kZXgiLCJmaW5kS2V5IiwiZmluZExhc3QiLCJmaW5kTGFzdEluZGV4IiwiZmluZExhc3RLZXkiLCJmb3JFYWNoUmlnaHQiLCJmb3JJbiIsImZvckluUmlnaHQiLCJmb3JPd24iLCJmb3JPd25SaWdodCIsImd0ZSIsImhhc0luIiwiaGVhZCIsImlkZW50aXR5IiwiaW5jbHVkZXMiLCJpbmRleE9mIiwiaW5SYW5nZSIsImludm9rZSIsImlzQXJndW1lbnRzIiwiaXNBcnJheUxpa2UiLCJpc0FycmF5TGlrZU9iamVjdCIsImlzQm9vbGVhbiIsImlzRWxlbWVudCIsImlzRW1wdHkiLCJpc0VxdWFsIiwiaXNFcXVhbFdpdGgiLCJpc0Vycm9yIiwiaXNJbnRlZ2VyIiwiaXNMZW5ndGgiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc05hTiIsImlzTmF0aXZlIiwiaXNOaWwiLCJpc051bGwiLCJpc051bWJlciIsImlzT2JqZWN0IiwiaXNPYmplY3RMaWtlIiwiaXNQbGFpbk9iamVjdCIsImlzU2FmZUludGVnZXIiLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNVbmRlZmluZWQiLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXQiLCJrZWJhYkNhc2UiLCJsYXN0IiwibGFzdEluZGV4T2YiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwibHRlIiwibWF4QnkiLCJtZWFuIiwibWVhbkJ5IiwibWluQnkiLCJzdHViQXJyYXkiLCJzdHViRmFsc2UiLCJzdHViT2JqZWN0Iiwic3R1YlN0cmluZyIsInN0dWJUcnVlIiwibXVsdGlwbHkiLCJudGgiLCJub0NvbmZsaWN0Iiwibm9vcCIsInBhZCIsInBhZEVuZCIsInBhZFN0YXJ0IiwicmVkdWNlUmlnaHQiLCJyZXBlYXQiLCJyb3VuZCIsInNhbXBsZSIsInNuYWtlQ2FzZSIsInNvbWUiLCJzb3J0ZWRJbmRleCIsInNvcnRlZEluZGV4QnkiLCJzb3J0ZWRJbmRleE9mIiwic29ydGVkTGFzdEluZGV4Iiwic29ydGVkTGFzdEluZGV4QnkiLCJzb3J0ZWRMYXN0SW5kZXhPZiIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJzdWJ0cmFjdCIsInN1bSIsInN1bUJ5IiwidGVtcGxhdGUiLCJzb3VyY2VVUkwiLCJ0aW1lcyIsInRvRmluaXRlIiwidG9MZW5ndGgiLCJ0b0xvd2VyIiwidG9OdW1iZXIiLCJ0b1NhZmVJbnRlZ2VyIiwidG9VcHBlciIsInRyaW0iLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJzZXBhcmF0b3IiLCJvbWlzc2lvbiIsInNlYXJjaCIsInVuZXNjYXBlIiwidW5pcXVlSWQiLCJ1cHBlckNhc2UiLCJ1cHBlckZpcnN0IiwiZWFjaFJpZ2h0IiwiZmlyc3QiLCJWRVJTSU9OIiwiZW5kIiwiY29tbWl0IiwidG9KU09OIiwiZXZhbCIsIndpbmRvdyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJkZWZpbmVQcm9wZXJ0eSIsImZhcmVEYXRhIiwiZHVhbFpvbmVPdmVybGFwIiwiX18iLCJfYXJpdHkiLCJhMCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhNiIsImE3IiwiYTgiLCJhOSIsIl9hcnJheUZyb21JdGVyYXRvciIsIml0ZXIiLCJsaXN0IiwiX2Nsb25lUmVnRXhwIiwicGF0dGVybiIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJzdGlja3kiLCJ1bmljb2RlIiwiX2NvbXBsZW1lbnQiLCJfY29uY2F0Iiwic2V0MSIsInNldDIiLCJpZHgiLCJsZW4xIiwibGVuMiIsIl9jb250YWluc1dpdGgiLCJwcmVkIiwibGVuIiwiX2N1cnJ5MSIsImYxIiwiX2N1cnJ5MiIsImYyIiwiX2N1cnJ5MyIsImYzIiwiX2N1cnJ5TiIsInJlY2VpdmVkIiwiY29tYmluZWQiLCJhcmdzSWR4IiwibGVmdCIsImNvbWJpbmVkSWR4IiwiX2ZpbHRlciIsIl9mb3JjZVJlZHVjZWQiLCJfZnVuY3Rpb25zV2l0aCIsIm9iaiIsIl9oYXMiLCJwcm9wIiwiX2lkZW50aXR5IiwiX2lzQXJndW1lbnRzIiwiX2lzQXJyYXkiLCJ2YWwiLCJfaXNJbnRlZ2VyIiwiTnVtYmVyIiwiX2lzTnVtYmVyIiwiX2lzT2JqZWN0IiwiX2lzUmVnRXhwIiwiX2lzU3RyaW5nIiwiX2lzVHJhbnNmb3JtZXIiLCJfbWFwIiwiZnVuY3RvciIsIl9vZiIsIl9waXBlIiwiX3BpcGVQIiwiY3R4IiwiX3F1b3RlIiwiZXNjYXBlZCIsIl9yZWR1Y2VkIiwiX3NsaWNlIiwiX3RvSVNPU3RyaW5nIiwidG9JU09TdHJpbmciLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJ0b0ZpeGVkIiwiX3hkcm9wUmVwZWF0c1dpdGgiLCJYRHJvcFJlcGVhdHNXaXRoIiwibGFzdFZhbHVlIiwic2VlbkZpcnN0VmFsdWUiLCJzYW1lQXNMYXN0IiwiX3hmQmFzZSIsImluaXQiLCJfeGZpbHRlciIsIlhGaWx0ZXIiLCJfeGZpbmQiLCJYRmluZCIsImZvdW5kIiwiX3hmaW5kSW5kZXgiLCJYRmluZEluZGV4IiwiX3hmaW5kTGFzdCIsIlhGaW5kTGFzdCIsIl94ZmluZExhc3RJbmRleCIsIlhGaW5kTGFzdEluZGV4IiwibGFzdElkeCIsIl94bWFwIiwiWE1hcCIsIl94dGFrZSIsIlhUYWtlIiwiX3h0YWtlV2hpbGUiLCJYVGFrZVdoaWxlIiwiX3h3cmFwIiwiWFdyYXAiLCJhY2MiLCJhZGp1c3QiLCJfaWR4IiwiX2xpc3QiLCJhbHdheXMiLCJhbmQiLCJhcHBlbmQiLCJlbCIsImFzc29jIiwiYXNzb2NQYXRoIiwidGhpc09iaiIsImNvbXBhcmF0b3IiLCJjb250YWluc1dpdGgiLCJjb3VudHMiLCJjdXJyeU4iLCJkZWMiLCJzZWNvbmQiLCJvdXQiLCJmaXJzdExlbiIsImNvbnRhaW5zUHJlZCIsImRpc3NvYyIsImRpc3NvY1BhdGgiLCJkcm9wTGFzdFdoaWxlIiwiZW1wdHkiLCJldm9sdmUiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJ0cmFuc2Zvcm1hdGlvbiIsImlkZW50aWNhbCIsImlmRWxzZSIsImNvbmRpdGlvbiIsIm9uVHJ1ZSIsIm9uRmFsc2UiLCJfaWZFbHNlIiwiaW5jIiwiaW5zZXJ0IiwiZWx0IiwiaW5zZXJ0QWxsIiwiZWx0cyIsImlzIiwiQ3RvciIsImhhc0VudW1CdWciLCJub25FbnVtZXJhYmxlUHJvcHMiLCJjb250YWlucyIsIml0ZW0iLCJrcyIsIm5JZHgiLCJtYXBBY2N1bSIsInR1cGxlIiwibWFwQWNjdW1SaWdodCIsInJ4Iiwic3RyIiwibWF0aE1vZCIsIm1vZHVsbyIsIm5BcnkiLCJub3QiLCJvZmZzZXQiLCJvYmpPZiIsImNhbGxlZCIsIklkZW50aXR5IiwibGVucyIsImZzdCIsInNuZCIsInBhdGhPciIsIm5hbWVzIiwicGlja0FsbCIsInByZXBlbmQiLCJwcm9wT3IiLCJwcm9wU2F0aXNmaWVzIiwicHJvcHMiLCJwcyIsInJlZHVjZWQiLCJjb3VudCIsInJlZ2V4IiwicmVwbGFjZW1lbnQiLCJzY2FuIiwiYWEiLCJiYiIsInRha2VMYXN0V2hpbGUiLCJJbmZpbml0eSIsIndzIiwiemVyb1dpZHRoIiwiaGFzUHJvdG9UcmltIiwiYmVnaW5SeCIsImVuZFJ4IiwidW5hcHBseSIsInVuY3VycnlOIiwiZGVwdGgiLCJjdXJyZW50RGVwdGgiLCJlbmRJZHgiLCJ1bmZvbGQiLCJzZWVkIiwidW5sZXNzIiwid2hlbkZhbHNlRm4iLCJ2YWxzIiwidnMiLCJ2aWV3IiwiQ29uc3QiLCJ3aGVuIiwid2hlblRydWVGbiIsIndoZXJlIiwic3BlYyIsInRlc3RPYmoiLCJ4cHJvZCIsImlsZW4iLCJqbGVuIiwicnYiLCJ6aXBPYmoiLCJfYXBlcnR1cmUiLCJsaW1pdCIsIl9jaGVja0Zvck1ldGhvZCIsIm1ldGhvZG5hbWUiLCJfY2xvbmUiLCJyZWZGcm9tIiwicmVmVG8iLCJjb3BpZWRWYWx1ZSIsIl9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvciIsIl9kaXNwYXRjaGFibGUiLCJ0cmFuc2R1Y2VyIiwiX2VxdWFscyIsInN0YWNrQSIsInN0YWNrQiIsImVxdWFscyIsImtleXNBIiwiX21ha2VGbGF0IiwicmVjdXJzaXZlIiwiZmxhdHQiLCJfcmVkdWNlIiwiX2FycmF5UmVkdWNlIiwiX2l0ZXJhYmxlUmVkdWNlIiwic3RlcCIsIl9tZXRob2RSZWR1Y2UiLCJzeW1JdGVyYXRvciIsIl94YWxsIiwiWEFsbCIsImFsbCIsIl94YW55IiwiWEFueSIsImFueSIsIl94YXBlcnR1cmUiLCJYQXBlcnR1cmUiLCJwb3MiLCJmdWxsIiwic3RvcmUiLCJnZXRDb3B5IiwiX3hkcm9wIiwiWERyb3AiLCJfeGRyb3BXaGlsZSIsIlhEcm9wV2hpbGUiLCJfeGdyb3VwQnkiLCJYR3JvdXBCeSIsImlucHV0cyIsImFkZEluZGV4Iiwib3JpZ0ZuIiwiYXBlcnR1cmUiLCJiaW5hcnkiLCJjcmVhdGVNYXBFbnRyeSIsImxpc3QxIiwibGlzdDIiLCJyZXN1bHRzIiwiaW50ZXJzcGVyc2UiLCJpbnZlcnRPYmoiLCJ4cyIsIm1hcE9iaiIsIm1hcE9iakluZGV4ZWQiLCJub25lIiwicGF0aEVxIiwiX3BhdGgiLCJwbHVjayIsInByb3BFcSIsInByb3BJcyIsImZyb21JbmRleCIsInRvSW5kZXgiLCJzcGxpdEV2ZXJ5IiwidHJhbnNkdWNlIiwidXNlV2l0aCIsInRyYW5zZm9ybWVycyIsIndoZXJlRXEiLCJfZmxhdENhdCIsInByZXNlcnZpbmdSZWR1Y2VkIiwicmV0IiwiX3hjYXQiLCJyeGYiLCJfaW5kZXhPZiIsIl9zdGVwQ2F0IiwiX3N0ZXBDYXRBcnJheSIsIl9zdGVwQ2F0U3RyaW5nIiwiX3N0ZXBDYXRPYmplY3QiLCJfeGNoYWluIiwiYWxsUGFzcyIsInByZWRzIiwiYWxsVW5pcSIsImFueVBhc3MiLCJhcCIsImFwcGxpY2F0aXZlIiwibW9uYWQiLCJjb21tdXRlTWFwIiwiY29uc0YiLCJjb25zdHJ1Y3ROIiwiJDAiLCIkMSIsIiQyIiwiJDMiLCIkNCIsIiQ1IiwiJDYiLCIkNyIsIiQ4IiwiJDkiLCJjb252ZXJnZSIsImZucyIsImRyb3BMYXN0IiwiZHJvcFJlcGVhdHNXaXRoIiwiZXFCeSIsImVxUHJvcHMiLCJvYmoxIiwib2JqMiIsImludG8iLCJnZXR0ZXIiLCJzZXR0ZXIiLCJsZW5zSW5kZXgiLCJsZW5zUHJvcCIsImxpZnROIiwibGlmdGVkIiwibWVkaWFuIiwid2lkdGgiLCJtZXJnZUFsbCIsInBpcGUiLCJwaXBlUCIsInByb2R1Y3QiLCJwcm9qZWN0IiwidGFrZUxhc3QiLCJ1bm5lc3QiLCJfY29udGFpbnMiLCJfdG9TdHJpbmciLCJzZWVuIiwicmVjdXIiLCJtYXBQYWlycyIsImNvbW11dGUiLCJjb21wb3NlSyIsImNvbXBvc2VQIiwiY29uc3RydWN0IiwiZHJvcFJlcGVhdHMiLCJsaWZ0IiwicGlwZUsiLCJhcHBsaWVkIiwiYXBwbGllZEl0ZW0iLCJib3RoIiwiY29tcGxlbWVudCIsImVpdGhlciIsImludm9rZXIiLCJkZWZpbmUiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJhbnNpU3R5bGVzIiwic3RyaXBBbnNpIiwiaGFzQW5zaSIsInN1cHBvcnRzQ29sb3IiLCJkZWZpbmVQcm9wcyIsImRlZmluZVByb3BlcnRpZXMiLCJpc1NpbXBsZVdpbmRvd3NUZXJtIiwicGxhdGZvcm0iLCJlbnYiLCJURVJNIiwiQ2hhbGsiLCJlbmFibGVkIiwiYmx1ZSIsIm9wZW4iLCJzdHlsZXMiLCJjbG9zZVJlIiwiY2xvc2UiLCJidWlsZCIsIl9zdHlsZXMiLCJwcm90byIsImNoYWxrIiwiYnVpbGRlciIsImFwcGx5U3R5bGUiLCJfX3Byb3RvX18iLCJhcmdzTGVuIiwibmVzdGVkU3R5bGVzIiwib3JpZ2luYWxEaW0iLCJkaW0iLCJjb2RlIiwiaGFzQ29sb3IiLCJzdHJpcENvbG9yIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwiYWRkTGlzdGVuZXIiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiYXNzZW1ibGVTdHlsZXMiLCJtb2RpZmllcnMiLCJyZXNldCIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJpbnZlcnNlIiwiaGlkZGVuIiwic3RyaWtldGhyb3VnaCIsImNvbG9ycyIsImJsYWNrIiwicmVkIiwiZ3JlZW4iLCJ5ZWxsb3ciLCJtYWdlbnRhIiwiY3lhbiIsIndoaXRlIiwiZ3JheSIsImJnQ29sb3JzIiwiYmdCbGFjayIsImJnUmVkIiwiYmdHcmVlbiIsImJnWWVsbG93IiwiYmdCbHVlIiwiYmdNYWdlbnRhIiwiYmdDeWFuIiwiYmdXaGl0ZSIsImdyZXkiLCJncm91cE5hbWUiLCJncm91cCIsInN0eWxlTmFtZSIsInN0eWxlIiwicmVzIiwiaGFzT3duIiwiaGFzQWNjIiwidGVybWluYXRvciIsImhhc0ZsYWciLCJmbGFnIiwic3Rkb3V0IiwiaXNUVFkiLCJtYXRjaE9wZXJhdG9yc1JlIiwiYW5zaVJlZ2V4Iiwicm9vdCIsImlzTG9hZGVyIiwiZnJlZUdsb2JhbCIsIlN5bnRheEVycm9yIiwibmF0aXZlSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlIiwib2JqZWN0UHJvdG8iLCJnZXRDbGFzcyIsImlzUHJvcGVydHkiLCJ1bmRlZiIsImlzRXh0ZW5kZWQiLCJleGNlcHRpb24iLCJpc1N1cHBvcnRlZCIsInNlcmlhbGl6ZWQiLCJzdHJpbmdpZnlTdXBwb3J0ZWQiLCJwYXJzZVN1cHBvcnRlZCIsImZ1bmN0aW9uQ2xhc3MiLCJkYXRlQ2xhc3MiLCJudW1iZXJDbGFzcyIsInN0cmluZ0NsYXNzIiwiYXJyYXlDbGFzcyIsImJvb2xlYW5DbGFzcyIsImNoYXJJbmRleEJ1Z2d5IiwiTW9udGhzIiwiZ2V0RGF5IiwieWVhciIsIm1vbnRoIiwibWVtYmVycyIsIm9yaWdpbmFsIiwicGFyZW50IiwiUHJpbWl0aXZlVHlwZXMiLCJpc0hvc3RUeXBlIiwiY2FsbGJhY2siLCJQcm9wZXJ0aWVzIiwiaGFzUHJvcGVydHkiLCJpc0NvbnN0cnVjdG9yIiwiRXNjYXBlcyIsImxlYWRpbmdaZXJvZXMiLCJ0b1BhZGRlZFN0cmluZyIsInVuaWNvZGVQcmVmaXgiLCJxdW90ZSIsInVzZUNoYXJJbmRleCIsInN5bWJvbHMiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJzZXJpYWxpemUiLCJwcm9wZXJ0aWVzIiwid2hpdGVzcGFjZSIsImluZGVudGF0aW9uIiwic3RhY2siLCJjbGFzc05hbWUiLCJkYXRlIiwidGltZSIsImhvdXJzIiwibWludXRlcyIsInNlY29uZHMiLCJtaWxsaXNlY29uZHMiLCJlbGVtZW50IiwicHJlZml4IiwiZnJvbUNoYXJDb2RlIiwiVW5lc2NhcGVzIiwiSW5kZXgiLCJTb3VyY2UiLCJhYm9ydCIsImxleCIsImJlZ2luIiwicG9zaXRpb24iLCJpc1NpZ25lZCIsImhhc01lbWJlcnMiLCJ3YWxrIiwiSlNPTiIsIkpTT04zIiwiaXNBcmdzIiwiaGFzRG9udEVudW1CdWciLCJoYXNQcm90b0VudW1CdWciLCJkb250RW51bXMiLCJrZXlzU2hpbSIsInRoZUtleXMiLCJza2lwUHJvdG8iLCJjdG9yIiwic2tpcENvbnN0cnVjdG9yIiwiZG9udEVudW0iLCJzaGltIiwic2hpbU9iamVjdEtleXMiLCJjYWxsZWUiLCJ1dGlscyIsInN0cjJjb2xvciIsImdldEZuQXJncyIsImdldEZuTmFtZSIsImluc3BlY3QiLCJwcmludCIsIm1hcFRhaWwiLCJzdHJSZXBlYXQiLCJsaW5lcyIsInVubGluZXMiLCJpbmRlbnRUYWlsTGluZXMiLCJmb3JtYXRBcmdzIiwiZm5BcmdOYW1lcyIsImdldEFyZ1BhaXJzIiwiYXJnTGluZXMiLCJmb3JtYXRBcmciLCJzcGFjZSIsImFyZ05hbWUiLCJpbmRlbnRMZXZlbCIsInBhcnNlU3RycyIsImdldFBhcmVuc0NvbnRlbnQiLCJDSEFSIiwiYW5vbk4iLCJDT0xPUlMiLCJ1bnVzZWRDb2xvcnMiLCJjb2xvckJ5U3RyIiwiY29sb3IiLCJzdHJUb0VsZW0iLCJjaGFyQ29kZVN1bSIsImdldE9iamVjdEtleXMiLCJvYmplY3RLZXlzIiwib3B0cyIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiY3VzdG9tSW5zcGVjdCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlVHlwZSIsImFyZyIsIm9iamVjdFRvU3RyaW5nIiwiYXJyYXlUb0hhc2giLCJmb3JtYXRBcnJheSIsInJlY3Vyc2VUaW1lcyIsInZpc2libGVLZXlzIiwib3V0cHV0IiwiZm9ybWF0UHJvcGVydHkiLCJmb3JtYXRFcnJvciIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsImdldE93blByb3BlcnR5TmFtZXMiLCJiYXNlIiwiYnJhY2VzIiwidG9VVENTdHJpbmciLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJsaW5lIiwic3Vic3RyIiwic2ltcGxlIiwibnVtTGluZXNFc3QiLCJwcmV2IiwiY3VyIiwib3JpZ2luIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7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RCxTQUFTLEVBQVQsR0FBYyxFQUFkLEdBQW1CQSxPQUFPLEtBRDNCLElBRUEsR0FGQSxHQUdBTixPQUFPMWxELElBQVAsQ0FBWSxPQUFaLENBSEEsR0FJQSxHQUpBLEdBS0FpbUQsT0FBTyxDQUFQLENBTFA7QUFNRDs7QUFFRCxTQUFPQSxPQUFPLENBQVAsSUFBWUQsSUFBWixHQUFtQixHQUFuQixHQUF5Qk4sT0FBTzFsRCxJQUFQLENBQVksSUFBWixDQUF6QixHQUE2QyxHQUE3QyxHQUFtRGltRCxPQUFPLENBQVAsQ0FBMUQ7QUFDRDs7QUFFRCxTQUFTbEIsT0FBVCxDQUFpQjZCLE1BQWpCLEVBQXlCcDdDLEdBQXpCLEVBQThCO0FBQzVCO0FBQ0EsTUFBSSxDQUFDQSxHQUFELElBQVEsQ0FBQzJ2QixTQUFTM3ZCLEdBQVQsQ0FBYixFQUE0QixPQUFPbzdDLE1BQVA7O0FBRTVCLE1BQUk3K0MsT0FBTzI4QyxXQUFXbDVDLEdBQVgsQ0FBWDtBQUNBLE1BQUlHLElBQUk1RCxLQUFLcEosTUFBYjtBQUNBLFNBQU9nTixHQUFQLEVBQVk7QUFDVmk3QyxXQUFPNytDLEtBQUs0RCxDQUFMLENBQVAsSUFBa0JILElBQUl6RCxLQUFLNEQsQ0FBTCxDQUFKLENBQWxCO0FBQ0Q7QUFDRCxTQUFPaTdDLE1BQVA7QUFDRCxDIiwiZmlsZSI6Ii4vZGlzdC9qcy9hcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYWNmY2RhMjYzOWQwMzBjOTc0YTUiLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gvZnAnO1xuXG4vKipcbiAqIEdldHMgWm9uZXNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hcFRhbiAtIFRoZSBuYXB0YW4gb2YgdGhlIHN0YXRpb24gd2UncmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBzdGF0aW9ucyB3aXRoIG5hcFRhbnMgYXMga2V5cy5cbiAqIEByZXR1cm5zIHthcnJheX1cbiAqIEBkZXNjcmlwdGlvbiBVc2VzIHRoZSBuYXBUYW4gSUQgdG8gZmlndXJlIG91dCB3aGF0IHpvbmUgdGhhdCBzdGF0aW9uIGlzIGluIHZpYSBzdGF0aW9uLmpzb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFpvbmVzKG5hcFRhbiwgc3RhdGlvbnMpIHtcbiAgcmV0dXJuIHN0YXRpb25zW25hcFRhbl0uem9uZXM7XG59XG5cbi8qKlxuICogZmlsdGVycyBhIG5lc3RlZCBhcnJheSBiYXNlZCBvbiBpdHMgbGVuZ3RoIFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIC0gZWl0aGVyIDEgKGZvciBzaW5nbGUgem9uZSkgb3IgMiAoZHVhbCB6b25lKVxuICogQHBhcmFtIHtuZXN0ZWQgYXJyYXl9IHpvbmVzIC0gdGhlIG5lc3RlZCBhcnJheSBvZiBhcnJheXMgKG9mIHpvbmVzKVxuICogQHJldHVybnMge25lc3RlZCBhcnJheX0gLSBuZXN0ZWQgYXJyYXkgb2YgYWxsIGFycmF5IG9mIHpvbmVzIGZyb20gc3RhdGlvbnMgdGhhdCBvbmx5IGhhdmUgb25lIHpvbmUgYXNzb2NpYXRlZCB3aXRoIGl0IChpZiBudW0gPSAxKSBvci4uLlxuICogQGRlc2NyaXB0aW9uIC0gem9uZXMgcmVmZXJzIHRvIGdsb2JhbCBhbGxab25lcyAvIHVzZWQgdG8gZmlsdGVyIHRoZSBzdGF0aW9uIHpvbmVzIGJ5IHRoZSBudW1iZXIgb2Ygem9uZXMgaXQgaGFzIChkdWFsIHpvbmUgb3Igc2luZ2xlIHpvbmUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJab25lc0J5TnVtYmVyKG51bSwgem9uZXMpIHtcbiAgcmV0dXJuIHpvbmVzLmZpbHRlcihmdW5jdGlvbih6b25lKSB7XG4gICAgcmV0dXJuIHpvbmUubGVuZ3RoID09PSBudW07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIE51bWJlcnNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHthcnJheX0gbnVtYmVycyAtIHRoZSBhcnJheSBvZiBudW1iZXIocylcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRvciAtIHdoYXQgamF2YXNjcmlwdCBvcGVyYXRvciBwYXNzaW5nIHRocm91Z2ggKGUuZy4gTWF0aC5tYXgpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBzaW5nbGUgbnVtYmVyIGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgKHJlZHVjZXMgdG8gb25lIG51bWJlcilcbiAqIEBkZXNjcmlwdGlvbiBBc3NvY2lhdGVkIHdpdGggbWluTnVtIGFuZCBtYXhOdW06IHdoZXJlIGFycmF5Wm9uZXMgcmVmZXJzIHRvIHpvbmVzRnJvbVNpbmdsZVN0YXRpb25zLlxuIExvb3BzIHRocm91Z2ggdGhlIGFycmF5IG9mIHpvbmVzIGFuZCBhcHBsaWVzIHRoZSBvcGVyYXRvclxuICovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhcnJheU51bWJlcnMsIG9wZXJhdG9yKSB7XG4gIHJldHVybiBhcnJheU51bWJlcnMucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gb3BlcmF0b3IoYSwgYik7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF4TnVtKGFycmF5Wm9uZXMpIHtcbiAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGFycmF5Wm9uZXMsIE1hdGgubWF4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbk51bShhcnJheVpvbmVzKSB7XG4gIHJldHVybiBjb21wYXJlTnVtYmVycyhhcnJheVpvbmVzLCBNYXRoLm1pbik7XG59XG5cbi8qKlxuICogR2V0IGRpZmZlcmVuY2UgYmV0d2VlbiAyIG51bWJlcnNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJzfSBhLGIgLSB0aGUgdHdvIG51bWJlcnMgY29tcGFyaW5nIGFnYWluc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgMiBudW1iZXJzIChkaXNjYXJkaW5nIG5lZ2F0aXZlIG51bWJlcnMpXG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpZmZlcmVuY2UoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpO1xuICAvLyByZXR1cm4gYSAtIGI7XG59XG5cbi8qKlxuICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXlcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgdGhhdCBpcyBhbiBhcnJheSB3aXRoaW4gYW5vdGhlciBhcnJheVxuICogQHJldHVybnMge251bWJlcn0gLSBmbGF0dGVucyB0aGUgYXJyYXkgc28ganVzdCBvbmUgYXJyYXlcbiAqIEBkZXNjcmlwdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfSk7XG59XG5cbi8qKlxuICogU29ydCBhbiBhcnJheSBvZiAyIHpvbmVzIGNocm9ub2xvZ2ljYWxseSBhbmQgYWRkcyAnLSdcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHthcnJheX0gam91cm5leSAtIHRoZSBhcnJheSBvZiB0aGUgMiB6b25lcyBvZiB0aGF0IGpvdXJuZXlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gJ3gteSdcbiAqIEBkZXNjcmlwdGlvbiAtIHVzZWQgdG8gZ2V0IHRoZSBmYXJlcyBmcm9tIHRoZSBqc29uIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpvdXJuZXlUb0tleShqb3VybmV5KSB7XG4gIHJldHVybiBqb3VybmV5LnNvcnQoKS5qb2luKCctJyk7XG59XG5cbmZ1bmN0aW9uIHpvbmVUb0pvdXJuZXkoem9uZSkge1xuICByZXR1cm4gam91cm5leVRvS2V5KFsxLCB6b25lXSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGFpbHkgY2FwIGNvc3RcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IC0gdGhlIChtYXhpbXVtKSB6b25lXG4gKiBAcGFyYW0ge29iamVjdH0gZGFpbHlDYXBzIC0gbG9va3MgYXQgdGhlIGRhaWx5Q2FwcyBvYmplY3QgaW4gdGhlIGZhcmVzLmpzb24gZmlsZVxuICogQHJldHVybnMge251bWJlcn0gLSBnZXRzIHRoZSBkYWlseSBjYXAgYmV0d2VlbiB6b25lcyAxIGFuZCB0aGUgem9uZSBwYXJhbWV0ZXIgKGFzIGRhaWx5IGNhcHMgYWx3YXlzIHN0YXJ0cyBhdCB6b25lIDEpXG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhaWx5Q2FwKG1heFpvbmVzb2ZhciwgZGFpbHlDYXBzLCB0eXBlKSB7XG4gIHJldHVybiBkYWlseUNhcHNbam91cm5leVRvS2V5KFsxLCBtYXhab25lc29mYXJdKV1bdHlwZV07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDYXAgPSBfLmN1cnJ5KCh6b25lLCB0eXBlLCBjYXBzKSA9PiBjYXBzW3pvbmVUb0pvdXJuZXkoem9uZSldW3R5cGVdKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaW5nbGUgZmFyZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2FycmF5fSBqb3VybmV5IC0gdGhlIGFycmF5IG9mIHRoZSAyIHpvbmVzIHRyYXZlbGxpbmcgYmV0d2VlblxuICogQHBhcmFtIHtvYmplY3R9IHNpbmdsZUZhcmVzIC0gbG9va3MgYXQgdGhlIHNpbmdsZUZhcmVzIG9iamVjdCBpbiB0aGUgZmFyZXMuanNvbiBmaWxlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIGdldHMgdGhlIHNpbmdsZSBmYXJlIGJldHdlZW4gdGhvc2UgdHdvIHpvbmVzXG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpbmdsZUZhcmUoam91cm5leSwgc2luZ2xlRmFyZXMsIHR5cGUpIHtcbiAgLy8gZGVidWdnZXI7XG4gIHJldHVybiBzaW5nbGVGYXJlc1tqb3VybmV5VG9LZXkoam91cm5leSldW3R5cGVdO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBudW1lcmljIHRhcmdldCBoYXMgYmVlbiBtZXQgb3Igc3VycGFzc2VkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQgLSB0YXJnZXQgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSB0YXJnZXRcbiAqIEBkZXNjcmlwdGlvblxuICovXG5leHBvcnQgY29uc3QgbWV0ID0gXy5jdXJyeSgodGFyZ2V0LCB2YWx1ZSkgPT4gdmFsdWUgPj0gdGFyZ2V0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy91dGlsaXR5L191dGlsaXR5LmpzIiwiaW1wb3J0IHtcblx0Z2V0U2luZ2xlRmFyZSxcblx0bWF4TnVtLFxufSBmcm9tICcuLi91dGlsaXR5L191dGlsaXR5JztcblxuaW1wb3J0IHNwbGl0T3JGdWxsRmFyZSBmcm9tICcuL19zcGxpdE9yRnVsbEZhcmUnO1xuXG4vLyAvKipcbi8vICAqIENhbGN1bGF0ZXMgdGhlIGV4dGVuc2lvbiBmYXJlIChvciBub25lKSBvZiBhIGpvdXJuZXlcbi8vICAqIEBmdW5jdGlvblxuLy8gICogQHBhcmFtIHtvYmplY3R9IHNlZSBiZWxvd1xuLy8gICogQHBhcmFtIHtzaW5nbGVGYXJlc30gdXNlcyB0aGUgc2luZ2xlRmFyZXMganNvbiBkYXRhXG4vLyAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHJldHVybnMgdGhlIGV4dGVuc2lvbiBmYXJlIGZvciB0aGUgam91cm5leVxuLy8gICogQGRlc2NyaXB0aW9uXG4vL1xuLy8gXHRGT1IgREFJTFkgQ0FQUzogQUxXQVlTIFNUQVJUIEFUIDEgU08gTU9TVCBPRiBUSElTIENPREUgVE9PIENPTVBMRVg6IGJ1dCB3b3VsZCBzdGlsbCB3b3JrXG4vLyBcdEZPUiBXRUVLTFkgQ0FQUzogdGhpcyB3b3JrcyBvdXQgZmFyZSB3aXRob3V0IGFueSBkYWlseSBjYXBzIG9yIG1peCBkYWlseSBhbmQgd2Vla2x5IHdoZXJlIHRoZXJlIGFyZSBubyBnYXAgem9uZXMgKHNvIGJldHdlZW4gMSBhbmQgbWF4IHpvbmUgb2YgZWl0aGVyIGRhaWx5IG9yIHdlZWtseSBjYXApIC0tIHVubGVzcyB5b3UgYWRkIGluIE1heERhaWx5XG4vLyAgLy8gdGhpcyBpcyBvdmVybHkgY29tcGxpY2F0ZWQgZm9yIGRhaWx5IGNhcHMgKGFzIG9ubHkgZGVhbHMgd2l0aCB6b25lIDEgdG8geCkgYnV0IHN0aWxsIHdvcmtzLiBSRUxJRVMgT04gVEhFIEZBQ1QgREFJTFkgQUxXQVlTIFNUQVJUUyBBVCAxXG4vLyAgKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0ZW5zaW9uRmFyZXMob3B0aW9ucyA9IHt9LCBzaW5nbGVGYXJlcykge1xuICBjb25zdCBtYXhEYWlseSA9IG9wdGlvbnMubWF4RGFpbHkgfHwgbnVsbDtcbi8vIGJ5IGRlZmF1bHQ6IGp1c3Qgb25lIHRyYXZlbGNhcmQgKHdlZWtseSB3aXRob3V0IGRhaWx5IG9yIGp1c3QgZGFpbHkgY2FwKSBmb3IgZWl0aGVyIG95c3RlciBvciBjb250YWN0bGVzcywgb3Igb3lzdGVyIHdpdGggd2Vla2x5IGNhcCAoZG9lc24ndCBjdXQgb2ZmIGRhaWx5IHNlY3Rpb24gb2YgdGhlIGpvdXJuZXkpXG5cblx0bGV0IHtcblx0XHR6b25lcyxcblx0XHR0eXBlLFxuICAgIFx0bWluVHJhdmVsY2FyZCwgLy8gbWluaW11bSB6b25lIG9mIHRoZSB0cmF2ZWxjYXJkIGN1cnJlbnRseSB0ZXN0aW5nXG5cdFx0bWF4VHJhdmVsY2FyZCwgLy9tYXhpbXVtIHpvbmUgb2YgdGhlIHRyYXZlbGNhcmQgY3VycmVudGx5IHRlc3Rpbmdcblx0XHQvLyBpZiBtYXhkYWlseSBhbHNvIGludm9sdmVkIChmb3IgY29udGFjdGxlc3Mgd2Vla2x5IGFuZCBkYWlseSBjb21ibyk6IHNvIHRoYXQgaXQgb25seSBjaGFyZ2VzIHRoZSBnYXAgem9uZXNcblx0fSA9IG9wdGlvbnM7XG5cdC8vIHNhbWUgYXMgdmFyIG1pblNpbmdsZSA9IG9wdGlvbnMubWluU2luZ2xlO1xuXG4gIGxldCBmaW5hbENvbmRpdGlvbiA9IG51bGw7XG4gIGxldCBtaW5TaW5nbGUgPSB6b25lc1swXTtcbiAgbGV0IG1heFNpbmdsZSA9IHpvbmVzWzFdO1xuICBsZXQgbWluQ2hhcmdlZFpvbmUgPSBtaW5TaW5nbGU7XG5cblx0aWYgKG1heERhaWx5KSB7IC8vIElmIGNvbnRhY3RsZXNzLCBkYWlseSBhbmQgd2Vla2x5IGNvbWJvIChoZW5jZSBhZGRpbmcgaW4gbWF4RGFpbHkgYXMgYXJndW1lbnRfXG5cdCBcdGlmIChtYXhEYWlseSA+PSAobWluVHJhdmVsY2FyZCAtIDEpKSB7IC8vIGlmIG5vIGdhcCB6b25lcyBiZXR3ZWVuIG1heCBkYWlseSBhbmQgbWluIHRyYXZlbGNhcmRcblx0ICBcdG1pblRyYXZlbGNhcmQgPSAxOyAvLyBzaW5jZSBhbnl0aW1lIGRhaWx5IGNhcHMgYWx3YXlzIHN0YXJ0IGF0IHpvbmUgMVxuXHQgICBcdG1heFRyYXZlbGNhcmQgPSBtYXhOdW0oW21heERhaWx5LCBtYXhUcmF2ZWxjYXJkXSk7IC8vIG1heCB0cmF2ZWxjYXJkIGlzIHdoaWNoZXZlciBpcyBsYXJnZXN0IG1heCBkYWlseSBvciBtYXggdHJhdmVsY2FyZFxuLy8gZWxzZSBpZiBjb250YWN0bGVzcywgZGFpbHkgYW5kIHdlZWtseSBjb21ibywgYW5kIHRoZXJlIGFyZSBnYXAgem9uZXMgYmV0d2VlbiBtYXggZGFpbHkgYW5kIG1pbiB0cmF2ZWxjYXJkLCBoYXZlIGEgbWluIGNoYXJnZWQgem9uZSAobm90IGNoYXJnZSB0aGUgZGFpbHkgY2FwIC0gdGhlIGZyb250KVxuXHRcdH0gZWxzZSB7IC8vIElGIGRpZmZlcmVuY2UgYncgbWluIHdlZWtseSBhbmQgbWF4IGRhaWx5IGNhcCA+IDEgLS0gVEhFTiBUSEVSRSBBUkUgR0FQIFpPTkVTXG5cdFx0XHRcdG1pbkNoYXJnZWRab25lID0gKChtaW5TaW5nbGUgPD0gbWF4RGFpbHkpID8gbWF4RGFpbHkgKyAxIDogbWluU2luZ2xlKTtcblx0XHRcdFx0ZmluYWxDb25kaXRpb24gPSAobWluU2luZ2xlIDw9IG1heERhaWx5ICYmIG1heFNpbmdsZSA8PSBtYXhEYWlseSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gaWYgbWluIHNpbmdsZSBpc250IHdpdGhpbiB0cmF2ZWxjYXJkIHpvbmVzIGJ1dCBtYXggc2luZ2xlIGlzKE5CIG5vdCBuZWVkZWQgZm9yIGRhaWx5IGNhcCkgLSBjaGFyZ2UgZnJvbnRcblx0aWYgKChtaW5TaW5nbGUgPCBtaW5UcmF2ZWxjYXJkKSAmJiAobWluVHJhdmVsY2FyZCA8PSBtYXhTaW5nbGUgJiYgbWF4U2luZ2xlIDw9IG1heFRyYXZlbGNhcmQpKSB7XG5cdFx0IC8vIGRlYnVnZ2VyO1xuXHRcdHJldHVybiBnZXRTaW5nbGVGYXJlKFttaW5DaGFyZ2VkWm9uZSwgKG1pblRyYXZlbGNhcmQgLSAxKV0sIHNpbmdsZUZhcmVzLCB0eXBlKTtcblxuXHQvL2lmIG1pbiBzaW5nbGUgd2l0aGluIHRyYXZlbGNhcmQgem9uZXMgYnV0IG1heCBzaW5nbGUgaXNudCAtIGNoYXJnZSBlbmRcbiBcdH0gZWxzZSBpZiAoKG1pblRyYXZlbGNhcmQgPD0gbWluU2luZ2xlICYmIG1pblNpbmdsZSA8PSBtYXhUcmF2ZWxjYXJkKSAmJiAobWF4U2luZ2xlID4gbWF4VHJhdmVsY2FyZCkpIHtcbiBcdFx0IC8vIGRlYnVnZ2VyO1xuIFx0XHRyZXR1cm4gZ2V0U2luZ2xlRmFyZShbKG1heFRyYXZlbGNhcmQgKyAxKSwgbWF4U2luZ2xlXSwgc2luZ2xlRmFyZXMsIHR5cGUpO1xuXG4gXHQvL2lmIG1pbiBzaW5nbGUgbGVzcyB0aGFuIG1pbiB0cmF2ZWxjYXJkIGFuZCBtYXggc2luZ2xlIG1vcmUgdGhhbiBtYXggdHJhdmVsY2FyZCAoTkIgbm90IG5lZWRlZCBmb3IgZGFpbHkgY2FwKSAtIGNoYXJnZSBmcm9udCBhbmQgZW5kXG4gXHR9IGVsc2UgaWYgKG1pblNpbmdsZSA8IG1pblRyYXZlbGNhcmQgJiYgbWF4U2luZ2xlID4gbWF4VHJhdmVsY2FyZCkge1xuIFx0XHQgLy8gZGVidWdnZXI7XG4gXHRcdHJldHVybiBzcGxpdE9yRnVsbEZhcmUoXG4gICAgICBtaW5DaGFyZ2VkWm9uZSwgbWF4U2luZ2xlLFxuIFx0XHRcdG1pblRyYXZlbGNhcmQsIG1heFRyYXZlbGNhcmQsXG4gXHRcdFx0c2luZ2xlRmFyZXMsIHR5cGUpO1xuXG5cdC8vIGJvdGggc2luZ2xlIHpvbmVzIHdpdGhpbiB0cmF2ZWxjYXJkIHpvbmVzXG4gXHR9IGVsc2UgaWYgKChtaW5UcmF2ZWxjYXJkIDw9IG1pblNpbmdsZSAmJiBtaW5TaW5nbGUgPD0gbWF4VHJhdmVsY2FyZCkgJiYgKG1pblRyYXZlbGNhcmQgPD0gbWF4U2luZ2xlICYmIG1heFNpbmdsZSA8PSBtYXhUcmF2ZWxjYXJkKSB8fCBmaW5hbENvbmRpdGlvbikge1xuIFx0XHQgLy8gZGVidWdnZXI7XG4gXHRcdHJldHVybiAwO1xuIFx0Ly8gYm90aCBzaW5nbGUgem9uZXMgYXJlIG91dHNpZGUgdHJhdmVsY2FyZCB6b25lc1xuIFx0fVxuXG5cbiAgcmV0dXJuIGdldFNpbmdsZUZhcmUoW21pbkNoYXJnZWRab25lLCBtYXhTaW5nbGVdLCBzaW5nbGVGYXJlcywgdHlwZSk7XG4vLyBFTFNFIG1pbiBzaW5nbGUgYW5kIG1heCBzaW5nbGUgYm90aCA+IG1heCB3ZWVrbHkgem9uZSAob3IgYm90aCA8IG1pbiBkYWlseSkgT1IgbWluIHNpbmdsZSB6b25lID4gbWluIGdhcCB6b25lICYmIG1heCBzaW5nbGUgem9uZSA8IG1heCBnYXAgem9uZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3BhcnRpYWxzL19leHRlbnNpb25GYXJlcy5qcyIsIi8qKlxuICogR2V0cyBmYXJlcy5qc29uIGZpbGVcbiAqL1xudmFyIGZldGNoRmFyZURhdGEgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgZGF0YSA9IG51bGw7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChkYXRhKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnb2ghIHdlIGFyZSBnZXR0aW5nIHRoZSBjYWNoZWQgZGF0YSEnKTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZldGNoKCcvZGF0YS9mYXJlcy5qc29uJykudGhlbihmdW5jdGlvbihyZXNwKSB7XG5cdFx0XHRkYXRhID0gcmVzcC5qc29uKCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9KTtcblx0fVxufSgpKTtcblxuLy8gR2V0cyBzdGF0aW9uLmpzb24gLSBsaXN0aW5nIHdoYXQgem9uZXMgZWFjaCBzdGF0aW9uIGlzXG52YXIgZmV0Y2hTdGF0aW9uc0RhdGEgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBkYXRhID0gbnVsbDtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGRhdGEpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdvaCEgd2UgYXJlIGdldHRpbmcgdGhlIGNhY2hlZCBkYXRhIScpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmV0Y2goJy9kYXRhL3N0YXRpb25zLmpzb24nKS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcblx0XHRcdGRhdGEgPSByZXNwLmpzb24oKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH0pO1xuXHR9XG59KCkpO1xuXG4vL0ZldGNoZXMgdGhlIGpzb24gZmlsZSBmcm9tIFRGTCBBUElcbnZhciBmZXRjaEpvdXJuZXlEYXRhID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0cmV0dXJuIGZldGNoKCdodHRwczovL2FwaS50ZmwuZ292LnVrL2pvdXJuZXkvam91cm5leXJlc3VsdHMvJyArIGZyb20gKyAnL3RvLycgKyB0byArICc/YXBwX2lkPThhY2Q3OWE5JmFwcF9rZXk9ZDQzM2EyZDZkOWE5YzhlOGIxYjRhNmRkNDM3MWM2OWInKS50aGVuKGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gZS5qc29uKCk7XG5cdH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRmYXJlczogZmV0Y2hGYXJlRGF0YSxcblx0c3RhdGlvbnM6IGZldGNoU3RhdGlvbnNEYXRhLFxuXHRqb3VybmV5OiBmZXRjaEpvdXJuZXlEYXRhLFxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdXRpbGl0eS9fZ2V0RGF0YS5qcyIsInZhciBfID0gcmVxdWlyZSgnLi9sb2Rhc2gubWluJykucnVuSW5Db250ZXh0KCk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZnAvX2Jhc2VDb252ZXJ0JykoXywgXyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9mcC5qcyIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy9UaGUgY29tcGxldGUgZnVuY3Rpb24gaW4gb3JkZXIgdG8gZ2V0IHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHpvbmVzIG9mIHRoYXQgam91cm5leSAodGFraW5nIGludG8gY29uc2lkZXJhdGlvbiBkdWFsIHpvbmVzKVxuLy8gc3RhdGlvbnMgaXMgdGhlIC5qc29uIGZpbGUgZnJvbSBmZXRjaFN0YXRpb25zRGF0YSgpIGZ1bmN0aW9uXG4vLyBOZWVkIHRvIG1ha2UgaXQgc28gdGhhdCBpdCBnZW5lcmF0ZXMgaXQgYWZ0ZXIgZWFjaCBqb3VybmV5XG5cbmltcG9ydCBnZXREYXRhIGZyb20gJy4uL3V0aWxpdHkvX2dldERhdGEnO1xuaW1wb3J0IHtcblx0ZmxhdHRlbixcblx0Z2V0Wm9uZXMsXG5cdGZpbHRlclpvbmVzQnlOdW1iZXIsXG5cdG1pbk51bSxcblx0bWF4TnVtXG59IGZyb20gJy4uL3V0aWxpdHkvX3V0aWxpdHknO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTaW5nbGVKb3VybmV5Wm9uZXMoZnJvbSwgdG8sIHN0YXRpb25zKSB7XG5cdHJldHVybiBnZXREYXRhLmpvdXJuZXkoZnJvbSwgdG8pLnRoZW4oZnVuY3Rpb24oam91cm5leSkge1xuXHRcdHZhciBqb3VybmV5ID0gam91cm5leS5qb3VybmV5c1swXTsgLy8gc2VsZWN0aW5nIG9ubHkgdGhlIGZpcnN0IGpvdXJuZXkgZnJvbSB0aGUgQVBJXG5cdFx0dmFyIGxlZ3MgPSBqb3VybmV5LmxlZ3M7IC8vVG8gbG9vayBhdCBlYWNoIGxlZyBvZiB0aGUgam91cm5leVxuXG5cdFx0Ly8gVGhlIGFycmF5IG9mIHpvbmVzIGFzc29jaWF0ZWQgd2l0aCBhbGwgc3RhdGlvbnMgb2YgdGhhdCBqb3VybmV5XG5cdFx0dmFyIGFsbFpvbmVzID0gZmxhdHRlbihsZWdzLm1hcChmdW5jdGlvbihsZWcpIHtcblx0XHRcdHZhciB0ZW1wWm9uZXMgPSBbXTtcblxuXHRcdFx0Ly9HZXRzIHRoZSB6b25lcyBvZiB0aGUgZGVwYXJ0dXJlUG9pbnRzIGFuZCBhZGRzIHRoZW0gdG8gYWxsWm9uZXMgYXJyYXlcblx0XHRcdGlmIChsZWcuZGVwYXJ0dXJlUG9pbnQgJiYgbGVnLmRlcGFydHVyZVBvaW50Lm5hcHRhbklkKSB7IFxuXHRcdFx0XHR0ZW1wWm9uZXMucHVzaChnZXRab25lcyhsZWcuZGVwYXJ0dXJlUG9pbnQubmFwdGFuSWQsIHN0YXRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vR2V0cyB0aGUgem9uZXMgb2YgdGhlIFN0b3BQb2ludCBhbmQgYWRkcyB0aGVtIHRvIGFsbFpvbmVzIGFycmF5XG5cdFx0XHRpZiAobGVnLnBhdGguc3RvcFBvaW50cyAmJiBsZWcucGF0aC5zdG9wUG9pbnRzLmxlbmd0aCA+IDApIHsgXG5cdFx0XHRcdGxlZy5wYXRoLnN0b3BQb2ludHMuZm9yRWFjaChmdW5jdGlvbihzdG9wUG9pbnQpIHtcblx0XHRcdFx0XHRpZiAoc3RvcFBvaW50LmlkKSB7XG5cdFx0XHRcdFx0XHR0ZW1wWm9uZXMucHVzaChnZXRab25lcyhzdG9wUG9pbnQuaWQsIHN0YXRpb25zKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRlbXBab25lcztcblx0XHR9KSk7XG5cblxuXHRcdC8vRmlsdGVycyBhbGwgdGhlIHN0YXRpb25zIGFuZCBzcGxpdCB0aGVtIGludG8gem9uZXNGcm9tU2luZ2xlU3RhdGlvbnMgYW5kIHpvbmVzRnJvbUR1YWxTdGF0aW9uc1xuXHRcdC8vIHZhciB6b25lc0Zyb21TaW5nbGVTdGF0aW9ucyA9IGZsYXR0ZW4oZmlsdGVyWm9uZXNCeU51bWJlcigxLCBhbGxab25lcykpO1xuXHRcdHZhciB6b25lc0Zyb21TaW5nbGVTdGF0aW9ucyA9IGZpbHRlclpvbmVzQnlOdW1iZXIoMSwgYWxsWm9uZXMpO1xuXHRcdHZhciB6b25lc0Zyb21EdWFsU3RhdGlvbnMgPSBmaWx0ZXJab25lc0J5TnVtYmVyKDIsIGFsbFpvbmVzKTsgLy9OQiB0aGlzIGlzIGFuIGFycmF5IHdpdGhpbiBhbiBhcnJheVxuXHRcdHZhciBmaW5hbE1heFpvbmUgPSBudWxsO1xuXHRcdHZhciBmaW5hbE1pblpvbmUgPSBudWxsO1xuXG5cdFx0aWYgKHpvbmVzRnJvbVNpbmdsZVN0YXRpb25zLmxlbmd0aCA9PT0gMCkgeyAvL2ZvciBkdWFsIHpvbmVzIHRvIGR1YWwgem9uZXMgKipBU1NVTUlORyBDQU4gT05MWSBUUkFWRUwgRlJPTSBUSEUgU0FNRSBEVUFMIFpPTkVTICgyLzMgdG8gMi8zIGFuZCBub3QgMi8zIHRvIDMvNCkqKlxuXHRcdFx0ZmluYWxNYXhab25lID0gbWluTnVtKGZsYXR0ZW4oem9uZXNGcm9tRHVhbFN0YXRpb25zKSk7XG5cdFx0XHRmaW5hbE1pblpvbmUgPSBtaW5OdW0oZmxhdHRlbih6b25lc0Zyb21EdWFsU3RhdGlvbnMpKTtcblx0XHQvLyoqTkVFRCBUTyBBREQgQSBGTEFHIEhFUkUgdG8gc2F5IHRoYXQgaXQgaXMgZHVhbCB0byBkdWFsIHpvbmUgJiB3aGF0IHpvbmVzIChzbyB0aGF0IGNhbiBtYW5pcHVsYXRlIGFuZCBwaWNrIHpvbmVzIGZyb20gY2xvc2VzdCB0byB3ZWVrbHkgY2FwcGVkIHpvbmUgcmF0aGVyIHRoYW4gbWluIHpvbmUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHpvbmVzRnJvbVNpbmdsZVN0YXRpb25zID0gZmxhdHRlbihmaWx0ZXJab25lc0J5TnVtYmVyKDEsIGFsbFpvbmVzKSk7XG5cdFx0XHRcblxuXHRcdFx0Ly9DYWxjdWxhdGVzIHRoZSBtYXggYW5kIG1pbiBab25lcyBvZiBhbGwgdGhlIHpvbmVzIHRoYXQgYXJlIGZyb20gc3RhdGlvbnMgd2l0aG91dCBhbnkgZHVhbCB6b25lcy5cblx0XHRcdHZhciBzaW5nbGVNYXggPSBtYXhOdW0oem9uZXNGcm9tU2luZ2xlU3RhdGlvbnMpO1xuXHRcdFx0dmFyIHNpbmdsZU1pbiA9IG1pbk51bSh6b25lc0Zyb21TaW5nbGVTdGF0aW9ucyk7XG5cblx0XHRcdC8vRm9yIGVhY2ggem9uZXNGcm9tRHVhbFN0YXRpb25zOiBwaWNrcyB0aGUgbW9zdCBhcHByb3ByaWF0ZSB6b25lIGFuZCBhcHBlbmRzIHRvIGR1YWxab25lcyBhcnJheSBcblx0XHRcdC8vIC0tPiBHb2luZyBmcm9tIDIvMyB0byAyLzMg4oCUPiBjaGFyZ2VzIHNhbWUgc2luZ2xlIDIsIDMgb3IgMi0zICgxLjcwKSBidXQgc2hvdWxkIHBpY2sgem9uZSBiYXNlZCBvbiB3ZWVrbHkgKGNvdWxkIGJlIDMpIG9yIGNhcCAoYWx3YXlzIHNtYWxsZXN0OiAyKVxuXHRcdFx0dmFyIGR1YWxab25lcyA9IHpvbmVzRnJvbUR1YWxTdGF0aW9ucy5tYXAoZnVuY3Rpb24oeikge1xuXHRcdFx0XHRyZXR1cm4gei5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdGlmIChnZXREaWZmZXJlbmNlKGEsIHNpbmdsZU1pbikgPCBnZXREaWZmZXJlbmNlKGIsIHNpbmdsZU1pbikpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly9BZGRzIGR1YWxab25lcyB0byBzaW5nbGVNYXggaW50byBhbiBhcnJheSBhbmQgY2FsY3VsYXRlcyB0aGUgbWF4IGFuZCBtaW4gem9uZSBvZiBib3RoXG5cdFx0XHRmaW5hbE1heFpvbmUgPSBtYXhOdW0oW3NpbmdsZU1heF0uY29uY2F0KGR1YWxab25lcykpO1xuXHRcdFx0ZmluYWxNaW5ab25lID0gbWluTnVtKFtzaW5nbGVNaW5dLmNvbmNhdChkdWFsWm9uZXMpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW2ZpbmFsTWluWm9uZSwgZmluYWxNYXhab25lXTtcblx0fSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3BhcnRpYWxzL19nZXRTaW5nbGVKb3VybmV5Wm9uZXMuanMiLCIvKipcbiAqIENhbGN1bGF0ZXMgdGhlIG95c3RlciB0b3RhbCBmYXJlIGZvciB0aGUgZGF5XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7am91cm5leX0gem9uZXMgYW5kIG9mZiBwZWFrIG9yIG9uIHBlYWtcbiAqIEBwYXJhbSB7anNvbiBkYXRhfSB1c2VzIHRoZSBzaW5nbGVGYXJlcyBqc29uIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gcmV0dXJucyB0aGUgdG90YWwgZmFyZVxuICogQGRlc2NyaXB0aW9uXG4gKi9cblxuXG4vLyBhbmQgc2luZ2xlIGZhcmUgaXMgY2FsY3VsYXRlZCB1dXNpbmcgZXh0ZW5zaW9uRmFyZSBmdW5jdGlvbiBpbnN0ZWFkXG4vLyBOZWVkIHNldCBhbiBhbGVydCBmb3Igd2hlbiByZWFjaCBhIFpvbmVzIDEtNCBvciBab25lcyAxLTYgZGFpbHkgY2FwLCBidXQgb25seSB0cmF2ZWwgYXQgb2ZmLXBlYWsgdGltZXMuXG5cbmltcG9ydCBfIGZyb20gJ2xvZGFzaC9mcCc7XG5pbXBvcnQgdHJlaXMgZnJvbSAndHJlaXMnO1xuXG5pbXBvcnQge1xuICBtaW5OdW0sXG4gIG1heE51bSxcbiAgZ2V0Q2FwLFxuICBnZXRTaW5nbGVGYXJlLFxuICBtZXQsXG59IGZyb20gJy4vLi4vdXRpbGl0eS9fdXRpbGl0eSc7XG5cbmltcG9ydCBleHRlbnNpb25GYXJlcyBmcm9tICcuL19leHRlbnNpb25GYXJlcyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3lzdGVyRGF5VG90YWwoZGF0YSA9IHt9LCBzaW5nbGVGYXJlcykge1xuICBsZXQge1xuICAgIGpvdXJuZXlzLFxuICAgIGRhaWx5Q2FwcywgLy9KU09OXG4gICAgLy8gbWluVHJhdmVsY2FyZCwgLy9pZiBuZWVkZWQgZm9yIHdlZWtseVxuICAgIC8vIG1heFRyYXZlbGNhcmQsIC8vaWYgbmVlZGVkIGZvciB3ZWVrbHlcbiAgfSA9IGRhdGE7XG5cblxuICBjb25zdCBnZXREYWlseUNhcCA9IGdldENhcChfLCBfLCBkYWlseUNhcHMpOyAvLyBXVEZcbiAgIGNvbnN0IGNhcE1ldCA9IF8uY29tcG9zZShtZXQsIGdldERhaWx5Q2FwKTsgLy9XVEZcbiAgICBcbiAgY29uc3QgdG90YWxzID0gam91cm5leXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICAvLyBpZiAobWF4VHJhdmVsY2FyZCkgeyBmb3Igd2Vla2x5XG5cbiAgICAvLyAgIGNvbnN0IHNpbmdsZUZhcmUgPSBleHRlbnNpb25GYXJlcyh7XG4gICAgLy8gICAgIHpvbmVzOiBiLnpvbmVzLFxuICAgIC8vICAgICBtaW5UcmF2ZWxjYXJkLCAvL3NpbmNlIHNhbWUgbmFtaW5nLCBzaG9ydGhhbmQgZm9yIFwibWluVHJhdmVsY2FyZFwiOiBtaW5UcmF2ZWxjYXJkO1xuICAgIC8vICAgICBtYXhUcmF2ZWxjYXJkLFxuICAgIC8vICAgICB0eXBlOiBiLnR5cGUsXG4gICAgLy8gICB9LCBzaW5nbGVGYXJlcyk7XG5cbiAgICAvLyB9IGVsc2Uge1xuICAgICAgXG4gICAgICBjb25zdCBzaW5nbGVGYXJlID0gZ2V0U2luZ2xlRmFyZShiLnpvbmVzLCBzaW5nbGVGYXJlcywgYi50eXBlKTsgLy9iLnpvbmVzID0gYW4gYXJyYXlcbiAgICAvLyB9XG5cbiAgICBsZXQgbWF4Wm9uZSA9IG1heE51bShbXS5jb25jYXQoYS5tYXhab25lLCBiLnpvbmVzKSk7XG4vLyAgICAgRk9SIFdFRUtMWVxuICAgIC8vIGlmICgobWF4VHJhdmVsY2FyZCkgJiYgKG1heFpvbmUgPD0gbWF4VHJhdmVsY2FyZCkgJiYgKG1heFpvbmUgPj0gKG1pblRyYXZlbGNhcmQgLSAxKSkpIHtcbiAgICAvLyAgIG1heFpvbmUgPSBtaW5UcmF2ZWxjYXJkIC0xOyAvLyhpZSBvbmx5IGNvbXBhcmVzIGFnYWluc3QgZGFpbHkgY2FwIG9mIG1pblNpbmdsZSB0byB6b25lRGFpbHkgLSByZW1vdmVzIG92ZXJsYXAgd2l0aCB3ZWVrbHkpXG4gICAgLy8gfVxuXG4gICAgY29uc3QgbWV0RGFpbHlDYXAgPSBjYXBNZXQobWF4Wm9uZSwgJ2FueXRpbWUnKTsgLy90cnVlIG9yIGZhbHNlXG5cbiAgICBsZXQgcGVha1RvdGFsID0gYS5wZWFrVG90YWwgKyBzaW5nbGVGYXJlO1xuICAgIGxldCBvZmZQZWFrVG90YWwgPSBhLm9mZlBlYWtUb3RhbCArIHNpbmdsZUZhcmU7XG5cbiAgICAvL2lmIE9GRiBwZWFrIHRyYXZlbCBhbmQgdGhlIE9GRiBQRUFLIGRhaWx5IGNhcCBmb3IgY3VycmVudCBtYXhpbXVtIHpvbmUgaXMgcmVhY2hlZCwgdGhlbiB0aGUgY3VtIHRvdGFsIGlzIG92ZXJyaWRlbiBieSB0aGUgcmVsZXZhbnQgbWF4aW11bSB6b25lIGRhaWx5IGNhcCBmYXJlXG4gICAgLy8gaWYgKGIudHlwZSA9PT0gJ29mZlBlYWsnICYmIG1ldERhaWx5Q2FwKG9mZlBlYWtUb3RhbCkpIHtcbiAgICAvLyAgIGRlYnVnZ2VyO1xuICAgIC8vICAgb2ZmUGVha1RvdGFsID0gZ2V0RGFpbHlDYXAobWF4Wm9uZSwgJ29mZlBlYWsnKTsgLy9hbmQgc2V0IGFuIGFsZXJ0IHRvIHNheSBvZmYgZGFpbHkgY2FwIHJlYWNoZWQ/Pz8/ISEhIChidXQgY291bGQgYmUgb3ZlcnJpZGRlbiBhZnRlcilcbiAgICAvLyB9XG5cbiAgICAvL2lmIHRoZSBkYWlseSBjYXAgZm9yIHRoZSBjdXJyZW50IG1heGltdW0gem9uZSBpcyByZWFjaGVkLCB0aGVuIHRoZSBjdW0gdG90YWwgaXMgb3ZlcnJpZGVuIGJ5IHRoZSByZWxldmFudCBtYXhpbXVtIHpvbmUgZGFpbHkgY2FwIGZhcmVcbiAgXG4gICAgaWYgKG1ldERhaWx5Q2FwKHBlYWtUb3RhbCkpIHtcbiAgICAgIHBlYWtUb3RhbCA9IGdldERhaWx5Q2FwKG1heFpvbmUsICdhbnl0aW1lJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBlYWtUb3RhbCxcbiAgICAgIG9mZlBlYWtUb3RhbCxcbiAgICAgIG1heFpvbmUsXG4gICAgfTtcbiAgfSwge1xuICAgIHBlYWtUb3RhbDogMCxcbiAgICBvZmZQZWFrVG90YWw6IDAsXG4gICAgbWF4Wm9uZTogbnVsbCxcbiAgICAvLyB0eXBlOiBudWxsLFxuICB9KTtcblxuICByZXR1cm4gbWluTnVtKFt0b3RhbHMucGVha1RvdGFsLCB0b3RhbHMub2ZmUGVha1RvdGFsXSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvcGFydGlhbHMvX295c3RlckRheVRvdGFsLmpzIiwidmFyIG1hcHBpbmcgPSByZXF1aXJlKCcuL19tYXBwaW5nJyksXG4gICAgZmFsbGJhY2tIb2xkZXIgPSByZXF1aXJlKCcuL3BsYWNlaG9sZGVyJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2UuICovXG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiwgd2l0aCBhbiBhcml0eSBvZiBgbmAsIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGVcbiAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBhcml0eSBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBcml0eShmdW5jLCBuKSB7XG4gIHJldHVybiBuID09IDJcbiAgICA/IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9XG4gICAgOiBmdW5jdGlvbihhKSB7IHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTsgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLCBpZ25vcmluZ1xuICogYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBhcml0eSBjYXAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFyeShmdW5jLCBuKSB7XG4gIHJldHVybiBuID09IDJcbiAgICA/IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGZ1bmMoYSwgYik7IH1cbiAgICA6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGZ1bmMoYSk7IH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHJlc3VsdFtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNsb25lcyBhIGdpdmVuIG9iamVjdCB1c2luZyB0aGUgYXNzaWdubWVudCBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGFzc2lnbm1lbnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjbG9uZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsb25lcihmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuYyh7fSwgb2JqZWN0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc3ByZWFkYCB3aGljaCBmbGF0dGVucyB0aGUgc3ByZWFkIGFycmF5IGludG9cbiAqIHRoZSBhcmd1bWVudHMgb2YgdGhlIGludm9rZWQgYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFNwcmVhZChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcmdzW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgIG90aGVyQXJncyA9IGFyZ3Muc2xpY2UoMCwgc3RhcnQpO1xuXG4gICAgaWYgKGFycmF5KSB7XG4gICAgICBwdXNoLmFwcGx5KG90aGVyQXJncywgYXJyYXkpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgIT0gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoLmFwcGx5KG90aGVyQXJncywgYXJncy5zbGljZShzdGFydCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIHVzZXMgYGNsb25lcmAgdG8gY2xvbmUgdGhlIGZpcnN0XG4gKiBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lciBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgYXJndW1lbnRzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW1tdXRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3cmFwSW1tdXRhYmxlKGZ1bmMsIGNsb25lcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBhcmdzWzBdID0gY2xvbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNvbnZlcnRgIHdoaWNoIGFjY2VwdHMgYSBgdXRpbGAgb2JqZWN0IG9mIG1ldGhvZHNcbiAqIHJlcXVpcmVkIHRvIHBlcmZvcm0gY29udmVyc2lvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHV0aWwgVGhlIHV0aWwgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhcD10cnVlXSBTcGVjaWZ5IGNhcHBpbmcgaXRlcmF0ZWUgYXJndW1lbnRzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jdXJyeT10cnVlXSBTcGVjaWZ5IGN1cnJ5aW5nLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5maXhlZD10cnVlXSBTcGVjaWZ5IGZpeGVkIGFyaXR5LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbW11dGFibGU9dHJ1ZV0gU3BlY2lmeSBpbW11dGFibGUgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVhcmc9dHJ1ZV0gU3BlY2lmeSByZWFycmFuZ2luZyBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgZnVuY3Rpb24gb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlQ29udmVydCh1dGlsLCBuYW1lLCBmdW5jLCBvcHRpb25zKSB7XG4gIHZhciBzZXRQbGFjZWhvbGRlcixcbiAgICAgIGlzTGliID0gdHlwZW9mIG5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGlzT2JqID0gbmFtZSA9PT0gT2JqZWN0KG5hbWUpO1xuXG4gIGlmIChpc09iaikge1xuICAgIG9wdGlvbnMgPSBmdW5jO1xuICAgIGZ1bmMgPSBuYW1lO1xuICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gIH1cbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICB2YXIgY29uZmlnID0ge1xuICAgICdjYXAnOiAnY2FwJyBpbiBvcHRpb25zID8gb3B0aW9ucy5jYXAgOiB0cnVlLFxuICAgICdjdXJyeSc6ICdjdXJyeScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY3VycnkgOiB0cnVlLFxuICAgICdmaXhlZCc6ICdmaXhlZCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZml4ZWQgOiB0cnVlLFxuICAgICdpbW11dGFibGUnOiAnaW1tdXRhYmxlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5pbW11dGFibGUgOiB0cnVlLFxuICAgICdyZWFyZyc6ICdyZWFyZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMucmVhcmcgOiB0cnVlXG4gIH07XG5cbiAgdmFyIGZvcmNlQ3VycnkgPSAoJ2N1cnJ5JyBpbiBvcHRpb25zKSAmJiBvcHRpb25zLmN1cnJ5LFxuICAgICAgZm9yY2VGaXhlZCA9ICgnZml4ZWQnIGluIG9wdGlvbnMpICYmIG9wdGlvbnMuZml4ZWQsXG4gICAgICBmb3JjZVJlYXJnID0gKCdyZWFyZycgaW4gb3B0aW9ucykgJiYgb3B0aW9ucy5yZWFyZyxcbiAgICAgIHBsYWNlaG9sZGVyID0gaXNMaWIgPyBmdW5jIDogZmFsbGJhY2tIb2xkZXIsXG4gICAgICBwcmlzdGluZSA9IGlzTGliID8gZnVuYy5ydW5JbkNvbnRleHQoKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgaGVscGVycyA9IGlzTGliID8gZnVuYyA6IHtcbiAgICAnYXJ5JzogdXRpbC5hcnksXG4gICAgJ2Fzc2lnbic6IHV0aWwuYXNzaWduLFxuICAgICdjbG9uZSc6IHV0aWwuY2xvbmUsXG4gICAgJ2N1cnJ5JzogdXRpbC5jdXJyeSxcbiAgICAnZm9yRWFjaCc6IHV0aWwuZm9yRWFjaCxcbiAgICAnaXNBcnJheSc6IHV0aWwuaXNBcnJheSxcbiAgICAnaXNGdW5jdGlvbic6IHV0aWwuaXNGdW5jdGlvbixcbiAgICAnaXRlcmF0ZWUnOiB1dGlsLml0ZXJhdGVlLFxuICAgICdrZXlzJzogdXRpbC5rZXlzLFxuICAgICdyZWFyZyc6IHV0aWwucmVhcmcsXG4gICAgJ3RvSW50ZWdlcic6IHV0aWwudG9JbnRlZ2VyLFxuICAgICd0b1BhdGgnOiB1dGlsLnRvUGF0aFxuICB9O1xuXG4gIHZhciBhcnkgPSBoZWxwZXJzLmFyeSxcbiAgICAgIGFzc2lnbiA9IGhlbHBlcnMuYXNzaWduLFxuICAgICAgY2xvbmUgPSBoZWxwZXJzLmNsb25lLFxuICAgICAgY3VycnkgPSBoZWxwZXJzLmN1cnJ5LFxuICAgICAgZWFjaCA9IGhlbHBlcnMuZm9yRWFjaCxcbiAgICAgIGlzQXJyYXkgPSBoZWxwZXJzLmlzQXJyYXksXG4gICAgICBpc0Z1bmN0aW9uID0gaGVscGVycy5pc0Z1bmN0aW9uLFxuICAgICAga2V5cyA9IGhlbHBlcnMua2V5cyxcbiAgICAgIHJlYXJnID0gaGVscGVycy5yZWFyZyxcbiAgICAgIHRvSW50ZWdlciA9IGhlbHBlcnMudG9JbnRlZ2VyLFxuICAgICAgdG9QYXRoID0gaGVscGVycy50b1BhdGg7XG5cbiAgdmFyIGFyeU1ldGhvZEtleXMgPSBrZXlzKG1hcHBpbmcuYXJ5TWV0aG9kKTtcblxuICB2YXIgd3JhcHBlcnMgPSB7XG4gICAgJ2Nhc3RBcnJheSc6IGZ1bmN0aW9uKGNhc3RBcnJheSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gY2FzdEFycmF5KGNsb25lQXJyYXkodmFsdWUpKVxuICAgICAgICAgIDogY2FzdEFycmF5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAnaXRlcmF0ZWUnOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyaXR5ID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgcmVzdWx0ID0gaXRlcmF0ZWUoZnVuYywgYXJpdHkpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoY29uZmlnLmNhcCAmJiB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhcml0eSA9IGFyaXR5ID4gMiA/IChhcml0eSAtIDIpIDogMTtcbiAgICAgICAgICByZXR1cm4gKGxlbmd0aCAmJiBsZW5ndGggPD0gYXJpdHkpID8gcmVzdWx0IDogYmFzZUFyeShyZXN1bHQsIGFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9LFxuICAgICdtaXhpbic6IGZ1bmN0aW9uKG1peGluKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciBmdW5jID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgcmV0dXJuIG1peGluKGZ1bmMsIE9iamVjdChzb3VyY2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgICAgZWFjaChrZXlzKHNvdXJjZSksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChba2V5LCBmdW5jLnByb3RvdHlwZVtrZXldXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtaXhpbihmdW5jLCBPYmplY3Qoc291cmNlKSk7XG5cbiAgICAgICAgZWFjaChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhaXJbMV07XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICBmdW5jLnByb3RvdHlwZVtwYWlyWzBdXSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZnVuYy5wcm90b3R5cGVbcGFpclswXV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9O1xuICAgIH0sXG4gICAgJ250aEFyZyc6IGZ1bmN0aW9uKG50aEFyZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGFyaXR5ID0gbiA8IDAgPyAxIDogKHRvSW50ZWdlcihuKSArIDEpO1xuICAgICAgICByZXR1cm4gY3VycnkobnRoQXJnKG4pLCBhcml0eSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgJ3JlYXJnJzogZnVuY3Rpb24ocmVhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICAgIHZhciBhcml0eSA9IGluZGV4ZXMgPyBpbmRleGVzLmxlbmd0aCA6IDA7XG4gICAgICAgIHJldHVybiBjdXJyeShyZWFyZyhmdW5jLCBpbmRleGVzKSwgYXJpdHkpO1xuICAgICAgfTtcbiAgICB9LFxuICAgICdydW5JbkNvbnRleHQnOiBmdW5jdGlvbihydW5JbkNvbnRleHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29udmVydCh1dGlsLCBydW5JbkNvbnRleHQoY29udGV4dCksIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENhc3RzIGBmdW5jYCB0byBhIGZ1bmN0aW9uIHdpdGggYW4gYXJpdHkgY2FwcGVkIGl0ZXJhdGVlIGlmIG5lZWRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FzdCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhc3RDYXAobmFtZSwgZnVuYykge1xuICAgIGlmIChjb25maWcuY2FwKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IG1hcHBpbmcuaXRlcmF0ZWVSZWFyZ1tuYW1lXTtcbiAgICAgIGlmIChpbmRleGVzKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZVJlYXJnKGZ1bmMsIGluZGV4ZXMpO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSAhaXNMaWIgJiYgbWFwcGluZy5pdGVyYXRlZUFyeVtuYW1lXTtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZUFyeShmdW5jLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cblxuICAvKipcbiAgICogQ2FzdHMgYGZ1bmNgIHRvIGEgY3VycmllZCBmdW5jdGlvbiBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhc3QgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYXN0Q3VycnkobmFtZSwgZnVuYywgbikge1xuICAgIHJldHVybiAoZm9yY2VDdXJyeSB8fCAoY29uZmlnLmN1cnJ5ICYmIG4gPiAxKSlcbiAgICAgID8gY3VycnkoZnVuYywgbilcbiAgICAgIDogZnVuYztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXN0cyBgZnVuY2AgdG8gYSBmaXhlZCBhcml0eSBmdW5jdGlvbiBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgYXJpdHkgY2FwLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhc3QgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjYXN0Rml4ZWQobmFtZSwgZnVuYywgbikge1xuICAgIGlmIChjb25maWcuZml4ZWQgJiYgKGZvcmNlRml4ZWQgfHwgIW1hcHBpbmcuc2tpcEZpeGVkW25hbWVdKSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXBwaW5nLm1ldGhvZFNwcmVhZFtuYW1lXSxcbiAgICAgICAgICBzdGFydCA9IGRhdGEgJiYgZGF0YS5zdGFydDtcblxuICAgICAgcmV0dXJuIHN0YXJ0ICA9PT0gdW5kZWZpbmVkID8gYXJ5KGZ1bmMsIG4pIDogZmxhdFNwcmVhZChmdW5jLCBzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIENhc3RzIGBmdW5jYCB0byBhbiByZWFyZ2VkIGZ1bmN0aW9uIGlmIG5lZWRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FzdCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhc3RSZWFyZyhuYW1lLCBmdW5jLCBuKSB7XG4gICAgcmV0dXJuIChjb25maWcucmVhcmcgJiYgbiA+IDEgJiYgKGZvcmNlUmVhcmcgfHwgIW1hcHBpbmcuc2tpcFJlYXJnW25hbWVdKSlcbiAgICAgID8gcmVhcmcoZnVuYywgbWFwcGluZy5tZXRob2RSZWFyZ1tuYW1lXSB8fCBtYXBwaW5nLmFyeVJlYXJnW25dKVxuICAgICAgOiBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgb2JqZWN0YCBieSBgcGF0aGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2xvbmUgYnkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBjbG9uZUJ5UGF0aChvYmplY3QsIHBhdGgpIHtcbiAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICByZXN1bHQgPSBjbG9uZShPYmplY3Qob2JqZWN0KSksXG4gICAgICAgIG5lc3RlZCA9IHJlc3VsdDtcblxuICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgICAgdmFsdWUgPSBuZXN0ZWRba2V5XTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbmVzdGVkW3BhdGhbaW5kZXhdXSA9IGNsb25lKGluZGV4ID09IGxhc3RJbmRleCA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKSk7XG4gICAgICB9XG4gICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbG9kYXNoYCB0byBhbiBpbW11dGFibGUgYXV0by1jdXJyaWVkIGl0ZXJhdGVlLWZpcnN0IGRhdGEtbGFzdFxuICAgKiB2ZXJzaW9uIHdpdGggY29udmVyc2lvbiBgb3B0aW9uc2AgYXBwbGllZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuIFNlZSBgYmFzZUNvbnZlcnRgIGZvciBtb3JlIGRldGFpbHMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29udmVydGVkIGBsb2Rhc2hgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29udmVydExpYihvcHRpb25zKSB7XG4gICAgcmV0dXJuIF8ucnVuSW5Db250ZXh0LmNvbnZlcnQob3B0aW9ucykodW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb252ZXJ0ZXIgZnVuY3Rpb24gZm9yIGBmdW5jYCBvZiBgbmFtZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb252ZXJ0ZXIgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDb252ZXJ0ZXIobmFtZSwgZnVuYykge1xuICAgIHZhciByZWFsTmFtZSA9IG1hcHBpbmcuYWxpYXNUb1JlYWxbbmFtZV0gfHwgbmFtZSxcbiAgICAgICAgbWV0aG9kTmFtZSA9IG1hcHBpbmcucmVtYXBbcmVhbE5hbWVdIHx8IHJlYWxOYW1lLFxuICAgICAgICBvbGRPcHRpb25zID0gb3B0aW9ucztcblxuICAgIHJldHVybiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbmV3VXRpbCA9IGlzTGliID8gcHJpc3RpbmUgOiBoZWxwZXJzLFxuICAgICAgICAgIG5ld0Z1bmMgPSBpc0xpYiA/IHByaXN0aW5lW21ldGhvZE5hbWVdIDogZnVuYyxcbiAgICAgICAgICBuZXdPcHRpb25zID0gYXNzaWduKGFzc2lnbih7fSwgb2xkT3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gYmFzZUNvbnZlcnQobmV3VXRpbCwgcmVhbE5hbWUsIG5ld0Z1bmMsIG5ld09wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdHMgaXRlcmF0ZWUsIHdpdGggdXAgdG8gYG5gXG4gICAqIGFyZ3VtZW50cywgaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgaXRlcmF0ZWUgYXJndW1lbnRzIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGFyaXR5IGNhcC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRlZUFyeShmdW5jLCBuKSB7XG4gICAgcmV0dXJuIG92ZXJBcmcoZnVuYywgZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBiYXNlQXJ5KGZ1bmMsIG4pIDogZnVuYztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0cyBpdGVyYXRlZSB3aXRoIGFyZ3VtZW50c1xuICAgKiBhcnJhbmdlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0XG4gICAqIHRoZSBmaXJzdCBpbmRleCBpcyBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdFxuICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGl0ZXJhdGVlIGFyZ3VtZW50cyBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0ZWVSZWFyZyhmdW5jLCBpbmRleGVzKSB7XG4gICAgcmV0dXJuIG92ZXJBcmcoZnVuYywgZnVuY3Rpb24oZnVuYykge1xuICAgICAgdmFyIG4gPSBpbmRleGVzLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlQXJpdHkocmVhcmcoYmFzZUFyeShmdW5jLCBuKSwgaW5kZXhlcyksIG4pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGZpcnN0IGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBhcmdzW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGNvbmZpZy5yZWFyZyA/IDAgOiAobGVuZ3RoIC0gMSk7XG4gICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybShhcmdzW2luZGV4XSk7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBhcHBseXMgdGhlIGNvbnZlcnNpb25zXG4gICAqIHJ1bGVzIGJ5IGBuYW1lYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29udmVydGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcChuYW1lLCBmdW5jKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgcmVhbE5hbWUgPSBtYXBwaW5nLmFsaWFzVG9SZWFsW25hbWVdIHx8IG5hbWUsXG4gICAgICAgIHdyYXBwZWQgPSBmdW5jLFxuICAgICAgICB3cmFwcGVyID0gd3JhcHBlcnNbcmVhbE5hbWVdO1xuXG4gICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgIHdyYXBwZWQgPSB3cmFwcGVyKGZ1bmMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb25maWcuaW1tdXRhYmxlKSB7XG4gICAgICBpZiAobWFwcGluZy5tdXRhdGUuYXJyYXlbcmVhbE5hbWVdKSB7XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwSW1tdXRhYmxlKGZ1bmMsIGNsb25lQXJyYXkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobWFwcGluZy5tdXRhdGUub2JqZWN0W3JlYWxOYW1lXSkge1xuICAgICAgICB3cmFwcGVkID0gd3JhcEltbXV0YWJsZShmdW5jLCBjcmVhdGVDbG9uZXIoZnVuYykpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobWFwcGluZy5tdXRhdGUuc2V0W3JlYWxOYW1lXSkge1xuICAgICAgICB3cmFwcGVkID0gd3JhcEltbXV0YWJsZShmdW5jLCBjbG9uZUJ5UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVhY2goYXJ5TWV0aG9kS2V5cywgZnVuY3Rpb24oYXJ5S2V5KSB7XG4gICAgICBlYWNoKG1hcHBpbmcuYXJ5TWV0aG9kW2FyeUtleV0sIGZ1bmN0aW9uKG90aGVyTmFtZSkge1xuICAgICAgICBpZiAocmVhbE5hbWUgPT0gb3RoZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXBwaW5nLm1ldGhvZFNwcmVhZFtyZWFsTmFtZV0sXG4gICAgICAgICAgICAgIGFmdGVyUmVhcmcgPSBkYXRhICYmIGRhdGEuYWZ0ZXJSZWFyZztcblxuICAgICAgICAgIHJlc3VsdCA9IGFmdGVyUmVhcmdcbiAgICAgICAgICAgID8gY2FzdEZpeGVkKHJlYWxOYW1lLCBjYXN0UmVhcmcocmVhbE5hbWUsIHdyYXBwZWQsIGFyeUtleSksIGFyeUtleSlcbiAgICAgICAgICAgIDogY2FzdFJlYXJnKHJlYWxOYW1lLCBjYXN0Rml4ZWQocmVhbE5hbWUsIHdyYXBwZWQsIGFyeUtleSksIGFyeUtleSk7XG5cbiAgICAgICAgICByZXN1bHQgPSBjYXN0Q2FwKHJlYWxOYW1lLCByZXN1bHQpO1xuICAgICAgICAgIHJlc3VsdCA9IGNhc3RDdXJyeShyZWFsTmFtZSwgcmVzdWx0LCBhcnlLZXkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9KTtcblxuICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gd3JhcHBlZCk7XG4gICAgaWYgKHJlc3VsdCA9PSBmdW5jKSB7XG4gICAgICByZXN1bHQgPSBmb3JjZUN1cnJ5ID8gY3VycnkocmVzdWx0LCAxKSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmVzdWx0LmNvbnZlcnQgPSBjcmVhdGVDb252ZXJ0ZXIocmVhbE5hbWUsIGZ1bmMpO1xuICAgIGlmIChtYXBwaW5nLnBsYWNlaG9sZGVyW3JlYWxOYW1lXSkge1xuICAgICAgc2V0UGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gZnVuYy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgaWYgKCFpc09iaikge1xuICAgIHJldHVybiB3cmFwKG5hbWUsIGZ1bmMpO1xuICB9XG4gIHZhciBfID0gZnVuYztcblxuICAvLyBDb252ZXJ0IG1ldGhvZHMgYnkgYXJ5IGNhcC5cbiAgdmFyIHBhaXJzID0gW107XG4gIGVhY2goYXJ5TWV0aG9kS2V5cywgZnVuY3Rpb24oYXJ5S2V5KSB7XG4gICAgZWFjaChtYXBwaW5nLmFyeU1ldGhvZFthcnlLZXldLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBmdW5jID0gX1ttYXBwaW5nLnJlbWFwW2tleV0gfHwga2V5XTtcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHBhaXJzLnB1c2goW2tleSwgd3JhcChrZXksIGZ1bmMpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbnZlcnQgcmVtYWluaW5nIG1ldGhvZHMuXG4gIGVhY2goa2V5cyhfKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZ1bmMgPSBfW2tleV07XG4gICAgaWYgKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHBhaXJzW2xlbmd0aF1bMF0gPT0ga2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jLmNvbnZlcnQgPSBjcmVhdGVDb252ZXJ0ZXIoa2V5LCBmdW5jKTtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgZnVuY10pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQXNzaWduIHRvIGBfYCBsZWF2aW5nIGBfLnByb3RvdHlwZWAgdW5jaGFuZ2VkIHRvIGFsbG93IGNoYWluaW5nLlxuICBlYWNoKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgX1twYWlyWzBdXSA9IHBhaXJbMV07XG4gIH0pO1xuXG4gIF8uY29udmVydCA9IGNvbnZlcnRMaWI7XG4gIGlmIChzZXRQbGFjZWhvbGRlcikge1xuICAgIF8ucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgfVxuICAvLyBBc3NpZ24gYWxpYXNlcy5cbiAgZWFjaChrZXlzKF8pLCBmdW5jdGlvbihrZXkpIHtcbiAgICBlYWNoKG1hcHBpbmcucmVhbFRvQWxpYXNba2V5XSB8fCBbXSwgZnVuY3Rpb24oYWxpYXMpIHtcbiAgICAgIF9bYWxpYXNdID0gX1trZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29udmVydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2ZwL19iYXNlQ29udmVydC5qcyIsIi8qKiBVc2VkIHRvIG1hcCBhbGlhc2VzIHRvIHRoZWlyIHJlYWwgbmFtZXMuICovXG5leHBvcnRzLmFsaWFzVG9SZWFsID0ge1xuXG4gIC8vIExvZGFzaCBhbGlhc2VzLlxuICAnZWFjaCc6ICdmb3JFYWNoJyxcbiAgJ2VhY2hSaWdodCc6ICdmb3JFYWNoUmlnaHQnLFxuICAnZW50cmllcyc6ICd0b1BhaXJzJyxcbiAgJ2VudHJpZXNJbic6ICd0b1BhaXJzSW4nLFxuICAnZXh0ZW5kJzogJ2Fzc2lnbkluJyxcbiAgJ2V4dGVuZEFsbCc6ICdhc3NpZ25JbkFsbCcsXG4gICdleHRlbmRBbGxXaXRoJzogJ2Fzc2lnbkluQWxsV2l0aCcsXG4gICdleHRlbmRXaXRoJzogJ2Fzc2lnbkluV2l0aCcsXG4gICdmaXJzdCc6ICdoZWFkJyxcblxuICAvLyBNZXRob2RzIHRoYXQgYXJlIGN1cnJpZWQgdmFyaWFudHMgb2Ygb3RoZXJzLlxuICAnY29uZm9ybXMnOiAnY29uZm9ybXNUbycsXG4gICdtYXRjaGVzJzogJ2lzTWF0Y2gnLFxuICAncHJvcGVydHknOiAnZ2V0JyxcblxuICAvLyBSYW1kYSBhbGlhc2VzLlxuICAnX18nOiAncGxhY2Vob2xkZXInLFxuICAnRic6ICdzdHViRmFsc2UnLFxuICAnVCc6ICdzdHViVHJ1ZScsXG4gICdhbGwnOiAnZXZlcnknLFxuICAnYWxsUGFzcyc6ICdvdmVyRXZlcnknLFxuICAnYWx3YXlzJzogJ2NvbnN0YW50JyxcbiAgJ2FueSc6ICdzb21lJyxcbiAgJ2FueVBhc3MnOiAnb3ZlclNvbWUnLFxuICAnYXBwbHknOiAnc3ByZWFkJyxcbiAgJ2Fzc29jJzogJ3NldCcsXG4gICdhc3NvY1BhdGgnOiAnc2V0JyxcbiAgJ2NvbXBsZW1lbnQnOiAnbmVnYXRlJyxcbiAgJ2NvbXBvc2UnOiAnZmxvd1JpZ2h0JyxcbiAgJ2NvbnRhaW5zJzogJ2luY2x1ZGVzJyxcbiAgJ2Rpc3NvYyc6ICd1bnNldCcsXG4gICdkaXNzb2NQYXRoJzogJ3Vuc2V0JyxcbiAgJ2Ryb3BMYXN0JzogJ2Ryb3BSaWdodCcsXG4gICdkcm9wTGFzdFdoaWxlJzogJ2Ryb3BSaWdodFdoaWxlJyxcbiAgJ2VxdWFscyc6ICdpc0VxdWFsJyxcbiAgJ2lkZW50aWNhbCc6ICdlcScsXG4gICdpbmRleEJ5JzogJ2tleUJ5JyxcbiAgJ2luaXQnOiAnaW5pdGlhbCcsXG4gICdpbnZlcnRPYmonOiAnaW52ZXJ0JyxcbiAgJ2p1eHQnOiAnb3ZlcicsXG4gICdvbWl0QWxsJzogJ29taXQnLFxuICAnbkFyeSc6ICdhcnknLFxuICAncGF0aCc6ICdnZXQnLFxuICAncGF0aEVxJzogJ21hdGNoZXNQcm9wZXJ0eScsXG4gICdwYXRoT3InOiAnZ2V0T3InLFxuICAncGF0aHMnOiAnYXQnLFxuICAncGlja0FsbCc6ICdwaWNrJyxcbiAgJ3BpcGUnOiAnZmxvdycsXG4gICdwbHVjayc6ICdtYXAnLFxuICAncHJvcCc6ICdnZXQnLFxuICAncHJvcEVxJzogJ21hdGNoZXNQcm9wZXJ0eScsXG4gICdwcm9wT3InOiAnZ2V0T3InLFxuICAncHJvcHMnOiAnYXQnLFxuICAnc3ltbWV0cmljRGlmZmVyZW5jZSc6ICd4b3InLFxuICAnc3ltbWV0cmljRGlmZmVyZW5jZUJ5JzogJ3hvckJ5JyxcbiAgJ3N5bW1ldHJpY0RpZmZlcmVuY2VXaXRoJzogJ3hvcldpdGgnLFxuICAndGFrZUxhc3QnOiAndGFrZVJpZ2h0JyxcbiAgJ3Rha2VMYXN0V2hpbGUnOiAndGFrZVJpZ2h0V2hpbGUnLFxuICAndW5hcHBseSc6ICdyZXN0JyxcbiAgJ3VubmVzdCc6ICdmbGF0dGVuJyxcbiAgJ3VzZVdpdGgnOiAnb3ZlckFyZ3MnLFxuICAnd2hlcmUnOiAnY29uZm9ybXNUbycsXG4gICd3aGVyZUVxJzogJ2lzTWF0Y2gnLFxuICAnemlwT2JqJzogJ3ppcE9iamVjdCdcbn07XG5cbi8qKiBVc2VkIHRvIG1hcCBhcnkgdG8gbWV0aG9kIG5hbWVzLiAqL1xuZXhwb3J0cy5hcnlNZXRob2QgPSB7XG4gICcxJzogW1xuICAgICdhc3NpZ25BbGwnLCAnYXNzaWduSW5BbGwnLCAnYXR0ZW1wdCcsICdjYXN0QXJyYXknLCAnY2VpbCcsICdjcmVhdGUnLFxuICAgICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ2RlZmF1bHRzQWxsJywgJ2RlZmF1bHRzRGVlcEFsbCcsICdmbG9vcicsICdmbG93JyxcbiAgICAnZmxvd1JpZ2h0JywgJ2Zyb21QYWlycycsICdpbnZlcnQnLCAnaXRlcmF0ZWUnLCAnbWVtb2l6ZScsICdtZXRob2QnLCAnbWVyZ2VBbGwnLFxuICAgICdtZXRob2RPZicsICdtaXhpbicsICdudGhBcmcnLCAnb3ZlcicsICdvdmVyRXZlcnknLCAnb3ZlclNvbWUnLCdyZXN0JywgJ3JldmVyc2UnLFxuICAgICdyb3VuZCcsICdydW5JbkNvbnRleHQnLCAnc3ByZWFkJywgJ3RlbXBsYXRlJywgJ3RyaW0nLCAndHJpbUVuZCcsICd0cmltU3RhcnQnLFxuICAgICd1bmlxdWVJZCcsICd3b3JkcycsICd6aXBBbGwnXG4gIF0sXG4gICcyJzogW1xuICAgICdhZGQnLCAnYWZ0ZXInLCAnYXJ5JywgJ2Fzc2lnbicsICdhc3NpZ25BbGxXaXRoJywgJ2Fzc2lnbkluJywgJ2Fzc2lnbkluQWxsV2l0aCcsXG4gICAgJ2F0JywgJ2JlZm9yZScsICdiaW5kJywgJ2JpbmRBbGwnLCAnYmluZEtleScsICdjaHVuaycsICdjbG9uZURlZXBXaXRoJyxcbiAgICAnY2xvbmVXaXRoJywgJ2NvbmNhdCcsICdjb25mb3Jtc1RvJywgJ2NvdW50QnknLCAnY3VycnlOJywgJ2N1cnJ5UmlnaHROJyxcbiAgICAnZGVib3VuY2UnLCAnZGVmYXVsdHMnLCAnZGVmYXVsdHNEZWVwJywgJ2RlZmF1bHRUbycsICdkZWxheScsICdkaWZmZXJlbmNlJyxcbiAgICAnZGl2aWRlJywgJ2Ryb3AnLCAnZHJvcFJpZ2h0JywgJ2Ryb3BSaWdodFdoaWxlJywgJ2Ryb3BXaGlsZScsICdlbmRzV2l0aCcsICdlcScsXG4gICAgJ2V2ZXJ5JywgJ2ZpbHRlcicsICdmaW5kJywgJ2ZpbmRJbmRleCcsICdmaW5kS2V5JywgJ2ZpbmRMYXN0JywgJ2ZpbmRMYXN0SW5kZXgnLFxuICAgICdmaW5kTGFzdEtleScsICdmbGF0TWFwJywgJ2ZsYXRNYXBEZWVwJywgJ2ZsYXR0ZW5EZXB0aCcsICdmb3JFYWNoJyxcbiAgICAnZm9yRWFjaFJpZ2h0JywgJ2ZvckluJywgJ2ZvckluUmlnaHQnLCAnZm9yT3duJywgJ2Zvck93blJpZ2h0JywgJ2dldCcsXG4gICAgJ2dyb3VwQnknLCAnZ3QnLCAnZ3RlJywgJ2hhcycsICdoYXNJbicsICdpbmNsdWRlcycsICdpbmRleE9mJywgJ2ludGVyc2VjdGlvbicsXG4gICAgJ2ludmVydEJ5JywgJ2ludm9rZScsICdpbnZva2VNYXAnLCAnaXNFcXVhbCcsICdpc01hdGNoJywgJ2pvaW4nLCAna2V5QnknLFxuICAgICdsYXN0SW5kZXhPZicsICdsdCcsICdsdGUnLCAnbWFwJywgJ21hcEtleXMnLCAnbWFwVmFsdWVzJywgJ21hdGNoZXNQcm9wZXJ0eScsXG4gICAgJ21heEJ5JywgJ21lYW5CeScsICdtZXJnZScsICdtZXJnZUFsbFdpdGgnLCAnbWluQnknLCAnbXVsdGlwbHknLCAnbnRoJywgJ29taXQnLFxuICAgICdvbWl0QnknLCAnb3ZlckFyZ3MnLCAncGFkJywgJ3BhZEVuZCcsICdwYWRTdGFydCcsICdwYXJzZUludCcsICdwYXJ0aWFsJyxcbiAgICAncGFydGlhbFJpZ2h0JywgJ3BhcnRpdGlvbicsICdwaWNrJywgJ3BpY2tCeScsICdwcm9wZXJ0eU9mJywgJ3B1bGwnLCAncHVsbEFsbCcsXG4gICAgJ3B1bGxBdCcsICdyYW5kb20nLCAncmFuZ2UnLCAncmFuZ2VSaWdodCcsICdyZWFyZycsICdyZWplY3QnLCAncmVtb3ZlJyxcbiAgICAncmVwZWF0JywgJ3Jlc3RGcm9tJywgJ3Jlc3VsdCcsICdzYW1wbGVTaXplJywgJ3NvbWUnLCAnc29ydEJ5JywgJ3NvcnRlZEluZGV4JyxcbiAgICAnc29ydGVkSW5kZXhPZicsICdzb3J0ZWRMYXN0SW5kZXgnLCAnc29ydGVkTGFzdEluZGV4T2YnLCAnc29ydGVkVW5pcUJ5JyxcbiAgICAnc3BsaXQnLCAnc3ByZWFkRnJvbScsICdzdGFydHNXaXRoJywgJ3N1YnRyYWN0JywgJ3N1bUJ5JywgJ3Rha2UnLCAndGFrZVJpZ2h0JyxcbiAgICAndGFrZVJpZ2h0V2hpbGUnLCAndGFrZVdoaWxlJywgJ3RhcCcsICd0aHJvdHRsZScsICd0aHJ1JywgJ3RpbWVzJywgJ3RyaW1DaGFycycsXG4gICAgJ3RyaW1DaGFyc0VuZCcsICd0cmltQ2hhcnNTdGFydCcsICd0cnVuY2F0ZScsICd1bmlvbicsICd1bmlxQnknLCAndW5pcVdpdGgnLFxuICAgICd1bnNldCcsICd1bnppcFdpdGgnLCAnd2l0aG91dCcsICd3cmFwJywgJ3hvcicsICd6aXAnLCAnemlwT2JqZWN0JyxcbiAgICAnemlwT2JqZWN0RGVlcCdcbiAgXSxcbiAgJzMnOiBbXG4gICAgJ2Fzc2lnbkluV2l0aCcsICdhc3NpZ25XaXRoJywgJ2NsYW1wJywgJ2RpZmZlcmVuY2VCeScsICdkaWZmZXJlbmNlV2l0aCcsXG4gICAgJ2ZpbmRGcm9tJywgJ2ZpbmRJbmRleEZyb20nLCAnZmluZExhc3RGcm9tJywgJ2ZpbmRMYXN0SW5kZXhGcm9tJywgJ2dldE9yJyxcbiAgICAnaW5jbHVkZXNGcm9tJywgJ2luZGV4T2ZGcm9tJywgJ2luUmFuZ2UnLCAnaW50ZXJzZWN0aW9uQnknLCAnaW50ZXJzZWN0aW9uV2l0aCcsXG4gICAgJ2ludm9rZUFyZ3MnLCAnaW52b2tlQXJnc01hcCcsICdpc0VxdWFsV2l0aCcsICdpc01hdGNoV2l0aCcsICdmbGF0TWFwRGVwdGgnLFxuICAgICdsYXN0SW5kZXhPZkZyb20nLCAnbWVyZ2VXaXRoJywgJ29yZGVyQnknLCAncGFkQ2hhcnMnLCAncGFkQ2hhcnNFbmQnLFxuICAgICdwYWRDaGFyc1N0YXJ0JywgJ3B1bGxBbGxCeScsICdwdWxsQWxsV2l0aCcsICdyYW5nZVN0ZXAnLCAncmFuZ2VTdGVwUmlnaHQnLFxuICAgICdyZWR1Y2UnLCAncmVkdWNlUmlnaHQnLCAncmVwbGFjZScsICdzZXQnLCAnc2xpY2UnLCAnc29ydGVkSW5kZXhCeScsXG4gICAgJ3NvcnRlZExhc3RJbmRleEJ5JywgJ3RyYW5zZm9ybScsICd1bmlvbkJ5JywgJ3VuaW9uV2l0aCcsICd1cGRhdGUnLCAneG9yQnknLFxuICAgICd4b3JXaXRoJywgJ3ppcFdpdGgnXG4gIF0sXG4gICc0JzogW1xuICAgICdmaWxsJywgJ3NldFdpdGgnLCAndXBkYXRlV2l0aCdcbiAgXVxufTtcblxuLyoqIFVzZWQgdG8gbWFwIGFyeSB0byByZWFyZyBjb25maWdzLiAqL1xuZXhwb3J0cy5hcnlSZWFyZyA9IHtcbiAgJzInOiBbMSwgMF0sXG4gICczJzogWzIsIDAsIDFdLFxuICAnNCc6IFszLCAyLCAwLCAxXVxufTtcblxuLyoqIFVzZWQgdG8gbWFwIG1ldGhvZCBuYW1lcyB0byB0aGVpciBpdGVyYXRlZSBhcnkuICovXG5leHBvcnRzLml0ZXJhdGVlQXJ5ID0ge1xuICAnZHJvcFJpZ2h0V2hpbGUnOiAxLFxuICAnZHJvcFdoaWxlJzogMSxcbiAgJ2V2ZXJ5JzogMSxcbiAgJ2ZpbHRlcic6IDEsXG4gICdmaW5kJzogMSxcbiAgJ2ZpbmRGcm9tJzogMSxcbiAgJ2ZpbmRJbmRleCc6IDEsXG4gICdmaW5kSW5kZXhGcm9tJzogMSxcbiAgJ2ZpbmRLZXknOiAxLFxuICAnZmluZExhc3QnOiAxLFxuICAnZmluZExhc3RGcm9tJzogMSxcbiAgJ2ZpbmRMYXN0SW5kZXgnOiAxLFxuICAnZmluZExhc3RJbmRleEZyb20nOiAxLFxuICAnZmluZExhc3RLZXknOiAxLFxuICAnZmxhdE1hcCc6IDEsXG4gICdmbGF0TWFwRGVlcCc6IDEsXG4gICdmbGF0TWFwRGVwdGgnOiAxLFxuICAnZm9yRWFjaCc6IDEsXG4gICdmb3JFYWNoUmlnaHQnOiAxLFxuICAnZm9ySW4nOiAxLFxuICAnZm9ySW5SaWdodCc6IDEsXG4gICdmb3JPd24nOiAxLFxuICAnZm9yT3duUmlnaHQnOiAxLFxuICAnbWFwJzogMSxcbiAgJ21hcEtleXMnOiAxLFxuICAnbWFwVmFsdWVzJzogMSxcbiAgJ3BhcnRpdGlvbic6IDEsXG4gICdyZWR1Y2UnOiAyLFxuICAncmVkdWNlUmlnaHQnOiAyLFxuICAncmVqZWN0JzogMSxcbiAgJ3JlbW92ZSc6IDEsXG4gICdzb21lJzogMSxcbiAgJ3Rha2VSaWdodFdoaWxlJzogMSxcbiAgJ3Rha2VXaGlsZSc6IDEsXG4gICd0aW1lcyc6IDEsXG4gICd0cmFuc2Zvcm0nOiAyXG59O1xuXG4vKiogVXNlZCB0byBtYXAgbWV0aG9kIG5hbWVzIHRvIGl0ZXJhdGVlIHJlYXJnIGNvbmZpZ3MuICovXG5leHBvcnRzLml0ZXJhdGVlUmVhcmcgPSB7XG4gICdtYXBLZXlzJzogWzFdLFxuICAncmVkdWNlUmlnaHQnOiBbMSwgMF1cbn07XG5cbi8qKiBVc2VkIHRvIG1hcCBtZXRob2QgbmFtZXMgdG8gcmVhcmcgY29uZmlncy4gKi9cbmV4cG9ydHMubWV0aG9kUmVhcmcgPSB7XG4gICdhc3NpZ25JbkFsbFdpdGgnOiBbMSwgMF0sXG4gICdhc3NpZ25JbldpdGgnOiBbMSwgMiwgMF0sXG4gICdhc3NpZ25BbGxXaXRoJzogWzEsIDBdLFxuICAnYXNzaWduV2l0aCc6IFsxLCAyLCAwXSxcbiAgJ2RpZmZlcmVuY2VCeSc6IFsxLCAyLCAwXSxcbiAgJ2RpZmZlcmVuY2VXaXRoJzogWzEsIDIsIDBdLFxuICAnZ2V0T3InOiBbMiwgMSwgMF0sXG4gICdpbnRlcnNlY3Rpb25CeSc6IFsxLCAyLCAwXSxcbiAgJ2ludGVyc2VjdGlvbldpdGgnOiBbMSwgMiwgMF0sXG4gICdpc0VxdWFsV2l0aCc6IFsxLCAyLCAwXSxcbiAgJ2lzTWF0Y2hXaXRoJzogWzIsIDEsIDBdLFxuICAnbWVyZ2VBbGxXaXRoJzogWzEsIDBdLFxuICAnbWVyZ2VXaXRoJzogWzEsIDIsIDBdLFxuICAncGFkQ2hhcnMnOiBbMiwgMSwgMF0sXG4gICdwYWRDaGFyc0VuZCc6IFsyLCAxLCAwXSxcbiAgJ3BhZENoYXJzU3RhcnQnOiBbMiwgMSwgMF0sXG4gICdwdWxsQWxsQnknOiBbMiwgMSwgMF0sXG4gICdwdWxsQWxsV2l0aCc6IFsyLCAxLCAwXSxcbiAgJ3JhbmdlU3RlcCc6IFsxLCAyLCAwXSxcbiAgJ3JhbmdlU3RlcFJpZ2h0JzogWzEsIDIsIDBdLFxuICAnc2V0V2l0aCc6IFszLCAxLCAyLCAwXSxcbiAgJ3NvcnRlZEluZGV4QnknOiBbMiwgMSwgMF0sXG4gICdzb3J0ZWRMYXN0SW5kZXhCeSc6IFsyLCAxLCAwXSxcbiAgJ3VuaW9uQnknOiBbMSwgMiwgMF0sXG4gICd1bmlvbldpdGgnOiBbMSwgMiwgMF0sXG4gICd1cGRhdGVXaXRoJzogWzMsIDEsIDIsIDBdLFxuICAneG9yQnknOiBbMSwgMiwgMF0sXG4gICd4b3JXaXRoJzogWzEsIDIsIDBdLFxuICAnemlwV2l0aCc6IFsxLCAyLCAwXVxufTtcblxuLyoqIFVzZWQgdG8gbWFwIG1ldGhvZCBuYW1lcyB0byBzcHJlYWQgY29uZmlncy4gKi9cbmV4cG9ydHMubWV0aG9kU3ByZWFkID0ge1xuICAnYXNzaWduQWxsJzogeyAnc3RhcnQnOiAwIH0sXG4gICdhc3NpZ25BbGxXaXRoJzogeyAnc3RhcnQnOiAwIH0sXG4gICdhc3NpZ25JbkFsbCc6IHsgJ3N0YXJ0JzogMCB9LFxuICAnYXNzaWduSW5BbGxXaXRoJzogeyAnc3RhcnQnOiAwIH0sXG4gICdkZWZhdWx0c0FsbCc6IHsgJ3N0YXJ0JzogMCB9LFxuICAnZGVmYXVsdHNEZWVwQWxsJzogeyAnc3RhcnQnOiAwIH0sXG4gICdpbnZva2VBcmdzJzogeyAnc3RhcnQnOiAyIH0sXG4gICdpbnZva2VBcmdzTWFwJzogeyAnc3RhcnQnOiAyIH0sXG4gICdtZXJnZUFsbCc6IHsgJ3N0YXJ0JzogMCB9LFxuICAnbWVyZ2VBbGxXaXRoJzogeyAnc3RhcnQnOiAwIH0sXG4gICdwYXJ0aWFsJzogeyAnc3RhcnQnOiAxIH0sXG4gICdwYXJ0aWFsUmlnaHQnOiB7ICdzdGFydCc6IDEgfSxcbiAgJ3dpdGhvdXQnOiB7ICdzdGFydCc6IDEgfSxcbiAgJ3ppcEFsbCc6IHsgJ3N0YXJ0JzogMCB9XG59O1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBtZXRob2RzIHdoaWNoIG11dGF0ZSBhcnJheXMgb3Igb2JqZWN0cy4gKi9cbmV4cG9ydHMubXV0YXRlID0ge1xuICAnYXJyYXknOiB7XG4gICAgJ2ZpbGwnOiB0cnVlLFxuICAgICdwdWxsJzogdHJ1ZSxcbiAgICAncHVsbEFsbCc6IHRydWUsXG4gICAgJ3B1bGxBbGxCeSc6IHRydWUsXG4gICAgJ3B1bGxBbGxXaXRoJzogdHJ1ZSxcbiAgICAncHVsbEF0JzogdHJ1ZSxcbiAgICAncmVtb3ZlJzogdHJ1ZSxcbiAgICAncmV2ZXJzZSc6IHRydWVcbiAgfSxcbiAgJ29iamVjdCc6IHtcbiAgICAnYXNzaWduJzogdHJ1ZSxcbiAgICAnYXNzaWduQWxsJzogdHJ1ZSxcbiAgICAnYXNzaWduQWxsV2l0aCc6IHRydWUsXG4gICAgJ2Fzc2lnbkluJzogdHJ1ZSxcbiAgICAnYXNzaWduSW5BbGwnOiB0cnVlLFxuICAgICdhc3NpZ25JbkFsbFdpdGgnOiB0cnVlLFxuICAgICdhc3NpZ25JbldpdGgnOiB0cnVlLFxuICAgICdhc3NpZ25XaXRoJzogdHJ1ZSxcbiAgICAnZGVmYXVsdHMnOiB0cnVlLFxuICAgICdkZWZhdWx0c0FsbCc6IHRydWUsXG4gICAgJ2RlZmF1bHRzRGVlcCc6IHRydWUsXG4gICAgJ2RlZmF1bHRzRGVlcEFsbCc6IHRydWUsXG4gICAgJ21lcmdlJzogdHJ1ZSxcbiAgICAnbWVyZ2VBbGwnOiB0cnVlLFxuICAgICdtZXJnZUFsbFdpdGgnOiB0cnVlLFxuICAgICdtZXJnZVdpdGgnOiB0cnVlLFxuICB9LFxuICAnc2V0Jzoge1xuICAgICdzZXQnOiB0cnVlLFxuICAgICdzZXRXaXRoJzogdHJ1ZSxcbiAgICAndW5zZXQnOiB0cnVlLFxuICAgICd1cGRhdGUnOiB0cnVlLFxuICAgICd1cGRhdGVXaXRoJzogdHJ1ZVxuICB9XG59O1xuXG4vKiogVXNlZCB0byB0cmFjayBtZXRob2RzIHdpdGggcGxhY2Vob2xkZXIgc3VwcG9ydCAqL1xuZXhwb3J0cy5wbGFjZWhvbGRlciA9IHtcbiAgJ2JpbmQnOiB0cnVlLFxuICAnYmluZEtleSc6IHRydWUsXG4gICdjdXJyeSc6IHRydWUsXG4gICdjdXJyeVJpZ2h0JzogdHJ1ZSxcbiAgJ3BhcnRpYWwnOiB0cnVlLFxuICAncGFydGlhbFJpZ2h0JzogdHJ1ZVxufTtcblxuLyoqIFVzZWQgdG8gbWFwIHJlYWwgbmFtZXMgdG8gdGhlaXIgYWxpYXNlcy4gKi9cbmV4cG9ydHMucmVhbFRvQWxpYXMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBvYmplY3QgPSBleHBvcnRzLmFsaWFzVG9SZWFsLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSgpKTtcblxuLyoqIFVzZWQgdG8gbWFwIG1ldGhvZCBuYW1lcyB0byBvdGhlciBuYW1lcy4gKi9cbmV4cG9ydHMucmVtYXAgPSB7XG4gICdhc3NpZ25BbGwnOiAnYXNzaWduJyxcbiAgJ2Fzc2lnbkFsbFdpdGgnOiAnYXNzaWduV2l0aCcsXG4gICdhc3NpZ25JbkFsbCc6ICdhc3NpZ25JbicsXG4gICdhc3NpZ25JbkFsbFdpdGgnOiAnYXNzaWduSW5XaXRoJyxcbiAgJ2N1cnJ5Tic6ICdjdXJyeScsXG4gICdjdXJyeVJpZ2h0Tic6ICdjdXJyeVJpZ2h0JyxcbiAgJ2RlZmF1bHRzQWxsJzogJ2RlZmF1bHRzJyxcbiAgJ2RlZmF1bHRzRGVlcEFsbCc6ICdkZWZhdWx0c0RlZXAnLFxuICAnZmluZEZyb20nOiAnZmluZCcsXG4gICdmaW5kSW5kZXhGcm9tJzogJ2ZpbmRJbmRleCcsXG4gICdmaW5kTGFzdEZyb20nOiAnZmluZExhc3QnLFxuICAnZmluZExhc3RJbmRleEZyb20nOiAnZmluZExhc3RJbmRleCcsXG4gICdnZXRPcic6ICdnZXQnLFxuICAnaW5jbHVkZXNGcm9tJzogJ2luY2x1ZGVzJyxcbiAgJ2luZGV4T2ZGcm9tJzogJ2luZGV4T2YnLFxuICAnaW52b2tlQXJncyc6ICdpbnZva2UnLFxuICAnaW52b2tlQXJnc01hcCc6ICdpbnZva2VNYXAnLFxuICAnbGFzdEluZGV4T2ZGcm9tJzogJ2xhc3RJbmRleE9mJyxcbiAgJ21lcmdlQWxsJzogJ21lcmdlJyxcbiAgJ21lcmdlQWxsV2l0aCc6ICdtZXJnZVdpdGgnLFxuICAncGFkQ2hhcnMnOiAncGFkJyxcbiAgJ3BhZENoYXJzRW5kJzogJ3BhZEVuZCcsXG4gICdwYWRDaGFyc1N0YXJ0JzogJ3BhZFN0YXJ0JyxcbiAgJ3Byb3BlcnR5T2YnOiAnZ2V0JyxcbiAgJ3JhbmdlU3RlcCc6ICdyYW5nZScsXG4gICdyYW5nZVN0ZXBSaWdodCc6ICdyYW5nZVJpZ2h0JyxcbiAgJ3Jlc3RGcm9tJzogJ3Jlc3QnLFxuICAnc3ByZWFkRnJvbSc6ICdzcHJlYWQnLFxuICAndHJpbUNoYXJzJzogJ3RyaW0nLFxuICAndHJpbUNoYXJzRW5kJzogJ3RyaW1FbmQnLFxuICAndHJpbUNoYXJzU3RhcnQnOiAndHJpbVN0YXJ0JyxcbiAgJ3ppcEFsbCc6ICd6aXAnXG59O1xuXG4vKiogVXNlZCB0byB0cmFjayBtZXRob2RzIHRoYXQgc2tpcCBmaXhpbmcgdGhlaXIgYXJpdHkuICovXG5leHBvcnRzLnNraXBGaXhlZCA9IHtcbiAgJ2Nhc3RBcnJheSc6IHRydWUsXG4gICdmbG93JzogdHJ1ZSxcbiAgJ2Zsb3dSaWdodCc6IHRydWUsXG4gICdpdGVyYXRlZSc6IHRydWUsXG4gICdtaXhpbic6IHRydWUsXG4gICdyZWFyZyc6IHRydWUsXG4gICdydW5JbkNvbnRleHQnOiB0cnVlXG59O1xuXG4vKiogVXNlZCB0byB0cmFjayBtZXRob2RzIHRoYXQgc2tpcCByZWFycmFuZ2luZyBhcmd1bWVudHMuICovXG5leHBvcnRzLnNraXBSZWFyZyA9IHtcbiAgJ2FkZCc6IHRydWUsXG4gICdhc3NpZ24nOiB0cnVlLFxuICAnYXNzaWduSW4nOiB0cnVlLFxuICAnYmluZCc6IHRydWUsXG4gICdiaW5kS2V5JzogdHJ1ZSxcbiAgJ2NvbmNhdCc6IHRydWUsXG4gICdkaWZmZXJlbmNlJzogdHJ1ZSxcbiAgJ2RpdmlkZSc6IHRydWUsXG4gICdlcSc6IHRydWUsXG4gICdndCc6IHRydWUsXG4gICdndGUnOiB0cnVlLFxuICAnaXNFcXVhbCc6IHRydWUsXG4gICdsdCc6IHRydWUsXG4gICdsdGUnOiB0cnVlLFxuICAnbWF0Y2hlc1Byb3BlcnR5JzogdHJ1ZSxcbiAgJ21lcmdlJzogdHJ1ZSxcbiAgJ211bHRpcGx5JzogdHJ1ZSxcbiAgJ292ZXJBcmdzJzogdHJ1ZSxcbiAgJ3BhcnRpYWwnOiB0cnVlLFxuICAncGFydGlhbFJpZ2h0JzogdHJ1ZSxcbiAgJ3Byb3BlcnR5T2YnOiB0cnVlLFxuICAncmFuZG9tJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3JhbmdlUmlnaHQnOiB0cnVlLFxuICAnc3VidHJhY3QnOiB0cnVlLFxuICAnemlwJzogdHJ1ZSxcbiAgJ3ppcE9iamVjdCc6IHRydWUsXG4gICd6aXBPYmplY3REZWVwJzogdHJ1ZVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2ZwL19tYXBwaW5nLmpzIiwiLyoqXG4gKiBUaGUgZGVmYXVsdCBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgbWV0aG9kcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvZnAvcGxhY2Vob2xkZXIuanMiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggbG9kYXNoLmNvbS9saWNlbnNlIHwgVW5kZXJzY29yZS5qcyAxLjguMyB1bmRlcnNjb3JlanMub3JnL0xJQ0VOU0VcbiAqL1xuOyhmdW5jdGlvbigpe2Z1bmN0aW9uIG4obix0KXtyZXR1cm4gbi5zZXQodFswXSx0WzFdKSxufWZ1bmN0aW9uIHQobix0KXtyZXR1cm4gbi5hZGQodCksbn1mdW5jdGlvbiByKG4sdCxyKXtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbi5jYWxsKHQpO2Nhc2UgMTpyZXR1cm4gbi5jYWxsKHQsclswXSk7Y2FzZSAyOnJldHVybiBuLmNhbGwodCxyWzBdLHJbMV0pO2Nhc2UgMzpyZXR1cm4gbi5jYWxsKHQsclswXSxyWzFdLHJbMl0pfXJldHVybiBuLmFwcGx5KHQscil9ZnVuY3Rpb24gZShuLHQscixlKXtmb3IodmFyIHU9LTEsaT1udWxsPT1uPzA6bi5sZW5ndGg7Kyt1PGk7KXt2YXIgbz1uW3VdO3QoZSxvLHIobyksbil9cmV0dXJuIGV9ZnVuY3Rpb24gdShuLHQpe2Zvcih2YXIgcj0tMSxlPW51bGw9PW4/MDpuLmxlbmd0aDsrK3I8ZSYmZmFsc2UhPT10KG5bcl0scixuKTspO3JldHVybiBufWZ1bmN0aW9uIGkobix0KXtmb3IodmFyIHI9bnVsbD09bj8wOm4ubGVuZ3RoO3ItLSYmZmFsc2UhPT10KG5bcl0scixuKTspO1xucmV0dXJuIG59ZnVuY3Rpb24gbyhuLHQpe2Zvcih2YXIgcj0tMSxlPW51bGw9PW4/MDpuLmxlbmd0aDsrK3I8ZTspaWYoIXQobltyXSxyLG4pKXJldHVybiBmYWxzZTtyZXR1cm4gdHJ1ZX1mdW5jdGlvbiBmKG4sdCl7Zm9yKHZhciByPS0xLGU9bnVsbD09bj8wOm4ubGVuZ3RoLHU9MCxpPVtdOysrcjxlOyl7dmFyIG89bltyXTt0KG8scixuKSYmKGlbdSsrXT1vKX1yZXR1cm4gaX1mdW5jdGlvbiBjKG4sdCl7cmV0dXJuIShudWxsPT1ufHwhbi5sZW5ndGgpJiYtMTxkKG4sdCwwKX1mdW5jdGlvbiBhKG4sdCxyKXtmb3IodmFyIGU9LTEsdT1udWxsPT1uPzA6bi5sZW5ndGg7KytlPHU7KWlmKHIodCxuW2VdKSlyZXR1cm4gdHJ1ZTtyZXR1cm4gZmFsc2V9ZnVuY3Rpb24gbChuLHQpe2Zvcih2YXIgcj0tMSxlPW51bGw9PW4/MDpuLmxlbmd0aCx1PUFycmF5KGUpOysrcjxlOyl1W3JdPXQobltyXSxyLG4pO3JldHVybiB1fWZ1bmN0aW9uIHMobix0KXtmb3IodmFyIHI9LTEsZT10Lmxlbmd0aCx1PW4ubGVuZ3RoOysrcjxlOyluW3Urcl09dFtyXTtcbnJldHVybiBufWZ1bmN0aW9uIGgobix0LHIsZSl7dmFyIHU9LTEsaT1udWxsPT1uPzA6bi5sZW5ndGg7Zm9yKGUmJmkmJihyPW5bKyt1XSk7Kyt1PGk7KXI9dChyLG5bdV0sdSxuKTtyZXR1cm4gcn1mdW5jdGlvbiBwKG4sdCxyLGUpe3ZhciB1PW51bGw9PW4/MDpuLmxlbmd0aDtmb3IoZSYmdSYmKHI9blstLXVdKTt1LS07KXI9dChyLG5bdV0sdSxuKTtyZXR1cm4gcn1mdW5jdGlvbiBfKG4sdCl7Zm9yKHZhciByPS0xLGU9bnVsbD09bj8wOm4ubGVuZ3RoOysrcjxlOylpZih0KG5bcl0scixuKSlyZXR1cm4gdHJ1ZTtyZXR1cm4gZmFsc2V9ZnVuY3Rpb24gdihuLHQscil7dmFyIGU7cmV0dXJuIHIobixmdW5jdGlvbihuLHIsdSl7aWYodChuLHIsdSkpcmV0dXJuIGU9cixmYWxzZX0pLGV9ZnVuY3Rpb24gZyhuLHQscixlKXt2YXIgdT1uLmxlbmd0aDtmb3Iocis9ZT8xOi0xO2U/ci0tOisrcjx1OylpZih0KG5bcl0scixuKSlyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBkKG4sdCxyKXtpZih0PT09dCluOntcbi0tcjtmb3IodmFyIGU9bi5sZW5ndGg7KytyPGU7KWlmKG5bcl09PT10KXtuPXI7YnJlYWsgbn1uPS0xfWVsc2Ugbj1nKG4sYixyKTtyZXR1cm4gbn1mdW5jdGlvbiB5KG4sdCxyLGUpey0tcjtmb3IodmFyIHU9bi5sZW5ndGg7KytyPHU7KWlmKGUobltyXSx0KSlyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBiKG4pe3JldHVybiBuIT09bn1mdW5jdGlvbiB4KG4sdCl7dmFyIHI9bnVsbD09bj8wOm4ubGVuZ3RoO3JldHVybiByP2sobix0KS9yOlB9ZnVuY3Rpb24gaihuKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/Rjp0W25dfX1mdW5jdGlvbiB3KG4pe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09bj9GOm5bdF19fWZ1bmN0aW9uIG0obix0LHIsZSx1KXtyZXR1cm4gdShuLGZ1bmN0aW9uKG4sdSxpKXtyPWU/KGU9ZmFsc2Usbik6dChyLG4sdSxpKX0pLHJ9ZnVuY3Rpb24gQShuLHQpe3ZhciByPW4ubGVuZ3RoO2ZvcihuLnNvcnQodCk7ci0tOyluW3JdPW5bcl0uYztcbnJldHVybiBufWZ1bmN0aW9uIGsobix0KXtmb3IodmFyIHIsZT0tMSx1PW4ubGVuZ3RoOysrZTx1Oyl7dmFyIGk9dChuW2VdKTtpIT09RiYmKHI9cj09PUY/aTpyK2kpfXJldHVybiByfWZ1bmN0aW9uIEUobix0KXtmb3IodmFyIHI9LTEsZT1BcnJheShuKTsrK3I8bjspZVtyXT10KHIpO3JldHVybiBlfWZ1bmN0aW9uIE8obix0KXtyZXR1cm4gbCh0LGZ1bmN0aW9uKHQpe3JldHVyblt0LG5bdF1dfSl9ZnVuY3Rpb24gUyhuKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG4odCl9fWZ1bmN0aW9uIEkobix0KXtyZXR1cm4gbCh0LGZ1bmN0aW9uKHQpe3JldHVybiBuW3RdfSl9ZnVuY3Rpb24gUihuLHQpe3JldHVybiBuLmhhcyh0KX1mdW5jdGlvbiB6KG4sdCl7Zm9yKHZhciByPS0xLGU9bi5sZW5ndGg7KytyPGUmJi0xPGQodCxuW3JdLDApOyk7cmV0dXJuIHJ9ZnVuY3Rpb24gVyhuLHQpe2Zvcih2YXIgcj1uLmxlbmd0aDtyLS0mJi0xPGQodCxuW3JdLDApOyk7cmV0dXJuIHJ9ZnVuY3Rpb24gQihuKXtcbnJldHVyblwiXFxcXFwiK1RuW25dfWZ1bmN0aW9uIEwobil7dmFyIHQ9LTEscj1BcnJheShuLnNpemUpO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24obixlKXtyWysrdF09W2Usbl19KSxyfWZ1bmN0aW9uIFUobix0KXtyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIG4odChyKSl9fWZ1bmN0aW9uIEMobix0KXtmb3IodmFyIHI9LTEsZT1uLmxlbmd0aCx1PTAsaT1bXTsrK3I8ZTspe3ZhciBvPW5bcl07byE9PXQmJlwiX19sb2Rhc2hfcGxhY2Vob2xkZXJfX1wiIT09b3x8KG5bcl09XCJfX2xvZGFzaF9wbGFjZWhvbGRlcl9fXCIsaVt1KytdPXIpfXJldHVybiBpfWZ1bmN0aW9uIEQobil7dmFyIHQ9LTEscj1BcnJheShuLnNpemUpO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24obil7clsrK3RdPW59KSxyfWZ1bmN0aW9uIE0obil7dmFyIHQ9LTEscj1BcnJheShuLnNpemUpO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24obil7clsrK3RdPVtuLG5dfSkscn1mdW5jdGlvbiBUKG4pe2lmKEJuLnRlc3Qobikpe1xuZm9yKHZhciB0PXpuLmxhc3RJbmRleD0wO3puLnRlc3Qobik7KSsrdDtuPXR9ZWxzZSBuPXR0KG4pO3JldHVybiBufWZ1bmN0aW9uICQobil7cmV0dXJuIEJuLnRlc3Qobik/bi5tYXRjaCh6bil8fFtdOm4uc3BsaXQoXCJcIil9dmFyIEYsTj0xLzAsUD1OYU4sWj1bW1wiYXJ5XCIsMTI4XSxbXCJiaW5kXCIsMV0sW1wiYmluZEtleVwiLDJdLFtcImN1cnJ5XCIsOF0sW1wiY3VycnlSaWdodFwiLDE2XSxbXCJmbGlwXCIsNTEyXSxbXCJwYXJ0aWFsXCIsMzJdLFtcInBhcnRpYWxSaWdodFwiLDY0XSxbXCJyZWFyZ1wiLDI1Nl1dLHE9L1xcYl9fcFxcKz0nJzsvZyxWPS9cXGIoX19wXFwrPSknJ1xcKy9nLEs9LyhfX2VcXCguKj9cXCl8XFxiX190XFwpKVxcKycnOy9nLEc9LyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLEg9L1smPD5cIiddL2csSj1SZWdFeHAoRy5zb3VyY2UpLFk9UmVnRXhwKEguc291cmNlKSxRPS88JS0oW1xcc1xcU10rPyklPi9nLFg9LzwlKFtcXHNcXFNdKz8pJT4vZyxubj0vPCU9KFtcXHNcXFNdKz8pJT4vZyx0bj0vXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLHJuPS9eXFx3KiQvLGVuPS9eXFwuLyx1bj0vW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2csb249L1tcXFxcXiQuKis/KClbXFxde318XS9nLGZuPVJlZ0V4cChvbi5zb3VyY2UpLGNuPS9eXFxzK3xcXHMrJC9nLGFuPS9eXFxzKy8sbG49L1xccyskLyxzbj0vXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLGhuPS9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxwbj0vLD8gJiAvLF9uPS9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZyx2bj0vXFxcXChcXFxcKT8vZyxnbj0vXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2csZG49L1xcdyokLyx5bj0vXlstK10weFswLTlhLWZdKyQvaSxibj0vXjBiWzAxXSskL2kseG49L15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLyxqbj0vXjBvWzAtN10rJC9pLHduPS9eKD86MHxbMS05XVxcZCopJC8sbW49L1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2csQW49LygkXikvLGtuPS9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZyxFbj1cIltcXFxcdWZlMGVcXFxcdWZlMGZdPyg/OltcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyZlxcXFx1MjBkMC1cXFxcdTIwZmZdfFxcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXSk/KD86XFxcXHUyMDBkKD86W15cXFxcdWQ4MDAtXFxcXHVkZmZmXXwoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9fFtcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXSlbXFxcXHVmZTBlXFxcXHVmZTBmXT8oPzpbXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMmZcXFxcdTIwZDAtXFxcXHUyMGZmXXxcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0pPykqXCIsT249XCIoPzpbXFxcXHUyNzAwLVxcXFx1MjdiZl18KD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfXxbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0pXCIrRW4sU249XCIoPzpbXlxcXFx1ZDgwMC1cXFxcdWRmZmZdW1xcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdWZlMjAtXFxcXHVmZTJmXFxcXHUyMGQwLVxcXFx1MjBmZl0/fFtcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyZlxcXFx1MjBkMC1cXFxcdTIwZmZdfCg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn18W1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdfFtcXFxcdWQ4MDAtXFxcXHVkZmZmXSlcIixJbj1SZWdFeHAoXCJbJ1xcdTIwMTldXCIsXCJnXCIpLFJuPVJlZ0V4cChcIltcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyZlxcXFx1MjBkMC1cXFxcdTIwZmZdXCIsXCJnXCIpLHpuPVJlZ0V4cChcIlxcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXSg/PVxcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXSl8XCIrU24rRW4sXCJnXCIpLFduPVJlZ0V4cChbXCJbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXT9bYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXSsoPzpbJ1xcdTIwMTldKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPyg/PVtcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3XFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmXFxcXHUyMDAwLVxcXFx1MjA2ZiBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwXXxbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXXwkKXwoPzpbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXXxbXlxcXFx1ZDgwMC1cXFxcdWRmZmZcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3XFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmXFxcXHUyMDAwLVxcXFx1MjA2ZiBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwXFxcXGQrXFxcXHUyNzAwLVxcXFx1MjdiZmEtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZkEtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZV0pKyg/OlsnXFx1MjAxOV0oPzpEfExMfE18UkV8U3xUfFZFKSk/KD89W1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmZcXFxcdTIwMDAtXFxcXHUyMDZmIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDBdfFtBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdKD86W2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZl18W15cXFxcdWQ4MDAtXFxcXHVkZmZmXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmN1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZlxcXFx1MjAwMC1cXFxcdTIwNmYgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFxcXFxkK1xcXFx1MjcwMC1cXFxcdTI3YmZhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdKXwkKXxbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXT8oPzpbYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXXxbXlxcXFx1ZDgwMC1cXFxcdWRmZmZcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3XFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmXFxcXHUyMDAwLVxcXFx1MjA2ZiBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwXFxcXGQrXFxcXHUyNzAwLVxcXFx1MjdiZmEtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZkEtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZV0pKyg/OlsnXFx1MjAxOV0oPzpkfGxsfG18cmV8c3x0fHZlKSk/fFtBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdKyg/OlsnXFx1MjAxOV0oPzpEfExMfE18UkV8U3xUfFZFKSk/fFxcXFxkKig/Oig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpXFxcXGIpfFxcXFxkKig/Oig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpXFxcXGIpfFxcXFxkK1wiLE9uXS5qb2luKFwifFwiKSxcImdcIiksQm49UmVnRXhwKFwiW1xcXFx1MjAwZFxcXFx1ZDgwMC1cXFxcdWRmZmZcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyZlxcXFx1MjBkMC1cXFxcdTIwZmZcXFxcdWZlMGVcXFxcdWZlMGZdXCIpLExuPS9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLyxVbj1cIkFycmF5IEJ1ZmZlciBEYXRhVmlldyBEYXRlIEVycm9yIEZsb2F0MzJBcnJheSBGbG9hdDY0QXJyYXkgRnVuY3Rpb24gSW50OEFycmF5IEludDE2QXJyYXkgSW50MzJBcnJheSBNYXAgTWF0aCBPYmplY3QgUHJvbWlzZSBSZWdFeHAgU2V0IFN0cmluZyBTeW1ib2wgVHlwZUVycm9yIFVpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgVWludDE2QXJyYXkgVWludDMyQXJyYXkgV2Vha01hcCBfIGNsZWFyVGltZW91dCBpc0Zpbml0ZSBwYXJzZUludCBzZXRUaW1lb3V0XCIuc3BsaXQoXCIgXCIpLENuPXt9O1xuQ25bXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIl09Q25bXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIl09Q25bXCJbb2JqZWN0IEludDhBcnJheV1cIl09Q25bXCJbb2JqZWN0IEludDE2QXJyYXldXCJdPUNuW1wiW29iamVjdCBJbnQzMkFycmF5XVwiXT1DbltcIltvYmplY3QgVWludDhBcnJheV1cIl09Q25bXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiXT1DbltcIltvYmplY3QgVWludDE2QXJyYXldXCJdPUNuW1wiW29iamVjdCBVaW50MzJBcnJheV1cIl09dHJ1ZSxDbltcIltvYmplY3QgQXJndW1lbnRzXVwiXT1DbltcIltvYmplY3QgQXJyYXldXCJdPUNuW1wiW29iamVjdCBBcnJheUJ1ZmZlcl1cIl09Q25bXCJbb2JqZWN0IEJvb2xlYW5dXCJdPUNuW1wiW29iamVjdCBEYXRhVmlld11cIl09Q25bXCJbb2JqZWN0IERhdGVdXCJdPUNuW1wiW29iamVjdCBFcnJvcl1cIl09Q25bXCJbb2JqZWN0IEZ1bmN0aW9uXVwiXT1DbltcIltvYmplY3QgTWFwXVwiXT1DbltcIltvYmplY3QgTnVtYmVyXVwiXT1DbltcIltvYmplY3QgT2JqZWN0XVwiXT1DbltcIltvYmplY3QgUmVnRXhwXVwiXT1DbltcIltvYmplY3QgU2V0XVwiXT1DbltcIltvYmplY3QgU3RyaW5nXVwiXT1DbltcIltvYmplY3QgV2Vha01hcF1cIl09ZmFsc2U7XG52YXIgRG49e307RG5bXCJbb2JqZWN0IEFyZ3VtZW50c11cIl09RG5bXCJbb2JqZWN0IEFycmF5XVwiXT1EbltcIltvYmplY3QgQXJyYXlCdWZmZXJdXCJdPURuW1wiW29iamVjdCBEYXRhVmlld11cIl09RG5bXCJbb2JqZWN0IEJvb2xlYW5dXCJdPURuW1wiW29iamVjdCBEYXRlXVwiXT1EbltcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiXT1EbltcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiXT1EbltcIltvYmplY3QgSW50OEFycmF5XVwiXT1EbltcIltvYmplY3QgSW50MTZBcnJheV1cIl09RG5bXCJbb2JqZWN0IEludDMyQXJyYXldXCJdPURuW1wiW29iamVjdCBNYXBdXCJdPURuW1wiW29iamVjdCBOdW1iZXJdXCJdPURuW1wiW29iamVjdCBPYmplY3RdXCJdPURuW1wiW29iamVjdCBSZWdFeHBdXCJdPURuW1wiW29iamVjdCBTZXRdXCJdPURuW1wiW29iamVjdCBTdHJpbmddXCJdPURuW1wiW29iamVjdCBTeW1ib2xdXCJdPURuW1wiW29iamVjdCBVaW50OEFycmF5XVwiXT1EbltcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCJdPURuW1wiW29iamVjdCBVaW50MTZBcnJheV1cIl09RG5bXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiXT10cnVlLFxuRG5bXCJbb2JqZWN0IEVycm9yXVwiXT1EbltcIltvYmplY3QgRnVuY3Rpb25dXCJdPURuW1wiW29iamVjdCBXZWFrTWFwXVwiXT1mYWxzZTt2YXIgTW4sVG49e1wiXFxcXFwiOlwiXFxcXFwiLFwiJ1wiOlwiJ1wiLFwiXFxuXCI6XCJuXCIsXCJcXHJcIjpcInJcIixcIlxcdTIwMjhcIjpcInUyMDI4XCIsXCJcXHUyMDI5XCI6XCJ1MjAyOVwifSwkbj1wYXJzZUZsb2F0LEZuPXBhcnNlSW50LE5uPXR5cGVvZiBnbG9iYWw9PVwib2JqZWN0XCImJmdsb2JhbCYmZ2xvYmFsLk9iamVjdD09PU9iamVjdCYmZ2xvYmFsLFBuPXR5cGVvZiBzZWxmPT1cIm9iamVjdFwiJiZzZWxmJiZzZWxmLk9iamVjdD09PU9iamVjdCYmc2VsZixabj1Obnx8UG58fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSxxbj10eXBlb2YgZXhwb3J0cz09XCJvYmplY3RcIiYmZXhwb3J0cyYmIWV4cG9ydHMubm9kZVR5cGUmJmV4cG9ydHMsVm49cW4mJnR5cGVvZiBtb2R1bGU9PVwib2JqZWN0XCImJm1vZHVsZSYmIW1vZHVsZS5ub2RlVHlwZSYmbW9kdWxlLEtuPVZuJiZWbi5leHBvcnRzPT09cW4sR249S24mJk5uLnByb2Nlc3M7XG5uOnt0cnl7TW49R24mJkduLmJpbmRpbmcmJkduLmJpbmRpbmcoXCJ1dGlsXCIpO2JyZWFrIG59Y2F0Y2gobil7fU1uPXZvaWQgMH12YXIgSG49TW4mJk1uLmlzQXJyYXlCdWZmZXIsSm49TW4mJk1uLmlzRGF0ZSxZbj1NbiYmTW4uaXNNYXAsUW49TW4mJk1uLmlzUmVnRXhwLFhuPU1uJiZNbi5pc1NldCxudD1NbiYmTW4uaXNUeXBlZEFycmF5LHR0PWooXCJsZW5ndGhcIikscnQ9dyh7XCJcXHhjMFwiOlwiQVwiLFwiXFx4YzFcIjpcIkFcIixcIlxceGMyXCI6XCJBXCIsXCJcXHhjM1wiOlwiQVwiLFwiXFx4YzRcIjpcIkFcIixcIlxceGM1XCI6XCJBXCIsXCJcXHhlMFwiOlwiYVwiLFwiXFx4ZTFcIjpcImFcIixcIlxceGUyXCI6XCJhXCIsXCJcXHhlM1wiOlwiYVwiLFwiXFx4ZTRcIjpcImFcIixcIlxceGU1XCI6XCJhXCIsXCJcXHhjN1wiOlwiQ1wiLFwiXFx4ZTdcIjpcImNcIixcIlxceGQwXCI6XCJEXCIsXCJcXHhmMFwiOlwiZFwiLFwiXFx4YzhcIjpcIkVcIixcIlxceGM5XCI6XCJFXCIsXCJcXHhjYVwiOlwiRVwiLFwiXFx4Y2JcIjpcIkVcIixcIlxceGU4XCI6XCJlXCIsXCJcXHhlOVwiOlwiZVwiLFwiXFx4ZWFcIjpcImVcIixcIlxceGViXCI6XCJlXCIsXCJcXHhjY1wiOlwiSVwiLFwiXFx4Y2RcIjpcIklcIixcIlxceGNlXCI6XCJJXCIsXG5cIlxceGNmXCI6XCJJXCIsXCJcXHhlY1wiOlwiaVwiLFwiXFx4ZWRcIjpcImlcIixcIlxceGVlXCI6XCJpXCIsXCJcXHhlZlwiOlwiaVwiLFwiXFx4ZDFcIjpcIk5cIixcIlxceGYxXCI6XCJuXCIsXCJcXHhkMlwiOlwiT1wiLFwiXFx4ZDNcIjpcIk9cIixcIlxceGQ0XCI6XCJPXCIsXCJcXHhkNVwiOlwiT1wiLFwiXFx4ZDZcIjpcIk9cIixcIlxceGQ4XCI6XCJPXCIsXCJcXHhmMlwiOlwib1wiLFwiXFx4ZjNcIjpcIm9cIixcIlxceGY0XCI6XCJvXCIsXCJcXHhmNVwiOlwib1wiLFwiXFx4ZjZcIjpcIm9cIixcIlxceGY4XCI6XCJvXCIsXCJcXHhkOVwiOlwiVVwiLFwiXFx4ZGFcIjpcIlVcIixcIlxceGRiXCI6XCJVXCIsXCJcXHhkY1wiOlwiVVwiLFwiXFx4ZjlcIjpcInVcIixcIlxceGZhXCI6XCJ1XCIsXCJcXHhmYlwiOlwidVwiLFwiXFx4ZmNcIjpcInVcIixcIlxceGRkXCI6XCJZXCIsXCJcXHhmZFwiOlwieVwiLFwiXFx4ZmZcIjpcInlcIixcIlxceGM2XCI6XCJBZVwiLFwiXFx4ZTZcIjpcImFlXCIsXCJcXHhkZVwiOlwiVGhcIixcIlxceGZlXCI6XCJ0aFwiLFwiXFx4ZGZcIjpcInNzXCIsXCJcXHUwMTAwXCI6XCJBXCIsXCJcXHUwMTAyXCI6XCJBXCIsXCJcXHUwMTA0XCI6XCJBXCIsXCJcXHUwMTAxXCI6XCJhXCIsXCJcXHUwMTAzXCI6XCJhXCIsXCJcXHUwMTA1XCI6XCJhXCIsXCJcXHUwMTA2XCI6XCJDXCIsXCJcXHUwMTA4XCI6XCJDXCIsXCJcXHUwMTBhXCI6XCJDXCIsXG5cIlxcdTAxMGNcIjpcIkNcIixcIlxcdTAxMDdcIjpcImNcIixcIlxcdTAxMDlcIjpcImNcIixcIlxcdTAxMGJcIjpcImNcIixcIlxcdTAxMGRcIjpcImNcIixcIlxcdTAxMGVcIjpcIkRcIixcIlxcdTAxMTBcIjpcIkRcIixcIlxcdTAxMGZcIjpcImRcIixcIlxcdTAxMTFcIjpcImRcIixcIlxcdTAxMTJcIjpcIkVcIixcIlxcdTAxMTRcIjpcIkVcIixcIlxcdTAxMTZcIjpcIkVcIixcIlxcdTAxMThcIjpcIkVcIixcIlxcdTAxMWFcIjpcIkVcIixcIlxcdTAxMTNcIjpcImVcIixcIlxcdTAxMTVcIjpcImVcIixcIlxcdTAxMTdcIjpcImVcIixcIlxcdTAxMTlcIjpcImVcIixcIlxcdTAxMWJcIjpcImVcIixcIlxcdTAxMWNcIjpcIkdcIixcIlxcdTAxMWVcIjpcIkdcIixcIlxcdTAxMjBcIjpcIkdcIixcIlxcdTAxMjJcIjpcIkdcIixcIlxcdTAxMWRcIjpcImdcIixcIlxcdTAxMWZcIjpcImdcIixcIlxcdTAxMjFcIjpcImdcIixcIlxcdTAxMjNcIjpcImdcIixcIlxcdTAxMjRcIjpcIkhcIixcIlxcdTAxMjZcIjpcIkhcIixcIlxcdTAxMjVcIjpcImhcIixcIlxcdTAxMjdcIjpcImhcIixcIlxcdTAxMjhcIjpcIklcIixcIlxcdTAxMmFcIjpcIklcIixcIlxcdTAxMmNcIjpcIklcIixcIlxcdTAxMmVcIjpcIklcIixcIlxcdTAxMzBcIjpcIklcIixcIlxcdTAxMjlcIjpcImlcIixcIlxcdTAxMmJcIjpcImlcIixcIlxcdTAxMmRcIjpcImlcIixcblwiXFx1MDEyZlwiOlwiaVwiLFwiXFx1MDEzMVwiOlwiaVwiLFwiXFx1MDEzNFwiOlwiSlwiLFwiXFx1MDEzNVwiOlwialwiLFwiXFx1MDEzNlwiOlwiS1wiLFwiXFx1MDEzN1wiOlwia1wiLFwiXFx1MDEzOFwiOlwia1wiLFwiXFx1MDEzOVwiOlwiTFwiLFwiXFx1MDEzYlwiOlwiTFwiLFwiXFx1MDEzZFwiOlwiTFwiLFwiXFx1MDEzZlwiOlwiTFwiLFwiXFx1MDE0MVwiOlwiTFwiLFwiXFx1MDEzYVwiOlwibFwiLFwiXFx1MDEzY1wiOlwibFwiLFwiXFx1MDEzZVwiOlwibFwiLFwiXFx1MDE0MFwiOlwibFwiLFwiXFx1MDE0MlwiOlwibFwiLFwiXFx1MDE0M1wiOlwiTlwiLFwiXFx1MDE0NVwiOlwiTlwiLFwiXFx1MDE0N1wiOlwiTlwiLFwiXFx1MDE0YVwiOlwiTlwiLFwiXFx1MDE0NFwiOlwiblwiLFwiXFx1MDE0NlwiOlwiblwiLFwiXFx1MDE0OFwiOlwiblwiLFwiXFx1MDE0YlwiOlwiblwiLFwiXFx1MDE0Y1wiOlwiT1wiLFwiXFx1MDE0ZVwiOlwiT1wiLFwiXFx1MDE1MFwiOlwiT1wiLFwiXFx1MDE0ZFwiOlwib1wiLFwiXFx1MDE0ZlwiOlwib1wiLFwiXFx1MDE1MVwiOlwib1wiLFwiXFx1MDE1NFwiOlwiUlwiLFwiXFx1MDE1NlwiOlwiUlwiLFwiXFx1MDE1OFwiOlwiUlwiLFwiXFx1MDE1NVwiOlwiclwiLFwiXFx1MDE1N1wiOlwiclwiLFwiXFx1MDE1OVwiOlwiclwiLFwiXFx1MDE1YVwiOlwiU1wiLFwiXFx1MDE1Y1wiOlwiU1wiLFxuXCJcXHUwMTVlXCI6XCJTXCIsXCJcXHUwMTYwXCI6XCJTXCIsXCJcXHUwMTViXCI6XCJzXCIsXCJcXHUwMTVkXCI6XCJzXCIsXCJcXHUwMTVmXCI6XCJzXCIsXCJcXHUwMTYxXCI6XCJzXCIsXCJcXHUwMTYyXCI6XCJUXCIsXCJcXHUwMTY0XCI6XCJUXCIsXCJcXHUwMTY2XCI6XCJUXCIsXCJcXHUwMTYzXCI6XCJ0XCIsXCJcXHUwMTY1XCI6XCJ0XCIsXCJcXHUwMTY3XCI6XCJ0XCIsXCJcXHUwMTY4XCI6XCJVXCIsXCJcXHUwMTZhXCI6XCJVXCIsXCJcXHUwMTZjXCI6XCJVXCIsXCJcXHUwMTZlXCI6XCJVXCIsXCJcXHUwMTcwXCI6XCJVXCIsXCJcXHUwMTcyXCI6XCJVXCIsXCJcXHUwMTY5XCI6XCJ1XCIsXCJcXHUwMTZiXCI6XCJ1XCIsXCJcXHUwMTZkXCI6XCJ1XCIsXCJcXHUwMTZmXCI6XCJ1XCIsXCJcXHUwMTcxXCI6XCJ1XCIsXCJcXHUwMTczXCI6XCJ1XCIsXCJcXHUwMTc0XCI6XCJXXCIsXCJcXHUwMTc1XCI6XCJ3XCIsXCJcXHUwMTc2XCI6XCJZXCIsXCJcXHUwMTc3XCI6XCJ5XCIsXCJcXHUwMTc4XCI6XCJZXCIsXCJcXHUwMTc5XCI6XCJaXCIsXCJcXHUwMTdiXCI6XCJaXCIsXCJcXHUwMTdkXCI6XCJaXCIsXCJcXHUwMTdhXCI6XCJ6XCIsXCJcXHUwMTdjXCI6XCJ6XCIsXCJcXHUwMTdlXCI6XCJ6XCIsXCJcXHUwMTMyXCI6XCJJSlwiLFwiXFx1MDEzM1wiOlwiaWpcIixcIlxcdTAxNTJcIjpcIk9lXCIsXCJcXHUwMTUzXCI6XCJvZVwiLFxuXCJcXHUwMTQ5XCI6XCInblwiLFwiXFx1MDE3ZlwiOlwic1wifSksZXQ9dyh7XCImXCI6XCImYW1wO1wiLFwiPFwiOlwiJmx0O1wiLFwiPlwiOlwiJmd0O1wiLCdcIic6XCImcXVvdDtcIixcIidcIjpcIiYjMzk7XCJ9KSx1dD13KHtcIiZhbXA7XCI6XCImXCIsXCImbHQ7XCI6XCI8XCIsXCImZ3Q7XCI6XCI+XCIsXCImcXVvdDtcIjonXCInLFwiJiMzOTtcIjpcIidcIn0pLGl0PWZ1bmN0aW9uIHcoRW4pe2Z1bmN0aW9uIE9uKG4pe2lmKHh1KG4pJiYhYWYobikmJiEobiBpbnN0YW5jZW9mIE1uKSl7aWYobiBpbnN0YW5jZW9mIHpuKXJldHVybiBuO2lmKGNpLmNhbGwobixcIl9fd3JhcHBlZF9fXCIpKXJldHVybiBQZShuKX1yZXR1cm4gbmV3IHpuKG4pfWZ1bmN0aW9uIFNuKCl7fWZ1bmN0aW9uIHpuKG4sdCl7dGhpcy5fX3dyYXBwZWRfXz1uLHRoaXMuX19hY3Rpb25zX189W10sdGhpcy5fX2NoYWluX189ISF0LHRoaXMuX19pbmRleF9fPTAsdGhpcy5fX3ZhbHVlc19fPUZ9ZnVuY3Rpb24gTW4obil7dGhpcy5fX3dyYXBwZWRfXz1uLHRoaXMuX19hY3Rpb25zX189W10sdGhpcy5fX2Rpcl9fPTEsXG50aGlzLl9fZmlsdGVyZWRfXz1mYWxzZSx0aGlzLl9faXRlcmF0ZWVzX189W10sdGhpcy5fX3Rha2VDb3VudF9fPTQyOTQ5NjcyOTUsdGhpcy5fX3ZpZXdzX189W119ZnVuY3Rpb24gVG4obil7dmFyIHQ9LTEscj1udWxsPT1uPzA6bi5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK3Q8cjspe3ZhciBlPW5bdF07dGhpcy5zZXQoZVswXSxlWzFdKX19ZnVuY3Rpb24gTm4obil7dmFyIHQ9LTEscj1udWxsPT1uPzA6bi5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK3Q8cjspe3ZhciBlPW5bdF07dGhpcy5zZXQoZVswXSxlWzFdKX19ZnVuY3Rpb24gUG4obil7dmFyIHQ9LTEscj1udWxsPT1uPzA6bi5sZW5ndGg7Zm9yKHRoaXMuY2xlYXIoKTsrK3Q8cjspe3ZhciBlPW5bdF07dGhpcy5zZXQoZVswXSxlWzFdKX19ZnVuY3Rpb24gcW4obil7dmFyIHQ9LTEscj1udWxsPT1uPzA6bi5sZW5ndGg7Zm9yKHRoaXMuX19kYXRhX189bmV3IFBuOysrdDxyOyl0aGlzLmFkZChuW3RdKX1mdW5jdGlvbiBWbihuKXtcbnRoaXMuc2l6ZT0odGhpcy5fX2RhdGFfXz1uZXcgTm4obikpLnNpemV9ZnVuY3Rpb24gR24obix0KXt2YXIgcixlPWFmKG4pLHU9IWUmJmNmKG4pLGk9IWUmJiF1JiZzZihuKSxvPSFlJiYhdSYmIWkmJmdmKG4pLHU9KGU9ZXx8dXx8aXx8byk/RShuLmxlbmd0aCxyaSk6W10sZj11Lmxlbmd0aDtmb3IociBpbiBuKSF0JiYhY2kuY2FsbChuLHIpfHxlJiYoXCJsZW5ndGhcIj09cnx8aSYmKFwib2Zmc2V0XCI9PXJ8fFwicGFyZW50XCI9PXIpfHxvJiYoXCJidWZmZXJcIj09cnx8XCJieXRlTGVuZ3RoXCI9PXJ8fFwiYnl0ZU9mZnNldFwiPT1yKXx8UmUocixmKSl8fHUucHVzaChyKTtyZXR1cm4gdX1mdW5jdGlvbiB0dChuKXt2YXIgdD1uLmxlbmd0aDtyZXR1cm4gdD9uW2NyKDAsdC0xKV06Rn1mdW5jdGlvbiBvdChuLHQpe3JldHVybiBUZShNcihuKSxndCh0LDAsbi5sZW5ndGgpKX1mdW5jdGlvbiBmdChuKXtyZXR1cm4gVGUoTXIobikpfWZ1bmN0aW9uIGN0KG4sdCxyKXsocj09PUZ8fGh1KG5bdF0scikpJiYociE9PUZ8fHQgaW4gbil8fF90KG4sdCxyKTtcbn1mdW5jdGlvbiBhdChuLHQscil7dmFyIGU9blt0XTtjaS5jYWxsKG4sdCkmJmh1KGUscikmJihyIT09Rnx8dCBpbiBuKXx8X3Qobix0LHIpfWZ1bmN0aW9uIGx0KG4sdCl7Zm9yKHZhciByPW4ubGVuZ3RoO3ItLTspaWYoaHUobltyXVswXSx0KSlyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBzdChuLHQscixlKXtyZXR1cm4gb28obixmdW5jdGlvbihuLHUsaSl7dChlLG4scihuKSxpKX0pLGV9ZnVuY3Rpb24gaHQobix0KXtyZXR1cm4gbiYmVHIodCxMdSh0KSxuKX1mdW5jdGlvbiBwdChuLHQpe3JldHVybiBuJiZUcih0LFV1KHQpLG4pfWZ1bmN0aW9uIF90KG4sdCxyKXtcIl9fcHJvdG9fX1wiPT10JiZFaT9FaShuLHQse2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6dHJ1ZSx2YWx1ZTpyLHdyaXRhYmxlOnRydWV9KTpuW3RdPXJ9ZnVuY3Rpb24gdnQobix0KXtmb3IodmFyIHI9LTEsZT10Lmxlbmd0aCx1PUh1KGUpLGk9bnVsbD09bjsrK3I8ZTspdVtyXT1pP0Y6V3Uobix0W3JdKTtyZXR1cm4gdTtcbn1mdW5jdGlvbiBndChuLHQscil7cmV0dXJuIG49PT1uJiYociE9PUYmJihuPW48PXI/bjpyKSx0IT09RiYmKG49bj49dD9uOnQpKSxufWZ1bmN0aW9uIGR0KG4sdCxyLGUsaSxvKXt2YXIgZixjPTEmdCxhPTImdCxsPTQmdDtpZihyJiYoZj1pP3IobixlLGksbyk6cihuKSksZiE9PUYpcmV0dXJuIGY7aWYoIWJ1KG4pKXJldHVybiBuO2lmKGU9YWYobikpe2lmKGY9RWUobiksIWMpcmV0dXJuIE1yKG4sZil9ZWxzZXt2YXIgcz15byhuKSxoPVwiW29iamVjdCBGdW5jdGlvbl1cIj09c3x8XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiPT1zO2lmKHNmKG4pKXJldHVybiBXcihuLGMpO2lmKFwiW29iamVjdCBPYmplY3RdXCI9PXN8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PXN8fGgmJiFpKXtpZihmPWF8fGg/e306T2UobiksIWMpcmV0dXJuIGE/RnIobixwdChmLG4pKTokcihuLGh0KGYsbikpfWVsc2V7aWYoIURuW3NdKXJldHVybiBpP246e307Zj1TZShuLHMsZHQsYyl9fWlmKG98fChvPW5ldyBWbiksXG5pPW8uZ2V0KG4pKXJldHVybiBpO28uc2V0KG4sZik7dmFyIGE9bD9hP3llOmRlOmE/VXU6THUscD1lP0Y6YShuKTtyZXR1cm4gdShwfHxuLGZ1bmN0aW9uKGUsdSl7cCYmKHU9ZSxlPW5bdV0pLGF0KGYsdSxkdChlLHQscix1LG4sbykpfSksZn1mdW5jdGlvbiB5dChuKXt2YXIgdD1MdShuKTtyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIGJ0KHIsbix0KX19ZnVuY3Rpb24gYnQobix0LHIpe3ZhciBlPXIubGVuZ3RoO2lmKG51bGw9PW4pcmV0dXJuIWU7Zm9yKG49bmkobik7ZS0tOyl7dmFyIHU9cltlXSxpPXRbdV0sbz1uW3VdO2lmKG89PT1GJiYhKHUgaW4gbil8fCFpKG8pKXJldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiB4dChuLHQscil7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgZWkoXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIpO3JldHVybiBqbyhmdW5jdGlvbigpe24uYXBwbHkoRixyKX0sdCl9ZnVuY3Rpb24ganQobix0LHIsZSl7dmFyIHU9LTEsaT1jLG89dHJ1ZSxmPW4ubGVuZ3RoLHM9W10saD10Lmxlbmd0aDtcbmlmKCFmKXJldHVybiBzO3ImJih0PWwodCxTKHIpKSksZT8oaT1hLG89ZmFsc2UpOjIwMDw9dC5sZW5ndGgmJihpPVIsbz1mYWxzZSx0PW5ldyBxbih0KSk7bjpmb3IoOysrdTxmOyl7dmFyIHA9blt1XSxfPW51bGw9PXI/cDpyKHApLHA9ZXx8MCE9PXA/cDowO2lmKG8mJl89PT1fKXtmb3IodmFyIHY9aDt2LS07KWlmKHRbdl09PT1fKWNvbnRpbnVlIG47cy5wdXNoKHApfWVsc2UgaSh0LF8sZSl8fHMucHVzaChwKX1yZXR1cm4gc31mdW5jdGlvbiB3dChuLHQpe3ZhciByPXRydWU7cmV0dXJuIG9vKG4sZnVuY3Rpb24obixlLHUpe3JldHVybiByPSEhdChuLGUsdSl9KSxyfWZ1bmN0aW9uIG10KG4sdCxyKXtmb3IodmFyIGU9LTEsdT1uLmxlbmd0aDsrK2U8dTspe3ZhciBpPW5bZV0sbz10KGkpO2lmKG51bGwhPW8mJihmPT09Rj9vPT09byYmIUF1KG8pOnIobyxmKSkpdmFyIGY9byxjPWl9cmV0dXJuIGN9ZnVuY3Rpb24gQXQobix0KXt2YXIgcj1bXTtyZXR1cm4gb28obixmdW5jdGlvbihuLGUsdSl7XG50KG4sZSx1KSYmci5wdXNoKG4pfSkscn1mdW5jdGlvbiBrdChuLHQscixlLHUpe3ZhciBpPS0xLG89bi5sZW5ndGg7Zm9yKHJ8fChyPUllKSx1fHwodT1bXSk7KytpPG87KXt2YXIgZj1uW2ldOzA8dCYmcihmKT8xPHQ/a3QoZix0LTEscixlLHUpOnModSxmKTplfHwodVt1Lmxlbmd0aF09Zil9cmV0dXJuIHV9ZnVuY3Rpb24gRXQobix0KXtyZXR1cm4gbiYmY28obix0LEx1KX1mdW5jdGlvbiBPdChuLHQpe3JldHVybiBuJiZhbyhuLHQsTHUpfWZ1bmN0aW9uIFN0KG4sdCl7cmV0dXJuIGYodCxmdW5jdGlvbih0KXtyZXR1cm4gZ3Uoblt0XSl9KX1mdW5jdGlvbiBJdChuLHQpe3Q9UnIodCxuKTtmb3IodmFyIHI9MCxlPXQubGVuZ3RoO251bGwhPW4mJnI8ZTspbj1uWyRlKHRbcisrXSldO3JldHVybiByJiZyPT1lP246Rn1mdW5jdGlvbiBSdChuLHQscil7cmV0dXJuIHQ9dChuKSxhZihuKT90OnModCxyKG4pKX1mdW5jdGlvbiB6dChuKXtpZihudWxsPT1uKW49bj09PUY/XCJbb2JqZWN0IFVuZGVmaW5lZF1cIjpcIltvYmplY3QgTnVsbF1cIjtlbHNlIGlmKGtpJiZraSBpbiBuaShuKSl7XG52YXIgdD1jaS5jYWxsKG4sa2kpLHI9bltraV07dHJ5e25ba2ldPUY7dmFyIGU9dHJ1ZX1jYXRjaChuKXt9dmFyIHU9c2kuY2FsbChuKTtlJiYodD9uW2tpXT1yOmRlbGV0ZSBuW2tpXSksbj11fWVsc2Ugbj1zaS5jYWxsKG4pO3JldHVybiBufWZ1bmN0aW9uIFd0KG4sdCl7cmV0dXJuIG4+dH1mdW5jdGlvbiBCdChuLHQpe3JldHVybiBudWxsIT1uJiZjaS5jYWxsKG4sdCl9ZnVuY3Rpb24gTHQobix0KXtyZXR1cm4gbnVsbCE9biYmdCBpbiBuaShuKX1mdW5jdGlvbiBVdChuLHQscil7Zm9yKHZhciBlPXI/YTpjLHU9blswXS5sZW5ndGgsaT1uLmxlbmd0aCxvPWksZj1IdShpKSxzPTEvMCxoPVtdO28tLTspe3ZhciBwPW5bb107byYmdCYmKHA9bChwLFModCkpKSxzPU1pKHAubGVuZ3RoLHMpLGZbb109IXImJih0fHwxMjA8PXUmJjEyMDw9cC5sZW5ndGgpP25ldyBxbihvJiZwKTpGfXZhciBwPW5bMF0sXz0tMSx2PWZbMF07bjpmb3IoOysrXzx1JiZoLmxlbmd0aDxzOyl7dmFyIGc9cFtfXSxkPXQ/dChnKTpnLGc9cnx8MCE9PWc/ZzowO1xuaWYodj8hUih2LGQpOiFlKGgsZCxyKSl7Zm9yKG89aTstLW87KXt2YXIgeT1mW29dO2lmKHk/IVIoeSxkKTohZShuW29dLGQscikpY29udGludWUgbn12JiZ2LnB1c2goZCksaC5wdXNoKGcpfX1yZXR1cm4gaH1mdW5jdGlvbiBDdChuLHQscil7dmFyIGU9e307cmV0dXJuIEV0KG4sZnVuY3Rpb24obix1LGkpe3QoZSxyKG4pLHUsaSl9KSxlfWZ1bmN0aW9uIER0KG4sdCxlKXtyZXR1cm4gdD1Scih0LG4pLG49Mj50Lmxlbmd0aD9uOkl0KG4sdnIodCwwLC0xKSksdD1udWxsPT1uP246blskZShHZSh0KSldLG51bGw9PXQ/RjpyKHQsbixlKX1mdW5jdGlvbiBNdChuKXtyZXR1cm4geHUobikmJlwiW29iamVjdCBBcmd1bWVudHNdXCI9PXp0KG4pfWZ1bmN0aW9uIFR0KG4pe3JldHVybiB4dShuKSYmXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiPT16dChuKX1mdW5jdGlvbiAkdChuKXtyZXR1cm4geHUobikmJlwiW29iamVjdCBEYXRlXVwiPT16dChuKX1mdW5jdGlvbiBGdChuLHQscixlLHUpe2lmKG49PT10KXQ9dHJ1ZTtlbHNlIGlmKG51bGw9PW58fG51bGw9PXR8fCF4dShuKSYmIXh1KHQpKXQ9biE9PW4mJnQhPT10O2Vsc2Ugbjp7XG52YXIgaT1hZihuKSxvPWFmKHQpLGY9aT9cIltvYmplY3QgQXJyYXldXCI6eW8obiksYz1vP1wiW29iamVjdCBBcnJheV1cIjp5byh0KSxmPVwiW29iamVjdCBBcmd1bWVudHNdXCI9PWY/XCJbb2JqZWN0IE9iamVjdF1cIjpmLGM9XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09Yz9cIltvYmplY3QgT2JqZWN0XVwiOmMsYT1cIltvYmplY3QgT2JqZWN0XVwiPT1mLG89XCJbb2JqZWN0IE9iamVjdF1cIj09YztpZigoYz1mPT1jKSYmc2Yobikpe2lmKCFzZih0KSl7dD1mYWxzZTticmVhayBufWk9dHJ1ZSxhPWZhbHNlfWlmKGMmJiFhKXV8fCh1PW5ldyBWbiksdD1pfHxnZihuKT9fZShuLHQscixlLEZ0LHUpOnZlKG4sdCxmLHIsZSxGdCx1KTtlbHNle2lmKCEoMSZyKSYmKGk9YSYmY2kuY2FsbChuLFwiX193cmFwcGVkX19cIiksZj1vJiZjaS5jYWxsKHQsXCJfX3dyYXBwZWRfX1wiKSxpfHxmKSl7bj1pP24udmFsdWUoKTpuLHQ9Zj90LnZhbHVlKCk6dCx1fHwodT1uZXcgVm4pLHQ9RnQobix0LHIsZSx1KTticmVhayBufWlmKGMpdDppZih1fHwodT1uZXcgVm4pLFxuaT0xJnIsZj1kZShuKSxvPWYubGVuZ3RoLGM9ZGUodCkubGVuZ3RoLG89PWN8fGkpe2ZvcihhPW87YS0tOyl7dmFyIGw9ZlthXTtpZighKGk/bCBpbiB0OmNpLmNhbGwodCxsKSkpe3Q9ZmFsc2U7YnJlYWsgdH19aWYoKGM9dS5nZXQobikpJiZ1LmdldCh0KSl0PWM9PXQ7ZWxzZXtjPXRydWUsdS5zZXQobix0KSx1LnNldCh0LG4pO2Zvcih2YXIgcz1pOysrYTxvOyl7dmFyIGw9ZlthXSxoPW5bbF0scD10W2xdO2lmKGUpdmFyIF89aT9lKHAsaCxsLHQsbix1KTplKGgscCxsLG4sdCx1KTtpZihfPT09Rj9oIT09cCYmIUZ0KGgscCxyLGUsdSk6IV8pe2M9ZmFsc2U7YnJlYWt9c3x8KHM9XCJjb25zdHJ1Y3RvclwiPT1sKX1jJiYhcyYmKHI9bi5jb25zdHJ1Y3RvcixlPXQuY29uc3RydWN0b3IsciE9ZSYmXCJjb25zdHJ1Y3RvclwiaW4gbiYmXCJjb25zdHJ1Y3RvclwiaW4gdCYmISh0eXBlb2Ygcj09XCJmdW5jdGlvblwiJiZyIGluc3RhbmNlb2YgciYmdHlwZW9mIGU9PVwiZnVuY3Rpb25cIiYmZSBpbnN0YW5jZW9mIGUpJiYoYz1mYWxzZSkpLFxudS5kZWxldGUobiksdS5kZWxldGUodCksdD1jfX1lbHNlIHQ9ZmFsc2U7ZWxzZSB0PWZhbHNlfX1yZXR1cm4gdH1mdW5jdGlvbiBOdChuKXtyZXR1cm4geHUobikmJlwiW29iamVjdCBNYXBdXCI9PXlvKG4pfWZ1bmN0aW9uIFB0KG4sdCxyLGUpe3ZhciB1PXIubGVuZ3RoLGk9dSxvPSFlO2lmKG51bGw9PW4pcmV0dXJuIWk7Zm9yKG49bmkobik7dS0tOyl7dmFyIGY9clt1XTtpZihvJiZmWzJdP2ZbMV0hPT1uW2ZbMF1dOiEoZlswXWluIG4pKXJldHVybiBmYWxzZX1mb3IoOysrdTxpOyl7dmFyIGY9clt1XSxjPWZbMF0sYT1uW2NdLGw9ZlsxXTtpZihvJiZmWzJdKXtpZihhPT09RiYmIShjIGluIG4pKXJldHVybiBmYWxzZX1lbHNle2lmKGY9bmV3IFZuLGUpdmFyIHM9ZShhLGwsYyxuLHQsZik7aWYocz09PUY/IUZ0KGwsYSwzLGUsZik6IXMpcmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiBadChuKXtyZXR1cm4hKCFidShuKXx8bGkmJmxpIGluIG4pJiYoZ3Uobik/X2k6eG4pLnRlc3QoRmUobikpfWZ1bmN0aW9uIHF0KG4pe1xucmV0dXJuIHh1KG4pJiZcIltvYmplY3QgUmVnRXhwXVwiPT16dChuKX1mdW5jdGlvbiBWdChuKXtyZXR1cm4geHUobikmJlwiW29iamVjdCBTZXRdXCI9PXlvKG4pfWZ1bmN0aW9uIEt0KG4pe3JldHVybiB4dShuKSYmeXUobi5sZW5ndGgpJiYhIUNuW3p0KG4pXX1mdW5jdGlvbiBHdChuKXtyZXR1cm4gdHlwZW9mIG49PVwiZnVuY3Rpb25cIj9uOm51bGw9PW4/TnU6dHlwZW9mIG49PVwib2JqZWN0XCI/YWYobik/WHQoblswXSxuWzFdKTpRdChuKTpWdShuKX1mdW5jdGlvbiBIdChuKXtpZighTGUobikpcmV0dXJuIENpKG4pO3ZhciB0LHI9W107Zm9yKHQgaW4gbmkobikpY2kuY2FsbChuLHQpJiZcImNvbnN0cnVjdG9yXCIhPXQmJnIucHVzaCh0KTtyZXR1cm4gcn1mdW5jdGlvbiBKdChuLHQpe3JldHVybiBuPHR9ZnVuY3Rpb24gWXQobix0KXt2YXIgcj0tMSxlPXB1KG4pP0h1KG4ubGVuZ3RoKTpbXTtyZXR1cm4gb28obixmdW5jdGlvbihuLHUsaSl7ZVsrK3JdPXQobix1LGkpfSksZX1mdW5jdGlvbiBRdChuKXtcbnZhciB0PW1lKG4pO3JldHVybiAxPT10Lmxlbmd0aCYmdFswXVsyXT9VZSh0WzBdWzBdLHRbMF1bMV0pOmZ1bmN0aW9uKHIpe3JldHVybiByPT09bnx8UHQocixuLHQpfX1mdW5jdGlvbiBYdChuLHQpe3JldHVybiBXZShuKSYmdD09PXQmJiFidSh0KT9VZSgkZShuKSx0KTpmdW5jdGlvbihyKXt2YXIgZT1XdShyLG4pO3JldHVybiBlPT09RiYmZT09PXQ/QnUocixuKTpGdCh0LGUsMyl9fWZ1bmN0aW9uIG5yKG4sdCxyLGUsdSl7biE9PXQmJmNvKHQsZnVuY3Rpb24oaSxvKXtpZihidShpKSl7dXx8KHU9bmV3IFZuKTt2YXIgZj11LGM9bltvXSxhPXRbb10sbD1mLmdldChhKTtpZihsKWN0KG4sbyxsKTtlbHNle3ZhciBsPWU/ZShjLGEsbytcIlwiLG4sdCxmKTpGLHM9bD09PUY7aWYocyl7dmFyIGg9YWYoYSkscD0haCYmc2YoYSksXz0haCYmIXAmJmdmKGEpLGw9YTtofHxwfHxfP2FmKGMpP2w9YzpfdShjKT9sPU1yKGMpOnA/KHM9ZmFsc2UsbD1XcihhLHRydWUpKTpfPyhzPWZhbHNlLGw9THIoYSx0cnVlKSk6bD1bXTp3dShhKXx8Y2YoYSk/KGw9YyxcbmNmKGMpP2w9UnUoYyk6KCFidShjKXx8ciYmZ3UoYykpJiYobD1PZShhKSkpOnM9ZmFsc2V9cyYmKGYuc2V0KGEsbCksbnIobCxhLHIsZSxmKSxmLmRlbGV0ZShhKSksY3QobixvLGwpfX1lbHNlIGY9ZT9lKG5bb10saSxvK1wiXCIsbix0LHUpOkYsZj09PUYmJihmPWkpLGN0KG4sbyxmKX0sVXUpfWZ1bmN0aW9uIHRyKG4sdCl7dmFyIHI9bi5sZW5ndGg7aWYocilyZXR1cm4gdCs9MD50P3I6MCxSZSh0LHIpP25bdF06Rn1mdW5jdGlvbiBycihuLHQscil7dmFyIGU9LTE7cmV0dXJuIHQ9bCh0Lmxlbmd0aD90OltOdV0sUyhqZSgpKSksbj1ZdChuLGZ1bmN0aW9uKG4pe3JldHVybnthOmwodCxmdW5jdGlvbih0KXtyZXR1cm4gdChuKX0pLGI6KytlLGM6bn19KSxBKG4sZnVuY3Rpb24obix0KXt2YXIgZTtuOntlPS0xO2Zvcih2YXIgdT1uLmEsaT10LmEsbz11Lmxlbmd0aCxmPXIubGVuZ3RoOysrZTxvOyl7dmFyIGM9VXIodVtlXSxpW2VdKTtpZihjKXtlPWU+PWY/YzpjKihcImRlc2NcIj09cltlXT8tMToxKTtcbmJyZWFrIG59fWU9bi5iLXQuYn1yZXR1cm4gZX0pfWZ1bmN0aW9uIGVyKG4sdCl7cmV0dXJuIHVyKG4sdCxmdW5jdGlvbih0LHIpe3JldHVybiBCdShuLHIpfSl9ZnVuY3Rpb24gdXIobix0LHIpe2Zvcih2YXIgZT0tMSx1PXQubGVuZ3RoLGk9e307KytlPHU7KXt2YXIgbz10W2VdLGY9SXQobixvKTtyKGYsbykmJnByKGksUnIobyxuKSxmKX1yZXR1cm4gaX1mdW5jdGlvbiBpcihuKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIEl0KHQsbil9fWZ1bmN0aW9uIG9yKG4sdCxyLGUpe3ZhciB1PWU/eTpkLGk9LTEsbz10Lmxlbmd0aCxmPW47Zm9yKG49PT10JiYodD1Ncih0KSksciYmKGY9bChuLFMocikpKTsrK2k8bzspZm9yKHZhciBjPTAsYT10W2ldLGE9cj9yKGEpOmE7LTE8KGM9dShmLGEsYyxlKSk7KWYhPT1uJiZ3aS5jYWxsKGYsYywxKSx3aS5jYWxsKG4sYywxKTtyZXR1cm4gbn1mdW5jdGlvbiBmcihuLHQpe2Zvcih2YXIgcj1uP3QubGVuZ3RoOjAsZT1yLTE7ci0tOyl7dmFyIHU9dFtyXTtcbmlmKHI9PWV8fHUhPT1pKXt2YXIgaT11O1JlKHUpP3dpLmNhbGwobix1LDEpOm1yKG4sdSl9fX1mdW5jdGlvbiBjcihuLHQpe3JldHVybiBuK3ppKEZpKCkqKHQtbisxKSl9ZnVuY3Rpb24gYXIobix0KXt2YXIgcj1cIlwiO2lmKCFufHwxPnR8fDkwMDcxOTkyNTQ3NDA5OTE8dClyZXR1cm4gcjtkbyB0JTImJihyKz1uKSwodD16aSh0LzIpKSYmKG4rPW4pO3doaWxlKHQpO3JldHVybiByfWZ1bmN0aW9uIGxyKG4sdCl7cmV0dXJuIHdvKENlKG4sdCxOdSksbitcIlwiKX1mdW5jdGlvbiBzcihuKXtyZXR1cm4gdHQoRHUobikpfWZ1bmN0aW9uIGhyKG4sdCl7dmFyIHI9RHUobik7cmV0dXJuIFRlKHIsZ3QodCwwLHIubGVuZ3RoKSl9ZnVuY3Rpb24gcHIobix0LHIsZSl7aWYoIWJ1KG4pKXJldHVybiBuO3Q9UnIodCxuKTtmb3IodmFyIHU9LTEsaT10Lmxlbmd0aCxvPWktMSxmPW47bnVsbCE9ZiYmKyt1PGk7KXt2YXIgYz0kZSh0W3VdKSxhPXI7aWYodSE9byl7dmFyIGw9ZltjXSxhPWU/ZShsLGMsZik6RjtcbmE9PT1GJiYoYT1idShsKT9sOlJlKHRbdSsxXSk/W106e30pfWF0KGYsYyxhKSxmPWZbY119cmV0dXJuIG59ZnVuY3Rpb24gX3Iobil7cmV0dXJuIFRlKER1KG4pKX1mdW5jdGlvbiB2cihuLHQscil7dmFyIGU9LTEsdT1uLmxlbmd0aDtmb3IoMD50JiYodD0tdD51PzA6dSt0KSxyPXI+dT91OnIsMD5yJiYocis9dSksdT10PnI/MDpyLXQ+Pj4wLHQ+Pj49MCxyPUh1KHUpOysrZTx1OylyW2VdPW5bZSt0XTtyZXR1cm4gcn1mdW5jdGlvbiBncihuLHQpe3ZhciByO3JldHVybiBvbyhuLGZ1bmN0aW9uKG4sZSx1KXtyZXR1cm4gcj10KG4sZSx1KSwhcn0pLCEhcn1mdW5jdGlvbiBkcihuLHQscil7dmFyIGU9MCx1PW51bGw9PW4/ZTpuLmxlbmd0aDtpZih0eXBlb2YgdD09XCJudW1iZXJcIiYmdD09PXQmJjIxNDc0ODM2NDc+PXUpe2Zvcig7ZTx1Oyl7dmFyIGk9ZSt1Pj4+MSxvPW5baV07bnVsbCE9PW8mJiFBdShvKSYmKHI/bzw9dDpvPHQpP2U9aSsxOnU9aX1yZXR1cm4gdX1yZXR1cm4geXIobix0LE51LHIpO1xufWZ1bmN0aW9uIHlyKG4sdCxyLGUpe3Q9cih0KTtmb3IodmFyIHU9MCxpPW51bGw9PW4/MDpuLmxlbmd0aCxvPXQhPT10LGY9bnVsbD09PXQsYz1BdSh0KSxhPXQ9PT1GO3U8aTspe3ZhciBsPXppKCh1K2kpLzIpLHM9cihuW2xdKSxoPXMhPT1GLHA9bnVsbD09PXMsXz1zPT09cyx2PUF1KHMpOyhvP2V8fF86YT9fJiYoZXx8aCk6Zj9fJiZoJiYoZXx8IXApOmM/XyYmaCYmIXAmJihlfHwhdik6cHx8dj8wOmU/czw9dDpzPHQpP3U9bCsxOmk9bH1yZXR1cm4gTWkoaSw0Mjk0OTY3Mjk0KX1mdW5jdGlvbiBicihuLHQpe2Zvcih2YXIgcj0tMSxlPW4ubGVuZ3RoLHU9MCxpPVtdOysrcjxlOyl7dmFyIG89bltyXSxmPXQ/dChvKTpvO2lmKCFyfHwhaHUoZixjKSl7dmFyIGM9ZjtpW3UrK109MD09PW8/MDpvfX1yZXR1cm4gaX1mdW5jdGlvbiB4cihuKXtyZXR1cm4gdHlwZW9mIG49PVwibnVtYmVyXCI/bjpBdShuKT9QOitufWZ1bmN0aW9uIGpyKG4pe2lmKHR5cGVvZiBuPT1cInN0cmluZ1wiKXJldHVybiBuO1xuaWYoYWYobikpcmV0dXJuIGwobixqcikrXCJcIjtpZihBdShuKSlyZXR1cm4gdW8/dW8uY2FsbChuKTpcIlwiO3ZhciB0PW4rXCJcIjtyZXR1cm5cIjBcIj09dCYmMS9uPT0tTj9cIi0wXCI6dH1mdW5jdGlvbiB3cihuLHQscil7dmFyIGU9LTEsdT1jLGk9bi5sZW5ndGgsbz10cnVlLGY9W10sbD1mO2lmKHIpbz1mYWxzZSx1PWE7ZWxzZSBpZigyMDA8PWkpe2lmKHU9dD9udWxsOnBvKG4pKXJldHVybiBEKHUpO289ZmFsc2UsdT1SLGw9bmV3IHFufWVsc2UgbD10P1tdOmY7bjpmb3IoOysrZTxpOyl7dmFyIHM9bltlXSxoPXQ/dChzKTpzLHM9cnx8MCE9PXM/czowO2lmKG8mJmg9PT1oKXtmb3IodmFyIHA9bC5sZW5ndGg7cC0tOylpZihsW3BdPT09aCljb250aW51ZSBuO3QmJmwucHVzaChoKSxmLnB1c2gocyl9ZWxzZSB1KGwsaCxyKXx8KGwhPT1mJiZsLnB1c2goaCksZi5wdXNoKHMpKX1yZXR1cm4gZn1mdW5jdGlvbiBtcihuLHQpe3JldHVybiB0PVJyKHQsbiksbj0yPnQubGVuZ3RoP246SXQobix2cih0LDAsLTEpKSxcbm51bGw9PW58fGRlbGV0ZSBuWyRlKEdlKHQpKV19ZnVuY3Rpb24gQXIobix0LHIsZSl7Zm9yKHZhciB1PW4ubGVuZ3RoLGk9ZT91Oi0xOyhlP2ktLTorK2k8dSkmJnQobltpXSxpLG4pOyk7cmV0dXJuIHI/dnIobixlPzA6aSxlP2krMTp1KTp2cihuLGU/aSsxOjAsZT91OmkpfWZ1bmN0aW9uIGtyKG4sdCl7dmFyIHI9bjtyZXR1cm4gciBpbnN0YW5jZW9mIE1uJiYocj1yLnZhbHVlKCkpLGgodCxmdW5jdGlvbihuLHQpe3JldHVybiB0LmZ1bmMuYXBwbHkodC50aGlzQXJnLHMoW25dLHQuYXJncykpfSxyKX1mdW5jdGlvbiBFcihuLHQscil7dmFyIGU9bi5sZW5ndGg7aWYoMj5lKXJldHVybiBlP3dyKG5bMF0pOltdO2Zvcih2YXIgdT0tMSxpPUh1KGUpOysrdTxlOylmb3IodmFyIG89blt1XSxmPS0xOysrZjxlOylmIT11JiYoaVt1XT1qdChpW3VdfHxvLG5bZl0sdCxyKSk7cmV0dXJuIHdyKGt0KGksMSksdCxyKX1mdW5jdGlvbiBPcihuLHQscil7Zm9yKHZhciBlPS0xLHU9bi5sZW5ndGgsaT10Lmxlbmd0aCxvPXt9OysrZTx1OylyKG8sbltlXSxlPGk/dFtlXTpGKTtcbnJldHVybiBvfWZ1bmN0aW9uIFNyKG4pe3JldHVybiBfdShuKT9uOltdfWZ1bmN0aW9uIElyKG4pe3JldHVybiB0eXBlb2Ygbj09XCJmdW5jdGlvblwiP246TnV9ZnVuY3Rpb24gUnIobix0KXtyZXR1cm4gYWYobik/bjpXZShuLHQpP1tuXTptbyh6dShuKSl9ZnVuY3Rpb24genIobix0LHIpe3ZhciBlPW4ubGVuZ3RoO3JldHVybiByPXI9PT1GP2U6ciwhdCYmcj49ZT9uOnZyKG4sdCxyKX1mdW5jdGlvbiBXcihuLHQpe2lmKHQpcmV0dXJuIG4uc2xpY2UoKTt2YXIgcj1uLmxlbmd0aCxyPXlpP3lpKHIpOm5ldyBuLmNvbnN0cnVjdG9yKHIpO3JldHVybiBuLmNvcHkocikscn1mdW5jdGlvbiBCcihuKXt2YXIgdD1uZXcgbi5jb25zdHJ1Y3RvcihuLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgZGkodCkuc2V0KG5ldyBkaShuKSksdH1mdW5jdGlvbiBMcihuLHQpe3JldHVybiBuZXcgbi5jb25zdHJ1Y3Rvcih0P0JyKG4uYnVmZmVyKTpuLmJ1ZmZlcixuLmJ5dGVPZmZzZXQsbi5sZW5ndGgpfWZ1bmN0aW9uIFVyKG4sdCl7XG5pZihuIT09dCl7dmFyIHI9biE9PUYsZT1udWxsPT09bix1PW49PT1uLGk9QXUobiksbz10IT09RixmPW51bGw9PT10LGM9dD09PXQsYT1BdSh0KTtpZighZiYmIWEmJiFpJiZuPnR8fGkmJm8mJmMmJiFmJiYhYXx8ZSYmbyYmY3x8IXImJmN8fCF1KXJldHVybiAxO2lmKCFlJiYhaSYmIWEmJm48dHx8YSYmciYmdSYmIWUmJiFpfHxmJiZyJiZ1fHwhbyYmdXx8IWMpcmV0dXJuLTF9cmV0dXJuIDB9ZnVuY3Rpb24gQ3Iobix0LHIsZSl7dmFyIHU9LTEsaT1uLmxlbmd0aCxvPXIubGVuZ3RoLGY9LTEsYz10Lmxlbmd0aCxhPURpKGktbywwKSxsPUh1KGMrYSk7Zm9yKGU9IWU7KytmPGM7KWxbZl09dFtmXTtmb3IoOysrdTxvOykoZXx8dTxpKSYmKGxbclt1XV09blt1XSk7Zm9yKDthLS07KWxbZisrXT1uW3UrK107cmV0dXJuIGx9ZnVuY3Rpb24gRHIobix0LHIsZSl7dmFyIHU9LTEsaT1uLmxlbmd0aCxvPS0xLGY9ci5sZW5ndGgsYz0tMSxhPXQubGVuZ3RoLGw9RGkoaS1mLDApLHM9SHUobCthKTtcbmZvcihlPSFlOysrdTxsOylzW3VdPW5bdV07Zm9yKGw9dTsrK2M8YTspc1tsK2NdPXRbY107Zm9yKDsrK288ZjspKGV8fHU8aSkmJihzW2wrcltvXV09blt1KytdKTtyZXR1cm4gc31mdW5jdGlvbiBNcihuLHQpe3ZhciByPS0xLGU9bi5sZW5ndGg7Zm9yKHR8fCh0PUh1KGUpKTsrK3I8ZTspdFtyXT1uW3JdO3JldHVybiB0fWZ1bmN0aW9uIFRyKG4sdCxyLGUpe3ZhciB1PSFyO3J8fChyPXt9KTtmb3IodmFyIGk9LTEsbz10Lmxlbmd0aDsrK2k8bzspe3ZhciBmPXRbaV0sYz1lP2UocltmXSxuW2ZdLGYscixuKTpGO2M9PT1GJiYoYz1uW2ZdKSx1P190KHIsZixjKTphdChyLGYsYyl9cmV0dXJuIHJ9ZnVuY3Rpb24gJHIobix0KXtyZXR1cm4gVHIobix2byhuKSx0KX1mdW5jdGlvbiBGcihuLHQpe3JldHVybiBUcihuLGdvKG4pLHQpfWZ1bmN0aW9uIE5yKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIsdSl7dmFyIGk9YWYocik/ZTpzdCxvPXQ/dCgpOnt9O3JldHVybiBpKHIsbixqZSh1LDIpLG8pO1xufX1mdW5jdGlvbiBQcihuKXtyZXR1cm4gbHIoZnVuY3Rpb24odCxyKXt2YXIgZT0tMSx1PXIubGVuZ3RoLGk9MTx1P3JbdS0xXTpGLG89Mjx1P3JbMl06RixpPTM8bi5sZW5ndGgmJnR5cGVvZiBpPT1cImZ1bmN0aW9uXCI/KHUtLSxpKTpGO2ZvcihvJiZ6ZShyWzBdLHJbMV0sbykmJihpPTM+dT9GOmksdT0xKSx0PW5pKHQpOysrZTx1Oykobz1yW2VdKSYmbih0LG8sZSxpKTtyZXR1cm4gdH0pfWZ1bmN0aW9uIFpyKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIsZSl7aWYobnVsbD09cilyZXR1cm4gcjtpZighcHUocikpcmV0dXJuIG4ocixlKTtmb3IodmFyIHU9ci5sZW5ndGgsaT10P3U6LTEsbz1uaShyKTsodD9pLS06KytpPHUpJiZmYWxzZSE9PWUob1tpXSxpLG8pOyk7cmV0dXJuIHJ9fWZ1bmN0aW9uIHFyKG4pe3JldHVybiBmdW5jdGlvbih0LHIsZSl7dmFyIHU9LTEsaT1uaSh0KTtlPWUodCk7Zm9yKHZhciBvPWUubGVuZ3RoO28tLTspe3ZhciBmPWVbbj9vOisrdV07aWYoZmFsc2U9PT1yKGlbZl0sZixpKSlicmVhaztcbn1yZXR1cm4gdH19ZnVuY3Rpb24gVnIobix0LHIpe2Z1bmN0aW9uIGUoKXtyZXR1cm4odGhpcyYmdGhpcyE9PVpuJiZ0aGlzIGluc3RhbmNlb2YgZT9pOm4pLmFwcGx5KHU/cjp0aGlzLGFyZ3VtZW50cyl9dmFyIHU9MSZ0LGk9SHIobik7cmV0dXJuIGV9ZnVuY3Rpb24gS3Iobil7cmV0dXJuIGZ1bmN0aW9uKHQpe3Q9enUodCk7dmFyIHI9Qm4udGVzdCh0KT8kKHQpOkYsZT1yP3JbMF06dC5jaGFyQXQoMCk7cmV0dXJuIHQ9cj96cihyLDEpLmpvaW4oXCJcIik6dC5zbGljZSgxKSxlW25dKCkrdH19ZnVuY3Rpb24gR3Iobil7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBoKCR1KFR1KHQpLnJlcGxhY2UoSW4sXCJcIikpLG4sXCJcIil9fWZ1bmN0aW9uIEhyKG4pe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cztzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IG47Y2FzZSAxOnJldHVybiBuZXcgbih0WzBdKTtjYXNlIDI6cmV0dXJuIG5ldyBuKHRbMF0sdFsxXSk7Y2FzZSAzOlxucmV0dXJuIG5ldyBuKHRbMF0sdFsxXSx0WzJdKTtjYXNlIDQ6cmV0dXJuIG5ldyBuKHRbMF0sdFsxXSx0WzJdLHRbM10pO2Nhc2UgNTpyZXR1cm4gbmV3IG4odFswXSx0WzFdLHRbMl0sdFszXSx0WzRdKTtjYXNlIDY6cmV0dXJuIG5ldyBuKHRbMF0sdFsxXSx0WzJdLHRbM10sdFs0XSx0WzVdKTtjYXNlIDc6cmV0dXJuIG5ldyBuKHRbMF0sdFsxXSx0WzJdLHRbM10sdFs0XSx0WzVdLHRbNl0pfXZhciByPWlvKG4ucHJvdG90eXBlKSx0PW4uYXBwbHkocix0KTtyZXR1cm4gYnUodCk/dDpyfX1mdW5jdGlvbiBKcihuLHQsZSl7ZnVuY3Rpb24gdSgpe2Zvcih2YXIgbz1hcmd1bWVudHMubGVuZ3RoLGY9SHUobyksYz1vLGE9eGUodSk7Yy0tOylmW2NdPWFyZ3VtZW50c1tjXTtyZXR1cm4gYz0zPm8mJmZbMF0hPT1hJiZmW28tMV0hPT1hP1tdOkMoZixhKSxvLT1jLmxlbmd0aCxvPGU/ZmUobix0LFhyLHUucGxhY2Vob2xkZXIsRixmLGMsRixGLGUtbyk6cih0aGlzJiZ0aGlzIT09Wm4mJnRoaXMgaW5zdGFuY2VvZiB1P2k6bix0aGlzLGYpO1xufXZhciBpPUhyKG4pO3JldHVybiB1fWZ1bmN0aW9uIFlyKG4pe3JldHVybiBmdW5jdGlvbih0LHIsZSl7dmFyIHU9bmkodCk7aWYoIXB1KHQpKXt2YXIgaT1qZShyLDMpO3Q9THUodCkscj1mdW5jdGlvbihuKXtyZXR1cm4gaSh1W25dLG4sdSl9fXJldHVybiByPW4odCxyLGUpLC0xPHI/dVtpP3Rbcl06cl06Rn19ZnVuY3Rpb24gUXIobil7cmV0dXJuIGdlKGZ1bmN0aW9uKHQpe3ZhciByPXQubGVuZ3RoLGU9cix1PXpuLnByb3RvdHlwZS50aHJ1O2ZvcihuJiZ0LnJldmVyc2UoKTtlLS07KXt2YXIgaT10W2VdO2lmKHR5cGVvZiBpIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IGVpKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtpZih1JiYhbyYmXCJ3cmFwcGVyXCI9PWJlKGkpKXZhciBvPW5ldyB6bihbXSx0cnVlKX1mb3IoZT1vP2U6cjsrK2U8cjspdmFyIGk9dFtlXSx1PWJlKGkpLGY9XCJ3cmFwcGVyXCI9PXU/X28oaSk6RixvPWYmJkJlKGZbMF0pJiY0MjQ9PWZbMV0mJiFmWzRdLmxlbmd0aCYmMT09Zls5XT9vW2JlKGZbMF0pXS5hcHBseShvLGZbM10pOjE9PWkubGVuZ3RoJiZCZShpKT9vW3VdKCk6by50aHJ1KGkpO1xucmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49YXJndW1lbnRzLGU9blswXTtpZihvJiYxPT1uLmxlbmd0aCYmYWYoZSkpcmV0dXJuIG8ucGxhbnQoZSkudmFsdWUoKTtmb3IodmFyIHU9MCxuPXI/dFt1XS5hcHBseSh0aGlzLG4pOmU7Kyt1PHI7KW49dFt1XS5jYWxsKHRoaXMsbik7cmV0dXJuIG59fSl9ZnVuY3Rpb24gWHIobix0LHIsZSx1LGksbyxmLGMsYSl7ZnVuY3Rpb24gbCgpe2Zvcih2YXIgZD1hcmd1bWVudHMubGVuZ3RoLHk9SHUoZCksYj1kO2ItLTspeVtiXT1hcmd1bWVudHNbYl07aWYoXyl7dmFyIHgsaj14ZShsKSxiPXkubGVuZ3RoO2Zvcih4PTA7Yi0tOyl5W2JdPT09aiYmKyt4fWlmKGUmJih5PUNyKHksZSx1LF8pKSxpJiYoeT1Ecih5LGksbyxfKSksZC09eCxfJiZkPGEpcmV0dXJuIGo9Qyh5LGopLGZlKG4sdCxYcixsLnBsYWNlaG9sZGVyLHIseSxqLGYsYyxhLWQpO2lmKGo9aD9yOnRoaXMsYj1wP2pbbl06bixkPXkubGVuZ3RoLGYpe3g9eS5sZW5ndGg7Zm9yKHZhciB3PU1pKGYubGVuZ3RoLHgpLG09TXIoeSk7dy0tOyl7XG52YXIgQT1mW3ddO3lbd109UmUoQSx4KT9tW0FdOkZ9fWVsc2UgdiYmMTxkJiZ5LnJldmVyc2UoKTtyZXR1cm4gcyYmYzxkJiYoeS5sZW5ndGg9YyksdGhpcyYmdGhpcyE9PVpuJiZ0aGlzIGluc3RhbmNlb2YgbCYmKGI9Z3x8SHIoYikpLGIuYXBwbHkoaix5KX12YXIgcz0xMjgmdCxoPTEmdCxwPTImdCxfPTI0JnQsdj01MTImdCxnPXA/RjpIcihuKTtyZXR1cm4gbH1mdW5jdGlvbiBuZShuLHQpe3JldHVybiBmdW5jdGlvbihyLGUpe3JldHVybiBDdChyLG4sdChlKSl9fWZ1bmN0aW9uIHRlKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIsZSl7dmFyIHU7aWYocj09PUYmJmU9PT1GKXJldHVybiB0O2lmKHIhPT1GJiYodT1yKSxlIT09Ril7aWYodT09PUYpcmV0dXJuIGU7dHlwZW9mIHI9PVwic3RyaW5nXCJ8fHR5cGVvZiBlPT1cInN0cmluZ1wiPyhyPWpyKHIpLGU9anIoZSkpOihyPXhyKHIpLGU9eHIoZSkpLHU9bihyLGUpfXJldHVybiB1fX1mdW5jdGlvbiByZShuKXtyZXR1cm4gZ2UoZnVuY3Rpb24odCl7XG5yZXR1cm4gdD1sKHQsUyhqZSgpKSksbHIoZnVuY3Rpb24oZSl7dmFyIHU9dGhpcztyZXR1cm4gbih0LGZ1bmN0aW9uKG4pe3JldHVybiByKG4sdSxlKX0pfSl9KX1mdW5jdGlvbiBlZShuLHQpe3Q9dD09PUY/XCIgXCI6anIodCk7dmFyIHI9dC5sZW5ndGg7cmV0dXJuIDI+cj9yP2FyKHQsbik6dDoocj1hcih0LFJpKG4vVCh0KSkpLEJuLnRlc3QodCk/enIoJChyKSwwLG4pLmpvaW4oXCJcIik6ci5zbGljZSgwLG4pKX1mdW5jdGlvbiB1ZShuLHQsZSx1KXtmdW5jdGlvbiBpKCl7Zm9yKHZhciB0PS0xLGM9YXJndW1lbnRzLmxlbmd0aCxhPS0xLGw9dS5sZW5ndGgscz1IdShsK2MpLGg9dGhpcyYmdGhpcyE9PVpuJiZ0aGlzIGluc3RhbmNlb2YgaT9mOm47KythPGw7KXNbYV09dVthXTtmb3IoO2MtLTspc1thKytdPWFyZ3VtZW50c1srK3RdO3JldHVybiByKGgsbz9lOnRoaXMscyl9dmFyIG89MSZ0LGY9SHIobik7cmV0dXJuIGl9ZnVuY3Rpb24gaWUobil7cmV0dXJuIGZ1bmN0aW9uKHQscixlKXtcbmUmJnR5cGVvZiBlIT1cIm51bWJlclwiJiZ6ZSh0LHIsZSkmJihyPWU9RiksdD1FdSh0KSxyPT09Rj8ocj10LHQ9MCk6cj1FdShyKSxlPWU9PT1GP3Q8cj8xOi0xOkV1KGUpO3ZhciB1PS0xO3I9RGkoUmkoKHItdCkvKGV8fDEpKSwwKTtmb3IodmFyIGk9SHUocik7ci0tOylpW24/cjorK3VdPXQsdCs9ZTtyZXR1cm4gaX19ZnVuY3Rpb24gb2Uobil7cmV0dXJuIGZ1bmN0aW9uKHQscil7cmV0dXJuIHR5cGVvZiB0PT1cInN0cmluZ1wiJiZ0eXBlb2Ygcj09XCJzdHJpbmdcInx8KHQ9SXUodCkscj1JdShyKSksbih0LHIpfX1mdW5jdGlvbiBmZShuLHQscixlLHUsaSxvLGYsYyxhKXt2YXIgbD04JnQscz1sP286RjtvPWw/RjpvO3ZhciBoPWw/aTpGO3JldHVybiBpPWw/RjppLHQ9KHR8KGw/MzI6NjQpKSZ+KGw/NjQ6MzIpLDQmdHx8KHQmPS00KSx1PVtuLHQsdSxoLHMsaSxvLGYsYyxhXSxyPXIuYXBwbHkoRix1KSxCZShuKSYmeG8ocix1KSxyLnBsYWNlaG9sZGVyPWUsRGUocixuLHQpfWZ1bmN0aW9uIGNlKG4pe1xudmFyIHQ9WHVbbl07cmV0dXJuIGZ1bmN0aW9uKG4scil7aWYobj1JdShuKSxyPW51bGw9PXI/MDpNaShPdShyKSwyOTIpKXt2YXIgZT0oenUobikrXCJlXCIpLnNwbGl0KFwiZVwiKSxlPXQoZVswXStcImVcIisoK2VbMV0rcikpLGU9KHp1KGUpK1wiZVwiKS5zcGxpdChcImVcIik7cmV0dXJuKyhlWzBdK1wiZVwiKygrZVsxXS1yKSl9cmV0dXJuIHQobil9fWZ1bmN0aW9uIGFlKG4pe3JldHVybiBmdW5jdGlvbih0KXt2YXIgcj15byh0KTtyZXR1cm5cIltvYmplY3QgTWFwXVwiPT1yP0wodCk6XCJbb2JqZWN0IFNldF1cIj09cj9NKHQpOk8odCxuKHQpKX19ZnVuY3Rpb24gbGUobix0LHIsZSx1LGksbyxmKXt2YXIgYz0yJnQ7aWYoIWMmJnR5cGVvZiBuIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IGVpKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTt2YXIgYT1lP2UubGVuZ3RoOjA7aWYoYXx8KHQmPS05NyxlPXU9Riksbz1vPT09Rj9vOkRpKE91KG8pLDApLGY9Zj09PUY/ZjpPdShmKSxhLT11P3UubGVuZ3RoOjAsNjQmdCl7XG52YXIgbD1lLHM9dTtlPXU9Rn12YXIgaD1jP0Y6X28obik7cmV0dXJuIGk9W24sdCxyLGUsdSxsLHMsaSxvLGZdLGgmJihyPWlbMV0sbj1oWzFdLHQ9cnxuLGU9MTI4PT1uJiY4PT1yfHwxMjg9PW4mJjI1Nj09ciYmaVs3XS5sZW5ndGg8PWhbOF18fDM4ND09biYmaFs3XS5sZW5ndGg8PWhbOF0mJjg9PXIsMTMxPnR8fGUpJiYoMSZuJiYoaVsyXT1oWzJdLHR8PTEmcj8wOjQpLChyPWhbM10pJiYoZT1pWzNdLGlbM109ZT9DcihlLHIsaFs0XSk6cixpWzRdPWU/QyhpWzNdLFwiX19sb2Rhc2hfcGxhY2Vob2xkZXJfX1wiKTpoWzRdKSwocj1oWzVdKSYmKGU9aVs1XSxpWzVdPWU/RHIoZSxyLGhbNl0pOnIsaVs2XT1lP0MoaVs1XSxcIl9fbG9kYXNoX3BsYWNlaG9sZGVyX19cIik6aFs2XSksKHI9aFs3XSkmJihpWzddPXIpLDEyOCZuJiYoaVs4XT1udWxsPT1pWzhdP2hbOF06TWkoaVs4XSxoWzhdKSksbnVsbD09aVs5XSYmKGlbOV09aFs5XSksaVswXT1oWzBdLGlbMV09dCksbj1pWzBdLHQ9aVsxXSxcbnI9aVsyXSxlPWlbM10sdT1pWzRdLGY9aVs5XT1pWzldPT09Rj9jPzA6bi5sZW5ndGg6RGkoaVs5XS1hLDApLCFmJiYyNCZ0JiYodCY9LTI1KSxEZSgoaD9sbzp4bykodCYmMSE9dD84PT10fHwxNj09dD9KcihuLHQsZik6MzIhPXQmJjMzIT10fHx1Lmxlbmd0aD9Yci5hcHBseShGLGkpOnVlKG4sdCxyLGUpOlZyKG4sdCxyKSxpKSxuLHQpfWZ1bmN0aW9uIHNlKG4sdCxyLGUpe3JldHVybiBuPT09Rnx8aHUobixpaVtyXSkmJiFjaS5jYWxsKGUscik/dDpufWZ1bmN0aW9uIGhlKG4sdCxyLGUsdSxpKXtyZXR1cm4gYnUobikmJmJ1KHQpJiYoaS5zZXQodCxuKSxucihuLHQsRixoZSxpKSxpLmRlbGV0ZSh0KSksbn1mdW5jdGlvbiBwZShuKXtyZXR1cm4gd3Uobik/RjpufWZ1bmN0aW9uIF9lKG4sdCxyLGUsdSxpKXt2YXIgbz0xJnIsZj1uLmxlbmd0aCxjPXQubGVuZ3RoO2lmKGYhPWMmJiEobyYmYz5mKSlyZXR1cm4gZmFsc2U7aWYoKGM9aS5nZXQobikpJiZpLmdldCh0KSlyZXR1cm4gYz09dDt2YXIgYz0tMSxhPXRydWUsbD0yJnI/bmV3IHFuOkY7XG5mb3IoaS5zZXQobix0KSxpLnNldCh0LG4pOysrYzxmOyl7dmFyIHM9bltjXSxoPXRbY107aWYoZSl2YXIgcD1vP2UoaCxzLGMsdCxuLGkpOmUocyxoLGMsbix0LGkpO2lmKHAhPT1GKXtpZihwKWNvbnRpbnVlO2E9ZmFsc2U7YnJlYWt9aWYobCl7aWYoIV8odCxmdW5jdGlvbihuLHQpe2lmKCFSKGwsdCkmJihzPT09bnx8dShzLG4scixlLGkpKSlyZXR1cm4gbC5wdXNoKHQpfSkpe2E9ZmFsc2U7YnJlYWt9fWVsc2UgaWYocyE9PWgmJiF1KHMsaCxyLGUsaSkpe2E9ZmFsc2U7YnJlYWt9fXJldHVybiBpLmRlbGV0ZShuKSxpLmRlbGV0ZSh0KSxhfWZ1bmN0aW9uIHZlKG4sdCxyLGUsdSxpLG8pe3N3aXRjaChyKXtjYXNlXCJbb2JqZWN0IERhdGFWaWV3XVwiOmlmKG4uYnl0ZUxlbmd0aCE9dC5ieXRlTGVuZ3RofHxuLmJ5dGVPZmZzZXQhPXQuYnl0ZU9mZnNldClicmVhaztuPW4uYnVmZmVyLHQ9dC5idWZmZXI7Y2FzZVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIjppZihuLmJ5dGVMZW5ndGghPXQuYnl0ZUxlbmd0aHx8IWkobmV3IGRpKG4pLG5ldyBkaSh0KSkpYnJlYWs7XG5yZXR1cm4gdHJ1ZTtjYXNlXCJbb2JqZWN0IEJvb2xlYW5dXCI6Y2FzZVwiW29iamVjdCBEYXRlXVwiOmNhc2VcIltvYmplY3QgTnVtYmVyXVwiOnJldHVybiBodSgrbiwrdCk7Y2FzZVwiW29iamVjdCBFcnJvcl1cIjpyZXR1cm4gbi5uYW1lPT10Lm5hbWUmJm4ubWVzc2FnZT09dC5tZXNzYWdlO2Nhc2VcIltvYmplY3QgUmVnRXhwXVwiOmNhc2VcIltvYmplY3QgU3RyaW5nXVwiOnJldHVybiBuPT10K1wiXCI7Y2FzZVwiW29iamVjdCBNYXBdXCI6dmFyIGY9TDtjYXNlXCJbb2JqZWN0IFNldF1cIjppZihmfHwoZj1EKSxuLnNpemUhPXQuc2l6ZSYmISgxJmUpKWJyZWFrO3JldHVybihyPW8uZ2V0KG4pKT9yPT10OihlfD0yLG8uc2V0KG4sdCksdD1fZShmKG4pLGYodCksZSx1LGksbyksby5kZWxldGUobiksdCk7Y2FzZVwiW29iamVjdCBTeW1ib2xdXCI6aWYoZW8pcmV0dXJuIGVvLmNhbGwobik9PWVvLmNhbGwodCl9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGdlKG4pe3JldHVybiB3byhDZShuLEYsVmUpLG4rXCJcIil9ZnVuY3Rpb24gZGUobil7XG5yZXR1cm4gUnQobixMdSx2byl9ZnVuY3Rpb24geWUobil7cmV0dXJuIFJ0KG4sVXUsZ28pfWZ1bmN0aW9uIGJlKG4pe2Zvcih2YXIgdD1uLm5hbWUrXCJcIixyPUppW3RdLGU9Y2kuY2FsbChKaSx0KT9yLmxlbmd0aDowO2UtLTspe3ZhciB1PXJbZV0saT11LmZ1bmM7aWYobnVsbD09aXx8aT09bilyZXR1cm4gdS5uYW1lfXJldHVybiB0fWZ1bmN0aW9uIHhlKG4pe3JldHVybihjaS5jYWxsKE9uLFwicGxhY2Vob2xkZXJcIik/T246bikucGxhY2Vob2xkZXJ9ZnVuY3Rpb24gamUoKXt2YXIgbj1Pbi5pdGVyYXRlZXx8UHUsbj1uPT09UHU/R3Q6bjtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD9uKGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pOm59ZnVuY3Rpb24gd2Uobix0KXt2YXIgcj1uLl9fZGF0YV9fLGU9dHlwZW9mIHQ7cmV0dXJuKFwic3RyaW5nXCI9PWV8fFwibnVtYmVyXCI9PWV8fFwic3ltYm9sXCI9PWV8fFwiYm9vbGVhblwiPT1lP1wiX19wcm90b19fXCIhPT10Om51bGw9PT10KT9yW3R5cGVvZiB0PT1cInN0cmluZ1wiP1wic3RyaW5nXCI6XCJoYXNoXCJdOnIubWFwO1xufWZ1bmN0aW9uIG1lKG4pe2Zvcih2YXIgdD1MdShuKSxyPXQubGVuZ3RoO3ItLTspe3ZhciBlPXRbcl0sdT1uW2VdO3Rbcl09W2UsdSx1PT09dSYmIWJ1KHUpXX1yZXR1cm4gdH1mdW5jdGlvbiBBZShuLHQpe3ZhciByPW51bGw9PW4/RjpuW3RdO3JldHVybiBadChyKT9yOkZ9ZnVuY3Rpb24ga2Uobix0LHIpe3Q9UnIodCxuKTtmb3IodmFyIGU9LTEsdT10Lmxlbmd0aCxpPWZhbHNlOysrZTx1Oyl7dmFyIG89JGUodFtlXSk7aWYoIShpPW51bGwhPW4mJnIobixvKSkpYnJlYWs7bj1uW29dfXJldHVybiBpfHwrK2UhPXU/aToodT1udWxsPT1uPzA6bi5sZW5ndGgsISF1JiZ5dSh1KSYmUmUobyx1KSYmKGFmKG4pfHxjZihuKSkpfWZ1bmN0aW9uIEVlKG4pe3ZhciB0PW4ubGVuZ3RoLHI9bi5jb25zdHJ1Y3Rvcih0KTtyZXR1cm4gdCYmXCJzdHJpbmdcIj09dHlwZW9mIG5bMF0mJmNpLmNhbGwobixcImluZGV4XCIpJiYoci5pbmRleD1uLmluZGV4LHIuaW5wdXQ9bi5pbnB1dCkscn1mdW5jdGlvbiBPZShuKXtcbnJldHVybiB0eXBlb2Ygbi5jb25zdHJ1Y3RvciE9XCJmdW5jdGlvblwifHxMZShuKT97fTppbyhiaShuKSl9ZnVuY3Rpb24gU2UocixlLHUsaSl7dmFyIG89ci5jb25zdHJ1Y3Rvcjtzd2l0Y2goZSl7Y2FzZVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIjpyZXR1cm4gQnIocik7Y2FzZVwiW29iamVjdCBCb29sZWFuXVwiOmNhc2VcIltvYmplY3QgRGF0ZV1cIjpyZXR1cm4gbmV3IG8oK3IpO2Nhc2VcIltvYmplY3QgRGF0YVZpZXddXCI6cmV0dXJuIGU9aT9CcihyLmJ1ZmZlcik6ci5idWZmZXIsbmV3IHIuY29uc3RydWN0b3IoZSxyLmJ5dGVPZmZzZXQsci5ieXRlTGVuZ3RoKTtjYXNlXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpjYXNlXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpjYXNlXCJbb2JqZWN0IEludDhBcnJheV1cIjpjYXNlXCJbb2JqZWN0IEludDE2QXJyYXldXCI6Y2FzZVwiW29iamVjdCBJbnQzMkFycmF5XVwiOmNhc2VcIltvYmplY3QgVWludDhBcnJheV1cIjpjYXNlXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuY2FzZVwiW29iamVjdCBVaW50MTZBcnJheV1cIjpjYXNlXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOnJldHVybiBMcihyLGkpO2Nhc2VcIltvYmplY3QgTWFwXVwiOnJldHVybiBlPWk/dShMKHIpLDEpOkwociksaChlLG4sbmV3IHIuY29uc3RydWN0b3IpO2Nhc2VcIltvYmplY3QgTnVtYmVyXVwiOmNhc2VcIltvYmplY3QgU3RyaW5nXVwiOnJldHVybiBuZXcgbyhyKTtjYXNlXCJbb2JqZWN0IFJlZ0V4cF1cIjpyZXR1cm4gZT1uZXcgci5jb25zdHJ1Y3RvcihyLnNvdXJjZSxkbi5leGVjKHIpKSxlLmxhc3RJbmRleD1yLmxhc3RJbmRleCxlO2Nhc2VcIltvYmplY3QgU2V0XVwiOnJldHVybiBlPWk/dShEKHIpLDEpOkQociksaChlLHQsbmV3IHIuY29uc3RydWN0b3IpO2Nhc2VcIltvYmplY3QgU3ltYm9sXVwiOnJldHVybiBlbz9uaShlby5jYWxsKHIpKTp7fX19ZnVuY3Rpb24gSWUobil7cmV0dXJuIGFmKG4pfHxjZihuKXx8ISEobWkmJm4mJm5bbWldKX1mdW5jdGlvbiBSZShuLHQpe3JldHVybiB0PW51bGw9PXQ/OTAwNzE5OTI1NDc0MDk5MTp0LFxuISF0JiYodHlwZW9mIG49PVwibnVtYmVyXCJ8fHduLnRlc3QobikpJiYtMTxuJiYwPT1uJTEmJm48dH1mdW5jdGlvbiB6ZShuLHQscil7aWYoIWJ1KHIpKXJldHVybiBmYWxzZTt2YXIgZT10eXBlb2YgdDtyZXR1cm4hIShcIm51bWJlclwiPT1lP3B1KHIpJiZSZSh0LHIubGVuZ3RoKTpcInN0cmluZ1wiPT1lJiZ0IGluIHIpJiZodShyW3RdLG4pfWZ1bmN0aW9uIFdlKG4sdCl7aWYoYWYobikpcmV0dXJuIGZhbHNlO3ZhciByPXR5cGVvZiBuO3JldHVybiEoXCJudW1iZXJcIiE9ciYmXCJzeW1ib2xcIiE9ciYmXCJib29sZWFuXCIhPXImJm51bGwhPW4mJiFBdShuKSl8fChybi50ZXN0KG4pfHwhdG4udGVzdChuKXx8bnVsbCE9dCYmbiBpbiBuaSh0KSl9ZnVuY3Rpb24gQmUobil7dmFyIHQ9YmUobikscj1Pblt0XTtyZXR1cm4gdHlwZW9mIHI9PVwiZnVuY3Rpb25cIiYmdCBpbiBNbi5wcm90b3R5cGUmJihuPT09cnx8KHQ9X28ociksISF0JiZuPT09dFswXSkpfWZ1bmN0aW9uIExlKG4pe3ZhciB0PW4mJm4uY29uc3RydWN0b3I7XG5yZXR1cm4gbj09PSh0eXBlb2YgdD09XCJmdW5jdGlvblwiJiZ0LnByb3RvdHlwZXx8aWkpfWZ1bmN0aW9uIFVlKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiBudWxsIT1yJiYocltuXT09PXQmJih0IT09Rnx8biBpbiBuaShyKSkpfX1mdW5jdGlvbiBDZShuLHQsZSl7cmV0dXJuIHQ9RGkodD09PUY/bi5sZW5ndGgtMTp0LDApLGZ1bmN0aW9uKCl7Zm9yKHZhciB1PWFyZ3VtZW50cyxpPS0xLG89RGkodS5sZW5ndGgtdCwwKSxmPUh1KG8pOysraTxvOylmW2ldPXVbdCtpXTtmb3IoaT0tMSxvPUh1KHQrMSk7KytpPHQ7KW9baV09dVtpXTtyZXR1cm4gb1t0XT1lKGYpLHIobix0aGlzLG8pfX1mdW5jdGlvbiBEZShuLHQscil7dmFyIGU9dCtcIlwiO3Q9d287dmFyIHUsaT1OZTtyZXR1cm4gdT0odT1lLm1hdGNoKGhuKSk/dVsxXS5zcGxpdChwbik6W10scj1pKHUsciksKGk9ci5sZW5ndGgpJiYodT1pLTEsclt1XT0oMTxpP1wiJiBcIjpcIlwiKStyW3VdLHI9ci5qb2luKDI8aT9cIiwgXCI6XCIgXCIpLFxuZT1lLnJlcGxhY2Uoc24sXCJ7XFxuLyogW3dyYXBwZWQgd2l0aCBcIityK1wiXSAqL1xcblwiKSksdChuLGUpfWZ1bmN0aW9uIE1lKG4pe3ZhciB0PTAscj0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPVRpKCksdT0xNi0oZS1yKTtpZihyPWUsMDx1KXtpZig4MDA8PSsrdClyZXR1cm4gYXJndW1lbnRzWzBdfWVsc2UgdD0wO3JldHVybiBuLmFwcGx5KEYsYXJndW1lbnRzKX19ZnVuY3Rpb24gVGUobix0KXt2YXIgcj0tMSxlPW4ubGVuZ3RoLHU9ZS0xO2Zvcih0PXQ9PT1GP2U6dDsrK3I8dDspe3ZhciBlPWNyKHIsdSksaT1uW2VdO25bZV09bltyXSxuW3JdPWl9cmV0dXJuIG4ubGVuZ3RoPXQsbn1mdW5jdGlvbiAkZShuKXtpZih0eXBlb2Ygbj09XCJzdHJpbmdcInx8QXUobikpcmV0dXJuIG47dmFyIHQ9bitcIlwiO3JldHVyblwiMFwiPT10JiYxL249PS1OP1wiLTBcIjp0fWZ1bmN0aW9uIEZlKG4pe2lmKG51bGwhPW4pe3RyeXtyZXR1cm4gZmkuY2FsbChuKX1jYXRjaChuKXt9cmV0dXJuIG4rXCJcIn1yZXR1cm5cIlwiO1xufWZ1bmN0aW9uIE5lKG4sdCl7cmV0dXJuIHUoWixmdW5jdGlvbihyKXt2YXIgZT1cIl8uXCIrclswXTt0JnJbMV0mJiFjKG4sZSkmJm4ucHVzaChlKX0pLG4uc29ydCgpfWZ1bmN0aW9uIFBlKG4pe2lmKG4gaW5zdGFuY2VvZiBNbilyZXR1cm4gbi5jbG9uZSgpO3ZhciB0PW5ldyB6bihuLl9fd3JhcHBlZF9fLG4uX19jaGFpbl9fKTtyZXR1cm4gdC5fX2FjdGlvbnNfXz1NcihuLl9fYWN0aW9uc19fKSx0Ll9faW5kZXhfXz1uLl9faW5kZXhfXyx0Ll9fdmFsdWVzX189bi5fX3ZhbHVlc19fLHR9ZnVuY3Rpb24gWmUobix0LHIpe3ZhciBlPW51bGw9PW4/MDpuLmxlbmd0aDtyZXR1cm4gZT8ocj1udWxsPT1yPzA6T3UociksMD5yJiYocj1EaShlK3IsMCkpLGcobixqZSh0LDMpLHIpKTotMX1mdW5jdGlvbiBxZShuLHQscil7dmFyIGU9bnVsbD09bj8wOm4ubGVuZ3RoO2lmKCFlKXJldHVybi0xO3ZhciB1PWUtMTtyZXR1cm4gciE9PUYmJih1PU91KHIpLHU9MD5yP0RpKGUrdSwwKTpNaSh1LGUtMSkpLFxuZyhuLGplKHQsMyksdSx0cnVlKX1mdW5jdGlvbiBWZShuKXtyZXR1cm4obnVsbD09bj8wOm4ubGVuZ3RoKT9rdChuLDEpOltdfWZ1bmN0aW9uIEtlKG4pe3JldHVybiBuJiZuLmxlbmd0aD9uWzBdOkZ9ZnVuY3Rpb24gR2Uobil7dmFyIHQ9bnVsbD09bj8wOm4ubGVuZ3RoO3JldHVybiB0P25bdC0xXTpGfWZ1bmN0aW9uIEhlKG4sdCl7cmV0dXJuIG4mJm4ubGVuZ3RoJiZ0JiZ0Lmxlbmd0aD9vcihuLHQpOm59ZnVuY3Rpb24gSmUobil7cmV0dXJuIG51bGw9PW4/bjpOaS5jYWxsKG4pfWZ1bmN0aW9uIFllKG4pe2lmKCFufHwhbi5sZW5ndGgpcmV0dXJuW107dmFyIHQ9MDtyZXR1cm4gbj1mKG4sZnVuY3Rpb24obil7aWYoX3UobikpcmV0dXJuIHQ9RGkobi5sZW5ndGgsdCksdHJ1ZX0pLEUodCxmdW5jdGlvbih0KXtyZXR1cm4gbChuLGoodCkpfSl9ZnVuY3Rpb24gUWUobix0KXtpZighbnx8IW4ubGVuZ3RoKXJldHVybltdO3ZhciBlPVllKG4pO3JldHVybiBudWxsPT10P2U6bChlLGZ1bmN0aW9uKG4pe1xucmV0dXJuIHIodCxGLG4pfSl9ZnVuY3Rpb24gWGUobil7cmV0dXJuIG49T24obiksbi5fX2NoYWluX189dHJ1ZSxufWZ1bmN0aW9uIG51KG4sdCl7cmV0dXJuIHQobil9ZnVuY3Rpb24gdHUoKXtyZXR1cm4gdGhpc31mdW5jdGlvbiBydShuLHQpe3JldHVybihhZihuKT91Om9vKShuLGplKHQsMykpfWZ1bmN0aW9uIGV1KG4sdCl7cmV0dXJuKGFmKG4pP2k6Zm8pKG4samUodCwzKSl9ZnVuY3Rpb24gdXUobix0KXtyZXR1cm4oYWYobik/bDpZdCkobixqZSh0LDMpKX1mdW5jdGlvbiBpdShuLHQscil7cmV0dXJuIHQ9cj9GOnQsdD1uJiZudWxsPT10P24ubGVuZ3RoOnQsbGUobiwxMjgsRixGLEYsRix0KX1mdW5jdGlvbiBvdShuLHQpe3ZhciByO2lmKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IGVpKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtyZXR1cm4gbj1PdShuKSxmdW5jdGlvbigpe3JldHVybiAwPC0tbiYmKHI9dC5hcHBseSh0aGlzLGFyZ3VtZW50cykpLDE+PW4mJih0PUYpLFxucn19ZnVuY3Rpb24gZnUobix0LHIpe3JldHVybiB0PXI/Rjp0LG49bGUobiw4LEYsRixGLEYsRix0KSxuLnBsYWNlaG9sZGVyPWZ1LnBsYWNlaG9sZGVyLG59ZnVuY3Rpb24gY3Uobix0LHIpe3JldHVybiB0PXI/Rjp0LG49bGUobiwxNixGLEYsRixGLEYsdCksbi5wbGFjZWhvbGRlcj1jdS5wbGFjZWhvbGRlcixufWZ1bmN0aW9uIGF1KG4sdCxyKXtmdW5jdGlvbiBlKHQpe3ZhciByPWMsZT1hO3JldHVybiBjPWE9RixfPXQscz1uLmFwcGx5KGUscil9ZnVuY3Rpb24gdShuKXt2YXIgcj1uLXA7cmV0dXJuIG4tPV8scD09PUZ8fHI+PXR8fDA+cnx8ZyYmbj49bH1mdW5jdGlvbiBpKCl7dmFyIG49Sm8oKTtpZih1KG4pKXJldHVybiBvKG4pO3ZhciByLGU9am87cj1uLV8sbj10LShuLXApLHI9Zz9NaShuLGwtcik6bixoPWUoaSxyKX1mdW5jdGlvbiBvKG4pe3JldHVybiBoPUYsZCYmYz9lKG4pOihjPWE9RixzKX1mdW5jdGlvbiBmKCl7dmFyIG49Sm8oKSxyPXUobik7aWYoYz1hcmd1bWVudHMsXG5hPXRoaXMscD1uLHIpe2lmKGg9PT1GKXJldHVybiBfPW49cCxoPWpvKGksdCksdj9lKG4pOnM7aWYoZylyZXR1cm4gaD1qbyhpLHQpLGUocCl9cmV0dXJuIGg9PT1GJiYoaD1qbyhpLHQpKSxzfXZhciBjLGEsbCxzLGgscCxfPTAsdj1mYWxzZSxnPWZhbHNlLGQ9dHJ1ZTtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBlaShcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIik7cmV0dXJuIHQ9SXUodCl8fDAsYnUocikmJih2PSEhci5sZWFkaW5nLGw9KGc9XCJtYXhXYWl0XCJpbiByKT9EaShJdShyLm1heFdhaXQpfHwwLHQpOmwsZD1cInRyYWlsaW5nXCJpbiByPyEhci50cmFpbGluZzpkKSxmLmNhbmNlbD1mdW5jdGlvbigpe2ghPT1GJiZobyhoKSxfPTAsYz1wPWE9aD1GfSxmLmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGg9PT1GP3M6byhKbygpKX0sZn1mdW5jdGlvbiBsdShuLHQpe2Z1bmN0aW9uIHIoKXt2YXIgZT1hcmd1bWVudHMsdT10P3QuYXBwbHkodGhpcyxlKTplWzBdLGk9ci5jYWNoZTtyZXR1cm4gaS5oYXModSk/aS5nZXQodSk6KGU9bi5hcHBseSh0aGlzLGUpLFxuci5jYWNoZT1pLnNldCh1LGUpfHxpLGUpfWlmKHR5cGVvZiBuIT1cImZ1bmN0aW9uXCJ8fG51bGwhPXQmJnR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IGVpKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtyZXR1cm4gci5jYWNoZT1uZXcobHUuQ2FjaGV8fFBuKSxyfWZ1bmN0aW9uIHN1KG4pe2lmKHR5cGVvZiBuIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IGVpKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHM7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIW4uY2FsbCh0aGlzKTtjYXNlIDE6cmV0dXJuIW4uY2FsbCh0aGlzLHRbMF0pO2Nhc2UgMjpyZXR1cm4hbi5jYWxsKHRoaXMsdFswXSx0WzFdKTtjYXNlIDM6cmV0dXJuIW4uY2FsbCh0aGlzLHRbMF0sdFsxXSx0WzJdKX1yZXR1cm4hbi5hcHBseSh0aGlzLHQpfX1mdW5jdGlvbiBodShuLHQpe3JldHVybiBuPT09dHx8biE9PW4mJnQhPT10fWZ1bmN0aW9uIHB1KG4pe3JldHVybiBudWxsIT1uJiZ5dShuLmxlbmd0aCkmJiFndShuKTtcbn1mdW5jdGlvbiBfdShuKXtyZXR1cm4geHUobikmJnB1KG4pfWZ1bmN0aW9uIHZ1KG4pe2lmKCF4dShuKSlyZXR1cm4gZmFsc2U7dmFyIHQ9enQobik7cmV0dXJuXCJbb2JqZWN0IEVycm9yXVwiPT10fHxcIltvYmplY3QgRE9NRXhjZXB0aW9uXVwiPT10fHx0eXBlb2Ygbi5tZXNzYWdlPT1cInN0cmluZ1wiJiZ0eXBlb2Ygbi5uYW1lPT1cInN0cmluZ1wiJiYhd3Uobil9ZnVuY3Rpb24gZ3Uobil7cmV0dXJuISFidShuKSYmKG49enQobiksXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1ufHxcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCI9PW58fFwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwiPT1ufHxcIltvYmplY3QgUHJveHldXCI9PW4pfWZ1bmN0aW9uIGR1KG4pe3JldHVybiB0eXBlb2Ygbj09XCJudW1iZXJcIiYmbj09T3Uobil9ZnVuY3Rpb24geXUobil7cmV0dXJuIHR5cGVvZiBuPT1cIm51bWJlclwiJiYtMTxuJiYwPT1uJTEmJjkwMDcxOTkyNTQ3NDA5OTE+PW59ZnVuY3Rpb24gYnUobil7dmFyIHQ9dHlwZW9mIG47cmV0dXJuIG51bGwhPW4mJihcIm9iamVjdFwiPT10fHxcImZ1bmN0aW9uXCI9PXQpO1xufWZ1bmN0aW9uIHh1KG4pe3JldHVybiBudWxsIT1uJiZ0eXBlb2Ygbj09XCJvYmplY3RcIn1mdW5jdGlvbiBqdShuKXtyZXR1cm4gdHlwZW9mIG49PVwibnVtYmVyXCJ8fHh1KG4pJiZcIltvYmplY3QgTnVtYmVyXVwiPT16dChuKX1mdW5jdGlvbiB3dShuKXtyZXR1cm4hKCF4dShuKXx8XCJbb2JqZWN0IE9iamVjdF1cIiE9enQobikpJiYobj1iaShuKSxudWxsPT09bnx8KG49Y2kuY2FsbChuLFwiY29uc3RydWN0b3JcIikmJm4uY29uc3RydWN0b3IsdHlwZW9mIG49PVwiZnVuY3Rpb25cIiYmbiBpbnN0YW5jZW9mIG4mJmZpLmNhbGwobik9PWhpKSl9ZnVuY3Rpb24gbXUobil7cmV0dXJuIHR5cGVvZiBuPT1cInN0cmluZ1wifHwhYWYobikmJnh1KG4pJiZcIltvYmplY3QgU3RyaW5nXVwiPT16dChuKX1mdW5jdGlvbiBBdShuKXtyZXR1cm4gdHlwZW9mIG49PVwic3ltYm9sXCJ8fHh1KG4pJiZcIltvYmplY3QgU3ltYm9sXVwiPT16dChuKX1mdW5jdGlvbiBrdShuKXtpZighbilyZXR1cm5bXTtpZihwdShuKSlyZXR1cm4gbXUobik/JChuKTpNcihuKTtcbmlmKEFpJiZuW0FpXSl7bj1uW0FpXSgpO2Zvcih2YXIgdCxyPVtdOyEodD1uLm5leHQoKSkuZG9uZTspci5wdXNoKHQudmFsdWUpO3JldHVybiByfXJldHVybiB0PXlvKG4pLChcIltvYmplY3QgTWFwXVwiPT10P0w6XCJbb2JqZWN0IFNldF1cIj09dD9EOkR1KShuKX1mdW5jdGlvbiBFdShuKXtyZXR1cm4gbj8obj1JdShuKSxuPT09Tnx8bj09PS1OPzEuNzk3NjkzMTM0ODYyMzE1N2UzMDgqKDA+bj8tMToxKTpuPT09bj9uOjApOjA9PT1uP246MH1mdW5jdGlvbiBPdShuKXtuPUV1KG4pO3ZhciB0PW4lMTtyZXR1cm4gbj09PW4/dD9uLXQ6bjowfWZ1bmN0aW9uIFN1KG4pe3JldHVybiBuP2d0KE91KG4pLDAsNDI5NDk2NzI5NSk6MH1mdW5jdGlvbiBJdShuKXtpZih0eXBlb2Ygbj09XCJudW1iZXJcIilyZXR1cm4gbjtpZihBdShuKSlyZXR1cm4gUDtpZihidShuKSYmKG49dHlwZW9mIG4udmFsdWVPZj09XCJmdW5jdGlvblwiP24udmFsdWVPZigpOm4sbj1idShuKT9uK1wiXCI6biksdHlwZW9mIG4hPVwic3RyaW5nXCIpcmV0dXJuIDA9PT1uP246K247XG5uPW4ucmVwbGFjZShjbixcIlwiKTt2YXIgdD1ibi50ZXN0KG4pO3JldHVybiB0fHxqbi50ZXN0KG4pP0ZuKG4uc2xpY2UoMiksdD8yOjgpOnluLnRlc3Qobik/UDorbn1mdW5jdGlvbiBSdShuKXtyZXR1cm4gVHIobixVdShuKSl9ZnVuY3Rpb24genUobil7cmV0dXJuIG51bGw9PW4/XCJcIjpqcihuKX1mdW5jdGlvbiBXdShuLHQscil7cmV0dXJuIG49bnVsbD09bj9GOkl0KG4sdCksbj09PUY/cjpufWZ1bmN0aW9uIEJ1KG4sdCl7cmV0dXJuIG51bGwhPW4mJmtlKG4sdCxMdCl9ZnVuY3Rpb24gTHUobil7cmV0dXJuIHB1KG4pP0duKG4pOkh0KG4pfWZ1bmN0aW9uIFV1KG4pe2lmKHB1KG4pKW49R24obix0cnVlKTtlbHNlIGlmKGJ1KG4pKXt2YXIgdCxyPUxlKG4pLGU9W107Zm9yKHQgaW4gbikoXCJjb25zdHJ1Y3RvclwiIT10fHwhciYmY2kuY2FsbChuLHQpKSYmZS5wdXNoKHQpO249ZX1lbHNle2lmKHQ9W10sbnVsbCE9bilmb3IociBpbiBuaShuKSl0LnB1c2gocik7bj10fXJldHVybiBufWZ1bmN0aW9uIEN1KG4sdCl7XG5pZihudWxsPT1uKXJldHVybnt9O3ZhciByPWwoeWUobiksZnVuY3Rpb24obil7cmV0dXJuW25dfSk7cmV0dXJuIHQ9amUodCksdXIobixyLGZ1bmN0aW9uKG4scil7cmV0dXJuIHQobixyWzBdKX0pfWZ1bmN0aW9uIER1KG4pe3JldHVybiBudWxsPT1uP1tdOkkobixMdShuKSl9ZnVuY3Rpb24gTXUobil7cmV0dXJuIE5mKHp1KG4pLnRvTG93ZXJDYXNlKCkpfWZ1bmN0aW9uIFR1KG4pe3JldHVybihuPXp1KG4pKSYmbi5yZXBsYWNlKG1uLHJ0KS5yZXBsYWNlKFJuLFwiXCIpfWZ1bmN0aW9uICR1KG4sdCxyKXtyZXR1cm4gbj16dShuKSx0PXI/Rjp0LHQ9PT1GP0xuLnRlc3Qobik/bi5tYXRjaChXbil8fFtdOm4ubWF0Y2goX24pfHxbXTpuLm1hdGNoKHQpfHxbXX1mdW5jdGlvbiBGdShuKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbn19ZnVuY3Rpb24gTnUobil7cmV0dXJuIG59ZnVuY3Rpb24gUHUobil7cmV0dXJuIEd0KHR5cGVvZiBuPT1cImZ1bmN0aW9uXCI/bjpkdChuLDEpKX1mdW5jdGlvbiBadShuLHQscil7XG52YXIgZT1MdSh0KSxpPVN0KHQsZSk7bnVsbCE9cnx8YnUodCkmJihpLmxlbmd0aHx8IWUubGVuZ3RoKXx8KHI9dCx0PW4sbj10aGlzLGk9U3QodCxMdSh0KSkpO3ZhciBvPSEoYnUocikmJlwiY2hhaW5cImluIHImJiFyLmNoYWluKSxmPWd1KG4pO3JldHVybiB1KGksZnVuY3Rpb24ocil7dmFyIGU9dFtyXTtuW3JdPWUsZiYmKG4ucHJvdG90eXBlW3JdPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fX2NoYWluX187aWYob3x8dCl7dmFyIHI9bih0aGlzLl9fd3JhcHBlZF9fKTtyZXR1cm4oci5fX2FjdGlvbnNfXz1Ncih0aGlzLl9fYWN0aW9uc19fKSkucHVzaCh7ZnVuYzplLGFyZ3M6YXJndW1lbnRzLHRoaXNBcmc6bn0pLHIuX19jaGFpbl9fPXQscn1yZXR1cm4gZS5hcHBseShuLHMoW3RoaXMudmFsdWUoKV0sYXJndW1lbnRzKSl9KX0pLG59ZnVuY3Rpb24gcXUoKXt9ZnVuY3Rpb24gVnUobil7cmV0dXJuIFdlKG4pP2ooJGUobikpOmlyKG4pfWZ1bmN0aW9uIEt1KCl7cmV0dXJuW119ZnVuY3Rpb24gR3UoKXtcbnJldHVybiBmYWxzZX1Fbj1udWxsPT1Fbj9abjppdC5kZWZhdWx0cyhabi5PYmplY3QoKSxFbixpdC5waWNrKFpuLFVuKSk7dmFyIEh1PUVuLkFycmF5LEp1PUVuLkRhdGUsWXU9RW4uRXJyb3IsUXU9RW4uRnVuY3Rpb24sWHU9RW4uTWF0aCxuaT1Fbi5PYmplY3QsdGk9RW4uUmVnRXhwLHJpPUVuLlN0cmluZyxlaT1Fbi5UeXBlRXJyb3IsdWk9SHUucHJvdG90eXBlLGlpPW5pLnByb3RvdHlwZSxvaT1FbltcIl9fY29yZS1qc19zaGFyZWRfX1wiXSxmaT1RdS5wcm90b3R5cGUudG9TdHJpbmcsY2k9aWkuaGFzT3duUHJvcGVydHksYWk9MCxsaT1mdW5jdGlvbigpe3ZhciBuPS9bXi5dKyQvLmV4ZWMob2kmJm9pLmtleXMmJm9pLmtleXMuSUVfUFJPVE98fFwiXCIpO3JldHVybiBuP1wiU3ltYm9sKHNyYylfMS5cIituOlwiXCJ9KCksc2k9aWkudG9TdHJpbmcsaGk9ZmkuY2FsbChuaSkscGk9Wm4uXyxfaT10aShcIl5cIitmaS5jYWxsKGNpKS5yZXBsYWNlKG9uLFwiXFxcXCQmXCIpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csXCIkMS4qP1wiKStcIiRcIiksdmk9S24/RW4uQnVmZmVyOkYsZ2k9RW4uU3ltYm9sLGRpPUVuLlVpbnQ4QXJyYXkseWk9dmk/dmkuZjpGLGJpPVUobmkuZ2V0UHJvdG90eXBlT2YsbmkpLHhpPW5pLmNyZWF0ZSxqaT1paS5wcm9wZXJ0eUlzRW51bWVyYWJsZSx3aT11aS5zcGxpY2UsbWk9Z2k/Z2kuaXNDb25jYXRTcHJlYWRhYmxlOkYsQWk9Z2k/Z2kuaXRlcmF0b3I6RixraT1naT9naS50b1N0cmluZ1RhZzpGLEVpPWZ1bmN0aW9uKCl7XG50cnl7dmFyIG49QWUobmksXCJkZWZpbmVQcm9wZXJ0eVwiKTtyZXR1cm4gbih7fSxcIlwiLHt9KSxufWNhdGNoKG4pe319KCksT2k9RW4uY2xlYXJUaW1lb3V0IT09Wm4uY2xlYXJUaW1lb3V0JiZFbi5jbGVhclRpbWVvdXQsU2k9SnUmJkp1Lm5vdyE9PVpuLkRhdGUubm93JiZKdS5ub3csSWk9RW4uc2V0VGltZW91dCE9PVpuLnNldFRpbWVvdXQmJkVuLnNldFRpbWVvdXQsUmk9WHUuY2VpbCx6aT1YdS5mbG9vcixXaT1uaS5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsQmk9dmk/dmkuaXNCdWZmZXI6RixMaT1Fbi5pc0Zpbml0ZSxVaT11aS5qb2luLENpPVUobmkua2V5cyxuaSksRGk9WHUubWF4LE1pPVh1Lm1pbixUaT1KdS5ub3csJGk9RW4ucGFyc2VJbnQsRmk9WHUucmFuZG9tLE5pPXVpLnJldmVyc2UsUGk9QWUoRW4sXCJEYXRhVmlld1wiKSxaaT1BZShFbixcIk1hcFwiKSxxaT1BZShFbixcIlByb21pc2VcIiksVmk9QWUoRW4sXCJTZXRcIiksS2k9QWUoRW4sXCJXZWFrTWFwXCIpLEdpPUFlKG5pLFwiY3JlYXRlXCIpLEhpPUtpJiZuZXcgS2ksSmk9e30sWWk9RmUoUGkpLFFpPUZlKFppKSxYaT1GZShxaSksbm89RmUoVmkpLHRvPUZlKEtpKSxybz1naT9naS5wcm90b3R5cGU6Rixlbz1ybz9yby52YWx1ZU9mOkYsdW89cm8/cm8udG9TdHJpbmc6Rixpbz1mdW5jdGlvbigpe1xuZnVuY3Rpb24gbigpe31yZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGJ1KHQpP3hpP3hpKHQpOihuLnByb3RvdHlwZT10LHQ9bmV3IG4sbi5wcm90b3R5cGU9Rix0KTp7fX19KCk7T24udGVtcGxhdGVTZXR0aW5ncz17ZXNjYXBlOlEsZXZhbHVhdGU6WCxpbnRlcnBvbGF0ZTpubix2YXJpYWJsZTpcIlwiLGltcG9ydHM6e186T259fSxPbi5wcm90b3R5cGU9U24ucHJvdG90eXBlLE9uLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1Pbix6bi5wcm90b3R5cGU9aW8oU24ucHJvdG90eXBlKSx6bi5wcm90b3R5cGUuY29uc3RydWN0b3I9em4sTW4ucHJvdG90eXBlPWlvKFNuLnByb3RvdHlwZSksTW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPU1uLFRuLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX19kYXRhX189R2k/R2kobnVsbCk6e30sdGhpcy5zaXplPTB9LFRuLnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24obil7cmV0dXJuIG49dGhpcy5oYXMobikmJmRlbGV0ZSB0aGlzLl9fZGF0YV9fW25dLFxudGhpcy5zaXplLT1uPzE6MCxufSxUbi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIEdpPyhuPXRbbl0sXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI9PT1uP0Y6bik6Y2kuY2FsbCh0LG4pP3Rbbl06Rn0sVG4ucHJvdG90eXBlLmhhcz1mdW5jdGlvbihuKXt2YXIgdD10aGlzLl9fZGF0YV9fO3JldHVybiBHaT90W25dIT09RjpjaS5jYWxsKHQsbil9LFRuLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24obix0KXt2YXIgcj10aGlzLl9fZGF0YV9fO3JldHVybiB0aGlzLnNpemUrPXRoaXMuaGFzKG4pPzA6MSxyW25dPUdpJiZ0PT09Rj9cIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjp0LHRoaXN9LE5uLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX19kYXRhX189W10sdGhpcy5zaXplPTB9LE5uLnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcy5fX2RhdGFfXztyZXR1cm4gbj1sdCh0LG4pLCEoMD5uKSYmKG49PXQubGVuZ3RoLTE/dC5wb3AoKTp3aS5jYWxsKHQsbiwxKSxcbi0tdGhpcy5zaXplLHRydWUpfSxObi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIG49bHQodCxuKSwwPm4/Rjp0W25dWzFdfSxObi5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKG4pe3JldHVybi0xPGx0KHRoaXMuX19kYXRhX18sbil9LE5uLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24obix0KXt2YXIgcj10aGlzLl9fZGF0YV9fLGU9bHQocixuKTtyZXR1cm4gMD5lPygrK3RoaXMuc2l6ZSxyLnB1c2goW24sdF0pKTpyW2VdWzFdPXQsdGhpc30sUG4ucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5zaXplPTAsdGhpcy5fX2RhdGFfXz17aGFzaDpuZXcgVG4sbWFwOm5ldyhaaXx8Tm4pLHN0cmluZzpuZXcgVG59fSxQbi5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKG4pe3JldHVybiBuPXdlKHRoaXMsbikuZGVsZXRlKG4pLHRoaXMuc2l6ZS09bj8xOjAsbn0sUG4ucHJvdG90eXBlLmdldD1mdW5jdGlvbihuKXtyZXR1cm4gd2UodGhpcyxuKS5nZXQobik7XG59LFBuLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24obil7cmV0dXJuIHdlKHRoaXMsbikuaGFzKG4pfSxQbi5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKG4sdCl7dmFyIHI9d2UodGhpcyxuKSxlPXIuc2l6ZTtyZXR1cm4gci5zZXQobix0KSx0aGlzLnNpemUrPXIuc2l6ZT09ZT8wOjEsdGhpc30scW4ucHJvdG90eXBlLmFkZD1xbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5zZXQobixcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIiksdGhpc30scW4ucHJvdG90eXBlLmhhcz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMobil9LFZuLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX19kYXRhX189bmV3IE5uLHRoaXMuc2l6ZT0wfSxWbi5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMuX19kYXRhX187cmV0dXJuIG49dC5kZWxldGUobiksdGhpcy5zaXplPXQuc2l6ZSxufSxWbi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG4pe1xucmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KG4pfSxWbi5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhuKX0sVm4ucHJvdG90eXBlLnNldD1mdW5jdGlvbihuLHQpe3ZhciByPXRoaXMuX19kYXRhX187aWYociBpbnN0YW5jZW9mIE5uKXt2YXIgZT1yLl9fZGF0YV9fO2lmKCFaaXx8MTk5PmUubGVuZ3RoKXJldHVybiBlLnB1c2goW24sdF0pLHRoaXMuc2l6ZT0rK3Iuc2l6ZSx0aGlzO3I9dGhpcy5fX2RhdGFfXz1uZXcgUG4oZSl9cmV0dXJuIHIuc2V0KG4sdCksdGhpcy5zaXplPXIuc2l6ZSx0aGlzfTt2YXIgb289WnIoRXQpLGZvPVpyKE90LHRydWUpLGNvPXFyKCksYW89cXIodHJ1ZSksbG89SGk/ZnVuY3Rpb24obix0KXtyZXR1cm4gSGkuc2V0KG4sdCksbn06TnUsc289RWk/ZnVuY3Rpb24obix0KXtyZXR1cm4gRWkobixcInRvU3RyaW5nXCIse2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6ZmFsc2UsdmFsdWU6RnUodCksd3JpdGFibGU6dHJ1ZX0pfTpOdSxobz1PaXx8ZnVuY3Rpb24obil7XG5yZXR1cm4gWm4uY2xlYXJUaW1lb3V0KG4pfSxwbz1WaSYmMS9EKG5ldyBWaShbLC0wXSkpWzFdPT1OP2Z1bmN0aW9uKG4pe3JldHVybiBuZXcgVmkobil9OnF1LF9vPUhpP2Z1bmN0aW9uKG4pe3JldHVybiBIaS5nZXQobil9OnF1LHZvPVdpP2Z1bmN0aW9uKG4pe3JldHVybiBudWxsPT1uP1tdOihuPW5pKG4pLGYoV2kobiksZnVuY3Rpb24odCl7cmV0dXJuIGppLmNhbGwobix0KX0pKX06S3UsZ289V2k/ZnVuY3Rpb24obil7Zm9yKHZhciB0PVtdO247KXModCx2byhuKSksbj1iaShuKTtyZXR1cm4gdH06S3UseW89enQ7KFBpJiZcIltvYmplY3QgRGF0YVZpZXddXCIhPXlvKG5ldyBQaShuZXcgQXJyYXlCdWZmZXIoMSkpKXx8WmkmJlwiW29iamVjdCBNYXBdXCIhPXlvKG5ldyBaaSl8fHFpJiZcIltvYmplY3QgUHJvbWlzZV1cIiE9eW8ocWkucmVzb2x2ZSgpKXx8VmkmJlwiW29iamVjdCBTZXRdXCIhPXlvKG5ldyBWaSl8fEtpJiZcIltvYmplY3QgV2Vha01hcF1cIiE9eW8obmV3IEtpKSkmJih5bz1mdW5jdGlvbihuKXtcbnZhciB0PXp0KG4pO2lmKG49KG49XCJbb2JqZWN0IE9iamVjdF1cIj09dD9uLmNvbnN0cnVjdG9yOkYpP0ZlKG4pOlwiXCIpc3dpdGNoKG4pe2Nhc2UgWWk6cmV0dXJuXCJbb2JqZWN0IERhdGFWaWV3XVwiO2Nhc2UgUWk6cmV0dXJuXCJbb2JqZWN0IE1hcF1cIjtjYXNlIFhpOnJldHVyblwiW29iamVjdCBQcm9taXNlXVwiO2Nhc2Ugbm86cmV0dXJuXCJbb2JqZWN0IFNldF1cIjtjYXNlIHRvOnJldHVyblwiW29iamVjdCBXZWFrTWFwXVwifXJldHVybiB0fSk7dmFyIGJvPW9pP2d1Okd1LHhvPU1lKGxvKSxqbz1JaXx8ZnVuY3Rpb24obix0KXtyZXR1cm4gWm4uc2V0VGltZW91dChuLHQpfSx3bz1NZShzbyksbW89ZnVuY3Rpb24obil7bj1sdShuLGZ1bmN0aW9uKG4pe3JldHVybiA1MDA9PT10LnNpemUmJnQuY2xlYXIoKSxufSk7dmFyIHQ9bi5jYWNoZTtyZXR1cm4gbn0oZnVuY3Rpb24obil7dmFyIHQ9W107cmV0dXJuIGVuLnRlc3QobikmJnQucHVzaChcIlwiKSxuLnJlcGxhY2UodW4sZnVuY3Rpb24obixyLGUsdSl7XG50LnB1c2goZT91LnJlcGxhY2Uodm4sXCIkMVwiKTpyfHxuKX0pLHR9KSxBbz1scihmdW5jdGlvbihuLHQpe3JldHVybiBfdShuKT9qdChuLGt0KHQsMSxfdSx0cnVlKSk6W119KSxrbz1scihmdW5jdGlvbihuLHQpe3ZhciByPUdlKHQpO3JldHVybiBfdShyKSYmKHI9RiksX3Uobik/anQobixrdCh0LDEsX3UsdHJ1ZSksamUociwyKSk6W119KSxFbz1scihmdW5jdGlvbihuLHQpe3ZhciByPUdlKHQpO3JldHVybiBfdShyKSYmKHI9RiksX3Uobik/anQobixrdCh0LDEsX3UsdHJ1ZSksRixyKTpbXX0pLE9vPWxyKGZ1bmN0aW9uKG4pe3ZhciB0PWwobixTcik7cmV0dXJuIHQubGVuZ3RoJiZ0WzBdPT09blswXT9VdCh0KTpbXX0pLFNvPWxyKGZ1bmN0aW9uKG4pe3ZhciB0PUdlKG4pLHI9bChuLFNyKTtyZXR1cm4gdD09PUdlKHIpP3Q9RjpyLnBvcCgpLHIubGVuZ3RoJiZyWzBdPT09blswXT9VdChyLGplKHQsMikpOltdfSksSW89bHIoZnVuY3Rpb24obil7dmFyIHQ9R2Uobikscj1sKG4sU3IpO3JldHVybih0PXR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dDpGKSYmci5wb3AoKSxcbnIubGVuZ3RoJiZyWzBdPT09blswXT9VdChyLEYsdCk6W119KSxSbz1scihIZSksem89Z2UoZnVuY3Rpb24obix0KXt2YXIgcj1udWxsPT1uPzA6bi5sZW5ndGgsZT12dChuLHQpO3JldHVybiBmcihuLGwodCxmdW5jdGlvbihuKXtyZXR1cm4gUmUobixyKT8rbjpufSkuc29ydChVcikpLGV9KSxXbz1scihmdW5jdGlvbihuKXtyZXR1cm4gd3Ioa3QobiwxLF91LHRydWUpKX0pLEJvPWxyKGZ1bmN0aW9uKG4pe3ZhciB0PUdlKG4pO3JldHVybiBfdSh0KSYmKHQ9Riksd3Ioa3QobiwxLF91LHRydWUpLGplKHQsMikpfSksTG89bHIoZnVuY3Rpb24obil7dmFyIHQ9R2UobiksdD10eXBlb2YgdD09XCJmdW5jdGlvblwiP3Q6RjtyZXR1cm4gd3Ioa3QobiwxLF91LHRydWUpLEYsdCl9KSxVbz1scihmdW5jdGlvbihuLHQpe3JldHVybiBfdShuKT9qdChuLHQpOltdfSksQ289bHIoZnVuY3Rpb24obil7cmV0dXJuIEVyKGYobixfdSkpfSksRG89bHIoZnVuY3Rpb24obil7dmFyIHQ9R2Uobik7cmV0dXJuIF91KHQpJiYodD1GKSxcbkVyKGYobixfdSksamUodCwyKSl9KSxNbz1scihmdW5jdGlvbihuKXt2YXIgdD1HZShuKSx0PXR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dDpGO3JldHVybiBFcihmKG4sX3UpLEYsdCl9KSxUbz1scihZZSksJG89bHIoZnVuY3Rpb24obil7dmFyIHQ9bi5sZW5ndGgsdD0xPHQ/blt0LTFdOkYsdD10eXBlb2YgdD09XCJmdW5jdGlvblwiPyhuLnBvcCgpLHQpOkY7cmV0dXJuIFFlKG4sdCl9KSxGbz1nZShmdW5jdGlvbihuKXtmdW5jdGlvbiB0KHQpe3JldHVybiB2dCh0LG4pfXZhciByPW4ubGVuZ3RoLGU9cj9uWzBdOjAsdT10aGlzLl9fd3JhcHBlZF9fO3JldHVybiEoMTxyfHx0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkmJnUgaW5zdGFuY2VvZiBNbiYmUmUoZSk/KHU9dS5zbGljZShlLCtlKyhyPzE6MCkpLHUuX19hY3Rpb25zX18ucHVzaCh7ZnVuYzpudSxhcmdzOlt0XSx0aGlzQXJnOkZ9KSxuZXcgem4odSx0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihuKXtyZXR1cm4gciYmIW4ubGVuZ3RoJiZuLnB1c2goRiksXG5ufSkpOnRoaXMudGhydSh0KX0pLE5vPU5yKGZ1bmN0aW9uKG4sdCxyKXtjaS5jYWxsKG4scik/KytuW3JdOl90KG4sciwxKX0pLFBvPVlyKFplKSxabz1ZcihxZSkscW89TnIoZnVuY3Rpb24obix0LHIpe2NpLmNhbGwobixyKT9uW3JdLnB1c2godCk6X3QobixyLFt0XSl9KSxWbz1scihmdW5jdGlvbihuLHQsZSl7dmFyIHU9LTEsaT10eXBlb2YgdD09XCJmdW5jdGlvblwiLG89cHUobik/SHUobi5sZW5ndGgpOltdO3JldHVybiBvbyhuLGZ1bmN0aW9uKG4pe29bKyt1XT1pP3IodCxuLGUpOkR0KG4sdCxlKX0pLG99KSxLbz1OcihmdW5jdGlvbihuLHQscil7X3QobixyLHQpfSksR289TnIoZnVuY3Rpb24obix0LHIpe25bcj8wOjFdLnB1c2godCl9LGZ1bmN0aW9uKCl7cmV0dXJuW1tdLFtdXX0pLEhvPWxyKGZ1bmN0aW9uKG4sdCl7aWYobnVsbD09bilyZXR1cm5bXTt2YXIgcj10Lmxlbmd0aDtyZXR1cm4gMTxyJiZ6ZShuLHRbMF0sdFsxXSk/dD1bXToyPHImJnplKHRbMF0sdFsxXSx0WzJdKSYmKHQ9W3RbMF1dKSxcbnJyKG4sa3QodCwxKSxbXSl9KSxKbz1TaXx8ZnVuY3Rpb24oKXtyZXR1cm4gWm4uRGF0ZS5ub3coKX0sWW89bHIoZnVuY3Rpb24obix0LHIpe3ZhciBlPTE7aWYoci5sZW5ndGgpdmFyIHU9QyhyLHhlKFlvKSksZT0zMnxlO3JldHVybiBsZShuLGUsdCxyLHUpfSksUW89bHIoZnVuY3Rpb24obix0LHIpe3ZhciBlPTM7aWYoci5sZW5ndGgpdmFyIHU9QyhyLHhlKFFvKSksZT0zMnxlO3JldHVybiBsZSh0LGUsbixyLHUpfSksWG89bHIoZnVuY3Rpb24obix0KXtyZXR1cm4geHQobiwxLHQpfSksbmY9bHIoZnVuY3Rpb24obix0LHIpe3JldHVybiB4dChuLEl1KHQpfHwwLHIpfSk7bHUuQ2FjaGU9UG47dmFyIHRmPWxyKGZ1bmN0aW9uKG4sdCl7dD0xPT10Lmxlbmd0aCYmYWYodFswXSk/bCh0WzBdLFMoamUoKSkpOmwoa3QodCwxKSxTKGplKCkpKTt2YXIgZT10Lmxlbmd0aDtyZXR1cm4gbHIoZnVuY3Rpb24odSl7Zm9yKHZhciBpPS0xLG89TWkodS5sZW5ndGgsZSk7KytpPG87KXVbaV09dFtpXS5jYWxsKHRoaXMsdVtpXSk7XG5yZXR1cm4gcihuLHRoaXMsdSl9KX0pLHJmPWxyKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGxlKG4sMzIsRix0LEModCx4ZShyZikpKX0pLGVmPWxyKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGxlKG4sNjQsRix0LEModCx4ZShlZikpKX0pLHVmPWdlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGxlKG4sMjU2LEYsRixGLHQpfSksb2Y9b2UoV3QpLGZmPW9lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4+PXR9KSxjZj1NdChmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpP010OmZ1bmN0aW9uKG4pe3JldHVybiB4dShuKSYmY2kuY2FsbChuLFwiY2FsbGVlXCIpJiYhamkuY2FsbChuLFwiY2FsbGVlXCIpfSxhZj1IdS5pc0FycmF5LGxmPUhuP1MoSG4pOlR0LHNmPUJpfHxHdSxoZj1Kbj9TKEpuKTokdCxwZj1Zbj9TKFluKTpOdCxfZj1Rbj9TKFFuKTpxdCx2Zj1Ybj9TKFhuKTpWdCxnZj1udD9TKG50KTpLdCxkZj1vZShKdCkseWY9b2UoZnVuY3Rpb24obix0KXtyZXR1cm4gbjw9dH0pLGJmPVByKGZ1bmN0aW9uKG4sdCl7XG5pZihMZSh0KXx8cHUodCkpVHIodCxMdSh0KSxuKTtlbHNlIGZvcih2YXIgciBpbiB0KWNpLmNhbGwodCxyKSYmYXQobixyLHRbcl0pfSkseGY9UHIoZnVuY3Rpb24obix0KXtUcih0LFV1KHQpLG4pfSksamY9UHIoZnVuY3Rpb24obix0LHIsZSl7VHIodCxVdSh0KSxuLGUpfSksd2Y9UHIoZnVuY3Rpb24obix0LHIsZSl7VHIodCxMdSh0KSxuLGUpfSksbWY9Z2UodnQpLEFmPWxyKGZ1bmN0aW9uKG4pe3JldHVybiBuLnB1c2goRixzZSkscihqZixGLG4pfSksa2Y9bHIoZnVuY3Rpb24obil7cmV0dXJuIG4ucHVzaChGLGhlKSxyKFJmLEYsbil9KSxFZj1uZShmdW5jdGlvbihuLHQscil7blt0XT1yfSxGdShOdSkpLE9mPW5lKGZ1bmN0aW9uKG4sdCxyKXtjaS5jYWxsKG4sdCk/blt0XS5wdXNoKHIpOm5bdF09W3JdfSxqZSksU2Y9bHIoRHQpLElmPVByKGZ1bmN0aW9uKG4sdCxyKXtucihuLHQscil9KSxSZj1QcihmdW5jdGlvbihuLHQscixlKXtucihuLHQscixlKX0pLHpmPWdlKGZ1bmN0aW9uKG4sdCl7XG52YXIgcj17fTtpZihudWxsPT1uKXJldHVybiByO3ZhciBlPWZhbHNlO3Q9bCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0PVJyKHQsbiksZXx8KGU9MTx0Lmxlbmd0aCksdH0pLFRyKG4seWUobiksciksZSYmKHI9ZHQociw3LHBlKSk7Zm9yKHZhciB1PXQubGVuZ3RoO3UtLTspbXIocix0W3VdKTtyZXR1cm4gcn0pLFdmPWdlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW4/e306ZXIobix0KX0pLEJmPWFlKEx1KSxMZj1hZShVdSksVWY9R3IoZnVuY3Rpb24obix0LHIpe3JldHVybiB0PXQudG9Mb3dlckNhc2UoKSxuKyhyP011KHQpOnQpfSksQ2Y9R3IoZnVuY3Rpb24obix0LHIpe3JldHVybiBuKyhyP1wiLVwiOlwiXCIpK3QudG9Mb3dlckNhc2UoKX0pLERmPUdyKGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbisocj9cIiBcIjpcIlwiKSt0LnRvTG93ZXJDYXNlKCl9KSxNZj1LcihcInRvTG93ZXJDYXNlXCIpLFRmPUdyKGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbisocj9cIl9cIjpcIlwiKSt0LnRvTG93ZXJDYXNlKCk7XG59KSwkZj1HcihmdW5jdGlvbihuLHQscil7cmV0dXJuIG4rKHI/XCIgXCI6XCJcIikrTmYodCl9KSxGZj1HcihmdW5jdGlvbihuLHQscil7cmV0dXJuIG4rKHI/XCIgXCI6XCJcIikrdC50b1VwcGVyQ2FzZSgpfSksTmY9S3IoXCJ0b1VwcGVyQ2FzZVwiKSxQZj1scihmdW5jdGlvbihuLHQpe3RyeXtyZXR1cm4gcihuLEYsdCl9Y2F0Y2gobil7cmV0dXJuIHZ1KG4pP246bmV3IFl1KG4pfX0pLFpmPWdlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIHUodCxmdW5jdGlvbih0KXt0PSRlKHQpLF90KG4sdCxZbyhuW3RdLG4pKX0pLG59KSxxZj1RcigpLFZmPVFyKHRydWUpLEtmPWxyKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiBEdChyLG4sdCl9fSksR2Y9bHIoZnVuY3Rpb24obix0KXtyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIER0KG4scix0KX19KSxIZj1yZShsKSxKZj1yZShvKSxZZj1yZShfKSxRZj1pZSgpLFhmPWllKHRydWUpLG5jPXRlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4rdH0sMCksdGM9Y2UoXCJjZWlsXCIpLHJjPXRlKGZ1bmN0aW9uKG4sdCl7XG5yZXR1cm4gbi90fSwxKSxlYz1jZShcImZsb29yXCIpLHVjPXRlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4qdH0sMSksaWM9Y2UoXCJyb3VuZFwiKSxvYz10ZShmdW5jdGlvbihuLHQpe3JldHVybiBuLXR9LDApO3JldHVybiBPbi5hZnRlcj1mdW5jdGlvbihuLHQpe2lmKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IGVpKFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtyZXR1cm4gbj1PdShuKSxmdW5jdGlvbigpe2lmKDE+LS1uKXJldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19LE9uLmFyeT1pdSxPbi5hc3NpZ249YmYsT24uYXNzaWduSW49eGYsT24uYXNzaWduSW5XaXRoPWpmLE9uLmFzc2lnbldpdGg9d2YsT24uYXQ9bWYsT24uYmVmb3JlPW91LE9uLmJpbmQ9WW8sT24uYmluZEFsbD1aZixPbi5iaW5kS2V5PVFvLE9uLmNhc3RBcnJheT1mdW5jdGlvbigpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybltdO3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gYWYobik/bjpbbl19LFxuT24uY2hhaW49WGUsT24uY2h1bms9ZnVuY3Rpb24obix0LHIpe2lmKHQ9KHI/emUobix0LHIpOnQ9PT1GKT8xOkRpKE91KHQpLDApLHI9bnVsbD09bj8wOm4ubGVuZ3RoLCFyfHwxPnQpcmV0dXJuW107Zm9yKHZhciBlPTAsdT0wLGk9SHUoUmkoci90KSk7ZTxyOylpW3UrK109dnIobixlLGUrPXQpO3JldHVybiBpfSxPbi5jb21wYWN0PWZ1bmN0aW9uKG4pe2Zvcih2YXIgdD0tMSxyPW51bGw9PW4/MDpuLmxlbmd0aCxlPTAsdT1bXTsrK3Q8cjspe3ZhciBpPW5bdF07aSYmKHVbZSsrXT1pKX1yZXR1cm4gdX0sT24uY29uY2F0PWZ1bmN0aW9uKCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aDtpZighbilyZXR1cm5bXTtmb3IodmFyIHQ9SHUobi0xKSxyPWFyZ3VtZW50c1swXTtuLS07KXRbbi0xXT1hcmd1bWVudHNbbl07cmV0dXJuIHMoYWYocik/TXIocik6W3JdLGt0KHQsMSkpfSxPbi5jb25kPWZ1bmN0aW9uKG4pe3ZhciB0PW51bGw9PW4/MDpuLmxlbmd0aCxlPWplKCk7cmV0dXJuIG49dD9sKG4sZnVuY3Rpb24obil7XG5pZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuWzFdKXRocm93IG5ldyBlaShcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIik7cmV0dXJuW2UoblswXSksblsxXV19KTpbXSxscihmdW5jdGlvbihlKXtmb3IodmFyIHU9LTE7Kyt1PHQ7KXt2YXIgaT1uW3VdO2lmKHIoaVswXSx0aGlzLGUpKXJldHVybiByKGlbMV0sdGhpcyxlKX19KX0sT24uY29uZm9ybXM9ZnVuY3Rpb24obil7cmV0dXJuIHl0KGR0KG4sMSkpfSxPbi5jb25zdGFudD1GdSxPbi5jb3VudEJ5PU5vLE9uLmNyZWF0ZT1mdW5jdGlvbihuLHQpe3ZhciByPWlvKG4pO3JldHVybiBudWxsPT10P3I6aHQocix0KX0sT24uY3Vycnk9ZnUsT24uY3VycnlSaWdodD1jdSxPbi5kZWJvdW5jZT1hdSxPbi5kZWZhdWx0cz1BZixPbi5kZWZhdWx0c0RlZXA9a2YsT24uZGVmZXI9WG8sT24uZGVsYXk9bmYsT24uZGlmZmVyZW5jZT1BbyxPbi5kaWZmZXJlbmNlQnk9a28sT24uZGlmZmVyZW5jZVdpdGg9RW8sT24uZHJvcD1mdW5jdGlvbihuLHQscil7dmFyIGU9bnVsbD09bj8wOm4ubGVuZ3RoO1xucmV0dXJuIGU/KHQ9cnx8dD09PUY/MTpPdSh0KSx2cihuLDA+dD8wOnQsZSkpOltdfSxPbi5kcm9wUmlnaHQ9ZnVuY3Rpb24obix0LHIpe3ZhciBlPW51bGw9PW4/MDpuLmxlbmd0aDtyZXR1cm4gZT8odD1yfHx0PT09Rj8xOk91KHQpLHQ9ZS10LHZyKG4sMCwwPnQ/MDp0KSk6W119LE9uLmRyb3BSaWdodFdoaWxlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4mJm4ubGVuZ3RoP0FyKG4samUodCwzKSx0cnVlLHRydWUpOltdfSxPbi5kcm9wV2hpbGU9ZnVuY3Rpb24obix0KXtyZXR1cm4gbiYmbi5sZW5ndGg/QXIobixqZSh0LDMpLHRydWUpOltdfSxPbi5maWxsPWZ1bmN0aW9uKG4sdCxyLGUpe3ZhciB1PW51bGw9PW4/MDpuLmxlbmd0aDtpZighdSlyZXR1cm5bXTtmb3IociYmdHlwZW9mIHIhPVwibnVtYmVyXCImJnplKG4sdCxyKSYmKHI9MCxlPXUpLHU9bi5sZW5ndGgscj1PdShyKSwwPnImJihyPS1yPnU/MDp1K3IpLGU9ZT09PUZ8fGU+dT91Ok91KGUpLDA+ZSYmKGUrPXUpLGU9cj5lPzA6U3UoZSk7cjxlOyluW3IrK109dDtcbnJldHVybiBufSxPbi5maWx0ZXI9ZnVuY3Rpb24obix0KXtyZXR1cm4oYWYobik/ZjpBdCkobixqZSh0LDMpKX0sT24uZmxhdE1hcD1mdW5jdGlvbihuLHQpe3JldHVybiBrdCh1dShuLHQpLDEpfSxPbi5mbGF0TWFwRGVlcD1mdW5jdGlvbihuLHQpe3JldHVybiBrdCh1dShuLHQpLE4pfSxPbi5mbGF0TWFwRGVwdGg9ZnVuY3Rpb24obix0LHIpe3JldHVybiByPXI9PT1GPzE6T3Uociksa3QodXUobix0KSxyKX0sT24uZmxhdHRlbj1WZSxPbi5mbGF0dGVuRGVlcD1mdW5jdGlvbihuKXtyZXR1cm4obnVsbD09bj8wOm4ubGVuZ3RoKT9rdChuLE4pOltdfSxPbi5mbGF0dGVuRGVwdGg9ZnVuY3Rpb24obix0KXtyZXR1cm4gbnVsbCE9biYmbi5sZW5ndGg/KHQ9dD09PUY/MTpPdSh0KSxrdChuLHQpKTpbXX0sT24uZmxpcD1mdW5jdGlvbihuKXtyZXR1cm4gbGUobiw1MTIpfSxPbi5mbG93PXFmLE9uLmZsb3dSaWdodD1WZixPbi5mcm9tUGFpcnM9ZnVuY3Rpb24obil7Zm9yKHZhciB0PS0xLHI9bnVsbD09bj8wOm4ubGVuZ3RoLGU9e307Kyt0PHI7KXtcbnZhciB1PW5bdF07ZVt1WzBdXT11WzFdfXJldHVybiBlfSxPbi5mdW5jdGlvbnM9ZnVuY3Rpb24obil7cmV0dXJuIG51bGw9PW4/W106U3QobixMdShuKSl9LE9uLmZ1bmN0aW9uc0luPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsPT1uP1tdOlN0KG4sVXUobikpfSxPbi5ncm91cEJ5PXFvLE9uLmluaXRpYWw9ZnVuY3Rpb24obil7cmV0dXJuKG51bGw9PW4/MDpuLmxlbmd0aCk/dnIobiwwLC0xKTpbXX0sT24uaW50ZXJzZWN0aW9uPU9vLE9uLmludGVyc2VjdGlvbkJ5PVNvLE9uLmludGVyc2VjdGlvbldpdGg9SW8sT24uaW52ZXJ0PUVmLE9uLmludmVydEJ5PU9mLE9uLmludm9rZU1hcD1WbyxPbi5pdGVyYXRlZT1QdSxPbi5rZXlCeT1LbyxPbi5rZXlzPUx1LE9uLmtleXNJbj1VdSxPbi5tYXA9dXUsT24ubWFwS2V5cz1mdW5jdGlvbihuLHQpe3ZhciByPXt9O3JldHVybiB0PWplKHQsMyksRXQobixmdW5jdGlvbihuLGUsdSl7X3Qocix0KG4sZSx1KSxuKX0pLHJ9LE9uLm1hcFZhbHVlcz1mdW5jdGlvbihuLHQpe1xudmFyIHI9e307cmV0dXJuIHQ9amUodCwzKSxFdChuLGZ1bmN0aW9uKG4sZSx1KXtfdChyLGUsdChuLGUsdSkpfSkscn0sT24ubWF0Y2hlcz1mdW5jdGlvbihuKXtyZXR1cm4gUXQoZHQobiwxKSl9LE9uLm1hdGNoZXNQcm9wZXJ0eT1mdW5jdGlvbihuLHQpe3JldHVybiBYdChuLGR0KHQsMSkpfSxPbi5tZW1vaXplPWx1LE9uLm1lcmdlPUlmLE9uLm1lcmdlV2l0aD1SZixPbi5tZXRob2Q9S2YsT24ubWV0aG9kT2Y9R2YsT24ubWl4aW49WnUsT24ubmVnYXRlPXN1LE9uLm50aEFyZz1mdW5jdGlvbihuKXtyZXR1cm4gbj1PdShuKSxscihmdW5jdGlvbih0KXtyZXR1cm4gdHIodCxuKX0pfSxPbi5vbWl0PXpmLE9uLm9taXRCeT1mdW5jdGlvbihuLHQpe3JldHVybiBDdShuLHN1KGplKHQpKSl9LE9uLm9uY2U9ZnVuY3Rpb24obil7cmV0dXJuIG91KDIsbil9LE9uLm9yZGVyQnk9ZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIG51bGw9PW4/W106KGFmKHQpfHwodD1udWxsPT10P1tdOlt0XSksXG5yPWU/RjpyLGFmKHIpfHwocj1udWxsPT1yP1tdOltyXSkscnIobix0LHIpKX0sT24ub3Zlcj1IZixPbi5vdmVyQXJncz10ZixPbi5vdmVyRXZlcnk9SmYsT24ub3ZlclNvbWU9WWYsT24ucGFydGlhbD1yZixPbi5wYXJ0aWFsUmlnaHQ9ZWYsT24ucGFydGl0aW9uPUdvLE9uLnBpY2s9V2YsT24ucGlja0J5PUN1LE9uLnByb3BlcnR5PVZ1LE9uLnByb3BlcnR5T2Y9ZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT1uP0Y6SXQobix0KX19LE9uLnB1bGw9Um8sT24ucHVsbEFsbD1IZSxPbi5wdWxsQWxsQnk9ZnVuY3Rpb24obix0LHIpe3JldHVybiBuJiZuLmxlbmd0aCYmdCYmdC5sZW5ndGg/b3Iobix0LGplKHIsMikpOm59LE9uLnB1bGxBbGxXaXRoPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbiYmbi5sZW5ndGgmJnQmJnQubGVuZ3RoP29yKG4sdCxGLHIpOm59LE9uLnB1bGxBdD16byxPbi5yYW5nZT1RZixPbi5yYW5nZVJpZ2h0PVhmLE9uLnJlYXJnPXVmLE9uLnJlamVjdD1mdW5jdGlvbihuLHQpe1xucmV0dXJuKGFmKG4pP2Y6QXQpKG4sc3UoamUodCwzKSkpfSxPbi5yZW1vdmU9ZnVuY3Rpb24obix0KXt2YXIgcj1bXTtpZighbnx8IW4ubGVuZ3RoKXJldHVybiByO3ZhciBlPS0xLHU9W10saT1uLmxlbmd0aDtmb3IodD1qZSh0LDMpOysrZTxpOyl7dmFyIG89bltlXTt0KG8sZSxuKSYmKHIucHVzaChvKSx1LnB1c2goZSkpfXJldHVybiBmcihuLHUpLHJ9LE9uLnJlc3Q9ZnVuY3Rpb24obix0KXtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBlaShcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIik7cmV0dXJuIHQ9dD09PUY/dDpPdSh0KSxscihuLHQpfSxPbi5yZXZlcnNlPUplLE9uLnNhbXBsZVNpemU9ZnVuY3Rpb24obix0LHIpe3JldHVybiB0PShyP3plKG4sdCxyKTp0PT09Rik/MTpPdSh0KSwoYWYobik/b3Q6aHIpKG4sdCl9LE9uLnNldD1mdW5jdGlvbihuLHQscil7cmV0dXJuIG51bGw9PW4/bjpwcihuLHQscil9LE9uLnNldFdpdGg9ZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIGU9dHlwZW9mIGU9PVwiZnVuY3Rpb25cIj9lOkYsXG5udWxsPT1uP246cHIobix0LHIsZSl9LE9uLnNodWZmbGU9ZnVuY3Rpb24obil7cmV0dXJuKGFmKG4pP2Z0Ol9yKShuKX0sT24uc2xpY2U9ZnVuY3Rpb24obix0LHIpe3ZhciBlPW51bGw9PW4/MDpuLmxlbmd0aDtyZXR1cm4gZT8ociYmdHlwZW9mIHIhPVwibnVtYmVyXCImJnplKG4sdCxyKT8odD0wLHI9ZSk6KHQ9bnVsbD09dD8wOk91KHQpLHI9cj09PUY/ZTpPdShyKSksdnIobix0LHIpKTpbXX0sT24uc29ydEJ5PUhvLE9uLnNvcnRlZFVuaXE9ZnVuY3Rpb24obil7cmV0dXJuIG4mJm4ubGVuZ3RoP2JyKG4pOltdfSxPbi5zb3J0ZWRVbmlxQnk9ZnVuY3Rpb24obix0KXtyZXR1cm4gbiYmbi5sZW5ndGg/YnIobixqZSh0LDIpKTpbXX0sT24uc3BsaXQ9ZnVuY3Rpb24obix0LHIpe3JldHVybiByJiZ0eXBlb2YgciE9XCJudW1iZXJcIiYmemUobix0LHIpJiYodD1yPUYpLHI9cj09PUY/NDI5NDk2NzI5NTpyPj4+MCxyPyhuPXp1KG4pKSYmKHR5cGVvZiB0PT1cInN0cmluZ1wifHxudWxsIT10JiYhX2YodCkpJiYodD1qcih0KSxcbiF0JiZCbi50ZXN0KG4pKT96cigkKG4pLDAscik6bi5zcGxpdCh0LHIpOltdfSxPbi5zcHJlYWQ9ZnVuY3Rpb24obix0KXtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBlaShcIkV4cGVjdGVkIGEgZnVuY3Rpb25cIik7cmV0dXJuIHQ9bnVsbD09dD8wOkRpKE91KHQpLDApLGxyKGZ1bmN0aW9uKGUpe3ZhciB1PWVbdF07cmV0dXJuIGU9enIoZSwwLHQpLHUmJnMoZSx1KSxyKG4sdGhpcyxlKX0pfSxPbi50YWlsPWZ1bmN0aW9uKG4pe3ZhciB0PW51bGw9PW4/MDpuLmxlbmd0aDtyZXR1cm4gdD92cihuLDEsdCk6W119LE9uLnRha2U9ZnVuY3Rpb24obix0LHIpe3JldHVybiBuJiZuLmxlbmd0aD8odD1yfHx0PT09Rj8xOk91KHQpLHZyKG4sMCwwPnQ/MDp0KSk6W119LE9uLnRha2VSaWdodD1mdW5jdGlvbihuLHQscil7dmFyIGU9bnVsbD09bj8wOm4ubGVuZ3RoO3JldHVybiBlPyh0PXJ8fHQ9PT1GPzE6T3UodCksdD1lLXQsdnIobiwwPnQ/MDp0LGUpKTpbXX0sT24udGFrZVJpZ2h0V2hpbGU9ZnVuY3Rpb24obix0KXtcbnJldHVybiBuJiZuLmxlbmd0aD9BcihuLGplKHQsMyksZmFsc2UsdHJ1ZSk6W119LE9uLnRha2VXaGlsZT1mdW5jdGlvbihuLHQpe3JldHVybiBuJiZuLmxlbmd0aD9BcihuLGplKHQsMykpOltdfSxPbi50YXA9ZnVuY3Rpb24obix0KXtyZXR1cm4gdChuKSxufSxPbi50aHJvdHRsZT1mdW5jdGlvbihuLHQscil7dmFyIGU9dHJ1ZSx1PXRydWU7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgZWkoXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIpO3JldHVybiBidShyKSYmKGU9XCJsZWFkaW5nXCJpbiByPyEhci5sZWFkaW5nOmUsdT1cInRyYWlsaW5nXCJpbiByPyEhci50cmFpbGluZzp1KSxhdShuLHQse2xlYWRpbmc6ZSxtYXhXYWl0OnQsdHJhaWxpbmc6dX0pfSxPbi50aHJ1PW51LE9uLnRvQXJyYXk9a3UsT24udG9QYWlycz1CZixPbi50b1BhaXJzSW49TGYsT24udG9QYXRoPWZ1bmN0aW9uKG4pe3JldHVybiBhZihuKT9sKG4sJGUpOkF1KG4pP1tuXTpNcihtbyh6dShuKSkpfSxPbi50b1BsYWluT2JqZWN0PVJ1LFxuT24udHJhbnNmb3JtPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1hZihuKSxpPWV8fHNmKG4pfHxnZihuKTtpZih0PWplKHQsNCksbnVsbD09cil7dmFyIG89biYmbi5jb25zdHJ1Y3RvcjtyPWk/ZT9uZXcgbzpbXTpidShuKSYmZ3Uobyk/aW8oYmkobikpOnt9fXJldHVybihpP3U6RXQpKG4sZnVuY3Rpb24obixlLHUpe3JldHVybiB0KHIsbixlLHUpfSkscn0sT24udW5hcnk9ZnVuY3Rpb24obil7cmV0dXJuIGl1KG4sMSl9LE9uLnVuaW9uPVdvLE9uLnVuaW9uQnk9Qm8sT24udW5pb25XaXRoPUxvLE9uLnVuaXE9ZnVuY3Rpb24obil7cmV0dXJuIG4mJm4ubGVuZ3RoP3dyKG4pOltdfSxPbi51bmlxQnk9ZnVuY3Rpb24obix0KXtyZXR1cm4gbiYmbi5sZW5ndGg/d3IobixqZSh0LDIpKTpbXX0sT24udW5pcVdpdGg9ZnVuY3Rpb24obix0KXtyZXR1cm4gdD10eXBlb2YgdD09XCJmdW5jdGlvblwiP3Q6RixuJiZuLmxlbmd0aD93cihuLEYsdCk6W119LE9uLnVuc2V0PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW58fG1yKG4sdCk7XG59LE9uLnVuemlwPVllLE9uLnVuemlwV2l0aD1RZSxPbi51cGRhdGU9ZnVuY3Rpb24obix0LHIpe3JldHVybiBudWxsPT1uP246cHIobix0LElyKHIpKEl0KG4sdCkpLHZvaWQgMCl9LE9uLnVwZGF0ZVdpdGg9ZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIGU9dHlwZW9mIGU9PVwiZnVuY3Rpb25cIj9lOkYsbnVsbCE9biYmKG49cHIobix0LElyKHIpKEl0KG4sdCkpLGUpKSxufSxPbi52YWx1ZXM9RHUsT24udmFsdWVzSW49ZnVuY3Rpb24obil7cmV0dXJuIG51bGw9PW4/W106SShuLFV1KG4pKX0sT24ud2l0aG91dD1VbyxPbi53b3Jkcz0kdSxPbi53cmFwPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHJmKElyKHQpLG4pfSxPbi54b3I9Q28sT24ueG9yQnk9RG8sT24ueG9yV2l0aD1NbyxPbi56aXA9VG8sT24uemlwT2JqZWN0PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIE9yKG58fFtdLHR8fFtdLGF0KX0sT24uemlwT2JqZWN0RGVlcD1mdW5jdGlvbihuLHQpe3JldHVybiBPcihufHxbXSx0fHxbXSxwcik7XG59LE9uLnppcFdpdGg9JG8sT24uZW50cmllcz1CZixPbi5lbnRyaWVzSW49TGYsT24uZXh0ZW5kPXhmLE9uLmV4dGVuZFdpdGg9amYsWnUoT24sT24pLE9uLmFkZD1uYyxPbi5hdHRlbXB0PVBmLE9uLmNhbWVsQ2FzZT1VZixPbi5jYXBpdGFsaXplPU11LE9uLmNlaWw9dGMsT24uY2xhbXA9ZnVuY3Rpb24obix0LHIpe3JldHVybiByPT09RiYmKHI9dCx0PUYpLHIhPT1GJiYocj1JdShyKSxyPXI9PT1yP3I6MCksdCE9PUYmJih0PUl1KHQpLHQ9dD09PXQ/dDowKSxndChJdShuKSx0LHIpfSxPbi5jbG9uZT1mdW5jdGlvbihuKXtyZXR1cm4gZHQobiw0KX0sT24uY2xvbmVEZWVwPWZ1bmN0aW9uKG4pe3JldHVybiBkdChuLDUpfSxPbi5jbG9uZURlZXBXaXRoPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHQ9dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90OkYsZHQobiw1LHQpfSxPbi5jbG9uZVdpdGg9ZnVuY3Rpb24obix0KXtyZXR1cm4gdD10eXBlb2YgdD09XCJmdW5jdGlvblwiP3Q6RixkdChuLDQsdCl9LFxuT24uY29uZm9ybXNUbz1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT10fHxidChuLHQsTHUodCkpfSxPbi5kZWJ1cnI9VHUsT24uZGVmYXVsdFRvPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW58fG4hPT1uP3Q6bn0sT24uZGl2aWRlPXJjLE9uLmVuZHNXaXRoPWZ1bmN0aW9uKG4sdCxyKXtuPXp1KG4pLHQ9anIodCk7dmFyIGU9bi5sZW5ndGgsZT1yPXI9PT1GP2U6Z3QoT3UociksMCxlKTtyZXR1cm4gci09dC5sZW5ndGgsMDw9ciYmbi5zbGljZShyLGUpPT10fSxPbi5lcT1odSxPbi5lc2NhcGU9ZnVuY3Rpb24obil7cmV0dXJuKG49enUobikpJiZZLnRlc3Qobik/bi5yZXBsYWNlKEgsZXQpOm59LE9uLmVzY2FwZVJlZ0V4cD1mdW5jdGlvbihuKXtyZXR1cm4obj16dShuKSkmJmZuLnRlc3Qobik/bi5yZXBsYWNlKG9uLFwiXFxcXCQmXCIpOm59LE9uLmV2ZXJ5PWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1hZihuKT9vOnd0O3JldHVybiByJiZ6ZShuLHQscikmJih0PUYpLGUobixqZSh0LDMpKTtcbn0sT24uZmluZD1QbyxPbi5maW5kSW5kZXg9WmUsT24uZmluZEtleT1mdW5jdGlvbihuLHQpe3JldHVybiB2KG4samUodCwzKSxFdCl9LE9uLmZpbmRMYXN0PVpvLE9uLmZpbmRMYXN0SW5kZXg9cWUsT24uZmluZExhc3RLZXk9ZnVuY3Rpb24obix0KXtyZXR1cm4gdihuLGplKHQsMyksT3QpfSxPbi5mbG9vcj1lYyxPbi5mb3JFYWNoPXJ1LE9uLmZvckVhY2hSaWdodD1ldSxPbi5mb3JJbj1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP246Y28obixqZSh0LDMpLFV1KX0sT24uZm9ySW5SaWdodD1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP246YW8obixqZSh0LDMpLFV1KX0sT24uZm9yT3duPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4mJkV0KG4samUodCwzKSl9LE9uLmZvck93blJpZ2h0PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4mJk90KG4samUodCwzKSl9LE9uLmdldD1XdSxPbi5ndD1vZixPbi5ndGU9ZmYsT24uaGFzPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGwhPW4mJmtlKG4sdCxCdCk7XG59LE9uLmhhc0luPUJ1LE9uLmhlYWQ9S2UsT24uaWRlbnRpdHk9TnUsT24uaW5jbHVkZXM9ZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIG49cHUobik/bjpEdShuKSxyPXImJiFlP091KHIpOjAsZT1uLmxlbmd0aCwwPnImJihyPURpKGUrciwwKSksbXUobik/cjw9ZSYmLTE8bi5pbmRleE9mKHQscik6ISFlJiYtMTxkKG4sdCxyKX0sT24uaW5kZXhPZj1mdW5jdGlvbihuLHQscil7dmFyIGU9bnVsbD09bj8wOm4ubGVuZ3RoO3JldHVybiBlPyhyPW51bGw9PXI/MDpPdShyKSwwPnImJihyPURpKGUrciwwKSksZChuLHQscikpOi0xfSxPbi5pblJhbmdlPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gdD1FdSh0KSxyPT09Rj8ocj10LHQ9MCk6cj1FdShyKSxuPUl1KG4pLG4+PU1pKHQscikmJm48RGkodCxyKX0sT24uaW52b2tlPVNmLE9uLmlzQXJndW1lbnRzPWNmLE9uLmlzQXJyYXk9YWYsT24uaXNBcnJheUJ1ZmZlcj1sZixPbi5pc0FycmF5TGlrZT1wdSxPbi5pc0FycmF5TGlrZU9iamVjdD1fdSxcbk9uLmlzQm9vbGVhbj1mdW5jdGlvbihuKXtyZXR1cm4gdHJ1ZT09PW58fGZhbHNlPT09bnx8eHUobikmJlwiW29iamVjdCBCb29sZWFuXVwiPT16dChuKX0sT24uaXNCdWZmZXI9c2YsT24uaXNEYXRlPWhmLE9uLmlzRWxlbWVudD1mdW5jdGlvbihuKXtyZXR1cm4geHUobikmJjE9PT1uLm5vZGVUeXBlJiYhd3Uobil9LE9uLmlzRW1wdHk9ZnVuY3Rpb24obil7aWYobnVsbD09bilyZXR1cm4gdHJ1ZTtpZihwdShuKSYmKGFmKG4pfHx0eXBlb2Ygbj09XCJzdHJpbmdcInx8dHlwZW9mIG4uc3BsaWNlPT1cImZ1bmN0aW9uXCJ8fHNmKG4pfHxnZihuKXx8Y2YobikpKXJldHVybiFuLmxlbmd0aDt2YXIgdD15byhuKTtpZihcIltvYmplY3QgTWFwXVwiPT10fHxcIltvYmplY3QgU2V0XVwiPT10KXJldHVybiFuLnNpemU7aWYoTGUobikpcmV0dXJuIUh0KG4pLmxlbmd0aDtmb3IodmFyIHIgaW4gbilpZihjaS5jYWxsKG4scikpcmV0dXJuIGZhbHNlO3JldHVybiB0cnVlfSxPbi5pc0VxdWFsPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEZ0KG4sdCk7XG59LE9uLmlzRXF1YWxXaXRoPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT0ocj10eXBlb2Ygcj09XCJmdW5jdGlvblwiP3I6Rik/cihuLHQpOkY7cmV0dXJuIGU9PT1GP0Z0KG4sdCxGLHIpOiEhZX0sT24uaXNFcnJvcj12dSxPbi5pc0Zpbml0ZT1mdW5jdGlvbihuKXtyZXR1cm4gdHlwZW9mIG49PVwibnVtYmVyXCImJkxpKG4pfSxPbi5pc0Z1bmN0aW9uPWd1LE9uLmlzSW50ZWdlcj1kdSxPbi5pc0xlbmd0aD15dSxPbi5pc01hcD1wZixPbi5pc01hdGNoPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG49PT10fHxQdChuLHQsbWUodCkpfSxPbi5pc01hdGNoV2l0aD1mdW5jdGlvbihuLHQscil7cmV0dXJuIHI9dHlwZW9mIHI9PVwiZnVuY3Rpb25cIj9yOkYsUHQobix0LG1lKHQpLHIpfSxPbi5pc05hTj1mdW5jdGlvbihuKXtyZXR1cm4ganUobikmJm4hPStufSxPbi5pc05hdGl2ZT1mdW5jdGlvbihuKXtpZihibyhuKSl0aHJvdyBuZXcgWXUoXCJVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC5cIik7XG5yZXR1cm4gWnQobil9LE9uLmlzTmlsPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsPT1ufSxPbi5pc051bGw9ZnVuY3Rpb24obil7cmV0dXJuIG51bGw9PT1ufSxPbi5pc051bWJlcj1qdSxPbi5pc09iamVjdD1idSxPbi5pc09iamVjdExpa2U9eHUsT24uaXNQbGFpbk9iamVjdD13dSxPbi5pc1JlZ0V4cD1fZixPbi5pc1NhZmVJbnRlZ2VyPWZ1bmN0aW9uKG4pe3JldHVybiBkdShuKSYmLTkwMDcxOTkyNTQ3NDA5OTE8PW4mJjkwMDcxOTkyNTQ3NDA5OTE+PW59LE9uLmlzU2V0PXZmLE9uLmlzU3RyaW5nPW11LE9uLmlzU3ltYm9sPUF1LE9uLmlzVHlwZWRBcnJheT1nZixPbi5pc1VuZGVmaW5lZD1mdW5jdGlvbihuKXtyZXR1cm4gbj09PUZ9LE9uLmlzV2Vha01hcD1mdW5jdGlvbihuKXtyZXR1cm4geHUobikmJlwiW29iamVjdCBXZWFrTWFwXVwiPT15byhuKX0sT24uaXNXZWFrU2V0PWZ1bmN0aW9uKG4pe3JldHVybiB4dShuKSYmXCJbb2JqZWN0IFdlYWtTZXRdXCI9PXp0KG4pfSxPbi5qb2luPWZ1bmN0aW9uKG4sdCl7XG5yZXR1cm4gbnVsbD09bj9cIlwiOlVpLmNhbGwobix0KX0sT24ua2ViYWJDYXNlPUNmLE9uLmxhc3Q9R2UsT24ubGFzdEluZGV4T2Y9ZnVuY3Rpb24obix0LHIpe3ZhciBlPW51bGw9PW4/MDpuLmxlbmd0aDtpZighZSlyZXR1cm4tMTt2YXIgdT1lO2lmKHIhPT1GJiYodT1PdShyKSx1PTA+dT9EaShlK3UsMCk6TWkodSxlLTEpKSx0PT09dCl7Zm9yKHI9dSsxO3ItLSYmbltyXSE9PXQ7KTtuPXJ9ZWxzZSBuPWcobixiLHUsdHJ1ZSk7cmV0dXJuIG59LE9uLmxvd2VyQ2FzZT1EZixPbi5sb3dlckZpcnN0PU1mLE9uLmx0PWRmLE9uLmx0ZT15ZixPbi5tYXg9ZnVuY3Rpb24obil7cmV0dXJuIG4mJm4ubGVuZ3RoP210KG4sTnUsV3QpOkZ9LE9uLm1heEJ5PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4mJm4ubGVuZ3RoP210KG4samUodCwyKSxXdCk6Rn0sT24ubWVhbj1mdW5jdGlvbihuKXtyZXR1cm4geChuLE51KX0sT24ubWVhbkJ5PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHgobixqZSh0LDIpKX0sT24ubWluPWZ1bmN0aW9uKG4pe1xucmV0dXJuIG4mJm4ubGVuZ3RoP210KG4sTnUsSnQpOkZ9LE9uLm1pbkJ5PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4mJm4ubGVuZ3RoP210KG4samUodCwyKSxKdCk6Rn0sT24uc3R1YkFycmF5PUt1LE9uLnN0dWJGYWxzZT1HdSxPbi5zdHViT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJue319LE9uLnN0dWJTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlwifSxPbi5zdHViVHJ1ZT1mdW5jdGlvbigpe3JldHVybiB0cnVlfSxPbi5tdWx0aXBseT11YyxPbi5udGg9ZnVuY3Rpb24obix0KXtyZXR1cm4gbiYmbi5sZW5ndGg/dHIobixPdSh0KSk6Rn0sT24ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBabi5fPT09dGhpcyYmKFpuLl89cGkpLHRoaXN9LE9uLm5vb3A9cXUsT24ubm93PUpvLE9uLnBhZD1mdW5jdGlvbihuLHQscil7bj16dShuKTt2YXIgZT0odD1PdSh0KSk/VChuKTowO3JldHVybiF0fHxlPj10P246KHQ9KHQtZSkvMixlZSh6aSh0KSxyKStuK2VlKFJpKHQpLHIpKX0sT24ucGFkRW5kPWZ1bmN0aW9uKG4sdCxyKXtcbm49enUobik7dmFyIGU9KHQ9T3UodCkpP1Qobik6MDtyZXR1cm4gdCYmZTx0P24rZWUodC1lLHIpOm59LE9uLnBhZFN0YXJ0PWZ1bmN0aW9uKG4sdCxyKXtuPXp1KG4pO3ZhciBlPSh0PU91KHQpKT9UKG4pOjA7cmV0dXJuIHQmJmU8dD9lZSh0LWUscikrbjpufSxPbi5wYXJzZUludD1mdW5jdGlvbihuLHQscil7cmV0dXJuIHJ8fG51bGw9PXQ/dD0wOnQmJih0PSt0KSwkaSh6dShuKS5yZXBsYWNlKGFuLFwiXCIpLHR8fDApfSxPbi5yYW5kb209ZnVuY3Rpb24obix0LHIpe2lmKHImJnR5cGVvZiByIT1cImJvb2xlYW5cIiYmemUobix0LHIpJiYodD1yPUYpLHI9PT1GJiYodHlwZW9mIHQ9PVwiYm9vbGVhblwiPyhyPXQsdD1GKTp0eXBlb2Ygbj09XCJib29sZWFuXCImJihyPW4sbj1GKSksbj09PUYmJnQ9PT1GPyhuPTAsdD0xKToobj1FdShuKSx0PT09Rj8odD1uLG49MCk6dD1FdSh0KSksbj50KXt2YXIgZT1uO249dCx0PWV9cmV0dXJuIHJ8fG4lMXx8dCUxPyhyPUZpKCksTWkobityKih0LW4rJG4oXCIxZS1cIisoKHIrXCJcIikubGVuZ3RoLTEpKSksdCkpOmNyKG4sdCk7XG59LE9uLnJlZHVjZT1mdW5jdGlvbihuLHQscil7dmFyIGU9YWYobik/aDptLHU9Mz5hcmd1bWVudHMubGVuZ3RoO3JldHVybiBlKG4samUodCw0KSxyLHUsb28pfSxPbi5yZWR1Y2VSaWdodD1mdW5jdGlvbihuLHQscil7dmFyIGU9YWYobik/cDptLHU9Mz5hcmd1bWVudHMubGVuZ3RoO3JldHVybiBlKG4samUodCw0KSxyLHUsZm8pfSxPbi5yZXBlYXQ9ZnVuY3Rpb24obix0LHIpe3JldHVybiB0PShyP3plKG4sdCxyKTp0PT09Rik/MTpPdSh0KSxhcih6dShuKSx0KX0sT24ucmVwbGFjZT1mdW5jdGlvbigpe3ZhciBuPWFyZ3VtZW50cyx0PXp1KG5bMF0pO3JldHVybiAzPm4ubGVuZ3RoP3Q6dC5yZXBsYWNlKG5bMV0sblsyXSl9LE9uLnJlc3VsdD1mdW5jdGlvbihuLHQscil7dD1Scih0LG4pO3ZhciBlPS0xLHU9dC5sZW5ndGg7Zm9yKHV8fCh1PTEsbj1GKTsrK2U8dTspe3ZhciBpPW51bGw9PW4/RjpuWyRlKHRbZV0pXTtpPT09RiYmKGU9dSxpPXIpLG49Z3UoaSk/aS5jYWxsKG4pOmk7XG59cmV0dXJuIG59LE9uLnJvdW5kPWljLE9uLnJ1bkluQ29udGV4dD13LE9uLnNhbXBsZT1mdW5jdGlvbihuKXtyZXR1cm4oYWYobik/dHQ6c3IpKG4pfSxPbi5zaXplPWZ1bmN0aW9uKG4pe2lmKG51bGw9PW4pcmV0dXJuIDA7aWYocHUobikpcmV0dXJuIG11KG4pP1Qobik6bi5sZW5ndGg7dmFyIHQ9eW8obik7cmV0dXJuXCJbb2JqZWN0IE1hcF1cIj09dHx8XCJbb2JqZWN0IFNldF1cIj09dD9uLnNpemU6SHQobikubGVuZ3RofSxPbi5zbmFrZUNhc2U9VGYsT24uc29tZT1mdW5jdGlvbihuLHQscil7dmFyIGU9YWYobik/XzpncjtyZXR1cm4gciYmemUobix0LHIpJiYodD1GKSxlKG4samUodCwzKSl9LE9uLnNvcnRlZEluZGV4PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIGRyKG4sdCl9LE9uLnNvcnRlZEluZGV4Qnk9ZnVuY3Rpb24obix0LHIpe3JldHVybiB5cihuLHQsamUociwyKSl9LE9uLnNvcnRlZEluZGV4T2Y9ZnVuY3Rpb24obix0KXt2YXIgcj1udWxsPT1uPzA6bi5sZW5ndGg7aWYocil7XG52YXIgZT1kcihuLHQpO2lmKGU8ciYmaHUobltlXSx0KSlyZXR1cm4gZX1yZXR1cm4tMX0sT24uc29ydGVkTGFzdEluZGV4PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIGRyKG4sdCx0cnVlKX0sT24uc29ydGVkTGFzdEluZGV4Qnk9ZnVuY3Rpb24obix0LHIpe3JldHVybiB5cihuLHQsamUociwyKSx0cnVlKX0sT24uc29ydGVkTGFzdEluZGV4T2Y9ZnVuY3Rpb24obix0KXtpZihudWxsPT1uPzA6bi5sZW5ndGgpe3ZhciByPWRyKG4sdCx0cnVlKS0xO2lmKGh1KG5bcl0sdCkpcmV0dXJuIHJ9cmV0dXJuLTF9LE9uLnN0YXJ0Q2FzZT0kZixPbi5zdGFydHNXaXRoPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbj16dShuKSxyPW51bGw9PXI/MDpndChPdShyKSwwLG4ubGVuZ3RoKSx0PWpyKHQpLG4uc2xpY2UocixyK3QubGVuZ3RoKT09dH0sT24uc3VidHJhY3Q9b2MsT24uc3VtPWZ1bmN0aW9uKG4pe3JldHVybiBuJiZuLmxlbmd0aD9rKG4sTnUpOjB9LE9uLnN1bUJ5PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4mJm4ubGVuZ3RoP2sobixqZSh0LDIpKTowO1xufSxPbi50ZW1wbGF0ZT1mdW5jdGlvbihuLHQscil7dmFyIGU9T24udGVtcGxhdGVTZXR0aW5ncztyJiZ6ZShuLHQscikmJih0PUYpLG49enUobiksdD1qZih7fSx0LGUsc2UpLHI9amYoe30sdC5pbXBvcnRzLGUuaW1wb3J0cyxzZSk7dmFyIHUsaSxvPUx1KHIpLGY9SShyLG8pLGM9MDtyPXQuaW50ZXJwb2xhdGV8fEFuO3ZhciBhPVwiX19wKz0nXCI7cj10aSgodC5lc2NhcGV8fEFuKS5zb3VyY2UrXCJ8XCIrci5zb3VyY2UrXCJ8XCIrKHI9PT1ubj9nbjpBbikuc291cmNlK1wifFwiKyh0LmV2YWx1YXRlfHxBbikuc291cmNlK1wifCRcIixcImdcIik7dmFyIGw9XCJzb3VyY2VVUkxcImluIHQ/XCIvLyMgc291cmNlVVJMPVwiK3Quc291cmNlVVJMK1wiXFxuXCI6XCJcIjtpZihuLnJlcGxhY2UocixmdW5jdGlvbih0LHIsZSxvLGYsbCl7cmV0dXJuIGV8fChlPW8pLGErPW4uc2xpY2UoYyxsKS5yZXBsYWNlKGtuLEIpLHImJih1PXRydWUsYSs9XCInK19fZShcIityK1wiKSsnXCIpLGYmJihpPXRydWUsYSs9XCInO1wiK2YrXCI7XFxuX19wKz0nXCIpLFxuZSYmKGErPVwiJysoKF9fdD0oXCIrZStcIikpPT1udWxsPycnOl9fdCkrJ1wiKSxjPWwrdC5sZW5ndGgsdH0pLGErPVwiJztcIiwodD10LnZhcmlhYmxlKXx8KGE9XCJ3aXRoKG9iail7XCIrYStcIn1cIiksYT0oaT9hLnJlcGxhY2UocSxcIlwiKTphKS5yZXBsYWNlKFYsXCIkMVwiKS5yZXBsYWNlKEssXCIkMTtcIiksYT1cImZ1bmN0aW9uKFwiKyh0fHxcIm9ialwiKStcIil7XCIrKHQ/XCJcIjpcIm9ianx8KG9iaj17fSk7XCIpK1widmFyIF9fdCxfX3A9JydcIisodT9cIixfX2U9Xy5lc2NhcGVcIjpcIlwiKSsoaT9cIixfX2o9QXJyYXkucHJvdG90eXBlLmpvaW47ZnVuY3Rpb24gcHJpbnQoKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyl9XCI6XCI7XCIpK2ErXCJyZXR1cm4gX19wfVwiLHQ9UGYoZnVuY3Rpb24oKXtyZXR1cm4gUXUobyxsK1wicmV0dXJuIFwiK2EpLmFwcGx5KEYsZil9KSx0LnNvdXJjZT1hLHZ1KHQpKXRocm93IHQ7cmV0dXJuIHR9LE9uLnRpbWVzPWZ1bmN0aW9uKG4sdCl7aWYobj1PdShuKSwxPm58fDkwMDcxOTkyNTQ3NDA5OTE8bilyZXR1cm5bXTtcbnZhciByPTQyOTQ5NjcyOTUsZT1NaShuLDQyOTQ5NjcyOTUpO2Zvcih0PWplKHQpLG4tPTQyOTQ5NjcyOTUsZT1FKGUsdCk7KytyPG47KXQocik7cmV0dXJuIGV9LE9uLnRvRmluaXRlPUV1LE9uLnRvSW50ZWdlcj1PdSxPbi50b0xlbmd0aD1TdSxPbi50b0xvd2VyPWZ1bmN0aW9uKG4pe3JldHVybiB6dShuKS50b0xvd2VyQ2FzZSgpfSxPbi50b051bWJlcj1JdSxPbi50b1NhZmVJbnRlZ2VyPWZ1bmN0aW9uKG4pe3JldHVybiBuP2d0KE91KG4pLC05MDA3MTk5MjU0NzQwOTkxLDkwMDcxOTkyNTQ3NDA5OTEpOjA9PT1uP246MH0sT24udG9TdHJpbmc9enUsT24udG9VcHBlcj1mdW5jdGlvbihuKXtyZXR1cm4genUobikudG9VcHBlckNhc2UoKX0sT24udHJpbT1mdW5jdGlvbihuLHQscil7cmV0dXJuKG49enUobikpJiYocnx8dD09PUYpP24ucmVwbGFjZShjbixcIlwiKTpuJiYodD1qcih0KSk/KG49JChuKSxyPSQodCksdD16KG4scikscj1XKG4scikrMSx6cihuLHQscikuam9pbihcIlwiKSk6bjtcbn0sT24udHJpbUVuZD1mdW5jdGlvbihuLHQscil7cmV0dXJuKG49enUobikpJiYocnx8dD09PUYpP24ucmVwbGFjZShsbixcIlwiKTpuJiYodD1qcih0KSk/KG49JChuKSx0PVcobiwkKHQpKSsxLHpyKG4sMCx0KS5qb2luKFwiXCIpKTpufSxPbi50cmltU3RhcnQ9ZnVuY3Rpb24obix0LHIpe3JldHVybihuPXp1KG4pKSYmKHJ8fHQ9PT1GKT9uLnJlcGxhY2UoYW4sXCJcIik6biYmKHQ9anIodCkpPyhuPSQobiksdD16KG4sJCh0KSksenIobix0KS5qb2luKFwiXCIpKTpufSxPbi50cnVuY2F0ZT1mdW5jdGlvbihuLHQpe3ZhciByPTMwLGU9XCIuLi5cIjtpZihidSh0KSl2YXIgdT1cInNlcGFyYXRvclwiaW4gdD90LnNlcGFyYXRvcjp1LHI9XCJsZW5ndGhcImluIHQ/T3UodC5sZW5ndGgpOnIsZT1cIm9taXNzaW9uXCJpbiB0P2pyKHQub21pc3Npb24pOmU7bj16dShuKTt2YXIgaT1uLmxlbmd0aDtpZihCbi50ZXN0KG4pKXZhciBvPSQobiksaT1vLmxlbmd0aDtpZihyPj1pKXJldHVybiBuO2lmKGk9ci1UKGUpLDE+aSlyZXR1cm4gZTtcbmlmKHI9bz96cihvLDAsaSkuam9pbihcIlwiKTpuLnNsaWNlKDAsaSksdT09PUYpcmV0dXJuIHIrZTtpZihvJiYoaSs9ci5sZW5ndGgtaSksX2YodSkpe2lmKG4uc2xpY2UoaSkuc2VhcmNoKHUpKXt2YXIgZj1yO2Zvcih1Lmdsb2JhbHx8KHU9dGkodS5zb3VyY2UsenUoZG4uZXhlYyh1KSkrXCJnXCIpKSx1Lmxhc3RJbmRleD0wO289dS5leGVjKGYpOyl2YXIgYz1vLmluZGV4O3I9ci5zbGljZSgwLGM9PT1GP2k6Yyl9fWVsc2Ugbi5pbmRleE9mKGpyKHUpLGkpIT1pJiYodT1yLmxhc3RJbmRleE9mKHUpLC0xPHUmJihyPXIuc2xpY2UoMCx1KSkpO3JldHVybiByK2V9LE9uLnVuZXNjYXBlPWZ1bmN0aW9uKG4pe3JldHVybihuPXp1KG4pKSYmSi50ZXN0KG4pP24ucmVwbGFjZShHLHV0KTpufSxPbi51bmlxdWVJZD1mdW5jdGlvbihuKXt2YXIgdD0rK2FpO3JldHVybiB6dShuKSt0fSxPbi51cHBlckNhc2U9RmYsT24udXBwZXJGaXJzdD1OZixPbi5lYWNoPXJ1LE9uLmVhY2hSaWdodD1ldSxPbi5maXJzdD1LZSxcblp1KE9uLGZ1bmN0aW9uKCl7dmFyIG49e307cmV0dXJuIEV0KE9uLGZ1bmN0aW9uKHQscil7Y2kuY2FsbChPbi5wcm90b3R5cGUscil8fChuW3JdPXQpfSksbn0oKSx7Y2hhaW46ZmFsc2V9KSxPbi5WRVJTSU9OPVwiNC4xNy40XCIsdShcImJpbmQgYmluZEtleSBjdXJyeSBjdXJyeVJpZ2h0IHBhcnRpYWwgcGFydGlhbFJpZ2h0XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKG4pe09uW25dLnBsYWNlaG9sZGVyPU9ufSksdShbXCJkcm9wXCIsXCJ0YWtlXCJdLGZ1bmN0aW9uKG4sdCl7TW4ucHJvdG90eXBlW25dPWZ1bmN0aW9uKHIpe3I9cj09PUY/MTpEaShPdShyKSwwKTt2YXIgZT10aGlzLl9fZmlsdGVyZWRfXyYmIXQ/bmV3IE1uKHRoaXMpOnRoaXMuY2xvbmUoKTtyZXR1cm4gZS5fX2ZpbHRlcmVkX18/ZS5fX3Rha2VDb3VudF9fPU1pKHIsZS5fX3Rha2VDb3VudF9fKTplLl9fdmlld3NfXy5wdXNoKHtzaXplOk1pKHIsNDI5NDk2NzI5NSksdHlwZTpuKygwPmUuX19kaXJfXz9cIlJpZ2h0XCI6XCJcIil9KSxlfSxNbi5wcm90b3R5cGVbbitcIlJpZ2h0XCJdPWZ1bmN0aW9uKHQpe1xucmV0dXJuIHRoaXMucmV2ZXJzZSgpW25dKHQpLnJldmVyc2UoKX19KSx1KFtcImZpbHRlclwiLFwibWFwXCIsXCJ0YWtlV2hpbGVcIl0sZnVuY3Rpb24obix0KXt2YXIgcj10KzEsZT0xPT1yfHwzPT1yO01uLnByb3RvdHlwZVtuXT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLmNsb25lKCk7cmV0dXJuIHQuX19pdGVyYXRlZXNfXy5wdXNoKHtpdGVyYXRlZTpqZShuLDMpLHR5cGU6cn0pLHQuX19maWx0ZXJlZF9fPXQuX19maWx0ZXJlZF9ffHxlLHR9fSksdShbXCJoZWFkXCIsXCJsYXN0XCJdLGZ1bmN0aW9uKG4sdCl7dmFyIHI9XCJ0YWtlXCIrKHQ/XCJSaWdodFwiOlwiXCIpO01uLnByb3RvdHlwZVtuXT1mdW5jdGlvbigpe3JldHVybiB0aGlzW3JdKDEpLnZhbHVlKClbMF19fSksdShbXCJpbml0aWFsXCIsXCJ0YWlsXCJdLGZ1bmN0aW9uKG4sdCl7dmFyIHI9XCJkcm9wXCIrKHQ/XCJcIjpcIlJpZ2h0XCIpO01uLnByb3RvdHlwZVtuXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fZmlsdGVyZWRfXz9uZXcgTW4odGhpcyk6dGhpc1tyXSgxKTtcbn19KSxNbi5wcm90b3R5cGUuY29tcGFjdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbHRlcihOdSl9LE1uLnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmZpbHRlcihuKS5oZWFkKCl9LE1uLnByb3RvdHlwZS5maW5kTGFzdD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChuKX0sTW4ucHJvdG90eXBlLmludm9rZU1hcD1scihmdW5jdGlvbihuLHQpe3JldHVybiB0eXBlb2Ygbj09XCJmdW5jdGlvblwiP25ldyBNbih0aGlzKTp0aGlzLm1hcChmdW5jdGlvbihyKXtyZXR1cm4gRHQocixuLHQpfSl9KSxNbi5wcm90b3R5cGUucmVqZWN0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmZpbHRlcihzdShqZShuKSkpfSxNbi5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24obix0KXtuPU91KG4pO3ZhciByPXRoaXM7cmV0dXJuIHIuX19maWx0ZXJlZF9fJiYoMDxufHwwPnQpP25ldyBNbihyKTooMD5uP3I9ci50YWtlUmlnaHQoLW4pOm4mJihyPXIuZHJvcChuKSksXG50IT09RiYmKHQ9T3UodCkscj0wPnQ/ci5kcm9wUmlnaHQoLXQpOnIudGFrZSh0LW4pKSxyKX0sTW4ucHJvdG90eXBlLnRha2VSaWdodFdoaWxlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUobikucmV2ZXJzZSgpfSxNbi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRha2UoNDI5NDk2NzI5NSl9LEV0KE1uLnByb3RvdHlwZSxmdW5jdGlvbihuLHQpe3ZhciByPS9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KHQpLGU9L14oPzpoZWFkfGxhc3QpJC8udGVzdCh0KSx1PU9uW2U/XCJ0YWtlXCIrKFwibGFzdFwiPT10P1wiUmlnaHRcIjpcIlwiKTp0XSxpPWV8fC9eZmluZC8udGVzdCh0KTt1JiYoT24ucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtyZXR1cm4gbj11LmFwcGx5KE9uLHMoW25dLGYpKSxlJiZoP25bMF06bn12YXIgbz10aGlzLl9fd3JhcHBlZF9fLGY9ZT9bMV06YXJndW1lbnRzLGM9byBpbnN0YW5jZW9mIE1uLGE9ZlswXSxsPWN8fGFmKG8pO1xubCYmciYmdHlwZW9mIGE9PVwiZnVuY3Rpb25cIiYmMSE9YS5sZW5ndGgmJihjPWw9ZmFsc2UpO3ZhciBoPXRoaXMuX19jaGFpbl9fLHA9ISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxhPWkmJiFoLGM9YyYmIXA7cmV0dXJuIWkmJmw/KG89Yz9vOm5ldyBNbih0aGlzKSxvPW4uYXBwbHkobyxmKSxvLl9fYWN0aW9uc19fLnB1c2goe2Z1bmM6bnUsYXJnczpbdF0sdGhpc0FyZzpGfSksbmV3IHpuKG8saCkpOmEmJmM/bi5hcHBseSh0aGlzLGYpOihvPXRoaXMudGhydSh0KSxhP2U/by52YWx1ZSgpWzBdOm8udmFsdWUoKTpvKX0pfSksdShcInBvcCBwdXNoIHNoaWZ0IHNvcnQgc3BsaWNlIHVuc2hpZnRcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24obil7dmFyIHQ9dWlbbl0scj0vXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3Qobik/XCJ0YXBcIjpcInRocnVcIixlPS9eKD86cG9wfHNoaWZ0KSQvLnRlc3Qobik7T24ucHJvdG90eXBlW25dPWZ1bmN0aW9uKCl7dmFyIG49YXJndW1lbnRzO2lmKGUmJiF0aGlzLl9fY2hhaW5fXyl7XG52YXIgdT10aGlzLnZhbHVlKCk7cmV0dXJuIHQuYXBwbHkoYWYodSk/dTpbXSxuKX1yZXR1cm4gdGhpc1tyXShmdW5jdGlvbihyKXtyZXR1cm4gdC5hcHBseShhZihyKT9yOltdLG4pfSl9fSksRXQoTW4ucHJvdG90eXBlLGZ1bmN0aW9uKG4sdCl7dmFyIHI9T25bdF07aWYocil7dmFyIGU9ci5uYW1lK1wiXCI7KEppW2VdfHwoSmlbZV09W10pKS5wdXNoKHtuYW1lOnQsZnVuYzpyfSl9fSksSmlbWHIoRiwyKS5uYW1lXT1be25hbWU6XCJ3cmFwcGVyXCIsZnVuYzpGfV0sTW4ucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIG49bmV3IE1uKHRoaXMuX193cmFwcGVkX18pO3JldHVybiBuLl9fYWN0aW9uc19fPU1yKHRoaXMuX19hY3Rpb25zX18pLG4uX19kaXJfXz10aGlzLl9fZGlyX18sbi5fX2ZpbHRlcmVkX189dGhpcy5fX2ZpbHRlcmVkX18sbi5fX2l0ZXJhdGVlc19fPU1yKHRoaXMuX19pdGVyYXRlZXNfXyksbi5fX3Rha2VDb3VudF9fPXRoaXMuX190YWtlQ291bnRfXyxuLl9fdmlld3NfXz1Ncih0aGlzLl9fdmlld3NfXyksXG5ufSxNbi5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbigpe2lmKHRoaXMuX19maWx0ZXJlZF9fKXt2YXIgbj1uZXcgTW4odGhpcyk7bi5fX2Rpcl9fPS0xLG4uX19maWx0ZXJlZF9fPXRydWV9ZWxzZSBuPXRoaXMuY2xvbmUoKSxuLl9fZGlyX18qPS0xO3JldHVybiBufSxNbi5wcm90b3R5cGUudmFsdWU9ZnVuY3Rpb24oKXt2YXIgbix0PXRoaXMuX193cmFwcGVkX18udmFsdWUoKSxyPXRoaXMuX19kaXJfXyxlPWFmKHQpLHU9MD5yLGk9ZT90Lmxlbmd0aDowO249aTtmb3IodmFyIG89dGhpcy5fX3ZpZXdzX18sZj0wLGM9LTEsYT1vLmxlbmd0aDsrK2M8YTspe3ZhciBsPW9bY10scz1sLnNpemU7c3dpdGNoKGwudHlwZSl7Y2FzZVwiZHJvcFwiOmYrPXM7YnJlYWs7Y2FzZVwiZHJvcFJpZ2h0XCI6bi09czticmVhaztjYXNlXCJ0YWtlXCI6bj1NaShuLGYrcyk7YnJlYWs7Y2FzZVwidGFrZVJpZ2h0XCI6Zj1EaShmLG4tcyl9fWlmKG49e3N0YXJ0OmYsZW5kOm59LG89bi5zdGFydCxmPW4uZW5kLG49Zi1vLFxubz11P2Y6by0xLGY9dGhpcy5fX2l0ZXJhdGVlc19fLGM9Zi5sZW5ndGgsYT0wLGw9TWkobix0aGlzLl9fdGFrZUNvdW50X18pLCFlfHwhdSYmaT09biYmbD09bilyZXR1cm4ga3IodCx0aGlzLl9fYWN0aW9uc19fKTtlPVtdO246Zm9yKDtuLS0mJmE8bDspe2ZvcihvKz1yLHU9LTEsaT10W29dOysrdTxjOyl7dmFyIGg9Zlt1XSxzPWgudHlwZSxoPSgwLGguaXRlcmF0ZWUpKGkpO2lmKDI9PXMpaT1oO2Vsc2UgaWYoIWgpe2lmKDE9PXMpY29udGludWUgbjticmVhayBufX1lW2ErK109aX1yZXR1cm4gZX0sT24ucHJvdG90eXBlLmF0PUZvLE9uLnByb3RvdHlwZS5jaGFpbj1mdW5jdGlvbigpe3JldHVybiBYZSh0aGlzKX0sT24ucHJvdG90eXBlLmNvbW1pdD1mdW5jdGlvbigpe3JldHVybiBuZXcgem4odGhpcy52YWx1ZSgpLHRoaXMuX19jaGFpbl9fKX0sT24ucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXt0aGlzLl9fdmFsdWVzX189PT1GJiYodGhpcy5fX3ZhbHVlc19fPWt1KHRoaXMudmFsdWUoKSkpO1xudmFyIG49dGhpcy5fX2luZGV4X18+PXRoaXMuX192YWx1ZXNfXy5sZW5ndGg7cmV0dXJue2RvbmU6bix2YWx1ZTpuP0Y6dGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdfX0sT24ucHJvdG90eXBlLnBsYW50PWZ1bmN0aW9uKG4pe2Zvcih2YXIgdCxyPXRoaXM7ciBpbnN0YW5jZW9mIFNuOyl7dmFyIGU9UGUocik7ZS5fX2luZGV4X189MCxlLl9fdmFsdWVzX189Rix0P3UuX193cmFwcGVkX189ZTp0PWU7dmFyIHU9ZSxyPXIuX193cmFwcGVkX199cmV0dXJuIHUuX193cmFwcGVkX189bix0fSxPbi5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX193cmFwcGVkX187cmV0dXJuIG4gaW5zdGFuY2VvZiBNbj8odGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgmJihuPW5ldyBNbih0aGlzKSksbj1uLnJldmVyc2UoKSxuLl9fYWN0aW9uc19fLnB1c2goe2Z1bmM6bnUsYXJnczpbSmVdLHRoaXNBcmc6Rn0pLG5ldyB6bihuLHRoaXMuX19jaGFpbl9fKSk6dGhpcy50aHJ1KEplKTtcbn0sT24ucHJvdG90eXBlLnRvSlNPTj1Pbi5wcm90b3R5cGUudmFsdWVPZj1Pbi5wcm90b3R5cGUudmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4ga3IodGhpcy5fX3dyYXBwZWRfXyx0aGlzLl9fYWN0aW9uc19fKX0sT24ucHJvdG90eXBlLmZpcnN0PU9uLnByb3RvdHlwZS5oZWFkLEFpJiYoT24ucHJvdG90eXBlW0FpXT10dSksT259KCk7dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZGVmaW5lLmFtZD09XCJvYmplY3RcIiYmZGVmaW5lLmFtZD8oWm4uXz1pdCwgZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGl0fSkpOlZuPygoVm4uZXhwb3J0cz1pdCkuXz1pdCxxbi5fPWl0KTpabi5fPWl0fSkuY2FsbCh0aGlzKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9sb2Rhc2gubWluLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCIvKipcbiAqIElmIG1pbiBzaW5nbGUgbGVzcyB0aGFuIG1pbiB0cmF2ZWxjYXJkIGFuZCBtYXggc2luZ2xlIG1vcmUgdGhhbiBtYXggdHJhdmVsY2FyZCAtIGNhbGN1bGF0ZXMgd2hpY2hldmVyIGlzIGNoZWFwZXI6XG4gKiBcdGVpdGhlciB0d28gc3BsaXQgc2luZ2xlcyBvciBmdWxsIGZhcmUgd2l0aG91dCB0cmF2ZWxjYXJkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyc30gbWluQ2hhcmdlZFpvbmUgLSB0aGUgbWluIHpvbmUgdGhhdCB3aWxsIGNoYXJnZSBiZXR3ZWVuIHRoaXMgbWluIGNoYXJnYWJsZSB6b25lIHRvIG1pbiB0cmF2ZWxjYXJkIC0gMSAoYXMgc2luZ2xlKSBhbmQgIG1heCBjaGFyZ2VhYmxlIHpvbmUgKHRvIGNoYXJnZSBiZXdlZW4gbWF4IHRyYXZlbGNhcmQgKzEgdG8gbWF4IGNoYXJnZWFibGUgem9uZSlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gcmV0dXJucyB0aGUgY2hlYXBlc3QgZmFyZVxuICogQGRlc2NyaXB0aW9uXG4gKi9cblxuaW1wb3J0IHtcblx0Z2V0U2luZ2xlRmFyZSxcblx0bWluTnVtLFxufSBmcm9tICcuLi91dGlsaXR5L191dGlsaXR5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3BsaXRPckZ1bGxGYXJlKFxuXHRtaW5DaGFyZ2VkWm9uZSwgbWF4U2luZ2xlLFxuXHRtaW5UcmF2ZWxjYXJkLCBtYXhUcmF2ZWxjYXJkLFxuXHRzaW5nbGVGYXJlcywgdHlwZSkge1xuXHRyZXR1cm4gbWluTnVtKFtcblx0XHRnZXRTaW5nbGVGYXJlKFttaW5DaGFyZ2VkWm9uZSwgbWF4U2luZ2xlXSwgc2luZ2xlRmFyZXMsIHR5cGUpLFxuXHRcdChnZXRTaW5nbGVGYXJlKFttaW5DaGFyZ2VkWm9uZSwgKG1pblRyYXZlbGNhcmQgLSAxKV0sIHNpbmdsZUZhcmVzLCB0eXBlKSArIGdldFNpbmdsZUZhcmUoWyhtYXhUcmF2ZWxjYXJkICsgMSksIG1heFNpbmdsZV0sIHNpbmdsZUZhcmVzLCB0eXBlKSlcblx0XSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3BhcnRpYWxzL19zcGxpdE9yRnVsbEZhcmUuanMiLCJpbXBvcnQge1xuXHRtYXhOdW0sXG5cdG1pbk51bSxcblx0ZmxhdHRlbixcblx0Z2V0RGFpbHlDYXAsXG5cdGdldFNpbmdsZUZhcmUsXG5cdGdldENhcCxcblx0bWV0LFxufSBmcm9tICcuL3V0aWxpdHkvX3V0aWxpdHknO1xuXG5pbXBvcnQgZ2V0RGF0YSBmcm9tICcuL3V0aWxpdHkvX2dldERhdGEnO1xuaW1wb3J0IGdldFNpbmdsZUpvdXJuZXlab25lcyBmcm9tICcuL3BhcnRpYWxzL19nZXRTaW5nbGVKb3VybmV5Wm9uZXMnO1xuaW1wb3J0IGV4dGVuc2lvbkZhcmVzIGZyb20gJy4vcGFydGlhbHMvX2V4dGVuc2lvbkZhcmVzJztcbmltcG9ydCBveXN0ZXJEYXlUb3RhbCBmcm9tICcuL3BhcnRpYWxzL19veXN0ZXJEYXlUb3RhbCc7XG5cbi8vIFRPIERPXG4vLyBPZmYgcGVhayB2cyBvbiBwZWFrIHNpbmdsZXMgKGVzcCBpbmNsdWRpbmcgb3V0IG9mIHpvbmUgMSB0byB6b25lIDEgaW4gZXZlbmluZyBpcyBvZmZwZWFrIGV4Y2VwdGlvbilcbi8vIE9mZnBlYWsgZGFpbHkgY2FwIGRpc2NvdW50cyAtIGtlZXAgdHJhY2sgd2hlbiBkYWlseSBjYXAgcmVhY2hlZCBidXQgb25seSB0cmF2ZWxsZWQgb2ZmIHBlYWsgKGlmIGdvaW5nIHRvIGRvIG9mZiBwZWFrIG95c3RlciBjdW0gdG90YWxzIHRoZW4gd291bGQga25vdyB0aGlzKVxuLy8gcG9zc2liaWxpdHkgb2YgYWx0ZXJpbmcgb3lzdGVyIHNvIHJlZmxlY3RzIG9mZiBwZWFrIC0tIHRoZW4gY291bGQgYWRkICB0aGUgUmFpbGNhcmQgb3IgR29sZCBjYXJkIGRpc2NvdW50IHRvIHlvdXIgT3lzdGVyIGFuZCAxLTggIHpvbmVzIG9yIHRvIDkgd2l0aG91dCB3YXRmb3JkXG4vLyBDQU4gRE8gQVBQUkVOVElDRSwgMTgrIFNUVURFTlQsIDE2KyBaSVAsIEpPQiBDRU5UUkUgT04gT1lTVEVSIC0gYXMgbm8gZGlmZiBidyBvZmYgcGVhayAvIG9uIHBlYWsgZGFpbHkgY2Fwc1xuLy8gTkIgV2Vla2x5IGNhcHBpbmcgaXMgYWx3YXlzIGFueXRpbWUgJiBkYWlseSBjYXBwaW5nIGFsd2F5cyBzdGFydHMgYXQgem9uZSAxXG5cbi8vIGdldERhdGEuc3RhdGlvbnMoKS50aGVuKGZ1bmN0aW9uIChzdGF0aW9ucykge1xuLy8gXHRnZXRTaW5nbGVKb3VybmV5Wm9uZXMoJzEwMDAwMjknLCAnMTAwMDEzOCcsIHN0YXRpb25zKS50aGVuKChyZXNwKSA9PiB7XG4vLyBcdFx0Ly8gY29uc29sZS5sb2cocmVzcCk7XG4vLyBcdH0pO1xuLy8gfSk7XG5cbmdldERhdGEuZmFyZXMoKS50aGVuKGZ1bmN0aW9uKGZhcmVEYXRhKSB7XG4gIGxldCBzaW5nbGVGYXJlcyA9IGZhcmVEYXRhLnNpbmdsZUZhcmVzO1xuICBsZXQgZGFpbHlDYXBzID0gZmFyZURhdGEuZGFpbHlDYXBzO1xuXG4gIGNvbnN0IGpvdXJuZXlzID0gW1xuICAgIHtcbiAgICAgIHpvbmVzOiBbMSwgNl0sXG4gICAgICBkdWFsWm9uZU92ZXJsYXA6IGZhbHNlLFxuICAgICAgdHlwZTogXCJhbnl0aW1lXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB6b25lczogWzEsIDJdLFxuICAgICAgZHVhbFpvbmVPdmVybGFwOiBmYWxzZSxcbiAgICAgIHR5cGU6IFwiYW55dGltZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgem9uZXM6IFsxLCAyXSxcbiAgICAgIGR1YWxab25lT3ZlcmxhcDogZmFsc2UsXG4gICAgICB0eXBlOiBcImFueXRpbWVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHpvbmVzOiBbMSwgMl0sXG4gICAgICBkdWFsWm9uZU92ZXJsYXA6IGZhbHNlLFxuICAgICAgdHlwZTogXCJhbnl0aW1lXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB6b25lczogWzEsIDJdLFxuICAgICAgZHVhbFpvbmVPdmVybGFwOiBmYWxzZSxcbiAgICAgIHR5cGU6IFwiYW55dGltZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgem9uZXM6IFsxLCAyXSxcbiAgICAgIGR1YWxab25lT3ZlcmxhcDogZmFsc2UsXG4gICAgICB0eXBlOiBcImFueXRpbWVcIixcbiAgICB9LFxuICBdO1xuXG5cdGNvbnNvbGUubG9nKFxuICAgICAgICBveXN0ZXJEYXlUb3RhbCh7XG4gICAgXHRcdGpvdXJuZXlzLFxuICAgIFx0XHRkYWlseUNhcHMsIC8vSlNPTlxuICAgIFx0XHRtaW5UcmF2ZWxjYXJkOiAyLFxuICAgIFx0XHRtYXhUcmF2ZWxjYXJkOiAzLFxuICAgIFx0fSwgc2luZ2xlRmFyZXMpXG4gICAgKTtcblxuXG59KTtcbi8vIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAvLyAtIENPTlRBQ1RMRVNTIENoZWFwZXN0IEZhcmUgPSB3aXRoIGRhaWx5IGNhcHNcbi8vIFx0Ly9UaGUgYXJyYXkgb2YgYWxsIGNvbWJpbmF0aW9uIHByaWNlcyB0byBiZSByZWR1Y2UgdG8gY2hlYXBlc3Qgb25lXG4vLyBcdGxldCBjb25BbGxGYXJlcyA9IFtdO1xuXG4vLyBcdC8vIGZvciB3aXRob3V0IGFueSBkYWlseSBjYXBzLCBvbmx5IHNpbmdsZXMgYWRkZWQgdG9nZXRoZXJcbi8vIFx0bGV0IGNvbkZhcmVzID0gbnVsbDtcbi8vIFx0am91cm5leXMuZm9yRWFjaChmdW5jdGlvbihqb3VybmV5KSB7XG4vLyBcdFx0Y29uRmFyZXMgKz0gZ2V0U2luZ2xlRmFyZShqb3VybmV5LnpvbmVzLCBzaW5nbGVGYXJlcyk7XG4vLyBcdH0pO1xuLy8gXHRjb25BbGxGYXJlcy5wdXNoKGNvbkZhcmVzKTtcblxuLy8gXHQvLyBcdFRoZW4gZm9yIGVhY2ggWm9uZSByYW5nZSAoZnJvbSBab25lIDEtMyB1bnRpbCBab25lIDEgdG8gbWF4KSByZXBlYXQgc2FtZSBjYWxjdWxhdGlvbi5cbi8vIFx0IGxldCBjb25NYXhab25lID0gbWF4TnVtKGZsYXR0ZW4oam91cm5leXMubWFwKGogPT4gai56b25lcykpKTtcbi8vIFx0IGZvciAobGV0IGkgPSAyOyBpIDw9IGNvbk1heFpvbmU7IGkrKykge1xuLy8gXHQgXHQvL2NvbnNvbGUubG9nKCdmb3IgZGFpbHkgY2FwIDEgdG8gJyArIGkpO1xuLy8gXHQgXHRsZXQgY29uQ3VtVG90YWwgPSBnZXREYWlseUNhcChpLCBkYWlseUNhcHMpO1xuLy8gXHQgXHQgZm9yIChsZXQgeCA9IDA7IHggPCBqb3VybmV5cy5sZW5ndGg7IHgrKykge1xuLy8gXHQgXHQgXHQvL2FkZGluZyBleHRlbnNpb24gZmFyZXMgdG8gY3VtVG90YWxcbi8vIFx0IFx0XHRjb25DdW1Ub3RhbCArPSBleHRlbnNpb25GYXJlcygxLCBpLCBqb3VybmV5c1t4XVswXSwgam91cm5leXNbeF1bMV0sIHNpbmdsZUZhcmVzKTtcbi8vIFx0IFx0IH07XG4vLyBcdCBcdGNvbkFsbEZhcmVzLnB1c2goY29uQ3VtVG90YWwpO1xuLy8gXHQgfVxuXG4vLyBcdC8vIFx0LS0tPiBDb21wYXJlIGFsbCB0aGUgcG9zc2liaWxpdGllcyBhbmQgc2VsZWN0IHRoZSBjaGVhcGVzdCAoaW5jbHVkaW5nIHRvdGFsIHNpbmdsZSkuXG4vLyBcdHJldHVybiBtaW5OdW0oY29uQWxsRmFyZXMpO1xuLy8gXHQvL3RoaXMgcmV0dXJucyB0aGUgZmluYWwgY29udGFjdGxlc3MgZGFpbHkgZmFyZVxuLy8gfSk7XG5cbi8vQ09OVEFDVExFU1Ncbi8vRm9yIGp1c3QgZGFpbHkgY2FwcyBPUiB3ZWVrbHkgY2FwIHdpdGhvdXQgZGFpbHkgY2FwOiB1c2UgZXh0ZW5zaW9uIGZhcmVzIHdpdGhvdXQgbWF4IGRhaWx5XG4vL0ZvciBjb21ibyBvZiBkYWlseSBjYXAgYW5kIHdlZWtseSBjYXA6IHVzZSBleHRlbnNpb24gZmFyZXMgd2l0aCBtYXggZGFpbHkgY2FwXG4vL1xuLy8gT0ZGIFBFQUsgREFJTFkgYW5kIFdFRUtMWTogRm9yIG9mZiBwZWFrIGRhaWx5IGNhcCBjb21ib3M6IGlmIG9mZiBwZWFrLCB1c2UgZXh0ZW5zaW9uIGZhcmVzIHRvIGNhbGN1bGF0ZSB1c2luZyBib3RoIGRhaWx5IGFuZCB3ZWVrbHkgY2Fwc1xuLy8gLS0tIHdoaWxzdCBpZiBwZWFrIHRyYXZlbCB0aGVuIHVzZSBleHRlbnNpb24gZmFyZXMgd2l0aCBvbmx5IHdlZWtseSB0cmF2ZWwgY2FyZCBjYXBzIGFuZCBhZGQgdG8gdG90YWxcbi8vIEFOWVRJTUUgREFJTFkgYW5kIFdFRUtMWTogdXNlIHRoZSBleHRlbnNpb24gZmFyZSB0byBjYWxjdWxhdGUgYWxsIGZhcmVzIHdpdGggZGFpbHkgYW55dGltZSBjYXAgYW5kIHdlZWtseSBjYXAgKGN1cnJlbnQgc2V0IHVwKVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvYXBwLmpzIiwiLy8gIFJhbWRhIHYwLjE4LjBcbi8vICBodHRwczovL2dpdGh1Yi5jb20vcmFtZGEvcmFtZGFcbi8vICAoYykgMjAxMy0yMDE1IFNjb3R0IFNhdXlldCwgTWljaGFlbCBIdXJsZXksIGFuZCBEYXZpZCBDaGFtYmVyc1xuLy8gIFJhbWRhIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG47KGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICAgKiBBIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgdXNlZCB0byBzcGVjaWZ5IFwiZ2Fwc1wiIHdpdGhpbiBjdXJyaWVkIGZ1bmN0aW9ucyxcbiAgICAgKiBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBJZiBgZ2AgaXMgYSBjdXJyaWVkIHRlcm5hcnkgZnVuY3Rpb24gYW5kIGBfYCBpcyBgUi5fX2AsIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gICAgICpcbiAgICAgKiAgIC0gYGcoMSwgMiwgMylgXG4gICAgICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICAgICAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gICAgICogICAtIGBnKF8sIDIsIF8pKDEsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSwgMylgXG4gICAgICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICAgICAqXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gUi5yZXBsYWNlKCd7bmFtZX0nLCBSLl9fLCAnSGVsbG8sIHtuYW1lfSEnKTtcbiAgICAgKiAgICAgIGdyZWV0KCdBbGljZScpOyAvLz0+ICdIZWxsbywgQWxpY2UhJ1xuICAgICAqL1xuICAgIHZhciBfXyA9IHsgJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlcic6IHRydWUgfTtcblxuICAgIC8vIGpzaGludCB1bnVzZWQ6dmFyc1xuICAgIHZhciBfYXJpdHkgPSBmdW5jdGlvbiBfYXJpdHkobiwgZm4pIHtcbiAgICAgICAgLy8ganNoaW50IHVudXNlZDp2YXJzXG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIF9hcml0eSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfYXJyYXlGcm9tSXRlcmF0b3IgPSBmdW5jdGlvbiBfYXJyYXlGcm9tSXRlcmF0b3IoaXRlcikge1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIHZhciBfY2xvbmVSZWdFeHAgPSBmdW5jdGlvbiBfY2xvbmVSZWdFeHAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4uZ2xvYmFsID8gJ2cnIDogJycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChwYXR0ZXJuLm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChwYXR0ZXJuLnN0aWNreSA/ICd5JyA6ICcnKSArIChwYXR0ZXJuLnVuaWNvZGUgPyAndScgOiAnJykpO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbXBsZW1lbnQgPSBmdW5jdGlvbiBfY29tcGxlbWVudChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBbc2V0Mj1bXV0gQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3LCBtZXJnZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgX2NvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgICAgICAgc2V0MSA9IHNldDEgfHwgW107XG4gICAgICAgIHNldDIgPSBzZXQyIHx8IFtdO1xuICAgICAgICB2YXIgaWR4O1xuICAgICAgICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4xKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQxW2lkeF07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuMikge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIF9jb250YWluc1dpdGggPSBmdW5jdGlvbiBfY29udGFpbnNXaXRoKHByZWQsIHgsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAocHJlZCh4LCBsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBpbnRlcm5hbCBvbmUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIF9jdXJyeTEgPSBmdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYSAhPSBudWxsICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgX2N1cnJ5MiA9IGZ1bmN0aW9uIF9jdXJyeTIoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYyKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAxICYmIGEgIT0gbnVsbCAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycnkxKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMiAmJiBhICE9IG51bGwgJiYgYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUgJiYgYiAhPSBudWxsICYmIGJbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyICYmIGEgIT0gbnVsbCAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycnkxKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMiAmJiBiICE9IG51bGwgJiYgYlsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJ5MShmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIGludGVybmFsIHRocmVlLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBfY3VycnkzID0gZnVuY3Rpb24gX2N1cnJ5Myhmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDEgJiYgYSAhPSBudWxsICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyICYmIGEgIT0gbnVsbCAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSAmJiBiICE9IG51bGwgJiYgYlsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDIgJiYgYSAhPSBudWxsICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyICYmIGIgIT0gbnVsbCAmJiBiWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiLCBjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycnkxKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiLCBjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMyAmJiBhICE9IG51bGwgJiYgYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUgJiYgYiAhPSBudWxsICYmIGJbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlICYmIGMgIT0gbnVsbCAmJiBjWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMyAmJiBhICE9IG51bGwgJiYgYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUgJiYgYiAhPSBudWxsICYmIGJbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAzICYmIGEgIT0gbnVsbCAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSAmJiBjICE9IG51bGwgJiYgY1snQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDMgJiYgYiAhPSBudWxsICYmIGJbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlICYmIGMgIT0gbnVsbCAmJiBjWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiLCBjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMyAmJiBhICE9IG51bGwgJiYgYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJ5MShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDMgJiYgYiAhPSBudWxsICYmIGJbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAzICYmIGMgIT0gbnVsbCAmJiBjWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY3VycnkxKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhLCBiLCBjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjdXJyeU4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IG9mIHRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBhcmd1bWVudHMgcmVjZWl2ZWQgdGh1cyBmYXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqL1xuICAgIHZhciBfY3VycnlOID0gZnVuY3Rpb24gX2N1cnJ5TihsZW5ndGgsIHJlY2VpdmVkLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgICAgICAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCAmJiAocmVjZWl2ZWRbY29tYmluZWRJZHhdID09IG51bGwgfHwgcmVjZWl2ZWRbY29tYmluZWRJZHhdWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSAhPT0gdHJ1ZSB8fCBhcmdzSWR4ID49IGFyZ3VtZW50cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVkW2NvbWJpbmVkSWR4XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbYXJnc0lkeF07XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NJZHggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tYmluZWRbY29tYmluZWRJZHhdID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHRbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tYmluZWRJZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0IDw9IDAgPyBmbi5hcHBseSh0aGlzLCBjb21iaW5lZCkgOiBfYXJpdHkobGVmdCwgX2N1cnJ5TihsZW5ndGgsIGNvbWJpbmVkLCBmbikpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIF9maWx0ZXIoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoLCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgX2ZvcmNlUmVkdWNlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZHVjZWQoeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0BAdHJhbnNkdWNlci92YWx1ZSc6IHgsXG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHN0cmF0ZWd5IGZvciBleHRyYWN0aW5nIGZ1bmN0aW9uIG5hbWVzIGZyb20gYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBvYmplY3QgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgdmFyIF9mdW5jdGlvbnNXaXRoID0gZnVuY3Rpb24gX2Z1bmN0aW9uc1dpdGgoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBfZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgfSwgZm4ob2JqKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfaGFzID0gZnVuY3Rpb24gX2hhcyhwcm9wLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgIH07XG5cbiAgICB2YXIgX2lkZW50aXR5ID0gZnVuY3Rpb24gX2lkZW50aXR5KHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcblxuICAgIHZhciBfaXNBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nID8gZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgICAgICAgfSA6IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgICAgICAgICByZXR1cm4gX2hhcygnY2FsbGVlJywgeCk7XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWxgIGlzIGFuIGFycmF5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBfaXNBcnJheShbXSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIF9pc0FycmF5KHt9KTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgX2lzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gX2lzSW50ZWdlcihuKSB7XG4gICAgICAgIHJldHVybiBuIDw8IDAgPT09IG47XG4gICAgfTtcblxuICAgIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9O1xuXG4gICAgdmFyIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH07XG5cbiAgICB2YXIgX2lzUmVnRXhwID0gZnVuY3Rpb24gX2lzUmVnRXhwKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gICAgfTtcblxuICAgIHZhciBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9O1xuXG4gICAgdmFyIF9pc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24gX2lzVHJhbnNmb3JtZXIob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqWydAQHRyYW5zZHVjZXIvc3RlcCddID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIF9tYXAoZm4sIGZ1bmN0b3IpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBmdW5jdG9yLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbik7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBfb2YgPSBmdW5jdGlvbiBfb2YoeCkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH07XG5cbiAgICB2YXIgX3BpcGUgPSBmdW5jdGlvbiBfcGlwZShmLCBnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZy5jYWxsKHRoaXMsIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcGlwZVAgPSBmdW5jdGlvbiBfcGlwZVAoZiwgZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnLmNhbGwoY3R4LCB4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIHZhciBfcXVvdGUgPSBmdW5jdGlvbiBfcXVvdGUocykge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IHMucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bXFxiXS9nLCAnXFxcXGInKSAgICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykucmVwbGFjZSgvXFx2L2csICdcXFxcdicpLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIic7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlZCA9IGZ1bmN0aW9uIF9yZWR1Y2VkKHgpIHtcbiAgICAgICAgcmV0dXJuIHggJiYgeFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IHggOiB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW4gb3B0aW1pemVkLCBwcml2YXRlIGFycmF5IGBzbGljZWAgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5fSBhcmdzIFRoZSBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0IHRvIGNvbnNpZGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbT0wXSBUaGUgYXJyYXkgaW5kZXggdG8gc2xpY2UgZnJvbSwgaW5jbHVzaXZlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdG89YXJncy5sZW5ndGhdIFRoZSBhcnJheSBpbmRleCB0byBzbGljZSB0bywgZXhjbHVzaXZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgc2xpY2VkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIF9zbGljZShbMSwgMiwgMywgNCwgNV0sIDEsIDMpOyAvLz0+IFsyLCAzXVxuICAgICAqXG4gICAgICogICAgICB2YXIgZmlyc3RUaHJlZUFyZ3MgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgICogICAgICAgIHJldHVybiBfc2xpY2UoYXJndW1lbnRzLCAwLCAzKTtcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBmaXJzdFRocmVlQXJncygxLCAyLCAzLCA0KTsgLy89PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICB2YXIgX3NsaWNlID0gZnVuY3Rpb24gX3NsaWNlKGFyZ3MsIGZyb20sIHRvKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3NsaWNlKGFyZ3MsIDAsIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zbGljZShhcmdzLCBmcm9tLCBhcmdzLmxlbmd0aCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYXJncy5sZW5ndGgsIHRvKSAtIGZyb20pO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGxpc3RbaWR4XSA9IGFyZ3NbZnJvbSArIGlkeF07XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nPi5cbiAgICAgKi9cbiAgICB2YXIgX3RvSVNPU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAobiA8IDEwID8gJzAnIDogJycpICsgbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIF90b0lTT1N0cmluZyhkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC50b0lTT1N0cmluZygpO1xuICAgICAgICB9IDogZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgKyBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICsgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICsgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChkLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTAwMCkudG9GaXhlZCgzKS5zbGljZSgyLCA1KSArICdaJztcbiAgICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hkcm9wUmVwZWF0c1dpdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucHJlZCA9IHByZWQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2VlbkZpcnN0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBzYW1lQXNMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VlbkZpcnN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVkKHRoaXMubGFzdFZhbHVlLCBpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBzYW1lQXNMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gaW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gc2FtZUFzTGFzdCA/IHJlc3VsdCA6IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmQmFzZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9pbml0J10oKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF94ZmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmlsdGVyKGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICB9XG4gICAgICAgIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gICAgICAgIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaWx0ZXIoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbHRlcihmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGZpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhGaW5kKGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdm9pZCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmQoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEZpbmQoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmaW5kSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhGaW5kSW5kZXgoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgICAgICB0aGlzLmlkeCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgWEZpbmRJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5pZHggKz0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuaWR4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRJbmRleChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRmluZEluZGV4KGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZmluZExhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhGaW5kTGFzdChmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgfVxuICAgICAgICBYRmluZExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRmluZExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmxhc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdCA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kTGFzdChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRmluZExhc3QoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hmaW5kTGFzdEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRmluZExhc3RJbmRleChmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgICAgIHRoaXMuaWR4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmxhc3RJZHggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhGaW5kTGFzdEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5sYXN0SWR4KSk7XG4gICAgICAgIH07XG4gICAgICAgIFhGaW5kTGFzdEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlkeCArPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RJZHggPSB0aGlzLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmluZExhc3RJbmRleChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYRmluZExhc3RJbmRleChmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeG1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWE1hcChmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgfVxuICAgICAgICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuZihpbnB1dCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeG1hcChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTWFwKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94dGFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gWFRha2UobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMubiA9IG47XG4gICAgICAgIH1cbiAgICAgICAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICAgICAgICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlZChyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm4gLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3h0YWtlKG4sIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhUYWtlKG4sIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94dGFrZVdoaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYVGFrZVdoaWxlKGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICB9XG4gICAgICAgIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gICAgICAgIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSA6IF9yZWR1Y2VkKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94dGFrZVdoaWxlKGYsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhUYWtlV2hpbGUoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3h3cmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYV3JhcChmbikge1xuICAgICAgICAgICAgdGhpcy5mID0gZm47XG4gICAgICAgIH1cbiAgICAgICAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IG5vdCBpbXBsZW1lbnRlZCBvbiBYV3JhcCcpO1xuICAgICAgICB9O1xuICAgICAgICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChhY2MpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH07XG4gICAgICAgIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmYoYWNjLCB4KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF94d3JhcChmbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYV3JhcChmbik7XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSArIGJgIGJ1dCBjdXJyaWVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBzZWUgUi5zdWJ0cmFjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYWRkKDIsIDMpOyAgICAgICAvLz0+ICA1XG4gICAgICogICAgICBSLmFkZCg3KSgxMCk7ICAgICAgLy89PiAxN1xuICAgICAqL1xuICAgIHZhciBhZGQgPSBfY3VycnkyKGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IG9mIGFuIGFycmF5LFxuICAgICAqIHJldHVybmluZyBhIG5ldyBjb3B5IG9mIHRoZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlblxuICAgICAqIGluZGV4IHJlcGxhY2VkIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24uXG4gICAgICogQHNlZSBSLnVwZGF0ZVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IGEpIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdob3NlIHZhbHVlXG4gICAgICogICAgICAgIGF0IHRoZSBzdXBwbGllZCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgdGhlIHN1cHBsaWVkIGFycmF5LWxpa2Ugb2JqZWN0IHdpdGhcbiAgICAgKiAgICAgICAgIHRoZSBlbGVtZW50IGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlXG4gICAgICogICAgICAgICByZXR1cm5lZCBieSBhcHBseWluZyBgZm5gIHRvIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYWRqdXN0KFIuYWRkKDEwKSwgMSwgWzAsIDEsIDJdKTsgICAgIC8vPT4gWzAsIDExLCAyXVxuICAgICAqICAgICAgUi5hZGp1c3QoUi5hZGQoMTApKSgxKShbMCwgMSwgMl0pOyAgICAgLy89PiBbMCwgMTEsIDJdXG4gICAgICovXG4gICAgdmFyIGFkanVzdCA9IF9jdXJyeTMoZnVuY3Rpb24gYWRqdXN0KGZuLCBpZHgsIGxpc3QpIHtcbiAgICAgICAgaWYgKGlkeCA+PSBsaXN0Lmxlbmd0aCB8fCBpZHggPCAtbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IGlkeCA8IDAgPyBsaXN0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHZhciBfaWR4ID0gc3RhcnQgKyBpZHg7XG4gICAgICAgIHZhciBfbGlzdCA9IF9jb25jYXQobGlzdCk7XG4gICAgICAgIF9saXN0W19pZHhdID0gZm4obGlzdFtfaWR4XSk7XG4gICAgICAgIHJldHVybiBfbGlzdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZS4gTm90ZSB0aGF0IGZvclxuICAgICAqIG5vbi1wcmltaXRpdmVzIHRoZSB2YWx1ZSByZXR1cm5lZCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGtub3duIGFzIGBjb25zdGAsIGBjb25zdGFudGAsIG9yIGBLYCAoZm9yIEsgY29tYmluYXRvcilcbiAgICAgKiBpbiBvdGhlciBsYW5ndWFnZXMgYW5kIGxpYnJhcmllcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBhIC0+ICgqIC0+IGEpXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6ICogLT4gdmFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0ID0gUi5hbHdheXMoJ1RlZScpO1xuICAgICAqICAgICAgdCgpOyAvLz0+ICdUZWUnXG4gICAgICovXG4gICAgdmFyIGFsd2F5cyA9IF9jdXJyeTEoZnVuY3Rpb24gYWx3YXlzKHZhbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgdHJ1ZWA7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnICogLT4gKiAtPiAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhIEEgYm9vbGVhbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYiBBIGJvb2xlYW4gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYm90aCBhcmd1bWVudHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICAgKiBAc2VlIFIuYm90aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYW5kKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuYW5kKHRydWUsIGZhbHNlKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5hbmQoZmFsc2UsIHRydWUpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmFuZChmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGFuZCA9IF9jdXJyeTIoZnVuY3Rpb24gYW5kKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgJiYgYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICogZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7Kn0gZWwgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIG5ldyBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3Qgd2hvc2UgY29udGVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBvdXRwdXRcbiAgICAgKiAgICAgICAgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgb2xkIGxpc3QgZm9sbG93ZWQgYnkgYGVsYC5cbiAgICAgKiBAc2VlIFIucHJlcGVuZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFsnd3JpdGUnLCAnbW9yZSddKTsgLy89PiBbJ3dyaXRlJywgJ21vcmUnLCAndGVzdHMnXVxuICAgICAqICAgICAgUi5hcHBlbmQoJ3Rlc3RzJywgW10pOyAvLz0+IFsndGVzdHMnXVxuICAgICAqICAgICAgUi5hcHBlbmQoWyd0ZXN0cyddLCBbJ3dyaXRlJywgJ21vcmUnXSk7IC8vPT4gWyd3cml0ZScsICdtb3JlJywgWyd0ZXN0cyddXVxuICAgICAqL1xuICAgIHZhciBhcHBlbmQgPSBfY3VycnkyKGZ1bmN0aW9uIGFwcGVuZChlbCwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChsaXN0LCBbZWxdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZnVuY3Rpb24gYGZuYCB0byB0aGUgYXJndW1lbnQgbGlzdCBgYXJnc2AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgICAqIGNyZWF0aW5nIGEgZml4ZWQtYXJpdHkgZnVuY3Rpb24gZnJvbSBhIHZhcmlhZGljIGZ1bmN0aW9uLiBgZm5gIHNob3VsZFxuICAgICAqIGJlIGEgYm91bmQgZnVuY3Rpb24gaWYgY29udGV4dCBpcyBzaWduaWZpY2FudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKi4uLiAtPiBhKSAtPiBbKl0gLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLmNhbGwsIFIudW5hcHBseVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBudW1zID0gWzEsIDIsIDMsIC05OSwgNDIsIDYsIDddO1xuICAgICAqICAgICAgUi5hcHBseShNYXRoLm1heCwgbnVtcyk7IC8vPT4gNDJcbiAgICAgKi9cbiAgICB2YXIgYXBwbHkgPSBfY3VycnkyKGZ1bmN0aW9uIGFwcGx5KGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QsIHNldHRpbmcgb3Igb3ZlcnJpZGluZyB0aGUgc3BlY2lmaWVkXG4gICAgICogcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuICBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zXG4gICAgICogcHJvdG90eXBlIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdCBhcyB3ZWxsLiAgQWxsIG5vbi1wcmltaXRpdmVcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgdGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWwgdGhlIG5ldyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHNpbWlsYXIgdG8gdGhlIG9yaWdpbmFsIGV4Y2VwdCBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgICAgKiBAc2VlIFIuZGlzc29jXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hc3NvYygnYycsIDMsIHthOiAxLCBiOiAyfSk7IC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gICAgICovXG4gICAgdmFyIGFzc29jID0gX2N1cnJ5MyhmdW5jdGlvbiBhc3NvYyhwcm9wLCB2YWwsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXN1bHRbcF0gPSBvYmpbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgc2V0dGluZyBvciBvdmVycmlkaW5nIHRoZSBub2Rlc1xuICAgICAqIHJlcXVpcmVkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gcGF0aCwgYW5kIHBsYWNpbmcgdGhlIHNwZWNpZmljIHZhbHVlIGF0IHRoZVxuICAgICAqIHRhaWwgZW5kIG9mIHRoYXQgcGF0aC4gIE5vdGUgdGhhdCB0aGlzIGNvcGllcyBhbmQgZmxhdHRlbnMgcHJvdG90eXBlXG4gICAgICogcHJvcGVydGllcyBvbnRvIHRoZSBuZXcgb2JqZWN0IGFzIHdlbGwuICBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IGEgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggdGhlIHBhdGggdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWwgdGhlIG5ldyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHNpbWlsYXIgdG8gdGhlIG9yaWdpbmFsIGV4Y2VwdCBhbG9uZyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICogQHNlZSBSLmRpc3NvY1BhdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFzc29jUGF0aChbJ2EnLCAnYicsICdjJ10sIDQyLCB7YToge2I6IHtjOiAwfX19KTsgLy89PiB7YToge2I6IHtjOiA0Mn19fVxuICAgICAqL1xuICAgIHZhciBhc3NvY1BhdGggPSBfY3VycnkzKGZ1bmN0aW9uIGFzc29jUGF0aChwYXRoLCB2YWwsIG9iaikge1xuICAgICAgICBzd2l0Y2ggKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBhc3NvYyhwYXRoWzBdLCB2YWwsIG9iaik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYXNzb2MocGF0aFswXSwgYXNzb2NQYXRoKF9zbGljZShwYXRoLCAxKSwgdmFsLCBPYmplY3Qob2JqW3BhdGhbMF1dKSksIG9iaik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIGJvdW5kIHRvIGEgY29udGV4dC5cbiAgICAgKiBOb3RlOiBgUi5iaW5kYCBkb2VzIG5vdCBwcm92aWRlIHRoZSBhZGRpdGlvbmFsIGFyZ3VtZW50LWJpbmRpbmcgY2FwYWJpbGl0aWVzIG9mXG4gICAgICogW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzZWUgUi5wYXJ0aWFsXG4gICAgICogQHNpZyAoKiAtPiAqKSAtPiB7Kn0gLT4gKCogLT4gKilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmluZCB0byBjb250ZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNPYmogVGhlIGNvbnRleHQgdG8gYmluZCBgZm5gIHRvXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgYHRoaXNPYmpgLlxuICAgICAqL1xuICAgIHZhciBiaW5kID0gX2N1cnJ5MihmdW5jdGlvbiBiaW5kKGZuLCB0aGlzT2JqKSB7XG4gICAgICAgIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc09iaiwgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXBvcnRzIHdoZXRoZXIgdGhlIGZpcnN0IGVsZW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKGEsIGIgLT4gQm9vbGVhbikgLT4gKGEsIGIgLT4gTnVtYmVyKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb24gb2YgYXJpdHkgdHdvLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6IGEgLT4gYiAtPiBJbnQgdGhhdCByZXR1cm5zIGAtMWAgaWYgYSA8IGIsIGAxYCBpZiBiIDwgYSwgb3RoZXJ3aXNlIGAwYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgY21wID0gUi5jb21wYXJhdG9yKChhLCBiKSA9PiBhLmFnZSA8IGIuYWdlKTtcbiAgICAgKiAgICAgIHZhciBwZW9wbGUgPSBbXG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgXTtcbiAgICAgKiAgICAgIFIuc29ydChjbXAsIHBlb3BsZSk7XG4gICAgICovXG4gICAgdmFyIGNvbXBhcmF0b3IgPSBfY3VycnkxKGZ1bmN0aW9uIGNvbXBhcmF0b3IocHJlZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVkKGEsIGIpID8gLTEgOiBwcmVkKGIsIGEpID8gMSA6IDA7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24sIGBmbmAsIHdoaWNoIGVuY2Fwc3VsYXRlcyBpZi9lbHNlLWlmL2Vsc2UgbG9naWMuXG4gICAgICogYFIuY29uZGAgdGFrZXMgYSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybV0gcGFpcnMuIEFsbCBvZiB0aGVcbiAgICAgKiBhcmd1bWVudHMgdG8gYGZuYCBhcmUgYXBwbGllZCB0byBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm5cbiAgICAgKiB1bnRpbCBvbmUgcmV0dXJucyBhIFwidHJ1dGh5XCIgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGBmbmAgcmV0dXJucyB0aGVcbiAgICAgKiByZXN1bHQgb2YgYXBwbHlpbmcgaXRzIGFyZ3VtZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyB0cmFuc2Zvcm1lci5cbiAgICAgKiBJZiBub25lIG9mIHRoZSBwcmVkaWNhdGVzIG1hdGNoZXMsIGBmbmAgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgW1soKi4uLiAtPiBCb29sZWFuKSwoKi4uLiAtPiAqKV1dIC0+ICgqLi4uIC0+ICopXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZm4gPSBSLmNvbmQoW1xuICAgICAqICAgICAgICBbUi5lcXVhbHMoMCksICAgUi5hbHdheXMoJ3dhdGVyIGZyZWV6ZXMgYXQgMMKwQycpXSxcbiAgICAgKiAgICAgICAgW1IuZXF1YWxzKDEwMCksIFIuYWx3YXlzKCd3YXRlciBib2lscyBhdCAxMDDCsEMnKV0sXG4gICAgICogICAgICAgIFtSLlQsICAgICAgICAgICB0ZW1wID0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCAnICsgdGVtcCArICfCsEMnXVxuICAgICAqICAgICAgXSk7XG4gICAgICogICAgICBmbigwKTsgLy89PiAnd2F0ZXIgZnJlZXplcyBhdCAwwrBDJ1xuICAgICAqICAgICAgZm4oNTApOyAvLz0+ICdub3RoaW5nIHNwZWNpYWwgaGFwcGVucyBhdCA1MMKwQydcbiAgICAgKiAgICAgIGZuKDEwMCk7IC8vPT4gJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQydcbiAgICAgKi9cbiAgICB2YXIgY29uZCA9IF9jdXJyeTEoZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhaXJzW2lkeF1bMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcnNbaWR4XVsxXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBgeGAgaXMgZm91bmQgaW4gdGhlIGBsaXN0YCwgdXNpbmcgYHByZWRgIGFzIGFuXG4gICAgICogZXF1YWxpdHkgcHJlZGljYXRlIGZvciBgeGAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuNVxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSwgYSAtPiBCb29sZWFuKSAtPiBhIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgaXRlbSB0byBmaW5kXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGlzIGluIGBsaXN0YCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWJzRXEgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSkgPT09IE1hdGguYWJzKGIpO1xuICAgICAqICAgICAgUi5jb250YWluc1dpdGgoYWJzRXEsIDUsIFsxLCAyLCAzXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuY29udGFpbnNXaXRoKGFic0VxLCA1LCBbNCwgNSwgNl0pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuY29udGFpbnNXaXRoKGFic0VxLCA1LCBbLTEsIC0yLCAtM10pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmNvbnRhaW5zV2l0aChhYnNFcSwgNSwgWy00LCAtNSwgLTZdKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGNvbnRhaW5zV2l0aCA9IF9jdXJyeTMoX2NvbnRhaW5zV2l0aCk7XG5cbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdCBhY2NvcmRpbmcgdG8gaG93IG1hbnkgbWF0Y2ggZWFjaCB2YWx1ZVxuICAgICAqIG9mIGEga2V5IGdlbmVyYXRlZCBieSB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uIFJldHVybnMgYW4gb2JqZWN0XG4gICAgICogbWFwcGluZyB0aGUga2V5cyBwcm9kdWNlZCBieSBgZm5gIHRvIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW5cbiAgICAgKiB0aGUgbGlzdC4gTm90ZSB0aGF0IGFsbCBrZXlzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgYmVjYXVzZSBvZiBob3dcbiAgICAgKiBKYXZhU2NyaXB0IG9iamVjdHMgd29yay5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSAtPiBTdHJpbmcpIC0+IFthXSAtPiB7Kn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBtYXAgdmFsdWVzIHRvIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBjb3VudCBlbGVtZW50cyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IG1hcHBpbmcga2V5cyB0byBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW4gdGhlIGxpc3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMS4wLCAxLjEsIDEuMiwgMi4wLCAzLjAsIDIuMl07XG4gICAgICogICAgICB2YXIgbGV0dGVycyA9IFIuc3BsaXQoJycsICdhYmNBQkNhYWFCQmMnKTtcbiAgICAgKiAgICAgIFIuY291bnRCeShNYXRoLmZsb29yKShudW1iZXJzKTsgICAgLy89PiB7JzEnOiAzLCAnMic6IDIsICczJzogMX1cbiAgICAgKiAgICAgIFIuY291bnRCeShSLnRvTG93ZXIpKGxldHRlcnMpOyAgIC8vPT4geydhJzogNSwgJ2InOiA0LCAnYyc6IDN9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBfY3VycnkyKGZ1bmN0aW9uIGNvdW50QnkoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGNvdW50cyA9IHt9O1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZm4obGlzdFtpZHhdKTtcbiAgICAgICAgICAgIGNvdW50c1trZXldID0gKF9oYXMoa2V5LCBjb3VudHMpID8gY291bnRzW2tleV0gOiAwKSArIDE7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIHdpdGggdGhlXG4gICAgICogc3BlY2lmaWVkIGFyaXR5LiBUaGUgY3VycmllZCBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLlxuICAgICAqIEZpcnN0LCBpdHMgYXJndW1lbnRzIG5lZWRuJ3QgYmUgcHJvdmlkZWQgb25lIGF0IGEgdGltZS4gSWYgYGdgIGlzXG4gICAgICogYFIuY3VycnlOKDMsIGYpYCwgdGhlIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAgICAgKlxuICAgICAqICAgLSBgZygxKSgyKSgzKWBcbiAgICAgKiAgIC0gYGcoMSkoMiwgMylgXG4gICAgICogICAtIGBnKDEsIDIpKDMpYFxuICAgICAqICAgLSBgZygxLCAyLCAzKWBcbiAgICAgKlxuICAgICAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICAgICAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIGBSLl9fYCxcbiAgICAgKiB0aGUgZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICAgICAqXG4gICAgICogICAtIGBnKDEsIDIsIDMpYFxuICAgICAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gICAgICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoMSwgMylgXG4gICAgICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IGZvciB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIFIuY3VycnlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc3VtQXJncyA9ICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnlOKDQsIHN1bUFyZ3MpO1xuICAgICAqICAgICAgdmFyIGYgPSBjdXJyaWVkQWRkRm91ck51bWJlcnMoMSwgMik7XG4gICAgICogICAgICB2YXIgZyA9IGYoMyk7XG4gICAgICogICAgICBnKDQpOyAvLz0+IDEwXG4gICAgICovXG4gICAgdmFyIGN1cnJ5TiA9IF9jdXJyeTIoZnVuY3Rpb24gY3VycnlOKGxlbmd0aCwgZm4pIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZWNyZW1lbnRzIGl0cyBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKiBAc2VlIFIuaW5jXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5kZWMoNDIpOyAvLz0+IDQxXG4gICAgICovXG4gICAgdmFyIGRlYyA9IGFkZCgtMSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZWNvbmQgYXJndW1lbnQgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmBcbiAgICAgKiBvdGhlcndpc2UgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyBhIC0+IGIgLT4gYSB8IGJcbiAgICAgKiBAcGFyYW0ge2F9IHZhbCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2J9IHZhbCBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGl0IGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAqIEByZXR1cm4geyp9IFRoZSB0aGUgc2Vjb25kIHZhbHVlIG9yIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRlZmF1bHRUbzQyID0gUi5kZWZhdWx0VG8oNDIpO1xuICAgICAqXG4gICAgICogICAgICBkZWZhdWx0VG80MihudWxsKTsgIC8vPT4gNDJcbiAgICAgKiAgICAgIGRlZmF1bHRUbzQyKHVuZGVmaW5lZCk7ICAvLz0+IDQyXG4gICAgICogICAgICBkZWZhdWx0VG80MignUmFtZGEnKTsgIC8vPT4gJ1JhbWRhJ1xuICAgICAqICAgICAgZGVmYXVsdFRvNDIocGFyc2VJbnQoJ3N0cmluZycpKTsgLy89PiA0MlxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0VG8gPSBfY3VycnkyKGZ1bmN0aW9uIGRlZmF1bHRUbyhkLCB2KSB7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgfHwgdiAhPT0gdiA/IGQgOiB2O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90IGNvbnRhaW5lZCBpbiB0aGUgc2Vjb25kIGxpc3QuXG4gICAgICogRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3RcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSxhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAc2VlIFIuZGlmZmVyZW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZWxlbWVudHMgaW4gYGxpc3QxYCB0aGF0IGFyZSBub3QgaW4gYGxpc3QyYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBmdW5jdGlvbiBjbXAoeCwgeSkgPT4geC5hID09PSB5LmE7XG4gICAgICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gICAgICogICAgICB2YXIgbDIgPSBbe2E6IDN9LCB7YTogNH1dO1xuICAgICAqICAgICAgUi5kaWZmZXJlbmNlV2l0aChjbXAsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IF9jdXJyeTMoZnVuY3Rpb24gZGlmZmVyZW5jZVdpdGgocHJlZCwgZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgZmlyc3RMZW4gPSBmaXJzdC5sZW5ndGg7XG4gICAgICAgIHZhciBjb250YWluc1ByZWQgPSBjb250YWluc1dpdGgocHJlZCk7XG4gICAgICAgIHdoaWxlIChpZHggPCBmaXJzdExlbikge1xuICAgICAgICAgICAgaWYgKCFjb250YWluc1ByZWQoZmlyc3RbaWR4XSwgc2Vjb25kKSAmJiAhY29udGFpbnNQcmVkKGZpcnN0W2lkeF0sIG91dCkpIHtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBmaXJzdFtpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgZG9lcyBub3QgY29udGFpbiBhIGBwcm9wYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFN0cmluZyAtPiB7azogdn0gLT4ge2s6IHZ9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGRpc3NvY2lhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdCBzaW1pbGFyIHRvIHRoZSBvcmlnaW5hbCBidXQgd2l0aG91dCB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICogQHNlZSBSLmFzc29jXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5kaXNzb2MoJ2InLCB7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IHthOiAxLCBjOiAzfVxuICAgICAqL1xuICAgIHZhciBkaXNzb2MgPSBfY3VycnkyKGZ1bmN0aW9uIGRpc3NvYyhwcm9wLCBvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHAgIT09IHByb3ApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcF0gPSBvYmpbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QsIG9taXR0aW5nIHRoZSBwcm9wZXJ0eSBhdCB0aGVcbiAgICAgKiBnaXZlbiBwYXRoLiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICogb250byB0aGUgbmV3IG9iamVjdCBhcyB3ZWxsLiAgQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllcyBhcmUgY29waWVkXG4gICAgICogYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgW1N0cmluZ10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggdGhlIHBhdGggdG8gc2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIGNsb25lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgd2l0aG91dCB0aGUgcHJvcGVydHkgYXQgcGF0aFxuICAgICAqIEBzZWUgUi5hc3NvY1BhdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRpc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCB7YToge2I6IHtjOiA0Mn19fSk7IC8vPT4ge2E6IHtiOiB7fX19XG4gICAgICovXG4gICAgdmFyIGRpc3NvY1BhdGggPSBfY3VycnkyKGZ1bmN0aW9uIGRpc3NvY1BhdGgocGF0aCwgb2JqKSB7XG4gICAgICAgIHN3aXRjaCAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3NvYyhwYXRoWzBdLCBvYmopO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGhlYWQgPSBwYXRoWzBdO1xuICAgICAgICAgICAgdmFyIHRhaWwgPSBfc2xpY2UocGF0aCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2hlYWRdID09IG51bGwgPyBvYmogOiBhc3NvYyhoZWFkLCBkaXNzb2NQYXRoKHRhaWwsIG9ialtoZWFkXSksIG9iaik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdHdvIG51bWJlcnMuIEVxdWl2YWxlbnQgdG8gYGEgLyBiYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhIC8gYmAuXG4gICAgICogQHNlZSBSLm11bHRpcGx5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5kaXZpZGUoNzEsIDEwMCk7IC8vPT4gMC43MVxuICAgICAqXG4gICAgICogICAgICB2YXIgaGFsZiA9IFIuZGl2aWRlKFIuX18sIDIpO1xuICAgICAqICAgICAgaGFsZig0Mik7IC8vPT4gMjFcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHJlY2lwcm9jYWwgPSBSLmRpdmlkZSgxKTtcbiAgICAgKiAgICAgIHJlY2lwcm9jYWwoNCk7ICAgLy89PiAwLjI1XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IF9jdXJyeTIoZnVuY3Rpb24gZGl2aWRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLyBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCBsYXN0IHRoZWBuYCBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3QsXG4gICAgICogcGFzc2luZyBlYWNoIHZhbHVlIGZyb20gdGhlIHJpZ2h0IHRvIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24sIHNraXBwaW5nXG4gICAgICogZWxlbWVudHMgd2hpbGUgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYC4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkqLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi50YWtlTGFzdFdoaWxlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGx0ZVRocmVlID0geCA9PiB4IDw9IDM7XG4gICAgICpcbiAgICAgKiAgICAgIFIuZHJvcExhc3RXaGlsZShsdGVUaHJlZSwgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICB2YXIgZHJvcExhc3RXaGlsZSA9IF9jdXJyeTIoZnVuY3Rpb24gZHJvcExhc3RXaGlsZShwcmVkLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpZHggPj0gMCAmJiBwcmVkKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2xpY2UobGlzdCwgMCwgaWR4ICsgMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbXB0eSB2YWx1ZSBvZiBpdHMgYXJndW1lbnQncyB0eXBlLiBSYW1kYSBkZWZpbmVzIHRoZSBlbXB0eVxuICAgICAqIHZhbHVlIG9mIEFycmF5IChgW11gKSwgT2JqZWN0IChge31gKSwgU3RyaW5nIChgJydgKSwgYW5kIEFyZ3VtZW50cy5cbiAgICAgKiBPdGhlciB0eXBlcyBhcmUgc3VwcG9ydGVkIGlmIHRoZXkgZGVmaW5lIGA8VHlwZT4uZW1wdHlgIGFuZC9vclxuICAgICAqIGA8VHlwZT4ucHJvdG90eXBlLmVtcHR5YC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBlbXB0eWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMy4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBhIC0+IGFcbiAgICAgKiBAcGFyYW0geyp9IHhcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZW1wdHkoSnVzdCg0MikpOyAgICAgIC8vPT4gTm90aGluZygpXG4gICAgICogICAgICBSLmVtcHR5KFsxLCAyLCAzXSk7ICAgICAvLz0+IFtdXG4gICAgICogICAgICBSLmVtcHR5KCd1bmljb3JucycpOyAgICAvLz0+ICcnXG4gICAgICogICAgICBSLmVtcHR5KHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt9XG4gICAgICovXG4gICAgLy8gZWxzZVxuICAgIHZhciBlbXB0eSA9IF9jdXJyeTEoZnVuY3Rpb24gZW1wdHkoeCkge1xuICAgICAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4LmVtcHR5ID09PSAnZnVuY3Rpb24nID8geC5lbXB0eSgpIDogeCAhPSBudWxsICYmIHguY29uc3RydWN0b3IgIT0gbnVsbCAmJiB0eXBlb2YgeC5jb25zdHJ1Y3Rvci5lbXB0eSA9PT0gJ2Z1bmN0aW9uJyA/IHguY29uc3RydWN0b3IuZW1wdHkoKSA6IF9pc0FycmF5KHgpID8gW10gOiBfaXNTdHJpbmcoeCkgPyAnJyA6IF9pc09iamVjdCh4KSA/IHt9IDogX2lzQXJndW1lbnRzKHgpID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICAgICAgfSgpIDogLy8gZWxzZVxuICAgICAgICB2b2lkIDA7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBieSByZWN1cnNpdmVseSBldm9sdmluZyBhIHNoYWxsb3cgY29weSBvZiBgb2JqZWN0YCwgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGB0cmFuc2Zvcm1hdGlvbmAgZnVuY3Rpb25zLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgaXRzIGNvcnJlc3BvbmRpbmcga2V5IGRvZXMgbm90IGV4aXN0IGluXG4gICAgICogdGhlIGV2b2x2ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7azogKHYgLT4gdil9IC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtYXRpb25zIFRoZSBvYmplY3Qgc3BlY2lmeWluZyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYXBwbHlcbiAgICAgKiAgICAgICAgdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNmb3JtZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0b21hdG8gID0ge2ZpcnN0TmFtZTogJyAgVG9tYXRvICcsIGRhdGE6IHtlbGFwc2VkOiAxMDAsIHJlbWFpbmluZzogMTQwMH0sIGlkOjEyM307XG4gICAgICogICAgICB2YXIgdHJhbnNmb3JtYXRpb25zID0ge1xuICAgICAqICAgICAgICBmaXJzdE5hbWU6IFIudHJpbSxcbiAgICAgKiAgICAgICAgbGFzdE5hbWU6IFIudHJpbSwgLy8gV2lsbCBub3QgZ2V0IGludm9rZWQuXG4gICAgICogICAgICAgIGRhdGE6IHtlbGFwc2VkOiBSLmFkZCgxKSwgcmVtYWluaW5nOiBSLmFkZCgtMSl9XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgUi5ldm9sdmUodHJhbnNmb3JtYXRpb25zLCB0b21hdG8pOyAvLz0+IHtmaXJzdE5hbWU6ICdUb21hdG8nLCBkYXRhOiB7ZWxhcHNlZDogMTAxLCByZW1haW5pbmc6IDEzOTl9LCBpZDoxMjN9XG4gICAgICovXG4gICAgdmFyIGV2b2x2ZSA9IF9jdXJyeTIoZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiwga2V5LCB0eXBlLCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uc1trZXldO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGVvZiB0cmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHRyYW5zZm9ybWF0aW9uKG9iamVjdFtrZXldKSA6IHR5cGUgPT09ICdvYmplY3QnID8gZXZvbHZlKHRyYW5zZm9ybWF0aW9uc1trZXldLCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgb3V0IG9mIGEgbGlzdCBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbW2ssdl1dIC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIHR3by1lbGVtZW50IGFycmF5cyB0aGF0IHdpbGwgYmUgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIGBrZXlzYCBhbmQgYHZhbHVlc2AuXG4gICAgICogQHNlZSBSLnRvUGFpcnMsIFIucGFpclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl0sICBbJ2MnLCAzXV0pOyAvLz0+IHthOiAxLCBiOiAyLCBjOiAzfVxuICAgICAqL1xuICAgIHZhciBmcm9tUGFpcnMgPSBfY3VycnkxKGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgICB2YXIgaWR4ID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoLCBvdXQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKF9pc0FycmF5KHBhaXJzW2lkeF0pICYmIHBhaXJzW2lkeF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0W3BhaXJzW2lkeF1bMF1dID0gcGFpcnNbaWR4XVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQ7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZ3QoMiwgMSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5ndCgyLCAyKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ndCgyLCAzKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ndCgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZ3QoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBfY3VycnkyKGZ1bmN0aW9uIGd0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuZ3RlKDIsIDMpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuZ3RlKCd6JywgJ2EnKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IF9jdXJyeTIoZnVuY3Rpb24gZ3RlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPj0gYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aFxuICAgICAqIHRoZSBzcGVjaWZpZWQgbmFtZVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBzIC0+IHtzOiB4fSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBoYXNOYW1lID0gUi5oYXMoJ25hbWUnKTtcbiAgICAgKiAgICAgIGhhc05hbWUoe25hbWU6ICdhbGljZSd9KTsgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIGhhc05hbWUoe25hbWU6ICdib2InfSk7ICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIGhhc05hbWUoe30pOyAgICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBwb2ludCA9IHt4OiAwLCB5OiAwfTtcbiAgICAgKiAgICAgIHZhciBwb2ludEhhcyA9IFIuaGFzKFIuX18sIHBvaW50KTtcbiAgICAgKiAgICAgIHBvaW50SGFzKCd4Jyk7ICAvLz0+IHRydWVcbiAgICAgKiAgICAgIHBvaW50SGFzKCd5Jyk7ICAvLz0+IHRydWVcbiAgICAgKiAgICAgIHBvaW50SGFzKCd6Jyk7ICAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGhhcyA9IF9jdXJyeTIoX2hhcyk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhc1xuICAgICAqIGEgcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgcyAtPiB7czogeH0gLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBmdW5jdGlvbiBSZWN0YW5nbGUod2lkdGgsIGhlaWdodCkge1xuICAgICAqICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICogICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAqICAgICAgfVxuICAgICAqICAgICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgICogICAgICB9O1xuICAgICAqXG4gICAgICogICAgICB2YXIgc3F1YXJlID0gbmV3IFJlY3RhbmdsZSgyLCAyKTtcbiAgICAgKiAgICAgIFIuaGFzSW4oJ3dpZHRoJywgc3F1YXJlKTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5oYXNJbignYXJlYScsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaGFzSW4gPSBfY3VycnkyKGZ1bmN0aW9uIGhhc0luKHByb3AsIG9iaikge1xuICAgICAgICByZXR1cm4gcHJvcCBpbiBvYmo7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgaXRzIGFyZ3VtZW50cyBhcmUgaWRlbnRpY2FsLCBmYWxzZSBvdGhlcndpc2UuIFZhbHVlcyBhcmVcbiAgICAgKiBpZGVudGljYWwgaWYgdGhleSByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5LiBgTmFOYCBpcyBpZGVudGljYWwgdG8gYE5hTmA7XG4gICAgICogYDBgIGFuZCBgLTBgIGFyZSBub3QgaWRlbnRpY2FsLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBhIC0+IGEgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG8gPSB7fTtcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKG8sIG8pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKDEsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKFtdLCBbXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaWRlbnRpY2FsKDAsIC0wKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pZGVudGljYWwoTmFOLCBOYU4pOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHZhciBpZGVudGljYWwgPSBfY3VycnkyKGZ1bmN0aW9uIGlkZW50aWNhbChhLCBiKSB7XG4gICAgICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgICAgICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCByZXR1cm4gdGhlIHBhcmFtZXRlciBzdXBwbGllZCB0byBpdC4gR29vZCBhcyBhIGRlZmF1bHRcbiAgICAgKiBvciBwbGFjZWhvbGRlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBhIC0+IGFcbiAgICAgKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgaW5wdXQgdmFsdWUsIGB4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmlkZW50aXR5KDEpOyAvLz0+IDFcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAqICAgICAgUi5pZGVudGl0eShvYmopID09PSBvYmo7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpZGVudGl0eSA9IF9jdXJyeTEoX2lkZW50aXR5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWAgZnVuY3Rpb24gZGVwZW5kaW5nXG4gICAgICogdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzZWUgUi51bmxlc3MsIFIud2hlblxuICAgICAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gKikgLT4gKCouLi4gLT4gKikgLT4gKCouLi4gLT4gKilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblRydWUgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRmFsc2UgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgZmFsc3kgdmFsdWUuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IHVuYXJ5IGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9jZXNzIGVpdGhlciB0aGUgYG9uVHJ1ZWAgb3IgdGhlIGBvbkZhbHNlYFxuICAgICAqICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZXBlbmRpbmcgdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGluY0NvdW50ID0gUi5pZkVsc2UoXG4gICAgICogICAgICAgIFIuaGFzKCdjb3VudCcpLFxuICAgICAqICAgICAgICBSLm92ZXIoUi5sZW5zUHJvcCgnY291bnQnKSwgUi5pbmMpLFxuICAgICAqICAgICAgICBSLmFzc29jKCdjb3VudCcsIDEpXG4gICAgICogICAgICApO1xuICAgICAqICAgICAgaW5jQ291bnQoe30pOyAgICAgICAgICAgLy89PiB7IGNvdW50OiAxIH1cbiAgICAgKiAgICAgIGluY0NvdW50KHsgY291bnQ6IDEgfSk7IC8vPT4geyBjb3VudDogMiB9XG4gICAgICovXG4gICAgdmFyIGlmRWxzZSA9IF9jdXJyeTMoZnVuY3Rpb24gaWZFbHNlKGNvbmRpdGlvbiwgb25UcnVlLCBvbkZhbHNlKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4oTWF0aC5tYXgoY29uZGl0aW9uLmxlbmd0aCwgb25UcnVlLmxlbmd0aCwgb25GYWxzZS5sZW5ndGgpLCBmdW5jdGlvbiBfaWZFbHNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gb25UcnVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvbkZhbHNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50cyBpdHMgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICogQHNlZSBSLmRlY1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW5jKDQyKTsgLy89PiA0M1xuICAgICAqL1xuICAgIHZhciBpbmMgPSBhZGQoMSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoZSBzdXBwbGllZCBlbGVtZW50IGludG8gdGhlIGxpc3QsIGF0IGluZGV4IGBpbmRleGAuICBfTm90ZVxuICAgICAqIHRoYXQgdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICAgICAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjIuMlxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0geyp9IGVsdCBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGluc2VydCBpbnRvXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGVsdGAgaW5zZXJ0ZWQgYXQgYGluZGV4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluc2VydCgyLCAneCcsIFsxLDIsMyw0XSk7IC8vPT4gWzEsMiwneCcsMyw0XVxuICAgICAqL1xuICAgIHZhciBpbnNlcnQgPSBfY3VycnkzKGZ1bmN0aW9uIGluc2VydChpZHgsIGVsdCwgbGlzdCkge1xuICAgICAgICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3NsaWNlKGxpc3QpO1xuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgZWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHN1Yi1saXN0IGludG8gdGhlIGxpc3QsIGF0IGluZGV4IGBpbmRleGAuICBfTm90ZSAgdGhhdCB0aGlzXG4gICAgICogaXMgbm90IGRlc3RydWN0aXZlXzogaXQgcmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgd2l0aCB0aGUgY2hhbmdlcy5cbiAgICAgKiA8c21hbGw+Tm8gbGlzdHMgaGF2ZSBiZWVuIGhhcm1lZCBpbiB0aGUgYXBwbGljYXRpb24gb2YgdGhpcyBmdW5jdGlvbi48L3NtYWxsPlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHN1Yi1saXN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gZWx0cyBUaGUgc3ViLWxpc3QgdG8gaW5zZXJ0IGludG8gdGhlIEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpbnNlcnQgdGhlIHN1Yi1saXN0IGludG9cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0c2AgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgYGluZGV4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluc2VydEFsbCgyLCBbJ3gnLCd5JywneiddLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLCd5JywneicsMyw0XVxuICAgICAqL1xuICAgIHZhciBpbnNlcnRBbGwgPSBfY3VycnkzKGZ1bmN0aW9uIGluc2VydEFsbChpZHgsIGVsdHMsIGxpc3QpIHtcbiAgICAgICAgaWR4ID0gaWR4IDwgbGlzdC5sZW5ndGggJiYgaWR4ID49IDAgPyBpZHggOiBsaXN0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIF9jb25jYXQoX2NvbmNhdChfc2xpY2UobGlzdCwgMCwgaWR4KSwgZWx0cyksIF9zbGljZShsaXN0LCBpZHgpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBpZiBhbiBvYmplY3QgKGB2YWxgKSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IuXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGNoZWNrIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiwgaWYgYW55LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVHlwZVxuICAgICAqIEBzaWcgKCogLT4geyp9KSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3RvciBBIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCB7fSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pcyhOdW1iZXIsIDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCAxKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pcyhTdHJpbmcsICdzJyk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pcyhTdHJpbmcsIG5ldyBTdHJpbmcoJycpKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzKE9iamVjdCwgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXMoT2JqZWN0LCAncycpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzKE51bWJlciwge30pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzID0gX2N1cnJ5MihmdW5jdGlvbiBpcyhDdG9yLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQ3RvciB8fCB2YWwgaW5zdGFuY2VvZiBDdG9yO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBoYXMgYSBudW1lcmljIGxlbmd0aCBwcm9wZXJ0eSBhbmQgZXh0cmVtZSBpbmRpY2VzIGRlZmluZWQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UoW10pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UodHJ1ZSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzQXJyYXlMaWtlKHtsZW5ndGg6IDEwfSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuaXNBcnJheUxpa2UoezA6ICd6ZXJvJywgOTogJ25pbmUnLCBsZW5ndGg6IDEwfSk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5TGlrZSA9IF9jdXJyeTEoZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICAgICAgICBpZiAoX2lzQXJyYXkoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gISF4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4Lmhhc093blByb3BlcnR5KDApICYmIHguaGFzT3duUHJvcGVydHkoeC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IFR5cGVcbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5pc05pbChudWxsKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pc05pbCgwKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc05pbChbXSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNOaWwgPSBfY3VycnkxKGZ1bmN0aW9uIGlzTmlsKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPT0gbnVsbDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd25cbiAgICAgKiBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4gICAgICogY29uc2lzdGVudCBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5rZXlzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgLy8gY292ZXIgSUUgPCA5IGtleXMgaXNzdWVzXG4gICAgdmFyIGtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvdmVyIElFIDwgOSBrZXlzIGlzc3Vlc1xuICAgICAgICB2YXIgaGFzRW51bUJ1ZyA9ICF7IHRvU3RyaW5nOiBudWxsIH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gICAgICAgIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbXG4gICAgICAgICAgICAnY29uc3RydWN0b3InLFxuICAgICAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nJ1xuICAgICAgICBdO1xuICAgICAgICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2lkeF0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nID8gX2N1cnJ5MShmdW5jdGlvbiBrZXlzKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopICE9PSBvYmogPyBbXSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIH0pIDogX2N1cnJ5MShmdW5jdGlvbiBrZXlzKG9iaikge1xuICAgICAgICAgICAgaWYgKE9iamVjdChvYmopICE9PSBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcCwga3MgPSBbXSwgbklkeDtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNFbnVtQnVnKSB7XG4gICAgICAgICAgICAgICAgbklkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tuSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oYXMocHJvcCwgb2JqKSAmJiAhY29udGFpbnMoa3MsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuSWR4IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtzO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlXG4gICAgICogcHJvcGVydGllcyBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0LCBpbmNsdWRpbmcgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4gICAgICogY29uc2lzdGVudCBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIGFuZCBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB0aGlzLnggPSAnWCc7IH07XG4gICAgICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICAgICAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICAgICAqICAgICAgUi5rZXlzSW4oZik7IC8vPT4gWyd4JywgJ3knXVxuICAgICAqL1xuICAgIHZhciBrZXlzSW4gPSBfY3VycnkxKGZ1bmN0aW9uIGtleXNJbihvYmopIHtcbiAgICAgICAgdmFyIHByb3AsIGtzID0gW107XG4gICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrcztcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkgYnkgcmV0dXJuaW5nIGBsaXN0Lmxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubGVuZ3RoKFtdKTsgLy89PiAwXG4gICAgICogICAgICBSLmxlbmd0aChbMSwgMiwgM10pOyAvLz0+IDNcbiAgICAgKi9cbiAgICB2YXIgbGVuZ3RoID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5ndGgobGlzdCkge1xuICAgICAgICByZXR1cm4gbGlzdCAhPSBudWxsICYmIGlzKE51bWJlciwgbGlzdC5sZW5ndGgpID8gbGlzdC5sZW5ndGggOiBOYU47XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQ7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubHQoMiwgMSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIubHQoMiwgMik7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIubHQoMiwgMyk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5sdCgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5sdCgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBfY3VycnkyKGZ1bmN0aW9uIGx0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubHRlKDIsIDEpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmx0ZSgyLCAyKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0ZSgyLCAzKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmx0ZSgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5sdGUoJ3onLCAnYScpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IF9jdXJyeTIoZnVuY3Rpb24gbHRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPD0gYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXBBY2N1bSBmdW5jdGlvbiBiZWhhdmVzIGxpa2UgYSBjb21iaW5hdGlvbiBvZiBtYXAgYW5kIHJlZHVjZTsgaXQgYXBwbGllcyBhXG4gICAgICogZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIGEgbGlzdCwgcGFzc2luZyBhbiBhY2N1bXVsYXRpbmcgcGFyYW1ldGVyIGZyb20gbGVmdCB0b1xuICAgICAqIHJpZ2h0LCBhbmQgcmV0dXJuaW5nIGEgZmluYWwgdmFsdWUgb2YgdGhpcyBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gYXJndW1lbnRzLCAqYWNjKiBhbmQgKnZhbHVlKiwgYW5kIHNob3VsZCByZXR1cm5cbiAgICAgKiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhY2MgLT4geCAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICAgICAqICAgICAgdmFyIGFwcGVuZCA9IChhLCBiKSA9PiBbYSArIGIsIGEgKyBiXTtcbiAgICAgKlxuICAgICAqICAgICAgUi5tYXBBY2N1bShhcHBlbmQsIDAsIGRpZ2l0cyk7IC8vPT4gWycwMTIzNCcsIFsnMDEnLCAnMDEyJywgJzAxMjMnLCAnMDEyMzQnXV1cbiAgICAgKi9cbiAgICB2YXIgbWFwQWNjdW0gPSBfY3VycnkzKGZ1bmN0aW9uIG1hcEFjY3VtKGZuLCBhY2MsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoLCByZXN1bHQgPSBbXSwgdHVwbGUgPSBbYWNjXTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgdHVwbGUgPSBmbih0dXBsZVswXSwgbGlzdFtpZHhdKTtcbiAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gdHVwbGVbMV07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHVwbGVbMF0sXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXBBY2N1bVJpZ2h0IGZ1bmN0aW9uIGJlaGF2ZXMgbGlrZSBhIGNvbWJpbmF0aW9uIG9mIG1hcCBhbmQgcmVkdWNlOyBpdCBhcHBsaWVzIGFcbiAgICAgKiBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZyBwYXJhbWV0ZXIgZnJvbSByaWdodFxuICAgICAqIHRvIGxlZnQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzIGFjY3VtdWxhdG9yIHRvZ2V0aGVyIHdpdGggdGhlIG5ldyBsaXN0LlxuICAgICAqXG4gICAgICogU2ltaWxhciB0byBgbWFwQWNjdW1gLCBleGNlcHQgbW92ZXMgdGhyb3VnaCB0aGUgaW5wdXQgbGlzdCBmcm9tIHRoZSByaWdodCB0byB0aGVcbiAgICAgKiBsZWZ0LlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBhcmd1bWVudHMsICphY2MqIGFuZCAqdmFsdWUqLCBhbmQgc2hvdWxkIHJldHVyblxuICAgICAqIGEgdHVwbGUgKlthY2MsIHZhbHVlXSouXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGFjYyAtPiB4IC0+IChhY2MsIHkpKSAtPiBhY2MgLT4gW3hdIC0+IChhY2MsIFt5XSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZGlnaXRzID0gWycxJywgJzInLCAnMycsICc0J107XG4gICAgICogICAgICB2YXIgYXBwZW5kID0gKGEsIGIpID0+IFthICsgYiwgYSArIGJdO1xuICAgICAqXG4gICAgICogICAgICBSLm1hcEFjY3VtUmlnaHQoYXBwZW5kLCAwLCBkaWdpdHMpOyAvLz0+IFsnMDQzMjEnLCBbJzA0MzIxJywgJzA0MzInLCAnMDQzJywgJzA0J11dXG4gICAgICovXG4gICAgdmFyIG1hcEFjY3VtUmlnaHQgPSBfY3VycnkzKGZ1bmN0aW9uIG1hcEFjY3VtUmlnaHQoZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxLCByZXN1bHQgPSBbXSwgdHVwbGUgPSBbYWNjXTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0dXBsZVswXSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgYSByZWd1bGFyIGV4cHJlc3Npb24gYWdhaW5zdCBhIFN0cmluZy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnNcbiAgICAgKiBmcm9tIFtgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9tYXRjaClcbiAgICAgKiB3aGljaCByZXR1cm5zIGBudWxsYCB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAc2VlIFIudGVzdFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFJlZ0V4cCAtPiBTdHJpbmcgLT4gW1N0cmluZyB8IFVuZGVmaW5lZF1cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcnggQSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgbWF0Y2hlcyBvciBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICAgICAqICAgICAgUi5tYXRjaCgvYS8sICdiJyk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIubWF0Y2goL2EvLCBudWxsKTsgLy89PiBUeXBlRXJyb3I6IG51bGwgZG9lcyBub3QgaGF2ZSBhIG1ldGhvZCBuYW1lZCBcIm1hdGNoXCJcbiAgICAgKi9cbiAgICB2YXIgbWF0Y2ggPSBfY3VycnkyKGZ1bmN0aW9uIG1hdGNoKHJ4LCBzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5tYXRjaChyeCkgfHwgW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBtYXRoTW9kIGJlaGF2ZXMgbGlrZSB0aGUgbW9kdWxvIG9wZXJhdG9yIHNob3VsZCBtYXRoZW1hdGljYWxseSwgdW5saWtlIHRoZSBgJWBcbiAgICAgKiBvcGVyYXRvciAoYW5kIGJ5IGV4dGVuc2lvbiwgUi5tb2R1bG8pLiBTbyB3aGlsZSBcIi0xNyAlIDVcIiBpcyAtMixcbiAgICAgKiBtYXRoTW9kKC0xNywgNSkgaXMgMy4gbWF0aE1vZCByZXF1aXJlcyBJbnRlZ2VyIGFyZ3VtZW50cywgYW5kIHJldHVybnMgTmFOXG4gICAgICogd2hlbiB0aGUgbW9kdWx1cyBpcyB6ZXJvIG9yIG5lZ2F0aXZlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbSBUaGUgZGl2aWRlbmQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHAgdGhlIG1vZHVsdXMuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBiIG1vZCBhYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1hdGhNb2QoLTE3LCA1KTsgIC8vPT4gM1xuICAgICAqICAgICAgUi5tYXRoTW9kKDE3LCA1KTsgICAvLz0+IDJcbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgLTUpOyAgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgMCk7ICAgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNy4yLCA1KTsgLy89PiBOYU5cbiAgICAgKiAgICAgIFIubWF0aE1vZCgxNywgNS4zKTsgLy89PiBOYU5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNsb2NrID0gUi5tYXRoTW9kKFIuX18sIDEyKTtcbiAgICAgKiAgICAgIGNsb2NrKDE1KTsgLy89PiAzXG4gICAgICogICAgICBjbG9jaygyNCk7IC8vPT4gMFxuICAgICAqXG4gICAgICogICAgICB2YXIgc2V2ZW50ZWVuTW9kID0gUi5tYXRoTW9kKDE3KTtcbiAgICAgKiAgICAgIHNldmVudGVlbk1vZCgzKTsgIC8vPT4gMlxuICAgICAqICAgICAgc2V2ZW50ZWVuTW9kKDQpOyAgLy89PiAxXG4gICAgICogICAgICBzZXZlbnRlZW5Nb2QoMTApOyAvLz0+IDdcbiAgICAgKi9cbiAgICB2YXIgbWF0aE1vZCA9IF9jdXJyeTIoZnVuY3Rpb24gbWF0aE1vZChtLCBwKSB7XG4gICAgICAgIGlmICghX2lzSW50ZWdlcihtKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9pc0ludGVnZXIocCkgfHwgcCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtICUgcCArIHApICUgcDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLm1heEJ5LCBSLm1pblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWF4KDc4OSwgMTIzKTsgLy89PiA3ODlcbiAgICAgKiAgICAgIFIubWF4KCdhJywgJ2InKTsgLy89PiAnYidcbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gX2N1cnJ5MihmdW5jdGlvbiBtYXgoYSwgYikge1xuICAgICAgICByZXR1cm4gYiA+IGEgPyBiIDogYTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlc1xuICAgICAqIHRoZSBsYXJnZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOC4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5tYXgsIFIubWluQnlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgc3F1YXJlIDo6IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiAgICAgIHZhciBzcXVhcmUgPSBuID0+IG4gKiBuO1xuICAgICAqXG4gICAgICogICAgICBSLm1heEJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IC0zXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKFIubWF4Qnkoc3F1YXJlKSwgMCwgWzMsIC01LCA0LCAxLCAtMl0pOyAvLz0+IC01XG4gICAgICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFtdKTsgLy89PiAwXG4gICAgICovXG4gICAgdmFyIG1heEJ5ID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXhCeShmLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBmKGIpID4gZihhKSA/IGIgOiBhO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiBgYWBcbiAgICAgKiBtZXJnZWQgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGBiYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWVyZ2UoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDEwIH0sIHsgJ2FnZSc6IDQwIH0pO1xuICAgICAqICAgICAgLy89PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICAgICAqXG4gICAgICogICAgICB2YXIgcmVzZXRUb0RlZmF1bHQgPSBSLm1lcmdlKFIuX18sIHt4OiAwfSk7XG4gICAgICogICAgICByZXNldFRvRGVmYXVsdCh7eDogNSwgeTogMn0pOyAvLz0+IHt4OiAwLCB5OiAyfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IF9jdXJyeTIoZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBrcyA9IGtleXMoYSk7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwga3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRba3NbaWR4XV0gPSBhW2tzW2lkeF1dO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAga3MgPSBrZXlzKGIpO1xuICAgICAgICBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwga3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRba3NbaWR4XV0gPSBiW2tzW2lkeF1dO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGFcbiAgICAgKiBAcGFyYW0geyp9IGFcbiAgICAgKiBAcGFyYW0geyp9IGJcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5taW5CeSwgUi5tYXhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1pbig3ODksIDEyMyk7IC8vPT4gMTIzXG4gICAgICogICAgICBSLm1pbignYScsICdiJyk7IC8vPT4gJ2EnXG4gICAgICovXG4gICAgdmFyIG1pbiA9IF9jdXJyeTIoZnVuY3Rpb24gbWluKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIgPCBhID8gYiA6IGE7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzLCBhbmQgcmV0dXJucyB3aGljaGV2ZXIgdmFsdWUgcHJvZHVjZXNcbiAgICAgKiB0aGUgc21hbGxlciByZXN1bHQgd2hlbiBwYXNzZWQgdG8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICAqIEBwYXJhbSB7Kn0gYVxuICAgICAqIEBwYXJhbSB7Kn0gYlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLm1pbiwgUi5tYXhCeVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBzcXVhcmUgOjogTnVtYmVyIC0+IE51bWJlclxuICAgICAqICAgICAgdmFyIHNxdWFyZSA9IG4gPT4gbiAqIG47XG4gICAgICpcbiAgICAgKiAgICAgIFIubWluQnkoc3F1YXJlLCAtMywgMik7IC8vPT4gMlxuICAgICAqXG4gICAgICogICAgICBSLnJlZHVjZShSLm1pbkJ5KHNxdWFyZSksIEluZmluaXR5LCBbMywgLTUsIDQsIDEsIC0yXSk7IC8vPT4gMVxuICAgICAqICAgICAgUi5yZWR1Y2UoUi5taW5CeShzcXVhcmUpLCBJbmZpbml0eSwgW10pOyAvLz0+IEluZmluaXR5XG4gICAgICovXG4gICAgdmFyIG1pbkJ5ID0gX2N1cnJ5MyhmdW5jdGlvbiBtaW5CeShmLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBmKGIpIDwgZihhKSA/IGIgOiBhO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBieSB0aGUgZmlyc3QgYW5kIHJldHVybnMgdGhlIHJlbWFpbmRlci5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBwcmVzZXJ2ZXMgdGhlIEphdmFTY3JpcHQtc3R5bGUgYmVoYXZpb3IgZm9yXG4gICAgICogbW9kdWxvLiBGb3IgbWF0aGVtYXRpY2FsIG1vZHVsbyBzZWUgYG1hdGhNb2RgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgdmFsdWUgdG8gdGhlIGRpdmlkZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgcHNldWRvLW1vZHVsdXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgJSBhYC5cbiAgICAgKiBAc2VlIFIubWF0aE1vZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubW9kdWxvKDE3LCAzKTsgLy89PiAyXG4gICAgICogICAgICAvLyBKUyBiZWhhdmlvcjpcbiAgICAgKiAgICAgIFIubW9kdWxvKC0xNywgMyk7IC8vPT4gLTJcbiAgICAgKiAgICAgIFIubW9kdWxvKDE3LCAtMyk7IC8vPT4gMlxuICAgICAqXG4gICAgICogICAgICB2YXIgaXNPZGQgPSBSLm1vZHVsbyhSLl9fLCAyKTtcbiAgICAgKiAgICAgIGlzT2RkKDQyKTsgLy89PiAwXG4gICAgICogICAgICBpc09kZCgyMSk7IC8vPT4gMVxuICAgICAqL1xuICAgIHZhciBtb2R1bG8gPSBfY3VycnkyKGZ1bmN0aW9uIG1vZHVsbyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICUgYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIG51bWJlcnMuIEVxdWl2YWxlbnQgdG8gYGEgKiBiYCBidXQgY3VycmllZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhICogYmAuXG4gICAgICogQHNlZSBSLmRpdmlkZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBkb3VibGUgPSBSLm11bHRpcGx5KDIpO1xuICAgICAqICAgICAgdmFyIHRyaXBsZSA9IFIubXVsdGlwbHkoMyk7XG4gICAgICogICAgICBkb3VibGUoMyk7ICAgICAgIC8vPT4gIDZcbiAgICAgKiAgICAgIHRyaXBsZSg0KTsgICAgICAgLy89PiAxMlxuICAgICAqICAgICAgUi5tdWx0aXBseSgyLCA1KTsgIC8vPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBfY3VycnkyKGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBleGFjdGx5IGBuYFxuICAgICAqIHBhcmFtZXRlcnMuIEFueSBleHRyYW5lb3VzIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgcGFzc2VkIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgZGVzaXJlZCBhcml0eSBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAgICAgKiAgICAgICAgIGFyaXR5IGBuYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZXNUd29BcmdzID0gKGEsIGIpID0+IFthLCBiXTtcbiAgICAgKlxuICAgICAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gICAgICogICAgICB0YWtlc1R3b0FyZ3MoMSwgMik7IC8vPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB0YWtlc09uZUFyZyA9IFIubkFyeSgxLCB0YWtlc1R3b0FyZ3MpO1xuICAgICAqICAgICAgdGFrZXNPbmVBcmcubGVuZ3RoOyAvLz0+IDFcbiAgICAgKiAgICAgIC8vIE9ubHkgYG5gIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gICAgICogICAgICB0YWtlc09uZUFyZygxLCAyKTsgLy89PiBbMSwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIHZhciBuQXJ5ID0gX2N1cnJ5MihmdW5jdGlvbiBuQXJ5KG4sIGZuKSB7XG4gICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBuQXJ5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgaXRzIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubmVnYXRlKDQyKTsgLy89PiAtNDJcbiAgICAgKi9cbiAgICB2YXIgbmVnYXRlID0gX2N1cnJ5MShmdW5jdGlvbiBuZWdhdGUobikge1xuICAgICAgICByZXR1cm4gLW47XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYCFgIG9mIGl0cyBhcmd1bWVudC4gSXQgd2lsbCByZXR1cm4gYHRydWVgIHdoZW5cbiAgICAgKiBwYXNzZWQgZmFsc2UteSB2YWx1ZSwgYW5kIGBmYWxzZWAgd2hlbiBwYXNzZWQgYSB0cnV0aC15IG9uZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExvZ2ljXG4gICAgICogQHNpZyAqIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGEgYW55IHZhbHVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIGxvZ2ljYWwgaW52ZXJzZSBvZiBwYXNzZWQgYXJndW1lbnQuXG4gICAgICogQHNlZSBSLmNvbXBsZW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm5vdCh0cnVlKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5ub3QoZmFsc2UpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIubm90KDApOyA9PiB0cnVlXG4gICAgICogICAgICBSLm5vdCgxKTsgPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbm90ID0gX2N1cnJ5MShmdW5jdGlvbiBub3QoYSkge1xuICAgICAgICByZXR1cm4gIWE7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSB0aGUgZWxlbWVudCBhdCBpbmRleCBsZW5ndGggKyBuIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBsaXN0ID0gWydmb28nLCAnYmFyJywgJ2JheicsICdxdXV4J107XG4gICAgICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICAgICAqICAgICAgUi5udGgoLTEsIGxpc3QpOyAvLz0+ICdxdXV4J1xuICAgICAqICAgICAgUi5udGgoLTk5LCBsaXN0KTsgLy89PiB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqICAgICAgUi5udGgoJ2FiYycsIDIpOyAvLz0+ICdjJ1xuICAgICAqICAgICAgUi5udGgoJ2FiYycsIDMpOyAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIG50aCA9IF9jdXJyeTIoZnVuY3Rpb24gbnRoKG9mZnNldCwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gb2Zmc2V0IDwgMCA/IGxpc3QubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5jaGFyQXQoaWR4KSA6IGxpc3RbaWR4XTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGl0cyBudGggYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICouLi4gLT4gKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5udGhBcmcoMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2InXG4gICAgICogICAgICBSLm50aEFyZygtMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2MnXG4gICAgICovXG4gICAgdmFyIG50aEFyZyA9IF9jdXJyeTEoZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudGgobiwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUga2V5OnZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7U3RyaW5nOmF9XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqIEBzZWUgUi5wYWlyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hdGNoUGhyYXNlcyA9IFIuY29tcG9zZShcbiAgICAgKiAgICAgICAgUi5vYmpPZignbXVzdCcpLFxuICAgICAqICAgICAgICBSLm1hcChSLm9iak9mKCdtYXRjaF9waHJhc2UnKSlcbiAgICAgKiAgICAgICk7XG4gICAgICogICAgICBtYXRjaFBocmFzZXMoWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiB7bXVzdDogW3ttYXRjaF9waHJhc2U6ICdmb28nfSwge21hdGNoX3BocmFzZTogJ2Jhcid9LCB7bWF0Y2hfcGhyYXNlOiAnYmF6J31dfVxuICAgICAqL1xuICAgIHZhciBvYmpPZiA9IF9jdXJyeTIoZnVuY3Rpb24gb2JqT2Yoa2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGV0b24gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgYG9mYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgRVM2IGBvZmA7IFNlZVxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29mXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgYSAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IHggYW55IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IHdyYXBwaW5nIGB4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm9mKG51bGwpOyAvLz0+IFtudWxsXVxuICAgICAqICAgICAgUi5vZihbNDJdKTsgLy89PiBbWzQyXV1cbiAgICAgKi9cbiAgICB2YXIgb2YgPSBfY3VycnkxKF9vZik7XG5cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ3VhcmRzIGludm9jYXRpb24gb2YgYGZuYCBzdWNoIHRoYXRcbiAgICAgKiBgZm5gIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSB0aW1lcyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZmlyc3QgdmFsdWUgY2FsY3VsYXRlZCBpcyByZXR1cm5lZCBpbiBzdWJzZXF1ZW50IGludm9jYXRpb25zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIChhLi4uIC0+IGIpIC0+IChhLi4uIC0+IGIpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAgaW4gYSBjYWxsLW9ubHktb25jZSB3cmFwcGVyLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWRkT25lT25jZSA9IFIub25jZSh4ID0+IHggKyAxKTtcbiAgICAgKiAgICAgIGFkZE9uZU9uY2UoMTApOyAvLz0+IDExXG4gICAgICogICAgICBhZGRPbmVPbmNlKGFkZE9uZU9uY2UoNTApKTsgLy89PiAxMVxuICAgICAqL1xuICAgIHZhciBvbmNlID0gX2N1cnJ5MShmdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZSwgcmVzdWx0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBvbmUgb3IgYm90aCBvZiBpdHMgYXJndW1lbnRzIGFyZSBgdHJ1ZWAuIFJldHVybnMgYGZhbHNlYFxuICAgICAqIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnICogLT4gKiAtPiAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhIEEgYm9vbGVhbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYiBBIGJvb2xlYW4gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggYXJndW1lbnRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAgICogQHNlZSBSLmVpdGhlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIub3IodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5vcih0cnVlLCBmYWxzZSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5vcihmYWxzZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5vcihmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG9yID0gX2N1cnJ5MihmdW5jdGlvbiBvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIHx8IGI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgXCJzZXR0aW5nXCIgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlXG4gICAgICogZm9jdXNlZCBieSB0aGUgZ2l2ZW4gbGVucyB0byB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBnaXZlbiBmdW5jdGlvbiB0b1xuICAgICAqIHRoZSBmb2N1c2VkIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gICAgICogQHNpZyBMZW5zIHMgYSAtPiAoYSAtPiBhKSAtPiBzIC0+IHNcbiAgICAgKiBAcGFyYW0ge0xlbnN9IGxlbnNcbiAgICAgKiBAcGFyYW0geyp9IHZcbiAgICAgKiBAcGFyYW0geyp9IHhcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBoZWFkTGVucyA9IFIubGVuc0luZGV4KDApO1xuICAgICAqXG4gICAgICogICAgICBSLm92ZXIoaGVhZExlbnMsIFIudG9VcHBlciwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ0ZPTycsICdiYXInLCAnYmF6J11cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIElkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpdHkoZih4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTMoZnVuY3Rpb24gb3ZlcihsZW5zLCBmLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4gbGVucyhmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGl0eShmKHkpKTtcbiAgICAgICAgICAgIH0pKHgpLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0d28gYXJndW1lbnRzLCBgZnN0YCBhbmQgYHNuZGAsIGFuZCByZXR1cm5zIGBbZnN0LCBzbmRdYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTguMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IGIgLT4gKGEsYilcbiAgICAgKiBAcGFyYW0geyp9IGZzdFxuICAgICAqIEBwYXJhbSB7Kn0gc25kXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHNlZSBSLmNyZWF0ZU1hcEVudHJ5LCBSLm9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgcGFpcignZm9vJywgJ2JhcicpOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgdmFyIHBhaXIgPSBfY3VycnkyKGZ1bmN0aW9uIHBhaXIoZnN0LCBzbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZzdCxcbiAgICAgICAgICAgIHNuZFxuICAgICAgICBdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgW1N0cmluZ10gLT4ge2s6IHZ9IC0+IHYgfCBVbmRlZmluZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gICAgICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhciBwYXRoID0gX2N1cnJ5MihmdW5jdGlvbiBwYXRoKHBhdGhzLCBvYmopIHtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqO1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodmFsICE9IG51bGwgJiYgaWR4IDwgcGF0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsW3BhdGhzW2lkeF1dO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGdpdmVuLCBub24tbnVsbCBvYmplY3QgaGFzIGEgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGgsIHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgdGhhdCBwYXRoLiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIGEgLT4gW1N0cmluZ10gLT4gT2JqZWN0IC0+IGFcbiAgICAgKiBAcGFyYW0geyp9IGQgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcCBUaGUgcGF0aCB0byB1c2UuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGRhdGEgYXQgYHBhdGhgIG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5wYXRoT3IoJ04vQScsIFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gICAgICogICAgICBSLnBhdGhPcignTi9BJywgWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IFwiTi9BXCJcbiAgICAgKi9cbiAgICB2YXIgcGF0aE9yID0gX2N1cnJ5MyhmdW5jdGlvbiBwYXRoT3IoZCwgcCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VG8oZCwgcGF0aChwLCBvYmopKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyBzcGVjaWZpZWQuICBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGVcbiAgICAgKiBwcm9wZXJ0eSBpcyBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBvbiBpdC5cbiAgICAgKiBAc2VlIFIub21pdCwgUi5wcm9wc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGljayhbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICAgICAqICAgICAgUi5waWNrKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMX1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IF9jdXJyeTIoZnVuY3Rpb24gcGljayhuYW1lcywgb2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChuYW1lc1tpZHhdIGluIG9iaikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lc1tpZHhdXSA9IG9ialtuYW1lc1tpZHhdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGBwaWNrYCBleGNlcHQgdGhhdCB0aGlzIG9uZSBpbmNsdWRlcyBhIGBrZXk6IHVuZGVmaW5lZGAgcGFpciBmb3IgcHJvcGVydGllcyB0aGF0IGRvbid0IGV4aXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBvbiBpdC5cbiAgICAgKiBAc2VlIFIucGlja1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGlja0FsbChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICAgICAqICAgICAgUi5waWNrQWxsKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZTogdW5kZWZpbmVkLCBmOiB1bmRlZmluZWR9XG4gICAgICovXG4gICAgdmFyIHBpY2tBbGwgPSBfY3VycnkyKGZ1bmN0aW9uIHBpY2tBbGwobmFtZXMsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2lkeF07XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBrZXlzIHRoYXRcbiAgICAgKiBzYXRpc2Z5IHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnICh2LCBrIC0+IEJvb2xlYW4pIC0+IHtrOiB2fSAtPiB7azogdn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGtleVxuICAgICAqICAgICAgICBzaG91bGQgYmUgaW5jbHVkZWQgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIHRoYXQgc2F0aXNmeSBgcHJlZGBcbiAgICAgKiAgICAgICAgIG9uIGl0LlxuICAgICAqIEBzZWUgUi5waWNrXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzVXBwZXJDYXNlID0gKHZhbCwga2V5KSA9PiBrZXkudG9VcHBlckNhc2UoKSA9PT0ga2V5O1xuICAgICAqICAgICAgUi5waWNrQnkoaXNVcHBlckNhc2UsIHthOiAxLCBiOiAyLCBBOiAzLCBCOiA0fSk7IC8vPT4ge0E6IDMsIEI6IDR9XG4gICAgICovXG4gICAgdmFyIHBpY2tCeSA9IF9jdXJyeTIoZnVuY3Rpb24gcGlja0J5KHRlc3QsIG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodGVzdChvYmpbcHJvcF0sIHByb3AsIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRoIHRoZSBnaXZlbiBlbGVtZW50IGF0IHRoZSBmcm9udCwgZm9sbG93ZWQgYnkgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAqIGxpc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0geyp9IGVsIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgaGVhZCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gYWRkIHRvIHRoZSB0YWlsIG9mIHRoZSBvdXRwdXQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gICAgICogQHNlZSBSLmFwcGVuZFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucHJlcGVuZCgnZmVlJywgWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gWydmZWUnLCAnZmknLCAnZm8nLCAnZnVtJ11cbiAgICAgKi9cbiAgICB2YXIgcHJlcGVuZCA9IF9jdXJyeTIoZnVuY3Rpb24gcHJlcGVuZChlbCwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChbZWxdLCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gc3VwcGxpZWQgYW4gb2JqZWN0IHJldHVybnMgdGhlIGluZGljYXRlZCBwcm9wZXJ0eSBvZiB0aGF0IG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyBzIC0+IHtzOiBhfSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYG9iai5wYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3AoJ3gnLCB7eDogMTAwfSk7IC8vPT4gMTAwXG4gICAgICogICAgICBSLnByb3AoJ3gnLCB7fSk7IC8vPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgdmFyIHByb3AgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3AocCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbcF07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLFxuICAgICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkuXG4gICAgICogT3RoZXJ3aXNlIHJldHVybnMgdGhlIHByb3ZpZGVkIGRlZmF1bHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIGEgLT4gU3RyaW5nIC0+IE9iamVjdCAtPiBhXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHVybi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGdpdmVuIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZCBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFsaWNlID0ge1xuICAgICAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICAgICAqICAgICAgICBhZ2U6IDEwMVxuICAgICAqICAgICAgfTtcbiAgICAgKiAgICAgIHZhciBmYXZvcml0ZSA9IFIucHJvcCgnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gICAgICogICAgICB2YXIgZmF2b3JpdGVXaXRoRGVmYXVsdCA9IFIucHJvcE9yKCdSYW1kYScsICdmYXZvcml0ZUxpYnJhcnknKTtcbiAgICAgKlxuICAgICAqICAgICAgZmF2b3JpdGUoYWxpY2UpOyAgLy89PiB1bmRlZmluZWRcbiAgICAgKiAgICAgIGZhdm9yaXRlV2l0aERlZmF1bHQoYWxpY2UpOyAgLy89PiAnUmFtZGEnXG4gICAgICovXG4gICAgdmFyIHByb3BPciA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcE9yKHZhbCwgcCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfaGFzKHAsIG9iaikgPyBvYmpbcF0gOiB2YWw7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBzYXRpc2ZpZXMgdGhlIGdpdmVuXG4gICAgICogcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IHtTdHJpbmc6IGF9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLnByb3BFcVxuICAgICAqIEBzZWUgUi5wcm9wSXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BTYXRpc2ZpZXMoeCA9PiB4ID4gMCwgJ3gnLCB7eDogMSwgeTogMn0pOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgcHJvcFNhdGlzZmllcyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcFNhdGlzZmllcyhwcmVkLCBuYW1lLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIHByZWQob2JqW25hbWVdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFjdHMgYXMgbXVsdGlwbGUgYHByb3BgOiBhcnJheSBvZiBrZXlzIGluLCBhcnJheSBvZiB2YWx1ZXMgb3V0LiBQcmVzZXJ2ZXMgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtrXSAtPiB7azogdn0gLT4gW3ZdXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5XG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBvciBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BzKFsneCcsICd5J10sIHt4OiAxLCB5OiAyfSk7IC8vPT4gWzEsIDJdXG4gICAgICogICAgICBSLnByb3BzKFsnYycsICdhJywgJ2InXSwge2I6IDIsIGE6IDF9KTsgLy89PiBbdW5kZWZpbmVkLCAxLCAyXVxuICAgICAqXG4gICAgICogICAgICB2YXIgZnVsbE5hbWUgPSBSLmNvbXBvc2UoUi5qb2luKCcgJyksIFIucHJvcHMoWydmaXJzdCcsICdsYXN0J10pKTtcbiAgICAgKiAgICAgIGZ1bGxOYW1lKHtsYXN0OiAnQnVsbGV0LVRvb3RoJywgYWdlOiAzMywgZmlyc3Q6ICdUb255J30pOyAvLz0+ICdUb255IEJ1bGxldC1Ub290aCdcbiAgICAgKi9cbiAgICB2YXIgcHJvcHMgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3BzKHBzLCBvYmopIHtcbiAgICAgICAgdmFyIGxlbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgb3V0W2lkeF0gPSBvYmpbcHNbaWR4XV07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgbnVtYmVycyBmcm9tIGBmcm9tYCAoaW5jbHVzaXZlKSB0byBgdG9gXG4gICAgICogKGV4Y2x1c2l2ZSkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFtOdW1iZXJdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gVGhlIGZpcnN0IG51bWJlciBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG8gT25lIG1vcmUgdGhhbiB0aGUgbGFzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG51bWJlcnMgaW4gdHRoZSBzZXQgYFthLCBiKWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yYW5nZSgxLCA1KTsgICAgLy89PiBbMSwgMiwgMywgNF1cbiAgICAgKiAgICAgIFIucmFuZ2UoNTAsIDUzKTsgIC8vPT4gWzUwLCA1MSwgNTJdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gX2N1cnJ5MihmdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICAgICAgICBpZiAoIShfaXNOdW1iZXIoZnJvbSkgJiYgX2lzTnVtYmVyKHRvKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggYXJndW1lbnRzIHRvIHJhbmdlIG11c3QgYmUgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBmcm9tO1xuICAgICAgICB3aGlsZSAobiA8IHRvKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuKTtcbiAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZyB0aGUgaXRlcmF0b3JcbiAgICAgKiBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZFxuICAgICAqIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIGByZWR1Y2VgLCBleGNlcHQgbW92ZXMgdGhyb3VnaCB0aGUgaW5wdXQgbGlzdCBmcm9tIHRoZSByaWdodCB0byB0aGUgbGVmdC5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKGFjYywgdmFsdWUpKlxuICAgICAqXG4gICAgICogTm90ZTogYFIucmVkdWNlUmlnaHRgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZSBhcnJheXMpLCB1bmxpa2VcbiAgICAgKiB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHMgb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZVJpZ2h0I0Rlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSxiIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gICAgICogICAgICAgIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcGFpcnMgPSBbIFsnYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM10gXTtcbiAgICAgKiAgICAgIHZhciBmbGF0dGVuUGFpcnMgPSAoYWNjLCBwYWlyKSA9PiBhY2MuY29uY2F0KHBhaXIpO1xuICAgICAqXG4gICAgICogICAgICBSLnJlZHVjZVJpZ2h0KGZsYXR0ZW5QYWlycywgW10sIHBhaXJzKTsgLy89PiBbICdjJywgMywgJ2InLCAyLCAnYScsIDEgXVxuICAgICAqL1xuICAgIHZhciByZWR1Y2VSaWdodCA9IF9jdXJyeTMoZnVuY3Rpb24gcmVkdWNlUmlnaHQoZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGFjYyA9IGZuKGFjYywgbGlzdFtpZHhdKTtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmFsdWUgd3JhcHBlZCB0byBpbmRpY2F0ZSB0aGF0IGl0IGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGVcbiAgICAgKiByZWR1Y2UgYW5kIHRyYW5zZHVjZSBmdW5jdGlvbnMuICBUaGUgcmV0dXJuZWQgdmFsdWVcbiAgICAgKiBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGJsYWNrIGJveDogdGhlIGludGVybmFsIHN0cnVjdHVyZSBpcyBub3RcbiAgICAgKiBndWFyYW50ZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgb3B0aW1pemF0aW9uIGlzIHVuYXZhaWxhYmxlIHRvIGZ1bmN0aW9ucyBub3QgZXhwbGljaXRseSBsaXN0ZWRcbiAgICAgKiBhYm92ZS4gIEZvciBpbnN0YW5jZSwgaXQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgcmVkdWNlSW5kZXhlZCxcbiAgICAgKiByZWR1Y2VSaWdodCwgb3IgcmVkdWNlUmlnaHRJbmRleGVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2VlIFIucmVkdWNlLCBSLnRyYW5zZHVjZVxuICAgICAqIEBzaWcgYSAtPiAqXG4gICAgICogQHBhcmFtIHsqfSB4IFRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKFxuICAgICAqICAgICAgICBSLnBpcGUoUi5hZGQsIFIud2hlbihSLmd0ZShSLl9fLCAxMCksIFIucmVkdWNlZCkpLFxuICAgICAqICAgICAgICAwLFxuICAgICAqICAgICAgICBbMSwgMiwgMywgNCwgNV0pIC8vIDEwXG4gICAgICovXG4gICAgdmFyIHJlZHVjZWQgPSBfY3VycnkxKF9yZWR1Y2VkKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHN1Yi1saXN0IG9mIGBsaXN0YCBzdGFydGluZyBhdCBpbmRleCBgc3RhcnRgIGFuZCBjb250YWluaW5nXG4gICAgICogYGNvdW50YCBlbGVtZW50cy4gIF9Ob3RlIHRoYXQgdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGFcbiAgICAgKiBjb3B5IG9mIHRoZSBsaXN0IHdpdGggdGhlIGNoYW5nZXMuXG4gICAgICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4yXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgcG9zaXRpb24gdG8gc3RhcnQgcmVtb3ZpbmcgZWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHJlbW92ZSBmcm9tXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGNvdW50YCBlbGVtZW50cyBmcm9tIGBzdGFydGAgcmVtb3ZlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnJlbW92ZSgyLCAzLCBbMSwyLDMsNCw1LDYsNyw4XSk7IC8vPT4gWzEsMiw2LDcsOF1cbiAgICAgKi9cbiAgICB2YXIgcmVtb3ZlID0gX2N1cnJ5MyhmdW5jdGlvbiByZW1vdmUoc3RhcnQsIGNvdW50LCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0KF9zbGljZShsaXN0LCAwLCBNYXRoLm1pbihzdGFydCwgbGlzdC5sZW5ndGgpKSwgX3NsaWNlKGxpc3QsIE1hdGgubWluKGxpc3QubGVuZ3RoLCBzdGFydCArIGNvdW50KSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhIHN1YnN0cmluZyBvciByZWdleCBtYXRjaCBpbiBhIHN0cmluZyB3aXRoIGEgcmVwbGFjZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFJlZ0V4cHxTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHBhdHRlcm4gQSByZWd1bGFyIGV4cHJlc3Npb24gb3IgYSBzdWJzdHJpbmcgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBzdHJpbmcgdG8gcmVwbGFjZSB0aGUgbWF0Y2hlcyB3aXRoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byBkbyB0aGUgc2VhcmNoIGFuZCByZXBsYWNlbWVudCBpbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZXN1bHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZXBsYWNlKCdmb28nLCAnYmFyJywgJ2ZvbyBmb28gZm9vJyk7IC8vPT4gJ2JhciBmb28gZm9vJ1xuICAgICAqICAgICAgUi5yZXBsYWNlKC9mb28vLCAnYmFyJywgJ2ZvbyBmb28gZm9vJyk7IC8vPT4gJ2JhciBmb28gZm9vJ1xuICAgICAqXG4gICAgICogICAgICAvLyBVc2UgdGhlIFwiZ1wiIChnbG9iYWwpIGZsYWcgdG8gcmVwbGFjZSBhbGwgb2NjdXJyZW5jZXM6XG4gICAgICogICAgICBSLnJlcGxhY2UoL2Zvby9nLCAnYmFyJywgJ2ZvbyBmb28gZm9vJyk7IC8vPT4gJ2JhciBiYXIgYmFyJ1xuICAgICAqL1xuICAgIHZhciByZXBsYWNlID0gX2N1cnJ5MyhmdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCByZXBsYWNlbWVudCwgc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgcmVwbGFjZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IG9yIHN0cmluZyB3aXRoIHRoZSBlbGVtZW50cyBvciBjaGFyYWN0ZXJzIGluIHJldmVyc2VcbiAgICAgKiBvcmRlci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV1cbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbGlzdFxuICAgICAqIEByZXR1cm4ge0FycmF5fFN0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnJldmVyc2UoWzEsIDIsIDNdKTsgIC8vPT4gWzMsIDIsIDFdXG4gICAgICogICAgICBSLnJldmVyc2UoWzEsIDJdKTsgICAgIC8vPT4gWzIsIDFdXG4gICAgICogICAgICBSLnJldmVyc2UoWzFdKTsgICAgICAgIC8vPT4gWzFdXG4gICAgICogICAgICBSLnJldmVyc2UoW10pOyAgICAgICAgIC8vPT4gW11cbiAgICAgKlxuICAgICAqICAgICAgUi5yZXZlcnNlKCdhYmMnKTsgICAgICAvLz0+ICdjYmEnXG4gICAgICogICAgICBSLnJldmVyc2UoJ2FiJyk7ICAgICAgIC8vPT4gJ2JhJ1xuICAgICAqICAgICAgUi5yZXZlcnNlKCdhJyk7ICAgICAgICAvLz0+ICdhJ1xuICAgICAqICAgICAgUi5yZXZlcnNlKCcnKTsgICAgICAgICAvLz0+ICcnXG4gICAgICovXG4gICAgdmFyIHJldmVyc2UgPSBfY3VycnkxKGZ1bmN0aW9uIHJldmVyc2UobGlzdCkge1xuICAgICAgICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogX3NsaWNlKGxpc3QpLnJldmVyc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNjYW4gaXMgc2ltaWxhciB0byByZWR1Y2UsIGJ1dCByZXR1cm5zIGEgbGlzdCBvZiBzdWNjZXNzaXZlbHkgcmVkdWNlZCB2YWx1ZXMgZnJvbSB0aGUgbGVmdFxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLGIgLT4gYSkgLT4gYSAtPiBbYl0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICAgICAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBhbGwgaW50ZXJtZWRpYXRlbHkgcmVkdWNlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICogICAgICB2YXIgZmFjdG9yaWFscyA9IFIuc2NhbihSLm11bHRpcGx5LCAxLCBudW1iZXJzKTsgLy89PiBbMSwgMSwgMiwgNiwgMjRdXG4gICAgICovXG4gICAgdmFyIHNjYW4gPSBfY3VycnkzKGZ1bmN0aW9uIHNjYW4oZm4sIGFjYywgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMCwgbGVuID0gbGlzdC5sZW5ndGgsIHJlc3VsdCA9IFthY2NdO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBhY2MgPSBmbihhY2MsIGxpc3RbaWR4XSk7XG4gICAgICAgICAgICByZXN1bHRbaWR4ICsgMV0gPSBhY2M7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIFwic2V0dGluZ1wiIHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHN0cnVjdHVyZVxuICAgICAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gICAgICogQHNpZyBMZW5zIHMgYSAtPiBhIC0+IHMgLT4gc1xuICAgICAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICAgICAqIEBwYXJhbSB7Kn0gdlxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICAgICAqXG4gICAgICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gICAgICogICAgICBSLnNldCh4TGVucywgOCwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IDgsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIHNldCA9IF9jdXJyeTMoZnVuY3Rpb24gc2V0KGxlbnMsIHYsIHgpIHtcbiAgICAgICAgcmV0dXJuIG92ZXIobGVucywgYWx3YXlzKHYpLCB4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaXN0LCBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uLCB3aGljaCBzaG91bGQgYWNjZXB0IHR3byB2YWx1ZXMgYXQgYVxuICAgICAqIHRpbWUgYW5kIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgdmFsdWUgaXMgc21hbGxlciwgYSBwb3NpdGl2ZSBudW1iZXIgaWYgaXQncyBsYXJnZXIsIGFuZCB6ZXJvXG4gICAgICogaWYgdGhleSBhcmUgZXF1YWwuICBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYSAqKmNvcHkqKiBvZiB0aGUgbGlzdC4gIEl0IGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSxhIC0+IE51bWJlcikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgQSBzb3J0aW5nIGZ1bmN0aW9uIDo6IGEgLT4gYiAtPiBJbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHNvcnRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgd2l0aCBpdHMgZWxlbWVudHMgc29ydGVkIGJ5IHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBkaWZmID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG4gICAgICogICAgICBSLnNvcnQoZGlmZiwgWzQsMiw3LDVdKTsgLy89PiBbMiwgNCwgNSwgN11cbiAgICAgKi9cbiAgICB2YXIgc29ydCA9IF9jdXJyeTIoZnVuY3Rpb24gc29ydChjb21wYXJhdG9yLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UobGlzdCkuc29ydChjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBsaXN0IGFjY29yZGluZyB0byB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IHNvcnRlZCBieSB0aGUga2V5cyBnZW5lcmF0ZWQgYnkgYGZuYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc29ydEJ5Rmlyc3RJdGVtID0gUi5zb3J0QnkoUi5wcm9wKDApKTtcbiAgICAgKiAgICAgIHZhciBzb3J0QnlOYW1lQ2FzZUluc2Vuc2l0aXZlID0gUi5zb3J0QnkoUi5jb21wb3NlKFIudG9Mb3dlciwgUi5wcm9wKCduYW1lJykpKTtcbiAgICAgKiAgICAgIHZhciBwYWlycyA9IFtbLTEsIDFdLCBbLTIsIDJdLCBbLTMsIDNdXTtcbiAgICAgKiAgICAgIHNvcnRCeUZpcnN0SXRlbShwYWlycyk7IC8vPT4gW1stMywgM10sIFstMiwgMl0sIFstMSwgMV1dXG4gICAgICogICAgICB2YXIgYWxpY2UgPSB7XG4gICAgICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gICAgICogICAgICAgIGFnZTogMTAxXG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdmFyIGJvYiA9IHtcbiAgICAgKiAgICAgICAgbmFtZTogJ0JvYicsXG4gICAgICogICAgICAgIGFnZTogLTEwXG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdmFyIGNsYXJhID0ge1xuICAgICAqICAgICAgICBuYW1lOiAnY2xhcmEnLFxuICAgICAqICAgICAgICBhZ2U6IDMxNC4xNTlcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB2YXIgcGVvcGxlID0gW2NsYXJhLCBib2IsIGFsaWNlXTtcbiAgICAgKiAgICAgIHNvcnRCeU5hbWVDYXNlSW5zZW5zaXRpdmUocGVvcGxlKTsgLy89PiBbYWxpY2UsIGJvYiwgY2xhcmFdXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IF9jdXJyeTIoZnVuY3Rpb24gc29ydEJ5KGZuLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UobGlzdCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIGFhID0gZm4oYSk7XG4gICAgICAgICAgICB2YXIgYmIgPSBmbihiKTtcbiAgICAgICAgICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHR3byBudW1iZXJzLiBFcXVpdmFsZW50IHRvIGBhIC0gYmAgYnV0IGN1cnJpZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYSAtIGJgLlxuICAgICAqIEBzZWUgUi5hZGRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnN1YnRyYWN0KDEwLCA4KTsgLy89PiAyXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBtaW51czUgPSBSLnN1YnRyYWN0KFIuX18sIDUpO1xuICAgICAqICAgICAgbWludXM1KDE3KTsgLy89PiAxMlxuICAgICAqXG4gICAgICogICAgICB2YXIgY29tcGxlbWVudGFyeUFuZ2xlID0gUi5zdWJ0cmFjdCg5MCk7XG4gICAgICogICAgICBjb21wbGVtZW50YXJ5QW5nbGUoMzApOyAvLz0+IDYwXG4gICAgICogICAgICBjb21wbGVtZW50YXJ5QW5nbGUoNzIpOyAvLz0+IDE4XG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gX2N1cnJ5MihmdW5jdGlvbiBzdWJ0cmFjdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3QsIHBhc3NpbmcgZWFjaCB2YWx1ZVxuICAgICAqIHRvIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24sIGFuZCB0ZXJtaW5hdGluZyB3aGVuIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAqIGBmYWxzZWAuIEV4Y2x1ZGVzIHRoZSBlbGVtZW50IHRoYXQgY2F1c2VkIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZmFpbC4gVGhlIHByZWRpY2F0ZVxuICAgICAqIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6ICoodmFsdWUpKi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheS5cbiAgICAgKiBAc2VlIFIuZHJvcExhc3RXaGlsZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc05vdE9uZSA9IHggPT4geCAhPT0gMTtcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlTGFzdFdoaWxlKGlzTm90T25lLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIHZhciB0YWtlTGFzdFdoaWxlID0gX2N1cnJ5MihmdW5jdGlvbiB0YWtlTGFzdFdoaWxlKGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpZHggPj0gMCAmJiBmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NsaWNlKGxpc3QsIGlkeCArIDEsIEluZmluaXR5KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKGEgLT4gKikgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBgeGAuIFRoZSByZXR1cm4gdmFsdWUgb2YgYGZuYCB3aWxsIGJlIHRocm93biBhd2F5LlxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4geyp9IGB4YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc2F5WCA9IHggPT4gY29uc29sZS5sb2coJ3ggaXMgJyArIHgpO1xuICAgICAqICAgICAgUi50YXAoc2F5WCwgMTAwKTsgLy89PiAxMDBcbiAgICAgKiAgICAgIC8vLT4gJ3ggaXMgMTAwJ1xuICAgICAqL1xuICAgIHZhciB0YXAgPSBfY3VycnkyKGZ1bmN0aW9uIHRhcChmbiwgeCkge1xuICAgICAgICBmbih4KTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhbiBpbnB1dCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIHRob3NlXG4gICAgICogZnVuY3Rpb24gY2FsbHMuXG4gICAgICpcbiAgICAgKiBgZm5gIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IFRoZSBjdXJyZW50IHZhbHVlIG9mIGBuYCwgd2hpY2ggYmVnaW5zIGF0IGAwYCBhbmQgaXNcbiAgICAgKiBncmFkdWFsbHkgaW5jcmVtZW50ZWQgdG8gYG4gLSAxYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4zXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChpIC0+IGEpIC0+IGkgLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUGFzc2VkIG9uZSBhcmd1bWVudCwgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYG5gLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGBuIC0gMWAuIEluY3JlbWVudHMgYWZ0ZXIgZWFjaCBmdW5jdGlvbiBjYWxsLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgdmFyIHRpbWVzID0gX2N1cnJ5MihmdW5jdGlvbiB0aW1lcyhmbiwgbikge1xuICAgICAgICB2YXIgbGVuID0gTnVtYmVyKG4pO1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgbGlzdFtpZHhdID0gZm4oaWR4KTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuXG4gICAgICogT25seSB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIHVzZWQuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4gICAgICogY29uc2lzdGVudCBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge1N0cmluZzogKn0gLT4gW1tTdHJpbmcsKl1dXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgZnJvbVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgICAgKiBAc2VlIFIuZnJvbVBhaXJzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50b1BhaXJzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBfY3VycnkxKGZ1bmN0aW9uIHRvUGFpcnMob2JqKSB7XG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKF9oYXMocHJvcCwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbXG4gICAgICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuXG4gICAgICogVGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFuZCBwcm90b3R5cGUgcHJvcGVydGllcyBhcmUgdXNlZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbiAgICAgKiBjb25zaXN0ZW50IGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmcm9tXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzIGZyb20gdGhlIG9iamVjdCdzIG93blxuICAgICAqICAgICAgICAgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAgICAgKiAgICAgIEYucHJvdG90eXBlLnkgPSAnWSc7XG4gICAgICogICAgICB2YXIgZiA9IG5ldyBGKCk7XG4gICAgICogICAgICBSLnRvUGFpcnNJbihmKTsgLy89PiBbWyd4JywnWCddLCBbJ3knLCdZJ11dXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IF9jdXJyeTEoZnVuY3Rpb24gdG9QYWlyc0luKG9iaikge1xuICAgICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbXG4gICAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyAoc3RyaXBzKSB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRyaW1tZWQgdmVyc2lvbiBvZiBgc3RyYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRyaW0oJyAgIHh5eiAgJyk7IC8vPT4gJ3h5eidcbiAgICAgKiAgICAgIFIubWFwKFIudHJpbSwgUi5zcGxpdCgnLCcsICd4LCB5LCB6JykpOyAvLz0+IFsneCcsICd5JywgJ3onXVxuICAgICAqL1xuICAgIHZhciB0cmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3MgPSAnXFx0XFxuXFx4MEJcXGZcXHIgXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICsgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArICdcXHUyMDI5XFx1RkVGRic7XG4gICAgICAgIHZhciB6ZXJvV2lkdGggPSAnXFx1MjAwQic7XG4gICAgICAgIHZhciBoYXNQcm90b1RyaW0gPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoIWhhc1Byb3RvVHJpbSB8fCAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVnaW5SeCA9IG5ldyBSZWdFeHAoJ15bJyArIHdzICsgJ11bJyArIHdzICsgJ10qJyk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZFJ4ID0gbmV3IFJlZ0V4cCgnWycgKyB3cyArICddWycgKyB3cyArICddKiQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYmVnaW5SeCwgJycpLnJlcGxhY2UoZW5kUngsICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogR2l2ZXMgYSBzaW5nbGUtd29yZCBzdHJpbmcgZGVzY3JpcHRpb24gb2YgdGhlIChuYXRpdmUpIHR5cGUgb2YgYSB2YWx1ZSwgcmV0dXJuaW5nIHN1Y2hcbiAgICAgKiBhbnN3ZXJzIGFzICdPYmplY3QnLCAnTnVtYmVyJywgJ0FycmF5Jywgb3IgJ051bGwnLiAgRG9lcyBub3QgYXR0ZW1wdCB0byBkaXN0aW5ndWlzaCB1c2VyXG4gICAgICogT2JqZWN0IHR5cGVzIGFueSBmdXJ0aGVyLCByZXBvcnRpbmcgdGhlbSBhbGwgYXMgJ09iamVjdCcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjguMFxuICAgICAqIEBjYXRlZ29yeSBUeXBlXG4gICAgICogQHNpZyAoKiAtPiB7Kn0pIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudHlwZSh7fSk7IC8vPT4gXCJPYmplY3RcIlxuICAgICAqICAgICAgUi50eXBlKDEpOyAvLz0+IFwiTnVtYmVyXCJcbiAgICAgKiAgICAgIFIudHlwZShmYWxzZSk7IC8vPT4gXCJCb29sZWFuXCJcbiAgICAgKiAgICAgIFIudHlwZSgncycpOyAvLz0+IFwiU3RyaW5nXCJcbiAgICAgKiAgICAgIFIudHlwZShudWxsKTsgLy89PiBcIk51bGxcIlxuICAgICAqICAgICAgUi50eXBlKFtdKTsgLy89PiBcIkFycmF5XCJcbiAgICAgKiAgICAgIFIudHlwZSgvW0Etel0vKTsgLy89PiBcIlJlZ0V4cFwiXG4gICAgICovXG4gICAgdmFyIHR5cGUgPSBfY3VycnkxKGZ1bmN0aW9uIHR5cGUodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG51bGwgPyAnTnVsbCcgOiB2YWwgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBgZm5gLCB3aGljaCB0YWtlcyBhIHNpbmdsZSBhcnJheSBhcmd1bWVudCwgYW5kIHJldHVybnNcbiAgICAgKiBhIGZ1bmN0aW9uIHdoaWNoOlxuICAgICAqXG4gICAgICogICAtIHRha2VzIGFueSBudW1iZXIgb2YgcG9zaXRpb25hbCBhcmd1bWVudHM7XG4gICAgICogICAtIHBhc3NlcyB0aGVzZSBhcmd1bWVudHMgdG8gYGZuYCBhcyBhbiBhcnJheTsgYW5kXG4gICAgICogICAtIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzLCBSLnVuYXBwbHkgZGVyaXZlcyBhIHZhcmlhZGljIGZ1bmN0aW9uIGZyb20gYSBmdW5jdGlvblxuICAgICAqIHdoaWNoIHRha2VzIGFuIGFycmF5LiBSLnVuYXBwbHkgaXMgdGhlIGludmVyc2Ugb2YgUi5hcHBseS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoWyouLi5dIC0+IGEpIC0+ICgqLi4uIC0+IGEpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIuYXBwbHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVuYXBwbHkoSlNPTi5zdHJpbmdpZnkpKDEsIDIsIDMpOyAvLz0+ICdbMSwyLDNdJ1xuICAgICAqL1xuICAgIHZhciB1bmFwcGx5ID0gX2N1cnJ5MShmdW5jdGlvbiB1bmFwcGx5KGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oX3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBleGFjdGx5IDFcbiAgICAgKiBwYXJhbWV0ZXIuIEFueSBleHRyYW5lb3VzIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgcGFzc2VkIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKiAtPiBiKSAtPiAoYSAtPiBiKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAgICAgKiAgICAgICAgIGFyaXR5IDEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAgICAgKiAgICAgIHRha2VzVHdvQXJncygxLCAyKTsgLy89PiBbMSwgMl1cbiAgICAgKlxuICAgICAqICAgICAgdmFyIHRha2VzT25lQXJnID0gUi51bmFyeSh0YWtlc1R3b0FyZ3MpO1xuICAgICAqICAgICAgdGFrZXNPbmVBcmcubGVuZ3RoOyAvLz0+IDFcbiAgICAgKiAgICAgIC8vIE9ubHkgMSBhcmd1bWVudCBpcyBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAgICAgKiAgICAgIHRha2VzT25lQXJnKDEsIDIpOyAvLz0+IFsxLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgdmFyIHVuYXJ5ID0gX2N1cnJ5MShmdW5jdGlvbiB1bmFyeShmbikge1xuICAgICAgICByZXR1cm4gbkFyeSgxLCBmbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gb2YgYXJpdHkgYG5gIGZyb20gYSAobWFudWFsbHkpIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIE51bWJlciAtPiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGFyaXR5IGZvciB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHVuY3VycnkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgUi5jdXJyeVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhZGRGb3VyID0gYSA9PiBiID0+IGMgPT4gZCA9PiBhICsgYiArIGMgKyBkO1xuICAgICAqXG4gICAgICogICAgICB2YXIgdW5jdXJyaWVkQWRkRm91ciA9IFIudW5jdXJyeU4oNCwgYWRkRm91cik7XG4gICAgICogICAgICB1bmN1cnJpZWRBZGRGb3VyKDEsIDIsIDMsIDQpOyAvLz0+IDEwXG4gICAgICovXG4gICAgdmFyIHVuY3VycnlOID0gX2N1cnJ5MihmdW5jdGlvbiB1bmN1cnJ5TihkZXB0aCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5TihkZXB0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXB0aCA9IDE7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBmbjtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIGVuZElkeDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50RGVwdGggPD0gZGVwdGggJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZW5kSWR4ID0gY3VycmVudERlcHRoID09PSBkZXB0aCA/IGFyZ3VtZW50cy5sZW5ndGggOiBpZHggKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSh0aGlzLCBfc2xpY2UoYXJndW1lbnRzLCBpZHgsIGVuZElkeCkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXB0aCArPSAxO1xuICAgICAgICAgICAgICAgIGlkeCA9IGVuZElkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBsaXN0IGZyb20gYSBzZWVkIHZhbHVlLiBBY2NlcHRzIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIGVpdGhlciBmYWxzZVxuICAgICAqIHRvIHN0b3AgaXRlcmF0aW9uIG9yIGFuIGFycmF5IG9mIGxlbmd0aCAyIGNvbnRhaW5pbmcgdGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgcmVzdWx0aW5nXG4gICAgICogbGlzdCBhbmQgdGhlIHNlZWQgdG8gYmUgdXNlZCBpbiB0aGUgbmV4dCBjYWxsIHRvIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICooc2VlZCkqLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFtiXSkgLT4gKiAtPiBbYl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHNlZWRgLCBhbmQgcmV0dXJuc1xuICAgICAqICAgICAgICBlaXRoZXIgZmFsc2UgdG8gcXVpdCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIHR3byB0byBwcm9jZWVkLiBUaGUgZWxlbWVudFxuICAgICAqICAgICAgICBhdCBpbmRleCAwIG9mIHRoaXMgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LCBhbmQgdGhlIGVsZW1lbnRcbiAgICAgKiAgICAgICAgYXQgaW5kZXggMSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbmV4dCBjYWxsIHRvIGBmbmAuXG4gICAgICogQHBhcmFtIHsqfSBzZWVkIFRoZSBzZWVkIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmluYWwgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZiA9IG4gPT4gbiA+IDUwID8gZmFsc2UgOiBbLW4sIG4gKyAxMF07XG4gICAgICogICAgICBSLnVuZm9sZChmLCAxMCk7IC8vPT4gWy0xMCwgLTIwLCAtMzAsIC00MCwgLTUwXVxuICAgICAqL1xuICAgIHZhciB1bmZvbGQgPSBfY3VycnkyKGZ1bmN0aW9uIHVuZm9sZChmbiwgc2VlZCkge1xuICAgICAgICB2YXIgcGFpciA9IGZuKHNlZWQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChwYWlyICYmIHBhaXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBwYWlyWzBdO1xuICAgICAgICAgICAgcGFpciA9IGZuKHBhaXJbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgbGlzdCwgYmFzZWRcbiAgICAgKiB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLiBQcmVmZXJzXG4gICAgICogdGhlIGZpcnN0IGl0ZW0gaWYgdHdvIGl0ZW1zIGNvbXBhcmUgZXF1YWwgYmFzZWQgb24gdGhlIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLCBhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHVuaXF1ZSBpdGVtcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc3RyRXEgPSBSLmVxQnkoU3RyaW5nKTtcbiAgICAgKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDIsIDFdKTsgLy89PiBbMSwgMl1cbiAgICAgKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFt7fSwge31dKTsgICAgICAgLy89PiBbe31dXG4gICAgICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbMSwgJzEnLCAxXSk7ICAgIC8vPT4gWzFdXG4gICAgICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbJzEnLCAxLCAxXSk7ICAgIC8vPT4gWycxJ11cbiAgICAgKi9cbiAgICB2YXIgdW5pcVdpdGggPSBfY3VycnkyKGZ1bmN0aW9uIHVuaXFXaXRoKHByZWQsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGl0ZW07XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2lkeF07XG4gICAgICAgICAgICBpZiAoIV9jb250YWluc1dpdGgocHJlZCwgaXRlbSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgdGhlIGZpbmFsIGFyZ3VtZW50IGJ5IHBhc3NpbmcgaXQgdG8gdGhlIGdpdmVuIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBJZiB0aGUgcHJlZGljYXRlIGlzIG5vdCBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgY2FsbGluZyB0aGUgYHdoZW5GYWxzZUZuYCBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50LiBJZiB0aGVcbiAgICAgKiBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkLCB0aGUgYXJndW1lbnQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2VlIFIuaWZFbHNlLCBSLndoZW5cbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd2hlbkZhbHNlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYHByZWRgIGV2YWx1YXRlc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgZmFsc3kgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICAgQW4gb2JqZWN0IHRvIHRlc3Qgd2l0aCB0aGUgYHByZWRgIGZ1bmN0aW9uIGFuZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5GYWxzZUZuYCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHJldHVybiB7Kn0gRWl0aGVyIGB4YCBvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGB4YCB0byBgd2hlbkZhbHNlRm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC8vIGNvZXJjZUFycmF5IDo6IChhfFthXSkgLT4gW2FdXG4gICAgICogICAgICB2YXIgY29lcmNlQXJyYXkgPSBSLnVubGVzcyhSLmlzQXJyYXlMaWtlLCBSLm9mKTtcbiAgICAgKiAgICAgIGNvZXJjZUFycmF5KFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICogICAgICBjb2VyY2VBcnJheSgxKTsgICAgICAgICAvLz0+IFsxXVxuICAgICAqL1xuICAgIHZhciB1bmxlc3MgPSBfY3VycnkzKGZ1bmN0aW9uIHVubGVzcyhwcmVkLCB3aGVuRmFsc2VGbiwgeCkge1xuICAgICAgICByZXR1cm4gcHJlZCh4KSA/IHggOiB3aGVuRmFsc2VGbih4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgY29weSBvZiB0aGUgYXJyYXkgd2l0aCB0aGUgZWxlbWVudCBhdCB0aGVcbiAgICAgKiBwcm92aWRlZCBpbmRleCByZXBsYWNlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAc2VlIFIuYWRqdXN0XG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IGEgLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggVGhlIGluZGV4IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIGV4aXN0IGF0IHRoZSBnaXZlbiBpbmRleCBvZiB0aGUgcmV0dXJuZWQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IGxpc3QgVGhlIHNvdXJjZSBhcnJheS1saWtlIG9iamVjdCB0byBiZSB1cGRhdGVkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgYGxpc3RgIHdpdGggdGhlIHZhbHVlIGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggYHhgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudXBkYXRlKDEsIDExLCBbMCwgMSwgMl0pOyAgICAgLy89PiBbMCwgMTEsIDJdXG4gICAgICogICAgICBSLnVwZGF0ZSgxKSgxMSkoWzAsIDEsIDJdKTsgICAgIC8vPT4gWzAsIDExLCAyXVxuICAgICAqL1xuICAgIHZhciB1cGRhdGUgPSBfY3VycnkzKGZ1bmN0aW9uIHVwZGF0ZShpZHgsIHgsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdChhbHdheXMoeCksIGlkeCwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzXG4gICAgICogZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IFt2XVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudmFsdWVzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgdmFyIHZhbHVlcyA9IF9jdXJyeTEoZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YWxzW2lkeF0gPSBvYmpbcHJvcHNbaWR4XV07XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFscztcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgcHJvcGVydGllcywgaW5jbHVkaW5nIHByb3RvdHlwZSBwcm9wZXJ0aWVzLFxuICAgICAqIG9mIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4gICAgICogY29uc2lzdGVudCBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge2s6IHZ9IC0+IFt2XVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICAgICAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAgICAgKiAgICAgIHZhciBmID0gbmV3IEYoKTtcbiAgICAgKiAgICAgIFIudmFsdWVzSW4oZik7IC8vPT4gWydYJywgJ1knXVxuICAgICAqL1xuICAgIHZhciB2YWx1ZXNJbiA9IF9jdXJyeTEoZnVuY3Rpb24gdmFsdWVzSW4ob2JqKSB7XG4gICAgICAgIHZhciBwcm9wLCB2cyA9IFtdO1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICB2c1t2cy5sZW5ndGhdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2cztcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBcInZpZXdcIiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmUsIGRldGVybWluZWQgYnkgdGhlIGdpdmVuIGxlbnMuXG4gICAgICogVGhlIGxlbnMncyBmb2N1cyBkZXRlcm1pbmVzIHdoaWNoIHBvcnRpb24gb2YgdGhlIGRhdGEgc3RydWN0dXJlIGlzIHZpc2libGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIExlbnMgcyBhIC0+IHMgLT4gYVxuICAgICAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICAgICAqXG4gICAgICogICAgICBSLnZpZXcoeExlbnMsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IDFcbiAgICAgKiAgICAgIFIudmlldyh4TGVucywge3g6IDQsIHk6IDJ9KTsgIC8vPT4gNFxuICAgICAqL1xuICAgIHZhciB2aWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgQ29uc3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeCxcbiAgICAgICAgICAgICAgICBtYXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gdmlldyhsZW5zLCB4KSB7XG4gICAgICAgICAgICByZXR1cm4gbGVucyhDb25zdCkoeCkudmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAgICogSWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0XG4gICAgICogb2YgY2FsbGluZyB0aGUgYHdoZW5UcnVlRm5gIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgYXJndW1lbnQuIElmIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgYXJndW1lbnQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2VlIFIuaWZFbHNlLCBSLnVubGVzc1xuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdoZW5UcnVlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmBcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9ICAgICAgICB4ICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5UcnVlRm5gIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcmV0dXJuIHsqfSBFaXRoZXIgYHhgIG9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYHhgIHRvIGB3aGVuVHJ1ZUZuYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyB0cnVuY2F0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogICAgICB2YXIgdHJ1bmNhdGUgPSBSLndoZW4oXG4gICAgICogICAgICAgIFIucHJvcFNhdGlzZmllcyhSLmd0KFIuX18sIDEwKSwgJ2xlbmd0aCcpLFxuICAgICAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICAgICAqICAgICAgKTtcbiAgICAgKiAgICAgIHRydW5jYXRlKCcxMjM0NScpOyAgICAgICAgIC8vPT4gJzEyMzQ1J1xuICAgICAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAgICAgKi9cbiAgICB2YXIgd2hlbiA9IF9jdXJyeTMoZnVuY3Rpb24gd2hlbihwcmVkLCB3aGVuVHJ1ZUZuLCB4KSB7XG4gICAgICAgIHJldHVybiBwcmVkKHgpID8gd2hlblRydWVGbih4KSA6IHg7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gICAgICogdGhlIHNwZWMuIEVhY2ggb2YgdGhlIHNwZWMncyBvd24gcHJvcGVydGllcyBtdXN0IGJlIGEgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIEVhY2ggcHJlZGljYXRlIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG9mXG4gICAgICogdGhlIHRlc3Qgb2JqZWN0LiBgd2hlcmVgIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUsXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogYHdoZXJlYCBpcyB3ZWxsIHN1aXRlZCB0byBkZWNsYXJhdGl2ZWx5IGV4cHJlc3NpbmcgY29uc3RyYWludHMgZm9yIG90aGVyXG4gICAgICogZnVuY3Rpb25zIHN1Y2ggYXMgYGZpbHRlcmAgYW5kIGBmaW5kYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcge1N0cmluZzogKCogLT4gQm9vbGVhbil9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gICAgICogICAgICB2YXIgcHJlZCA9IFIud2hlcmUoe1xuICAgICAqICAgICAgICBhOiBSLmVxdWFscygnZm9vJyksXG4gICAgICogICAgICAgIGI6IFIuY29tcGxlbWVudChSLmVxdWFscygnYmFyJykpLFxuICAgICAqICAgICAgICB4OiBSLmd0KF8sIDEwKSxcbiAgICAgKiAgICAgICAgeTogUi5sdChfLCAyMClcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDExLCB5OiAxOX0pOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIHByZWQoe2E6ICd4eHgnLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAnYmFyJywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTAsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDIwfSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBfY3VycnkyKGZ1bmN0aW9uIHdoZXJlKHNwZWMsIHRlc3RPYmopIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgICAgICBpZiAoX2hhcyhwcm9wLCBzcGVjKSAmJiAhc3BlY1twcm9wXSh0ZXN0T2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyYXAgYSBmdW5jdGlvbiBpbnNpZGUgYW5vdGhlciB0byBhbGxvdyB5b3UgdG8gbWFrZSBhZGp1c3RtZW50cyB0byB0aGUgcGFyYW1ldGVycywgb3IgZG9cbiAgICAgKiBvdGhlciBwcm9jZXNzaW5nIGVpdGhlciBiZWZvcmUgdGhlIGludGVybmFsIGZ1bmN0aW9uIGlzIGNhbGxlZCBvciB3aXRoIGl0cyByZXN1bHRzLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnIChhLi4uIC0+IGIpIC0+ICgoYS4uLiAtPiBiKSAtPiBhLi4uIC0+IGMpIC0+IChhLi4uIC0+IGMpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gbmFtZSA9PiAnSGVsbG8gJyArIG5hbWU7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBzaG91dGVkR3JlZXQgPSBSLndyYXAoZ3JlZXQsIChnciwgbmFtZSkgPT4gZ3IobmFtZSkudG9VcHBlckNhc2UoKSk7XG4gICAgICpcbiAgICAgKiAgICAgIHNob3V0ZWRHcmVldChcIkthdGh5XCIpOyAvLz0+IFwiSEVMTE8gS0FUSFlcIlxuICAgICAqXG4gICAgICogICAgICB2YXIgc2hvcnRlbmVkR3JlZXQgPSBSLndyYXAoZ3JlZXQsIGZ1bmN0aW9uKGdyLCBuYW1lKSB7XG4gICAgICogICAgICAgIHJldHVybiBncihuYW1lLnN1YnN0cmluZygwLCAzKSk7XG4gICAgICogICAgICB9KTtcbiAgICAgKiAgICAgIHNob3J0ZW5lZEdyZWV0KFwiUm9iZXJ0XCIpOyAvLz0+IFwiSGVsbG8gUm9iXCJcbiAgICAgKi9cbiAgICB2YXIgd3JhcCA9IF9jdXJyeTIoZnVuY3Rpb24gd3JhcChmbiwgd3JhcHBlcikge1xuICAgICAgICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgX2NvbmNhdChbZm5dLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgY3JlYXRpbmcgZWFjaCBwb3NzaWJsZVxuICAgICAqIHBhaXIgZnJvbSB0aGUgbGlzdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcyBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIGVhY2ggcG9zc2libGUgcGFpciBmcm9tXG4gICAgICogICAgICAgICBgYXNgIGFuZCBgYnNgIGludG8gcGFpcnMgKGBbYSwgYl1gKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnhwcm9kKFsxLCAyXSwgWydhJywgJ2InXSk7IC8vPT4gW1sxLCAnYSddLCBbMSwgJ2InXSwgWzIsICdhJ10sIFsyLCAnYiddXVxuICAgICAqL1xuICAgIC8vID0geHByb2RXaXRoKHByZXBlbmQpOyAodGFrZXMgYWJvdXQgMyB0aW1lcyBhcyBsb25nLi4uKVxuICAgIHZhciB4cHJvZCA9IF9jdXJyeTIoZnVuY3Rpb24geHByb2QoYSwgYikge1xuICAgICAgICAvLyA9IHhwcm9kV2l0aChwcmVwZW5kKTsgKHRha2VzIGFib3V0IDMgdGltZXMgYXMgbG9uZy4uLilcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBpbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgamxlbiA9IGIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChpZHggPCBpbGVuKSB7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgamxlbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgYVtpZHhdLFxuICAgICAgICAgICAgICAgICAgICBiW2pdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IHBhaXJpbmcgdXBcbiAgICAgKiBlcXVhbGx5LXBvc2l0aW9uZWQgaXRlbXMgZnJvbSBib3RoIGxpc3RzLiAgVGhlIHJldHVybmVkIGxpc3QgaXNcbiAgICAgKiB0cnVuY2F0ZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIGlucHV0IGxpc3RzLlxuICAgICAqIE5vdGU6IGB6aXBgIGlzIGVxdWl2YWxlbnQgdG8gYHppcFdpdGgoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gW2EsIGJdIH0pYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYl0gLT4gW1thLGJdXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBtYWRlIGJ5IHBhaXJpbmcgdXAgc2FtZS1pbmRleGVkIGVsZW1lbnRzIG9mIGBsaXN0MWAgYW5kIGBsaXN0MmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi56aXAoWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pOyAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBfY3VycnkyKGZ1bmN0aW9uIHppcChhLCBiKSB7XG4gICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHJ2W2lkeF0gPSBbXG4gICAgICAgICAgICAgICAgYVtpZHhdLFxuICAgICAgICAgICAgICAgIGJbaWR4XVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IG91dCBvZiBhIGxpc3Qgb2Yga2V5cyBhbmQgYSBsaXN0IG9mIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMy4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IFsqXSAtPiB7U3RyaW5nOiAqfVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IHRoYXQgd2lsbCBiZSBwcm9wZXJ0aWVzIG9uIHRoZSBvdXRwdXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgbGlzdCBvZiB2YWx1ZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IG1hZGUgYnkgcGFpcmluZyB1cCBzYW1lLWluZGV4ZWQgZWxlbWVudHMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnppcE9iaihbJ2EnLCAnYicsICdjJ10sIFsxLCAyLCAzXSk7IC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gICAgICovXG4gICAgdmFyIHppcE9iaiA9IF9jdXJyeTIoZnVuY3Rpb24gemlwT2JqKGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgaWR4ID0gMCwgbGVuID0ga2V5cy5sZW5ndGgsIG91dCA9IHt9O1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBvdXRba2V5c1tpZHhdXSA9IHZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG9cbiAgICAgKiBlYWNoIGVxdWFsbHktcG9zaXRpb25lZCBwYWlyIGluIHRoZSBsaXN0cy4gVGhlIHJldHVybmVkIGxpc3QgaXNcbiAgICAgKiB0cnVuY2F0ZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIGlucHV0IGxpc3RzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhLGIgLT4gYykgLT4gW2FdIC0+IFtiXSAtPiBbY11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21iaW5lIHRoZSB0d28gZWxlbWVudHMgaW50byBvbmUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgXG4gICAgICogICAgICAgICB1c2luZyBgZm5gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBmID0gKHgsIHkpID0+IHtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgUi56aXBXaXRoKGYsIFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTtcbiAgICAgKiAgICAgIC8vPT4gW2YoMSwgJ2EnKSwgZigyLCAnYicpLCBmKDMsICdjJyldXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBfY3VycnkzKGZ1bmN0aW9uIHppcFdpdGgoZm4sIGEsIGIpIHtcbiAgICAgICAgdmFyIHJ2ID0gW10sIGlkeCA9IDAsIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIHJ2W2lkeF0gPSBmbihhW2lkeF0sIGJbaWR4XSk7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgYGZhbHNlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn1cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5hbHdheXMsIFIuVFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuRigpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIEYgPSBhbHdheXMoZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICogLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7Kn1cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5hbHdheXMsIFIuRlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuVCgpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgVCA9IGFsd2F5cyh0cnVlKTtcblxuICAgIHZhciBfYXBlcnR1cmUgPSBmdW5jdGlvbiBfYXBlcnR1cmUobiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIGxpbWl0ID0gbGlzdC5sZW5ndGggLSAobiAtIDEpO1xuICAgICAgICB2YXIgYWNjID0gbmV3IEFycmF5KGxpbWl0ID49IDAgPyBsaW1pdCA6IDApO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGltaXQpIHtcbiAgICAgICAgICAgIGFjY1tpZHhdID0gX3NsaWNlKGxpc3QsIGlkeCwgaWR4ICsgbik7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGhhc01ldGhvZCwgdGhpcyBjaGVja3Mgd2hldGhlciBhIGZ1bmN0aW9uIGhhcyBhIFttZXRob2RuYW1lXVxuICAgICAqIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhbiBhcnJheSBpdCB3aWxsIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiBvdGhlcndpc2UgaXQgd2lsbFxuICAgICAqIGRlZmF1bHQgdG8gdGhlIHJhbWRhIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kbmFtZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFdoYXRldmVyIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1ldGhvZCBpcy5cbiAgICAgKi9cbiAgICB2YXIgX2NoZWNrRm9yTWV0aG9kID0gZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gX2lzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqW21ldGhvZG5hbWVdICE9PSAnZnVuY3Rpb24nID8gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9ialttZXRob2RuYW1lXS5hcHBseShvYmosIF9zbGljZShhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY29waWVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gcmVmRnJvbSBBcnJheSBjb250YWluaW5nIHRoZSBzb3VyY2UgcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlZlRvIEFycmF5IGNvbnRhaW5pbmcgdGhlIGNvcGllZCBzb3VyY2UgcmVmZXJlbmNlc1xuICAgICAqIEByZXR1cm4geyp9IFRoZSBjb3BpZWQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIF9jbG9uZSA9IGZ1bmN0aW9uIF9jbG9uZSh2YWx1ZSwgcmVmRnJvbSwgcmVmVG8pIHtcbiAgICAgICAgdmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KGNvcGllZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gcmVmRnJvbS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlZkZyb21baWR4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVmVG9baWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWZGcm9tW2lkeCArIDFdID0gdmFsdWU7XG4gICAgICAgICAgICByZWZUb1tpZHggKyAxXSA9IGNvcGllZFZhbHVlO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29waWVkVmFsdWVba2V5XSA9IF9jbG9uZSh2YWx1ZVtrZXldLCByZWZGcm9tLCByZWZUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29waWVkVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAodHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICAgIHJldHVybiBjb3B5KHt9KTtcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIGNvcHkoW10pO1xuICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKGNvbmNhdCkge1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXJpdHkoTWF0aC5tYXgoMCwgZm4ubGVuZ3RoIC0gYXJncy5sZW5ndGgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGNvbmNhdChhcmdzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyB3aXRoIGRpZmZlcmVudCBzdHJhdGVnaWVzIGJhc2VkIG9uIHRoZVxuICAgICAqIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uIChsYXN0IGFyZ3VtZW50KS4gSWYgaXQgaXMgYW4gYXJyYXksIGV4ZWN1dGVzIFtmbl0uXG4gICAgICogT3RoZXJ3aXNlLCBpZiBpdCBoYXMgYSAgZnVuY3Rpb24gd2l0aCBbbWV0aG9kbmFtZV0sIGl0IHdpbGwgZXhlY3V0ZSB0aGF0XG4gICAgICogZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lciwgdXNlcyB0cmFuc2R1Y2VyXG4gICAgICogW3hmXSB0byByZXR1cm4gYSBuZXcgdHJhbnNmb3JtZXIgKHRyYW5zZHVjZXIgY2FzZSkuIE90aGVyd2lzZSwgaXQgd2lsbFxuICAgICAqIGRlZmF1bHQgdG8gZXhlY3V0aW5nIFtmbl0uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIHRyYW5zZHVjZXIgdG8gaW5pdGlhbGl6ZSBpZiBvYmplY3QgaXMgdHJhbnNmb3JtZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBkZWZhdWx0IHJhbWRhIGltcGxlbWVudGF0aW9uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gICAgICovXG4gICAgdmFyIF9kaXNwYXRjaGFibGUgPSBmdW5jdGlvbiBfZGlzcGF0Y2hhYmxlKG1ldGhvZG5hbWUsIHhmLCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFfaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfc2xpY2UoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialttZXRob2RuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZG5hbWVdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2R1Y2VyID0geGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2R1Y2VyKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFZhbHVlcyBvZiBvdGhlciB0eXBlcyBhcmUgb25seSBlcXVhbCBpZiBpZGVudGljYWwuXG4gICAgdmFyIF9lcXVhbHMgPSBmdW5jdGlvbiBfZXF1YWxzKGEsIGIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAgIGlmIChpZGVudGljYWwoYSwgYikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlKGEpICE9PSB0eXBlKGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGEuZXF1YWxzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBiLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJiBhLmVxdWFscyhiKSAmJiB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYi5lcXVhbHMoYSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKGEpKSB7XG4gICAgICAgIGNhc2UgJ0FyZ3VtZW50cyc6XG4gICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBpZGVudGljYWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgICAgICBpZiAoIWlkZW50aWNhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgICAgICBpZiAoIShhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJiBhLnN0aWNreSA9PT0gYi5zdGlja3kgJiYgYS51bmljb2RlID09PSBiLnVuaWNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgICAgICBpZiAoIV9lcXVhbHMoX2FycmF5RnJvbUl0ZXJhdG9yKGEuZW50cmllcygpKSwgX2FycmF5RnJvbUl0ZXJhdG9yKGIuZW50cmllcygpKSwgc3RhY2tBLCBzdGFja0IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBWYWx1ZXMgb2Ygb3RoZXIgdHlwZXMgYXJlIG9ubHkgZXF1YWwgaWYgaWRlbnRpY2FsLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzQSA9IGtleXMoYSk7XG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja0JbaWR4XSA9PT0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgICBzdGFja0IucHVzaChiKTtcbiAgICAgICAgaWR4ID0ga2V5c0EubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcbiAgICAgICAgICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgICBzdGFja0IucG9wKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBgX21ha2VGbGF0YCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBvbmUtbGV2ZWwgb3IgZnVsbHkgcmVjdXJzaXZlIGZ1bmN0aW9uXG4gICAgICogYmFzZWQgb24gdGhlIGZsYWcgcGFzc2VkIGluLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX21ha2VGbGF0ID0gZnVuY3Rpb24gX21ha2VGbGF0KHJlY3Vyc2l2ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZmxhdHQobGlzdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCByZXN1bHQgPSBbXSwgaWR4ID0gMCwgaiwgaWxlbiA9IGxpc3QubGVuZ3RoLCBqbGVuO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UobGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlY3Vyc2l2ZSA/IGZsYXR0KGxpc3RbaWR4XSkgOiBsaXN0W2lkeF07XG4gICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICBqbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgbGlzdFtpZHhdKTtcbiAgICAgICAgICAgICAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pdGVyYWJsZVJlZHVjZSh4ZiwgYWNjLCBpdGVyKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIHN0ZXAudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGVwID0gaXRlci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9tZXRob2RSZWR1Y2UoeGYsIGFjYywgb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShvYmoucmVkdWNlKGJpbmQoeGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHhmKSwgYWNjKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bUl0ZXJhdG9yID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBfcmVkdWNlKGZuLCBhY2MsIGxpc3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBmbiA9IF94d3JhcChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UobGlzdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2FycmF5UmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0LnJlZHVjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbWV0aG9kUmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpc3Rbc3ltSXRlcmF0b3JdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3Rbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0Lm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlOiBsaXN0IG11c3QgYmUgYXJyYXkgb3IgaXRlcmFibGUnKTtcbiAgICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhBbGwoZiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMuZiA9IGY7XG4gICAgICAgICAgICB0aGlzLmFsbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgWEFsbC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGFsbChmLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYQWxsKGYsIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94YW55ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYQW55KGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICAgICAgdGhpcy5hbnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbnkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhbnkoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEFueShmLCB4Zik7XG4gICAgICAgIH0pO1xuICAgIH0oKTtcblxuICAgIHZhciBfeGFwZXJ0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYQXBlcnR1cmUobiwgeGYpIHtcbiAgICAgICAgICAgIHRoaXMueGYgPSB4ZjtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIH1cbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gICAgICAgIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZShpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuZ2V0Q29weSgpKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5hY2NbdGhpcy5wb3NdID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgWEFwZXJ0dXJlLnByb3RvdHlwZS5nZXRDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb25jYXQoX3NsaWNlKHRoaXMuYWNjLCB0aGlzLnBvcyksIF9zbGljZSh0aGlzLmFjYywgMCwgdGhpcy5wb3MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhcGVydHVyZShuLCB4Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYQXBlcnR1cmUobiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRHJvcChuLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5uID0gbjtcbiAgICAgICAgfVxuICAgICAgICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gICAgICAgIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gICAgICAgIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubiAtPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wKG4sIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEcm9wKG4sIHhmKTtcbiAgICAgICAgfSk7XG4gICAgfSgpO1xuXG4gICAgdmFyIF94ZHJvcFdoaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYRHJvcFdoaWxlKGYsIHhmKSB7XG4gICAgICAgICAgICB0aGlzLnhmID0geGY7XG4gICAgICAgICAgICB0aGlzLmYgPSBmO1xuICAgICAgICB9XG4gICAgICAgIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYRHJvcFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gICAgICAgIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmYpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFdoaWxlKGYsIHhmKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhEcm9wV2hpbGUoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3hncm91cEJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBYR3JvdXBCeShmLCB4Zikge1xuICAgICAgICAgICAgdGhpcy54ZiA9IHhmO1xuICAgICAgICAgICAgdGhpcy5mID0gZjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgWEdyb3VwQnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICAgICAgICBYR3JvdXBCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiB0aGlzLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGlmIChfaGFzKGtleSwgdGhpcy5pbnB1dHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlucHV0c1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBYR3JvdXBCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZihpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0c1trZXldID0gdGhpcy5pbnB1dHNba2V5XSB8fCBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5pbnB1dHNba2V5XVsxXSA9IGFwcGVuZChpbnB1dCwgdGhpcy5pbnB1dHNba2V5XVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGdyb3VwQnkoZiwgeGYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWEdyb3VwQnkoZiwgeGYpO1xuICAgICAgICB9KTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIGZyb20gYW4gZXhpc3Rpbmcgb25lIGJ5IGFkZGluZyB0d28gbmV3IHBhcmFtZXRlcnNcbiAgICAgKiB0byBpdHMgY2FsbGJhY2sgZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4LCBhbmQgdGhlIGVudGlyZSBsaXN0LlxuICAgICAqXG4gICAgICogVGhpcyB3b3VsZCB0dXJuLCBmb3IgaW5zdGFuY2UsIFJhbWRhJ3Mgc2ltcGxlIGBtYXBgIGZ1bmN0aW9uIGludG8gb25lIHRoYXQgbW9yZSBjbG9zZWx5XG4gICAgICogcmVzZW1ibGVzIGBBcnJheS5wcm90b3R5cGUubWFwYC4gIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGZvciBmdW5jdGlvbnMgaW4gd2hpY2hcbiAgICAgKiB0aGUgaXRlcmF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGFuZCB3aGVyZSB0aGUgbGlzdCBpcyB0aGUgbGFzdFxuICAgICAqIHBhcmFtZXRlci4gIChUaGlzIGxhdHRlciBtaWdodCBiZSB1bmltcG9ydGFudCBpZiB0aGUgbGlzdCBwYXJhbWV0ZXIgaXMgbm90IHVzZWQuKVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnICgoYSAuLi4gLT4gYikgLi4uIC0+IFthXSAtPiAqKSAtPiAoYSAuLi4sIEludCwgW2FdIC0+IGIpIC4uLiAtPiBbYV0gLT4gKilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgcGFzcyBpbmRleCBvciBsaXN0IHRvIGl0cyBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBbiBhbHRlcmVkIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIChpdGVtLCBpbmRleCwgbGlzdCkgdG8gaXRzIGNhbGxiYWNrXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hcEluZGV4ZWQgPSBSLmFkZEluZGV4KFIubWFwKTtcbiAgICAgKiAgICAgIG1hcEluZGV4ZWQoKHZhbCwgaWR4KSA9PiBpZHggKyAnLScgKyB2YWwsIFsnZicsICdvJywgJ28nLCAnYicsICdhJywgJ3InXSk7XG4gICAgICogICAgICAvLz0+IFsnMC1mJywgJzEtbycsICcyLW8nLCAnMy1iJywgJzQtYScsICc1LXInXVxuICAgICAqL1xuICAgIHZhciBhZGRJbmRleCA9IF9jdXJyeTEoZnVuY3Rpb24gYWRkSW5kZXgoZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgdmFyIG9yaWdGbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzWzBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnRm4uYXBwbHkodGhpcywgX2NvbmNhdChhcmd1bWVudHMsIFtcbiAgICAgICAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICAgICAgICBsaXN0XG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLCBgZmFsc2VgIGlmIHRoZXJlIGFyZSBhbnlcbiAgICAgKiB0aGF0IGRvbid0LlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGFsbGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCBieSBldmVyeSBlbGVtZW50LCBgZmFsc2VgXG4gICAgICogICAgICAgICBvdGhlcndpc2UuXG4gICAgICogQHNlZSBSLmFueSwgUi5ub25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGxlc3NUaGFuMiA9IFIuZmxpcChSLmx0KSgyKTtcbiAgICAgKiAgICAgIHZhciBsZXNzVGhhbjMgPSBSLmZsaXAoUi5sdCkoMyk7XG4gICAgICogICAgICBSLmFsbChsZXNzVGhhbjIpKFsxLCAyXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuYWxsKGxlc3NUaGFuMykoWzEsIDJdKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGFsbCA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnYWxsJywgX3hhbGwsIGZ1bmN0aW9uIGFsbChmbiwgbGlzdCkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgb2YgZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQgYnkgYXQgbGVhc3Qgb25lIGVsZW1lbnQsIGBmYWxzZWBcbiAgICAgKiAgICAgICAgIG90aGVyd2lzZS5cbiAgICAgKiBAc2VlIFIuYWxsLCBSLm5vbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbGVzc1RoYW4wID0gUi5mbGlwKFIubHQpKDApO1xuICAgICAqICAgICAgdmFyIGxlc3NUaGFuMiA9IFIuZmxpcChSLmx0KSgyKTtcbiAgICAgKiAgICAgIFIuYW55KGxlc3NUaGFuMCkoWzEsIDJdKTsgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5hbnkobGVzc1RoYW4yKShbMSwgMl0pOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgYW55ID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdhbnknLCBfeGFueSwgZnVuY3Rpb24gYW55KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0LCBjb21wb3NlZCBvZiBuLXR1cGxlcyBvZiBjb25zZWN1dGl2ZSBlbGVtZW50c1xuICAgICAqIElmIGBuYCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgbGlzdCwgYW4gZW1wdHkgbGlzdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhcGVydHVyZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGVzIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc3BsaXQgaW50byBgbmAtdHVwbGVzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmFwZXJ0dXJlKDIsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW1sxLCAyXSwgWzIsIDNdLCBbMywgNF0sIFs0LCA1XV1cbiAgICAgKiAgICAgIFIuYXBlcnR1cmUoMywgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbWzEsIDIsIDNdLCBbMiwgMywgNF0sIFszLCA0LCA1XV1cbiAgICAgKiAgICAgIFIuYXBlcnR1cmUoNywgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbXVxuICAgICAqL1xuICAgIHZhciBhcGVydHVyZSA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnYXBlcnR1cmUnLCBfeGFwZXJ0dXJlLCBfYXBlcnR1cmUpKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgZXhhY3RseSAyXG4gICAgICogcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqIC0+IGMpIC0+IChhLCBiIC0+IGMpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIGBmbmAuIFRoZSBuZXcgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBiZSBvZlxuICAgICAqICAgICAgICAgYXJpdHkgMi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZXNUaHJlZUFyZ3MgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICAgICAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdGFrZXNUaHJlZUFyZ3MubGVuZ3RoOyAvLz0+IDNcbiAgICAgKiAgICAgIHRha2VzVGhyZWVBcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogICAgICB2YXIgdGFrZXNUd29BcmdzID0gUi5iaW5hcnkodGFrZXNUaHJlZUFyZ3MpO1xuICAgICAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gICAgICogICAgICAvLyBPbmx5IDIgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAgICAgKiAgICAgIHRha2VzVHdvQXJncygxLCAyLCAzKTsgLy89PiBbMSwgMiwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIHZhciBiaW5hcnkgPSBfY3VycnkxKGZ1bmN0aW9uIGJpbmFyeShmbikge1xuICAgICAgICByZXR1cm4gbkFyeSgyLCBmbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSB2YWx1ZSB3aGljaCBtYXkgY29udGFpbiAobmVzdGVkKSBgQXJyYXlgcyBhbmQgYE9iamVjdGBzLCBgTnVtYmVyYHMsXG4gICAgICogYFN0cmluZ2BzLCBgQm9vbGVhbmBzIGFuZCBgRGF0ZWBzLiBgRnVuY3Rpb25gcyBhcmUgbm90IGNvcGllZCwgYnV0IGFzc2lnbmVkIGJ5IHRoZWlyXG4gICAgICogcmVmZXJlbmNlLiBEaXNwYXRjaGVzIHRvIGEgYGNsb25lYCBtZXRob2QgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgeyp9IC0+IHsqfVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG9iamVjdCBvciBhcnJheSB0byBjbG9uZVxuICAgICAqIEByZXR1cm4geyp9IEEgbmV3IG9iamVjdCBvciBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgb2JqZWN0cyA9IFt7fSwge30sIHt9XTtcbiAgICAgKiAgICAgIHZhciBvYmplY3RzQ2xvbmUgPSBSLmNsb25lKG9iamVjdHMpO1xuICAgICAqICAgICAgb2JqZWN0c1swXSA9PT0gb2JqZWN0c0Nsb25lWzBdOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGNsb25lID0gX2N1cnJ5MShmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuY2xvbmUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5jbG9uZSgpIDogX2Nsb25lKHZhbHVlLCBbXSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBhIHNpbmdsZSBrZXk6dmFsdWUgcGFpci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgU3RyaW5nIC0+IGEgLT4ge1N0cmluZzphfVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAc2VlIFIucGFpciwgUi5vYmpPZlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWF0Y2hQaHJhc2VzID0gUi5jb21wb3NlKFxuICAgICAqICAgICAgICBSLmNyZWF0ZU1hcEVudHJ5KCdtdXN0JyksXG4gICAgICogICAgICAgIFIubWFwKFIuY3JlYXRlTWFwRW50cnkoJ21hdGNoX3BocmFzZScpKVxuICAgICAqICAgICAgKTtcbiAgICAgKiAgICAgIG1hdGNoUGhyYXNlcyhbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IHttdXN0OiBbe21hdGNoX3BocmFzZTogJ2Zvbyd9LCB7bWF0Y2hfcGhyYXNlOiAnYmFyJ30sIHttYXRjaF9waHJhc2U6ICdiYXonfV19XG4gICAgICovXG4gICAgdmFyIGNyZWF0ZU1hcEVudHJ5ID0gb2JqT2Y7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY3VycmllZCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gVGhlIGN1cnJpZWRcbiAgICAgKiBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLiBGaXJzdCwgaXRzIGFyZ3VtZW50cyBuZWVkbid0XG4gICAgICogYmUgcHJvdmlkZWQgb25lIGF0IGEgdGltZS4gSWYgYGZgIGlzIGEgdGVybmFyeSBmdW5jdGlvbiBhbmQgYGdgIGlzXG4gICAgICogYFIuY3VycnkoZilgLCB0aGUgZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICAgICAqXG4gICAgICogICAtIGBnKDEpKDIpKDMpYFxuICAgICAqICAgLSBgZygxKSgyLCAzKWBcbiAgICAgKiAgIC0gYGcoMSwgMikoMylgXG4gICAgICogICAtIGBnKDEsIDIsIDMpYFxuICAgICAqXG4gICAgICogU2Vjb25kbHksIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIGBSLl9fYCBtYXkgYmUgdXNlZCB0byBzcGVjaWZ5XG4gICAgICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAgICAgKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgYFIuX19gLFxuICAgICAqIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gICAgICpcbiAgICAgKiAgIC0gYGcoMSwgMiwgMylgXG4gICAgICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICAgICAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAgICAgKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gICAgICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICAgICAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAgICAgKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCogLT4gYSkgLT4gKCogLT4gYSlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgUi5jdXJyeU5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWRkRm91ck51bWJlcnMgPSAoYSwgYiwgYywgZCkgPT4gYSArIGIgKyBjICsgZDtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnkoYWRkRm91ck51bWJlcnMpO1xuICAgICAqICAgICAgdmFyIGYgPSBjdXJyaWVkQWRkRm91ck51bWJlcnMoMSwgMik7XG4gICAgICogICAgICB2YXIgZyA9IGYoMyk7XG4gICAgICogICAgICBnKDQpOyAvLz0+IDEwXG4gICAgICovXG4gICAgdmFyIGN1cnJ5ID0gX2N1cnJ5MShmdW5jdGlvbiBjdXJyeShmbikge1xuICAgICAgICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZm4pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgcGFzc2luZyBlYWNoIHZhbHVlXG4gICAgICogdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgc2tpcHBpbmcgZWxlbWVudHMgd2hpbGUgdGhlIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zXG4gICAgICogYHRydWVgLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6ICoodmFsdWUpKi5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wV2hpbGVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuOS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICAgICAqIEBzZWUgUi50YWtlV2hpbGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbHRlVHdvID0geCA9PiB4IDw9IDI7XG4gICAgICpcbiAgICAgKiAgICAgIFIuZHJvcFdoaWxlKGx0ZVR3bywgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMywgNCwgMywgMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgZHJvcFdoaWxlID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdkcm9wV2hpbGUnLCBfeGRyb3BXaGlsZSwgZnVuY3Rpb24gZHJvcFdoaWxlKHByZWQsIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuICYmIHByZWQobGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zbGljZShsaXN0LCBpZHgpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIGVxdWl2YWxlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIERpc3BhdGNoZXMgdG8gYW4gYGVxdWFsc2AgbWV0aG9kIGlmIHByZXNlbnQuIEhhbmRsZXMgY3ljbGljYWwgZGF0YVxuICAgICAqIHN0cnVjdHVyZXMuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZXF1YWxzYCBtZXRob2Qgb2YgYm90aCBhcmd1bWVudHMsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE1LjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIGEgLT4gYiAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHsqfSBhXG4gICAgICogQHBhcmFtIHsqfSBiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmVxdWFscygxLCAxKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmVxdWFscygxLCAnMScpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmVxdWFscyhbMSwgMiwgM10sIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYSA9IHt9OyBhLnYgPSBhO1xuICAgICAqICAgICAgdmFyIGIgPSB7fTsgYi52ID0gYjtcbiAgICAgKiAgICAgIFIuZXF1YWxzKGEsIGIpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgZXF1YWxzID0gX2N1cnJ5MihmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gX2VxdWFscyhhLCBiLCBbXSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSB0aG9zZSBpdGVtcyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgICAqIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGBSLmZpbHRlcmAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcywgdW5saWtlIHRoZSBuYXRpdmVcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIjRGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaWx0ZXJgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBSLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICAgICAqXG4gICAgICogICAgICBSLmZpbHRlcihpc0V2ZW4sIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDRdXG4gICAgICovXG4gICAgdmFyIGZpbHRlciA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnZmlsdGVyJywgX3hmaWx0ZXIsIF9maWx0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvciBgdW5kZWZpbmVkYCBpZiBub1xuICAgICAqIGVsZW1lbnQgbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaW5kYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gYSB8IHVuZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gICAgICogICAgICAgIGRlc2lyZWQgb25lLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGVsZW1lbnQgZm91bmQsIG9yIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4cyA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAgICAgKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDIpKSh4cyk7IC8vPT4ge2E6IDJ9XG4gICAgICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHZhciBmaW5kID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kJywgX3hmaW5kLCBmdW5jdGlvbiBmaW5kKGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvciBgLTFgXG4gICAgICogaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRJbmRleGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gICAgICogZGVzaXJlZCBvbmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhzID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICAgICAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IDFcbiAgICAgKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBmaW5kSW5kZXggPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2ZpbmRJbmRleCcsIF94ZmluZEluZGV4LCBmdW5jdGlvbiBmaW5kSW5kZXgoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yIGB1bmRlZmluZWRgIGlmIG5vXG4gICAgICogZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRMYXN0YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMVxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gYSB8IHVuZGVmaW5lZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gICAgICogZGVzaXJlZCBvbmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHhzID0gW3thOiAxLCBiOiAwfSwge2E6MSwgYjogMX1dO1xuICAgICAqICAgICAgUi5maW5kTGFzdChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4ge2E6IDEsIGI6IDF9XG4gICAgICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2ZpbmRMYXN0JywgX3hmaW5kTGFzdCwgZnVuY3Rpb24gZmluZExhc3QoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICAgICAqIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRMYXN0SW5kZXhgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4xXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICAgICAqIGRlc2lyZWQgb25lLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGZvdW5kLCBvciBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4cyA9IFt7YTogMSwgYjogMH0sIHthOjEsIGI6IDF9XTtcbiAgICAgKiAgICAgIFIuZmluZExhc3RJbmRleChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4gMVxuICAgICAqICAgICAgUi5maW5kTGFzdEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdEluZGV4ID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kTGFzdEluZGV4JywgX3hmaW5kTGFzdEluZGV4LCBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCBieSBwdWxsaW5nIGV2ZXJ5IGl0ZW0gb3V0IG9mIGl0IChhbmQgYWxsIGl0cyBzdWItYXJyYXlzKSBhbmQgcHV0dGluZ1xuICAgICAqIHRoZW0gaW4gYSBuZXcgYXJyYXksIGRlcHRoLWZpcnN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IFtiXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmxhdHRlbmVkIGxpc3QuXG4gICAgICogQHNlZSBSLnVubmVzdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZmxhdHRlbihbMSwgMiwgWzMsIDRdLCA1LCBbNiwgWzcsIDgsIFs5LCBbMTAsIDExXSwgMTJdXV1dKTtcbiAgICAgKiAgICAgIC8vPT4gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTJdXG4gICAgICovXG4gICAgdmFyIGZsYXR0ZW4gPSBfY3VycnkxKF9tYWtlRmxhdCh0cnVlKSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIG11Y2ggbGlrZSB0aGUgc3VwcGxpZWQgb25lLCBleGNlcHQgdGhhdCB0aGUgZmlyc3QgdHdvIGFyZ3VtZW50cydcbiAgICAgKiBvcmRlciBpcyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoYSAtPiBiIC0+IGMgLT4gLi4uIC0+IHopIC0+IChiIC0+IGEgLT4gYyAtPiAuLi4gLT4geilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdpdGggaXRzIGZpcnN0IHR3byBwYXJhbWV0ZXJzIHJldmVyc2VkLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgaW52b2tpbmcgYGZuYCB3aXRoIGl0cyBmaXJzdCB0d28gcGFyYW1ldGVycycgb3JkZXIgcmV2ZXJzZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1lcmdlVGhyZWUgPSAoYSwgYiwgYykgPT4gW10uY29uY2F0KGEsIGIsIGMpO1xuICAgICAqXG4gICAgICogICAgICBtZXJnZVRocmVlKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogICAgICBSLmZsaXAobWVyZ2VUaHJlZSkoMSwgMiwgMyk7IC8vPT4gWzIsIDEsIDNdXG4gICAgICovXG4gICAgdmFyIGZsaXAgPSBfY3VycnkxKGZ1bmN0aW9uIGZsaXAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IF9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJnc1swXSA9IGI7XG4gICAgICAgICAgICBhcmdzWzFdID0gYTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgYW4gaW5wdXQgYGxpc3RgLCBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gYGZuYCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZVxuICAgICAqIGxpc3QuXG4gICAgICpcbiAgICAgKiBgZm5gIHJlY2VpdmVzIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICAgICAqXG4gICAgICogTm90ZTogYFIuZm9yRWFjaGAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlIGFycmF5cyksIHVubGlrZVxuICAgICAqIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHMgb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2gjRGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFsc28gbm90ZSB0aGF0LCB1bmxpa2UgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCwgUmFtZGEncyBgZm9yRWFjaGAgcmV0dXJucyB0aGUgb3JpZ2luYWxcbiAgICAgKiBhcnJheS4gSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgZWFjaGAuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZm9yRWFjaGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMVxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiAqKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb3JpZ2luYWwgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcHJpbnRYUGx1c0ZpdmUgPSB4ID0+IGNvbnNvbGUubG9nKHggKyA1KTtcbiAgICAgKiAgICAgIFIuZm9yRWFjaChwcmludFhQbHVzRml2ZSwgWzEsIDIsIDNdKTsgLy89PiBbMSwgMiwgM11cbiAgICAgKiAgICAgIC8vLT4gNlxuICAgICAqICAgICAgLy8tPiA3XG4gICAgICogICAgICAvLy0+IDhcbiAgICAgKi9cbiAgICB2YXIgZm9yRWFjaCA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdmb3JFYWNoJywgZnVuY3Rpb24gZm9yRWFjaChmbiwgbGlzdCkge1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICBmbihsaXN0W2lkeF0pO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZnVuY3Rpb24gbmFtZXMgb2Ygb2JqZWN0J3Mgb3duIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7Kn0gLT4gW1N0cmluZ11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3RzIHdpdGggZnVuY3Rpb25zIGluIGl0XG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgdGhhdCBtYXAgdG8gZnVuY3Rpb25zLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmZ1bmN0aW9ucyhSKTsgLy8gcmV0dXJucyBsaXN0IG9mIHJhbWRhJ3Mgb3duIGZ1bmN0aW9uIG5hbWVzXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IGZ1bmN0aW9uKCl7fTsgdGhpcy55ID0gMTsgfVxuICAgICAqICAgICAgRi5wcm90b3R5cGUueiA9IGZ1bmN0aW9uKCkge307XG4gICAgICogICAgICBGLnByb3RvdHlwZS5hID0gMTAwO1xuICAgICAqICAgICAgUi5mdW5jdGlvbnMobmV3IEYoKSk7IC8vPT4gW1wieFwiXVxuICAgICAqL1xuICAgIHZhciBmdW5jdGlvbnMgPSBfY3VycnkxKF9mdW5jdGlvbnNXaXRoKGtleXMpKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZ1bmN0aW9uIG5hbWVzIG9mIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIGZ1bmN0aW9uc1xuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7Kn0gLT4gW1N0cmluZ11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3RzIHdpdGggZnVuY3Rpb25zIGluIGl0XG4gICAgICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZVxuICAgICAqICAgICAgICAgcHJvcGVydGllcyB0aGF0IG1hcCB0byBmdW5jdGlvbnMuXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMTguMFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZnVuY3Rpb25zSW4oUik7IC8vIHJldHVybnMgbGlzdCBvZiByYW1kYSdzIG93biBhbmQgcHJvdG90eXBlIGZ1bmN0aW9uIG5hbWVzXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IGZ1bmN0aW9uKCl7fTsgdGhpcy55ID0gMTsgfVxuICAgICAqICAgICAgRi5wcm90b3R5cGUueiA9IGZ1bmN0aW9uKCkge307XG4gICAgICogICAgICBGLnByb3RvdHlwZS5hID0gMTAwO1xuICAgICAqICAgICAgUi5mdW5jdGlvbnNJbihuZXcgRigpKTsgLy89PiBbXCJ4XCIsIFwielwiXVxuICAgICAqL1xuICAgIHZhciBmdW5jdGlvbnNJbiA9IF9jdXJyeTEoX2Z1bmN0aW9uc1dpdGgoa2V5c0luKSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBsaXN0IGludG8gc3ViLWxpc3RzIHN0b3JlZCBpbiBhbiBvYmplY3QsIGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIFN0cmluZy1yZXR1cm5pbmcgZnVuY3Rpb25cbiAgICAgKiBvbiBlYWNoIGVsZW1lbnQsIGFuZCBncm91cGluZyB0aGUgcmVzdWx0cyBhY2NvcmRpbmcgdG8gdmFsdWVzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYGdyb3VwQnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHtTdHJpbmc6IFthXX1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiA6OiBhIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBmbmAgZm9yIGtleXMsIG1hcHBlZCB0byBhcnJheXMgb2YgZWxlbWVudHNcbiAgICAgKiAgICAgICAgIHRoYXQgcHJvZHVjZWQgdGhhdCBrZXkgd2hlbiBwYXNzZWQgdG8gYGZuYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYnlHcmFkZSA9IFIuZ3JvdXBCeShmdW5jdGlvbihzdHVkZW50KSB7XG4gICAgICogICAgICAgIHZhciBzY29yZSA9IHN0dWRlbnQuc2NvcmU7XG4gICAgICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAgICAgKiAgICAgICAgICAgICAgIHNjb3JlIDwgNzAgPyAnRCcgOlxuICAgICAqICAgICAgICAgICAgICAgc2NvcmUgPCA4MCA/ICdDJyA6XG4gICAgICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICAgICAqICAgICAgfSk7XG4gICAgICogICAgICB2YXIgc3R1ZGVudHMgPSBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0VkZHknLCBzY29yZTogNTh9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSmFjaycsIHNjb3JlOiA2OX1dO1xuICAgICAqICAgICAgYnlHcmFkZShzdHVkZW50cyk7XG4gICAgICogICAgICAvLyB7XG4gICAgICogICAgICAvLyAgICdBJzogW3tuYW1lOiAnRGlhbm5lJywgc2NvcmU6IDk5fV0sXG4gICAgICogICAgICAvLyAgICdCJzogW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH1dXG4gICAgICogICAgICAvLyAgIC8vIC4uLixcbiAgICAgKiAgICAgIC8vICAgJ0YnOiBbe25hbWU6ICdFZGR5Jywgc2NvcmU6IDU4fV1cbiAgICAgKiAgICAgIC8vIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnZ3JvdXBCeScsIF94Z3JvdXBCeSwgZnVuY3Rpb24gZ3JvdXBCeShmbiwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBlbHQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBmbihlbHQpO1xuICAgICAgICAgICAgYWNjW2tleV0gPSBhcHBlbmQoZWx0LCBhY2Nba2V5XSB8fCAoYWNjW2tleV0gPSBbXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30sIGxpc3QpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLiBJbiBzb21lIGxpYnJhcmllc1xuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2VlIFIudGFpbCwgUi5pbml0LCBSLmxhc3RcbiAgICAgKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmhlYWQoWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gJ2ZpJ1xuICAgICAqICAgICAgUi5oZWFkKFtdKTsgLy89PiB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqICAgICAgUi5oZWFkKCdhYmMnKTsgLy89PiAnYSdcbiAgICAgKiAgICAgIFIuaGVhZCgnJyk7IC8vPT4gJydcbiAgICAgKi9cbiAgICB2YXIgaGVhZCA9IG50aCgwKTtcblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIHR3byBsaXN0cyBpbnRvIGEgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIGNvbXBvc2VkIG9mIHRob3NlXG4gICAgICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuICBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0XG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgKGEsYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICAgKiAgICAgICAgdGhlIHR3byBzdXBwbGllZCBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdDEgT25lIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIEEgc2Vjb25kIGxpc3Qgb2YgaXRlbXMgdG8gY29tcGFyZVxuICAgICAqIEBzZWUgUi5pbnRlcnNlY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgbGlzdCBjb250YWluaW5nIHRob3NlIGVsZW1lbnRzIGNvbW1vbiB0byBib3RoIGxpc3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBidWZmYWxvU3ByaW5nZmllbGQgPSBbXG4gICAgICogICAgICAgIHtpZDogODI0LCBuYW1lOiAnUmljaGllIEZ1cmF5J30sXG4gICAgICogICAgICAgIHtpZDogOTU2LCBuYW1lOiAnRGV3ZXkgTWFydGluJ30sXG4gICAgICogICAgICAgIHtpZDogMzEzLCBuYW1lOiAnQnJ1Y2UgUGFsbWVyJ30sXG4gICAgICogICAgICAgIHtpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSxcbiAgICAgKiAgICAgICAge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31cbiAgICAgKiAgICAgIF07XG4gICAgICogICAgICB2YXIgY3NueSA9IFtcbiAgICAgKiAgICAgICAge2lkOiAyMDQsIG5hbWU6ICdEYXZpZCBDcm9zYnknfSxcbiAgICAgKiAgICAgICAge2lkOiA0NTYsIG5hbWU6ICdTdGVwaGVuIFN0aWxscyd9LFxuICAgICAqICAgICAgICB7aWQ6IDUzOSwgbmFtZTogJ0dyYWhhbSBOYXNoJ30sXG4gICAgICogICAgICAgIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XG4gICAgICogICAgICBdO1xuICAgICAqXG4gICAgICogICAgICBSLmludGVyc2VjdGlvbldpdGgoUi5lcUJ5KFIucHJvcCgnaWQnKSksIGJ1ZmZhbG9TcHJpbmdmaWVsZCwgY3NueSk7XG4gICAgICogICAgICAvLz0+IFt7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gX2N1cnJ5MyhmdW5jdGlvbiBpbnRlcnNlY3Rpb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCBpZHggPSAwO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdDEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoX2NvbnRhaW5zV2l0aChwcmVkLCBsaXN0MVtpZHhdLCBsaXN0MikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGxpc3QxW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pcVdpdGgocHJlZCwgcmVzdWx0cyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxpc3Qgd2l0aCB0aGUgc2VwYXJhdG9yIGludGVycG9zZWQgYmV0d2VlbiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBpbnRlcnNwZXJzZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHsqfSBzZXBhcmF0b3IgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaW50ZXJwb3NlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW50ZXJzcGVyc2UoJ24nLCBbJ2JhJywgJ2EnLCAnYSddKTsgLy89PiBbJ2JhJywgJ24nLCAnYScsICduJywgJ2EnXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNwZXJzZSA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdpbnRlcnNwZXJzZScsIGZ1bmN0aW9uIGludGVyc3BlcnNlKHNlcGFyYXRvciwgbGlzdCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpZHggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsaXN0W2lkeF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsaXN0W2lkeF0sIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgUi5pbnZlcnRPYmosIGhvd2V2ZXIgdGhpcyBhY2NvdW50cyBmb3Igb2JqZWN0c1xuICAgICAqIHdpdGggZHVwbGljYXRlIHZhbHVlcyBieSBwdXR0aW5nIHRoZSB2YWx1ZXMgaW50byBhblxuICAgICAqIGFycmF5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7czogeH0gLT4ge3g6IFsgcywgLi4uIF19XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGludmVydFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb3V0IEEgbmV3IG9iamVjdCB3aXRoIGtleXNcbiAgICAgKiBpbiBhbiBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgcmFjZVJlc3VsdHNCeUZpcnN0TmFtZSA9IHtcbiAgICAgKiAgICAgICAgZmlyc3Q6ICdhbGljZScsXG4gICAgICogICAgICAgIHNlY29uZDogJ2pha2UnLFxuICAgICAqICAgICAgICB0aGlyZDogJ2FsaWNlJyxcbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBSLmludmVydChyYWNlUmVzdWx0c0J5Rmlyc3ROYW1lKTtcbiAgICAgKiAgICAgIC8vPT4geyAnYWxpY2UnOiBbJ2ZpcnN0JywgJ3RoaXJkJ10sICdqYWtlJzpbJ3NlY29uZCddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnQob2JqKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICB2YXIgbGlzdCA9IF9oYXModmFsLCBvdXQpID8gb3V0W3ZhbF0gOiBvdXRbdmFsXSA9IFtdO1xuICAgICAgICAgICAgbGlzdFtsaXN0Lmxlbmd0aF0gPSBrZXk7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUga2V5cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAgICogYXMgdmFsdWVzLCBhbmQgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCB3aGljaCBhcmVcbiAgICAgKiBjb2VyY2VkIHRvIHN0cmluZ3MsIGFzIGtleXMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBsYXN0IGtleSBmb3VuZCBpcyBwcmVmZXJyZWQgd2hlbiBoYW5kbGluZ1xuICAgICAqIHRoZSBzYW1lIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHNpZyB7czogeH0gLT4ge3g6IHN9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGludmVydFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb3V0IEEgbmV3IG9iamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciByYWNlUmVzdWx0cyA9IHtcbiAgICAgKiAgICAgICAgZmlyc3Q6ICdhbGljZScsXG4gICAgICogICAgICAgIHNlY29uZDogJ2pha2UnXG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgUi5pbnZlcnRPYmoocmFjZVJlc3VsdHMpO1xuICAgICAqICAgICAgLy89PiB7ICdhbGljZSc6ICdmaXJzdCcsICdqYWtlJzonc2Vjb25kJyB9XG4gICAgICpcbiAgICAgKiAgICAgIC8vIEFsdGVybmF0aXZlbHk6XG4gICAgICogICAgICB2YXIgcmFjZVJlc3VsdHMgPSBbJ2FsaWNlJywgJ2pha2UnXTtcbiAgICAgKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAgICAgKiAgICAgIC8vPT4geyAnYWxpY2UnOiAnMCcsICdqYWtlJzonMScgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRPYmogPSBfY3VycnkxKGZ1bmN0aW9uIGludmVydE9iaihvYmopIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICAgICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaWR4XTtcbiAgICAgICAgICAgIG91dFtvYmpba2V5XV0gPSBrZXk7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGl0cyB0eXBlJ3MgZW1wdHkgdmFsdWU7IGBmYWxzZWBcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgYSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHsqfSB4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIuZW1wdHlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmlzRW1wdHkoWzEsIDIsIDNdKTsgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmlzRW1wdHkoW10pOyAgICAgICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIFIuaXNFbXB0eSgnJyk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5pc0VtcHR5KG51bGwpOyAgICAgICAgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc0VtcHR5KHt9KTsgICAgICAgICAgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzRW1wdHkoe2xlbmd0aDogMH0pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRW1wdHkgPSBfY3VycnkxKGZ1bmN0aW9uIGlzRW1wdHkoeCkge1xuICAgICAgICByZXR1cm4geCAhPSBudWxsICYmIGVxdWFscyh4LCBlbXB0eSh4KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjRcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzZWUgUi5pbml0LCBSLmhlYWQsIFIudGFpbFxuICAgICAqIEBzaWcgW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubGFzdChbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiAnZnVtJ1xuICAgICAqICAgICAgUi5sYXN0KFtdKTsgLy89PiB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqICAgICAgUi5sYXN0KCdhYmMnKTsgLy89PiAnYydcbiAgICAgKiAgICAgIFIubGFzdCgnJyk7IC8vPT4gJydcbiAgICAgKi9cbiAgICB2YXIgbGFzdCA9IG50aCgtMSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW5cbiAgICAgKiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgICAgKiBgUi5lcXVhbHNgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBbYV0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGluZGV4IG9mIHRoZSB0YXJnZXQsIG9yIC0xIGlmIHRoZSB0YXJnZXQgaXMgbm90IGZvdW5kLlxuICAgICAqIEBzZWUgUi5pbmRleE9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5sYXN0SW5kZXhPZigzLCBbLTEsMywzLDAsMSwyLDMsNF0pOyAvLz0+IDZcbiAgICAgKiAgICAgIFIubGFzdEluZGV4T2YoMTAsIFsxLDIsMyw0XSk7IC8vPT4gLTFcbiAgICAgKi9cbiAgICB2YXIgbGFzdEluZGV4T2YgPSBfY3VycnkyKGZ1bmN0aW9uIGxhc3RJbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4cy5sYXN0SW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpKSB7XG4gICAgICAgICAgICByZXR1cm4geHMubGFzdEluZGV4T2YodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB4cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVxdWFscyh4c1tpZHhdLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QsIGNvbnN0cnVjdGVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBmdW5jdGlvbiB0byBldmVyeSBlbGVtZW50IG9mIHRoZVxuICAgICAqIHN1cHBsaWVkIGxpc3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiBgUi5tYXBgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZSBhcnJheXMpLCB1bmxpa2UgdGhlXG4gICAgICogbmF0aXZlIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHMgb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcCNEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGlzcGF0Y2hlcyB0byB0aGUgYG1hcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqXG4gICAgICogTWFwIHRyZWF0cyBhbHNvIHRyZWF0cyBmdW5jdGlvbnMgYXMgZnVuY3RvcnMgYW5kIHdpbGwgY29tcG9zZSB0aGVtIHRvZ2V0aGVyLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZG91YmxlID0geCA9PiB4ICogMjtcbiAgICAgKlxuICAgICAqICAgICAgUi5tYXAoZG91YmxlLCBbMSwgMiwgM10pOyAvLz0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogICAgICBSLm1hcChkb3VibGUsIHt4OiAxLCB5OiAyLCB6OiAzfSk7IC8vPT4ge3g6IDIsIHk6IDQsIHo6IDZ9XG4gICAgICovXG4gICAgdmFyIG1hcCA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnbWFwJywgX3htYXAsIGZ1bmN0aW9uIG1hcChmbiwgZnVuY3Rvcikge1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jdG9yKSkge1xuICAgICAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6XG4gICAgICAgICAgICByZXR1cm4gY3VycnlOKGZ1bmN0b3IubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZnVuY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBmbihmdW5jdG9yW2tleV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSwga2V5cyhmdW5jdG9yKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gX21hcChmbiwgZnVuY3Rvcik7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXAsIGJ1dCBmb3Igb2JqZWN0cy4gQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmpgIGFuZCB2YWx1ZXNcbiAgICAgKiBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIHByb3BlcnR5IG9mIGBvYmpgIHRocm91Z2ggYGZuYC4gYGZuYCBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OlxuICAgICAqICoodmFsdWUpKi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS40XG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBzaWcgKHYgLT4gdikgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gY2FsbGVkIGZvciBlYWNoIHByb3BlcnR5IGluIGBvYmpgLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICAgKiBiZWNvbWUgYSBuZXcgcHJvcGVydHkgb24gdGhlIHJldHVybiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamAgYW5kIHZhbHVlcyB0aGF0IGFyZSB0aGUgcmVzdWx0XG4gICAgICogICAgICAgICBvZiBydW5uaW5nIGVhY2ggcHJvcGVydHkgdGhyb3VnaCBgZm5gLlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgdmFsdWVzID0geyB4OiAxLCB5OiAyLCB6OiAzIH07XG4gICAgICogICAgICB2YXIgZG91YmxlID0gbnVtID0+IG51bSAqIDI7XG4gICAgICpcbiAgICAgKiAgICAgIFIubWFwT2JqKGRvdWJsZSwgdmFsdWVzKTsgLy89PiB7IHg6IDIsIHk6IDQsIHo6IDYgfVxuICAgICAqL1xuICAgIHZhciBtYXBPYmogPSBfY3VycnkyKGZ1bmN0aW9uIG1hcE9iaihmbiwgb2JqKSB7XG4gICAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBmbihvYmpba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSwga2V5cyhvYmopKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIExpa2UgYG1hcE9iamAsIGJ1dCBwYXNzZXMgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIHByZWRpY2F0ZSBmdW5jdGlvbi4gVGhlXG4gICAgICogcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aHJlZSBhcmd1bWVudHM6ICoodmFsdWUsIGtleSwgb2JqKSouXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnICh2LCBrLCB7azogdn0gLT4gdikgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gY2FsbGVkIGZvciBlYWNoIHByb3BlcnR5IGluIGBvYmpgLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICAgKiAgICAgICAgYmVjb21lIGEgbmV3IHByb3BlcnR5IG9uIHRoZSByZXR1cm4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmpgIGFuZCB2YWx1ZXMgdGhhdCBhcmUgdGhlIHJlc3VsdFxuICAgICAqICAgICAgICAgb2YgcnVubmluZyBlYWNoIHByb3BlcnR5IHRocm91Z2ggYGZuYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgdmFsdWVzID0geyB4OiAxLCB5OiAyLCB6OiAzIH07XG4gICAgICogICAgICB2YXIgcHJlcGVuZEtleUFuZERvdWJsZSA9IChudW0sIGtleSwgb2JqKSA9PiBrZXkgKyAobnVtICogMik7XG4gICAgICpcbiAgICAgKiAgICAgIFIubWFwT2JqSW5kZXhlZChwcmVwZW5kS2V5QW5kRG91YmxlLCB2YWx1ZXMpOyAvLz0+IHsgeDogJ3gyJywgeTogJ3k0JywgejogJ3o2JyB9XG4gICAgICovXG4gICAgdmFyIG1hcE9iakluZGV4ZWQgPSBfY3VycnkyKGZ1bmN0aW9uIG1hcE9iakluZGV4ZWQoZm4sIG9iaikge1xuICAgICAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gZm4ob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9LCBrZXlzKG9iaikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgbm8gZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkIGJ5IGV2ZXJ5IGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBzZWUgUi5hbGwsIFIuYW55XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5ub25lKFIuaXNOYU4sIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5ub25lKFIuaXNOYU4sIFsxLCAyLCAzLCBOYU5dKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBub25lID0gX2N1cnJ5MihfY29tcGxlbWVudChfZGlzcGF0Y2hhYmxlKCdhbnknLCBfeGFueSwgYW55KSkpO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBgZmAgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMsIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gYGdgLlxuICAgICAqIFdoZW4gYXBwbGllZCwgYGdgIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGFyZ3VtZW50c1xuICAgICAqIHByb3ZpZGVkIGluaXRpYWxseSBmb2xsb3dlZCBieSB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIGBnYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKChhLCBiLCBjLCAuLi4sIG4pIC0+IHgpIC0+IFthLCBiLCBjLCAuLi5dIC0+ICgoZCwgZSwgZiwgLi4uLCBuKSAtPiB4KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLnBhcnRpYWxSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBtdWx0aXBseSA9IChhLCBiKSA9PiBhICogYjtcbiAgICAgKiAgICAgIHZhciBkb3VibGUgPSBSLnBhcnRpYWwobXVsdGlwbHksIFsyXSk7XG4gICAgICogICAgICBkb3VibGUoMik7IC8vPT4gNFxuICAgICAqXG4gICAgICogICAgICB2YXIgZ3JlZXQgPSAoc2FsdXRhdGlvbiwgdGl0bGUsIGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+XG4gICAgICogICAgICAgIHNhbHV0YXRpb24gKyAnLCAnICsgdGl0bGUgKyAnICcgKyBmaXJzdE5hbWUgKyAnICcgKyBsYXN0TmFtZSArICchJztcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNheUhlbGxvID0gUi5wYXJ0aWFsKGdyZWV0LCBbJ0hlbGxvJ10pO1xuICAgICAqICAgICAgdmFyIHNheUhlbGxvVG9NcyA9IFIucGFydGlhbChzYXlIZWxsbywgWydNcy4nXSk7XG4gICAgICogICAgICBzYXlIZWxsb1RvTXMoJ0phbmUnLCAnSm9uZXMnKTsgLy89PiAnSGVsbG8sIE1zLiBKYW5lIEpvbmVzISdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcihfY29uY2F0KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAgICAgKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAgICAgKiBwcm92aWRlZCB0byBgZ2AgZm9sbG93ZWQgYnkgdGhlIGFyZ3VtZW50cyBwcm92aWRlZCBpbml0aWFsbHkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoYSwgYiwgYywgLi4uLCBuKSAtPiB4KSAtPiBbZCwgZSwgZiwgLi4uLCBuXSAtPiAoKGEsIGIsIGMsIC4uLikgLT4geClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5wYXJ0aWFsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGdyZWV0ID0gKHNhbHV0YXRpb24sIHRpdGxlLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PlxuICAgICAqICAgICAgICBzYWx1dGF0aW9uICsgJywgJyArIHRpdGxlICsgJyAnICsgZmlyc3ROYW1lICsgJyAnICsgbGFzdE5hbWUgKyAnISc7XG4gICAgICpcbiAgICAgKiAgICAgIHZhciBncmVldE1zSmFuZUpvbmVzID0gUi5wYXJ0aWFsUmlnaHQoZ3JlZXQsIFsnTXMuJywgJ0phbmUnLCAnSm9uZXMnXSk7XG4gICAgICpcbiAgICAgKiAgICAgIGdyZWV0TXNKYW5lSm9uZXMoJ0hlbGxvJyk7IC8vPT4gJ0hlbGxvLCBNcy4gSmFuZSBKb25lcyEnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcihmbGlwKF9jb25jYXQpKTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIGxpc3QgYW5kIHJldHVybnMgdGhlIHBhaXIgb2YgbGlzdHMgb2ZcbiAgICAgKiBlbGVtZW50cyB3aGljaCBkbyBhbmQgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgcmVzcGVjdGl2ZWx5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjRcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFtbYV0sW2FdXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIHdoaWNoIGFycmF5IHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gcGFydGl0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5lc3RlZCBhcnJheSwgY29udGFpbmluZyBmaXJzdCBhbiBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHNhdGlzZmllZCB0aGUgcHJlZGljYXRlLFxuICAgICAqICAgICAgICAgYW5kIHNlY29uZCBhbiBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGRpZCBub3Qgc2F0aXNmeS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnBhcnRpdGlvbihSLmNvbnRhaW5zKCdzJyksIFsnc3NzJywgJ3R0dCcsICdmb28nLCAnYmFycyddKTtcbiAgICAgKiAgICAgIC8vPT4gWyBbICdzc3MnLCAnYmFycycgXSwgIFsgJ3R0dCcsICdmb28nIF0gXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBfY3VycnkyKGZ1bmN0aW9uIHBhcnRpdGlvbihwcmVkLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVsdCkge1xuICAgICAgICAgICAgdmFyIHhzID0gYWNjW3ByZWQoZWx0KSA/IDAgOiAxXTtcbiAgICAgICAgICAgIHhzW3hzLmxlbmd0aF0gPSBlbHQ7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBbXSxcbiAgICAgICAgICAgIFtdXG4gICAgICAgIF0sIGxpc3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgbmVzdGVkIHBhdGggb24gYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmljIHZhbHVlLFxuICAgICAqIGluIGBSLmVxdWFsc2AgdGVybXMuIE1vc3QgbGlrZWx5IHVzZWQgdG8gZmlsdGVyIGEgbGlzdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNy4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyBbU3RyaW5nXSAtPiAqIC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBuZXN0ZWQgcHJvcGVydHkgdG8gdXNlXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSB3aXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIHRoZSBuZXN0ZWQgcHJvcGVydHkgaW5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGVxdWFscyB0aGUgbmVzdGVkIG9iamVjdCBwcm9wZXJ0eSxcbiAgICAgKiAgICAgICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB1c2VyMSA9IHsgYWRkcmVzczogeyB6aXBDb2RlOiA5MDIxMCB9IH07XG4gICAgICogICAgICB2YXIgdXNlcjIgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogNTU1NTUgfSB9O1xuICAgICAqICAgICAgdmFyIHVzZXIzID0geyBuYW1lOiAnQm9iJyB9O1xuICAgICAqICAgICAgdmFyIHVzZXJzID0gWyB1c2VyMSwgdXNlcjIsIHVzZXIzIF07XG4gICAgICogICAgICB2YXIgaXNGYW1vdXMgPSBSLnBhdGhFcShbJ2FkZHJlc3MnLCAnemlwQ29kZSddLCA5MDIxMCk7XG4gICAgICogICAgICBSLmZpbHRlcihpc0ZhbW91cywgdXNlcnMpOyAvLz0+IFsgdXNlcjEgXVxuICAgICAqL1xuICAgIHZhciBwYXRoRXEgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhFcShfcGF0aCwgdmFsLCBvYmopIHtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhwYXRoKF9wYXRoLCBvYmopLCB2YWwpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGJ5IHBsdWNraW5nIHRoZSBzYW1lIG5hbWVkIHByb3BlcnR5IG9mZiBhbGwgb2JqZWN0cyBpbiB0aGUgbGlzdCBzdXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGsgLT4gW3trOiB2fV0gLT4gW3ZdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgVGhlIGtleSBuYW1lIHRvIHBsdWNrIG9mZiBvZiBlYWNoIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBzZWUgUi5wcm9wc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucGx1Y2soJ2EnKShbe2E6IDF9LCB7YTogMn1dKTsgLy89PiBbMSwgMl1cbiAgICAgKiAgICAgIFIucGx1Y2soMCkoW1sxLCAyXSwgWzMsIDRdXSk7ICAgLy89PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgcGx1Y2sgPSBfY3VycnkyKGZ1bmN0aW9uIHBsdWNrKHAsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIG1hcChwcm9wKHApLCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGlzIGVxdWFsLCBpbiBgUi5lcXVhbHNgXG4gICAgICogdGVybXMsIHRvIHRoZSBnaXZlbiB2YWx1ZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgU3RyaW5nIC0+IGEgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHBhcmFtIHsqfSBvYmpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgUi5lcXVhbHMsIFIucHJvcFNhdGlzZmllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBhYmJ5ID0ge25hbWU6ICdBYmJ5JywgYWdlOiA3LCBoYWlyOiAnYmxvbmQnfTtcbiAgICAgKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJ307XG4gICAgICogICAgICB2YXIgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gICAgICogICAgICB2YXIgYWxvaXMgPSB7bmFtZTogJ0Fsb2lzJywgYWdlOiAxNSwgZGlzcG9zaXRpb246ICdzdXJseSd9O1xuICAgICAqICAgICAgdmFyIGtpZHMgPSBbYWJieSwgZnJlZCwgcnVzdHksIGFsb2lzXTtcbiAgICAgKiAgICAgIHZhciBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICAgICAqICAgICAgUi5maWx0ZXIoaGFzQnJvd25IYWlyLCBraWRzKTsgLy89PiBbZnJlZCwgcnVzdHldXG4gICAgICovXG4gICAgdmFyIHByb3BFcSA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcEVxKG5hbWUsIHZhbCwgb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wU2F0aXNmaWVzKGVxdWFscyh2YWwpLCBuYW1lLCBvYmopO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgb2YgdGhlIGdpdmVuIHR5cGU7XG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgVHlwZVxuICAgICAqIEBzaWcgVHlwZSAtPiBTdHJpbmcgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBSLmlzXG4gICAgICogQHNlZSBSLnByb3BTYXRpc2ZpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt4OiAnZm9vJ30pOyAgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge30pOyAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgcHJvcElzID0gX2N1cnJ5MyhmdW5jdGlvbiBwcm9wSXModHlwZSwgbmFtZSwgb2JqKSB7XG4gICAgICAgIHJldHVybiBwcm9wU2F0aXNmaWVzKGlzKHR5cGUpLCBuYW1lLCBvYmopO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZyB0aGUgaXRlcmF0b3JcbiAgICAgKiBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZFxuICAgICAqIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouICBJdCBtYXkgdXNlIGBSLnJlZHVjZWRgIHRvXG4gICAgICogc2hvcnRjdXQgdGhlIGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IGBSLnJlZHVjZWAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlIGFycmF5cyksIHVubGlrZVxuICAgICAqIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzIGJlaGF2aW9yLCBzZWU6XG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlI0Rlc2NyaXB0aW9uXG4gICAgICogQHNlZSBSLnJlZHVjZWRcbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGByZWR1Y2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSxiIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gICAgICogICAgICAgIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbnVtYmVycyA9IFsxLCAyLCAzXTtcbiAgICAgKiAgICAgIHZhciBhZGQgPSAoYSwgYikgPT4gYSArIGI7XG4gICAgICpcbiAgICAgKiAgICAgIFIucmVkdWNlKGFkZCwgMTAsIG51bWJlcnMpOyAvLz0+IDE2XG4gICAgICovXG4gICAgdmFyIHJlZHVjZSA9IF9jdXJyeTMoX3JlZHVjZSk7XG5cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGBmaWx0ZXJgLCBleGNlcHQgdGhhdCBpdCBrZWVwcyBvbmx5IHZhbHVlcyBmb3Igd2hpY2ggdGhlIGdpdmVuIHByZWRpY2F0ZVxuICAgICAqIGZ1bmN0aW9uIHJldHVybnMgZmFsc3kuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBSLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpc09kZCA9IChuKSA9PiBuICUgMiA9PT0gMTtcbiAgICAgKlxuICAgICAqICAgICAgUi5yZWplY3QoaXNPZGQsIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDRdXG4gICAgICovXG4gICAgdmFyIHJlamVjdCA9IF9jdXJyeTIoZnVuY3Rpb24gcmVqZWN0KGZuLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoX2NvbXBsZW1lbnQoZm4pLCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmaXhlZCBsaXN0IG9mIHNpemUgYG5gIGNvbnRhaW5pbmcgYSBzcGVjaWZpZWQgaWRlbnRpY2FsIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiBuIC0+IFthXVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBvdXRwdXQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkgY29udGFpbmluZyBgbmAgYHZhbHVlYHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5yZXBlYXQoJ2hpJywgNSk7IC8vPT4gWydoaScsICdoaScsICdoaScsICdoaScsICdoaSddXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgKiAgICAgIHZhciByZXBlYXRlZE9ianMgPSBSLnJlcGVhdChvYmosIDUpOyAvLz0+IFt7fSwge30sIHt9LCB7fSwge31dXG4gICAgICogICAgICByZXBlYXRlZE9ianNbMF0gPT09IHJlcGVhdGVkT2Jqc1sxXTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIHJlcGVhdCA9IF9jdXJyeTIoZnVuY3Rpb24gcmVwZWF0KHZhbHVlLCBuKSB7XG4gICAgICAgIHJldHVybiB0aW1lcyhhbHdheXModmFsdWUpLCBuKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0IHdpdGggYSBgc2xpY2VgXG4gICAgICogbWV0aG9kKSBmcm9tIGBmcm9tSW5kZXhgIChpbmNsdXNpdmUpIHRvIGB0b0luZGV4YCAoZXhjbHVzaXZlKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS40XG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgc3RhcnQgaW5kZXggKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvSW5kZXggVGhlIGVuZCBpbmRleCAoZXhjbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0geyp9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuc2xpY2UoMSwgMywgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAgLy89PiBbJ2InLCAnYyddXG4gICAgICogICAgICBSLnNsaWNlKDEsIEluZmluaXR5LCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7IC8vPT4gWydiJywgJ2MnLCAnZCddXG4gICAgICogICAgICBSLnNsaWNlKDAsIC0xLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgIC8vPT4gWydhJywgJ2InLCAnYyddXG4gICAgICogICAgICBSLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydiJywgJ2MnXVxuICAgICAqICAgICAgUi5zbGljZSgwLCAzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAgICAgICAvLz0+ICdyYW0nXG4gICAgICovXG4gICAgdmFyIHNsaWNlID0gX2N1cnJ5MyhfY2hlY2tGb3JNZXRob2QoJ3NsaWNlJywgZnVuY3Rpb24gc2xpY2UoZnJvbUluZGV4LCB0b0luZGV4LCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIGNvbGxlY3Rpb24gaW50byBzbGljZXMgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBbU3RyaW5nXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuc3BsaXRFdmVyeSgzLCBbMSwgMiwgMywgNCwgNSwgNiwgN10pOyAvLz0+IFtbMSwgMiwgM10sIFs0LCA1LCA2XSwgWzddXVxuICAgICAqICAgICAgUi5zcGxpdEV2ZXJ5KDMsICdmb29iYXJiYXonKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgICAgKi9cbiAgICB2YXIgc3BsaXRFdmVyeSA9IF9jdXJyeTIoZnVuY3Rpb24gc3BsaXRFdmVyeShuLCBsaXN0KSB7XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gc3BsaXRFdmVyeSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2xpY2UoaWR4LCBpZHggKz0gbiwgbGlzdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgc3VtIG9mIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgbGlzdC5cbiAgICAgKiBAc2VlIFIucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5zdW0oWzIsNCw2LDgsMTAwLDFdKTsgLy89PiAxMjFcbiAgICAgKi9cbiAgICB2YXIgc3VtID0gcmVkdWNlKGFkZCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3RcbiAgICAgKiB3aXRoIGEgYHRhaWxgIG1ldGhvZCkuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2xpY2VgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNlZSBSLmhlYWQsIFIuaW5pdCwgUi5sYXN0XG4gICAgICogQHNpZyBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRhaWwoWzEsIDIsIDNdKTsgIC8vPT4gWzIsIDNdXG4gICAgICogICAgICBSLnRhaWwoWzEsIDJdKTsgICAgIC8vPT4gWzJdXG4gICAgICogICAgICBSLnRhaWwoWzFdKTsgICAgICAgIC8vPT4gW11cbiAgICAgKiAgICAgIFIudGFpbChbXSk7ICAgICAgICAgLy89PiBbXVxuICAgICAqXG4gICAgICogICAgICBSLnRhaWwoJ2FiYycpOyAgLy89PiAnYmMnXG4gICAgICogICAgICBSLnRhaWwoJ2FiJyk7ICAgLy89PiAnYidcbiAgICAgKiAgICAgIFIudGFpbCgnYScpOyAgICAvLz0+ICcnXG4gICAgICogICAgICBSLnRhaWwoJycpOyAgICAgLy89PiAnJ1xuICAgICAqL1xuICAgIHZhciB0YWlsID0gX2NoZWNrRm9yTWV0aG9kKCd0YWlsJywgc2xpY2UoMSwgSW5maW5pdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCwgc3RyaW5nLCBvclxuICAgICAqIHRyYW5zZHVjZXIvdHJhbnNmb3JtZXIgKG9yIG9iamVjdCB3aXRoIGEgYHRha2VgIG1ldGhvZCkuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgdGFrZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLmRyb3BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRha2UoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gICAgICogICAgICBSLnRha2UoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInXVxuICAgICAqICAgICAgUi50YWtlKDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgICogICAgICBSLnRha2UoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgICAgKiAgICAgIFIudGFrZSgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYW0nXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBwZXJzb25uZWwgPSBbXG4gICAgICogICAgICAgICdEYXZlIEJydWJlY2snLFxuICAgICAqICAgICAgICAnUGF1bCBEZXNtb25kJyxcbiAgICAgKiAgICAgICAgJ0V1Z2VuZSBXcmlnaHQnLFxuICAgICAqICAgICAgICAnSm9lIE1vcmVsbG8nLFxuICAgICAqICAgICAgICAnR2VycnkgTXVsbGlnYW4nLFxuICAgICAqICAgICAgICAnQm9iIEJhdGVzJyxcbiAgICAgKiAgICAgICAgJ0pvZSBEb2RnZScsXG4gICAgICogICAgICAgICdSb24gQ3JvdHR5J1xuICAgICAqICAgICAgXTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHRha2VGaXZlID0gUi50YWtlKDUpO1xuICAgICAqICAgICAgdGFrZUZpdmUocGVyc29ubmVsKTtcbiAgICAgKiAgICAgIC8vPT4gWydEYXZlIEJydWJlY2snLCAnUGF1bCBEZXNtb25kJywgJ0V1Z2VuZSBXcmlnaHQnLCAnSm9lIE1vcmVsbG8nLCAnR2VycnkgTXVsbGlnYW4nXVxuICAgICAqL1xuICAgIHZhciB0YWtlID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCd0YWtlJywgX3h0YWtlLCBmdW5jdGlvbiB0YWtlKG4sIHhzKSB7XG4gICAgICAgIHJldHVybiBzbGljZSgwLCBuIDwgMCA/IEluZmluaXR5IDogbiwgeHMpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LCBwYXNzaW5nIGVhY2ggdmFsdWVcbiAgICAgKiB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBhbmQgdGVybWluYXRpbmcgd2hlbiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBgZmFsc2VgLiBFeGNsdWRlcyB0aGUgZWxlbWVudCB0aGF0IGNhdXNlZCB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGVcbiAgICAgKiBmdW5jdGlvbiBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgdGFrZVdoaWxlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheS5cbiAgICAgKiBAc2VlIFIuZHJvcFdoaWxlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGlzTm90Rm91ciA9IHggPT4geCAhPT0gNDtcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlV2hpbGUoaXNOb3RGb3VyLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciB0YWtlV2hpbGUgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ3Rha2VXaGlsZScsIF94dGFrZVdoaWxlLCBmdW5jdGlvbiB0YWtlV2hpbGUoZm4sIGxpc3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaWR4IDwgbGVuICYmIGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2xpY2UobGlzdCwgMCwgaWR4KTtcbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIHRyYW5zZHVjZXIgdXNpbmcgc3VwcGxpZWQgaXRlcmF0b3IgZnVuY3Rpb24uIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieVxuICAgICAqIGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZyB0aGUgdHJhbnNmb3JtZWQgaXRlcmF0b3IgZnVuY3Rpb24gYW5kXG4gICAgICogcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmdcbiAgICAgKiB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IHdpbGwgYmUgd3JhcHBlZCBhcyBhXG4gICAgICogdHJhbnNmb3JtZXIgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNkdWNlci4gQSB0cmFuc2Zvcm1lciBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGluIHBsYWNlXG4gICAgICogb2YgYW4gaXRlcmF0b3IgZnVuY3Rpb24uICBJbiBib3RoIGNhc2VzLCBpdGVyYXRpb24gbWF5IGJlIHN0b3BwZWQgZWFybHkgd2l0aCB0aGVcbiAgICAgKiBgUi5yZWR1Y2VkYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEEgdHJhbnNkdWNlciBpcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGEgdHJhbnNmb3JtZXIgYW5kIGNhblxuICAgICAqIGJlIGNvbXBvc2VkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogQSB0cmFuc2Zvcm1lciBpcyBhbiBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhIDItYXJpdHkgcmVkdWNpbmcgaXRlcmF0b3IgZnVuY3Rpb24sIHN0ZXAsXG4gICAgICogMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmQgMS1hcml0eSByZXN1bHQgZXh0cmFjdGlvbiBmdW5jdGlvbiwgcmVzdWx0LlxuICAgICAqIFRoZSBzdGVwIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkXG4gICAgICogdG8gY29udmVydCB0aGUgZmluYWwgYWNjdW11bGF0b3IgaW50byB0aGUgcmV0dXJuIHR5cGUgYW5kIGluIG1vc3QgY2FzZXMgaXMgUi5pZGVudGl0eS5cbiAgICAgKiBUaGUgaW5pdCBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGFuIGluaXRpYWwgYWNjdW11bGF0b3IsIGJ1dCBpcyBpZ25vcmVkIGJ5IHRyYW5zZHVjZS5cbiAgICAgKlxuICAgICAqIFRoZSBpdGVyYXRpb24gaXMgcGVyZm9ybWVkIHdpdGggUi5yZWR1Y2UgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSB0cmFuc2R1Y2VyLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2VlIFIucmVkdWNlLCBSLnJlZHVjZWQsIFIuaW50b1xuICAgICAqIEBzaWcgKGMgLT4gYykgLT4gKGEsYiAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0geGYgVGhlIHRyYW5zZHVjZXIgZnVuY3Rpb24uIFJlY2VpdmVzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYSB0cmFuc2Zvcm1lci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gICAgICogICAgICAgIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheS4gV3JhcHBlZCBhcyB0cmFuc2Zvcm1lciwgaWYgbmVjZXNzYXJ5LCBhbmQgdXNlZCB0b1xuICAgICAqICAgICAgICBpbml0aWFsaXplIHRoZSB0cmFuc2R1Y2VyXG4gICAgICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbnVtYmVycyA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiAgICAgIHZhciB0cmFuc2R1Y2VyID0gUi5jb21wb3NlKFIubWFwKFIuYWRkKDEpKSwgUi50YWtlKDIpKTtcbiAgICAgKlxuICAgICAqICAgICAgUi50cmFuc2R1Y2UodHJhbnNkdWNlciwgUi5mbGlwKFIuYXBwZW5kKSwgW10sIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciB0cmFuc2R1Y2UgPSBjdXJyeU4oNCwgZnVuY3Rpb24gdHJhbnNkdWNlKHhmLCBmbiwgYWNjLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfcmVkdWNlKHhmKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IF94d3JhcChmbikgOiBmbiksIGFjYywgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHMgb2YgZWFjaCBsaXN0LiAgRHVwbGljYXRpb24gaXNcbiAgICAgKiBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byB0d28gbGlzdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSxhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZpcnN0IGFuZCBzZWNvbmQgbGlzdHMgY29uY2F0ZW5hdGVkLCB3aXRoXG4gICAgICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gICAgICogQHNlZSBSLnVuaW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGwxID0gW3thOiAxfSwge2E6IDJ9XTtcbiAgICAgKiAgICAgIHZhciBsMiA9IFt7YTogMX0sIHthOiA0fV07XG4gICAgICogICAgICBSLnVuaW9uV2l0aChSLmVxQnkoUi5wcm9wKCdhJykpLCBsMSwgbDIpOyAvLz0+IFt7YTogMX0sIHthOiAyfSwge2E6IDR9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBfY3VycnkzKGZ1bmN0aW9uIHVuaW9uV2l0aChwcmVkLCBsaXN0MSwgbGlzdDIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXFXaXRoKHByZWQsIF9jb25jYXQobGlzdDEsIGxpc3QyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgbGlzdC5cbiAgICAgKiBgUi5lcXVhbHNgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IFthXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51bmlxKFsxLCAxLCAyLCAxXSk7IC8vPT4gWzEsIDJdXG4gICAgICogICAgICBSLnVuaXEoWzEsICcxJ10pOyAgICAgLy89PiBbMSwgJzEnXVxuICAgICAqICAgICAgUi51bmlxKFtbNDJdLCBbNDJdXSk7IC8vPT4gW1s0Ml1dXG4gICAgICovXG4gICAgdmFyIHVuaXEgPSB1bmlxV2l0aChlcXVhbHMpO1xuXG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBhIGZ1bmN0aW9uIGBmbmAgYW5kIGEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnMgYW5kIHJldHVybnMgYSBuZXcgY3VycmllZFxuICAgICAqIGZ1bmN0aW9uLiBXaGVuIHRoZSBuZXcgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQgY2FsbHMgdGhlIGZ1bmN0aW9uIGBmbmAgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICogY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZWFjaCBzdXBwbGllZCBoYW5kbGVyIG9uIHN1Y2Nlc3NpdmUgYXJndW1lbnRzIHRvIHRoZVxuICAgICAqIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIElmIG1vcmUgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRoYW4gdHJhbnNmb3JtZXIgZnVuY3Rpb25zLCB0aG9zZVxuICAgICAqIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGRpcmVjdGx5IHRvIGBmbmAgYXMgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBJZiB5b3UgZXhwZWN0IGFkZGl0aW9uYWxcbiAgICAgKiBhcmd1bWVudHMgdGhhdCBkb24ndCBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkLCBhbHRob3VnaCB5b3UgY2FuIGlnbm9yZSB0aGVtLCBpdCdzIGJlc3QgdG9cbiAgICAgKiBwYXNzIGFuIGlkZW50aXR5IGZ1bmN0aW9uIHNvIHRoYXQgdGhlIG5ldyBmdW5jdGlvbiByZXBvcnRzIHRoZSBjb3JyZWN0IGFyaXR5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICh4MSAtPiB4MiAtPiAuLi4gLT4geikgLT4gWyhhIC0+IHgxKSwgKGIgLT4geDIpLCAuLi5dIC0+IChhIC0+IGIgLT4gLi4uIC0+IHopXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtZXJzIEEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5pZGVudGl0eSwgUi5pZGVudGl0eV0pKDMsIDQpOyAvLz0+IDgxXG4gICAgICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmlkZW50aXR5LCBSLmlkZW50aXR5XSkoMykoNCk7IC8vPT4gODFcbiAgICAgKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuZGVjLCBSLmluY10pKDMsIDQpOyAvLz0+IDMyXG4gICAgICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmRlYywgUi5pbmNdKSgzKSg0KTsgLy89PiAzMlxuICAgICAqL1xuICAgIHZhciB1c2VXaXRoID0gX2N1cnJ5MihmdW5jdGlvbiB1c2VXaXRoKGZuLCB0cmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5KF9hcml0eSh0cmFuc2Zvcm1lcnMubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBpZHggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2godHJhbnNmb3JtZXJzW2lkeF0uY2FsbCh0aGlzLCBhcmd1bWVudHNbaWR4XSkpO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KF9zbGljZShhcmd1bWVudHMsIHRyYW5zZm9ybWVycy5sZW5ndGgpKSk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgc3BlYyBvYmplY3QgYW5kIGEgdGVzdCBvYmplY3Q7IHJldHVybnMgdHJ1ZSBpZiB0aGUgdGVzdCBzYXRpc2ZpZXNcbiAgICAgKiB0aGUgc3BlYywgZmFsc2Ugb3RoZXJ3aXNlLiBBbiBvYmplY3Qgc2F0aXNmaWVzIHRoZSBzcGVjIGlmLCBmb3IgZWFjaCBvZiB0aGVcbiAgICAgKiBzcGVjJ3Mgb3duIHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBvYmplY3QgZ2l2ZXMgdGhlIHNhbWVcbiAgICAgKiB2YWx1ZSAoaW4gYFIuZXF1YWxzYCB0ZXJtcykgYXMgYWNjZXNzaW5nIHRoYXQgcHJvcGVydHkgb2YgdGhlIHNwZWMuXG4gICAgICpcbiAgICAgKiBgd2hlcmVFcWAgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbYHdoZXJlYF0oI3doZXJlKS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFIud2hlcmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gICAgICogICAgICB2YXIgcHJlZCA9IFIud2hlcmVFcSh7YTogMSwgYjogMn0pO1xuICAgICAqXG4gICAgICogICAgICBwcmVkKHthOiAxfSk7ICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gICAgICogICAgICBwcmVkKHthOiAxLCBiOiAyfSk7ICAgICAgICAvLz0+IHRydWVcbiAgICAgKiAgICAgIHByZWQoe2E6IDEsIGI6IDIsIGM6IDN9KTsgIC8vPT4gdHJ1ZVxuICAgICAqICAgICAgcHJlZCh7YTogMSwgYjogMX0pOyAgICAgICAgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciB3aGVyZUVxID0gX2N1cnJ5MihmdW5jdGlvbiB3aGVyZUVxKHNwZWMsIHRlc3RPYmopIHtcbiAgICAgICAgcmV0dXJuIHdoZXJlKG1hcE9iaihlcXVhbHMsIHNwZWMpLCB0ZXN0T2JqKTtcbiAgICB9KTtcblxuICAgIHZhciBfZmxhdENhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXNlcnZpbmdSZWR1Y2VkID0gZnVuY3Rpb24gKHhmKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IF9mb3JjZVJlZHVjZWQocmV0KSA6IHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX3hjYXQoeGYpIHtcbiAgICAgICAgICAgIHZhciByeGYgPSBwcmVzZXJ2aW5nUmVkdWNlZCh4Zik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdAQHRyYW5zZHVjZXIvaW5pdCc6IF94ZkJhc2UuaW5pdCxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzQXJyYXlMaWtlKGlucHV0KSA/IF9yZWR1Y2UocnhmLCByZXN1bHQsIFtpbnB1dF0pIDogX3JlZHVjZShyeGYsIHJlc3VsdCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgdmFyIF9pbmRleE9mID0gZnVuY3Rpb24gX2luZGV4T2YobGlzdCwgaXRlbSwgZnJvbSkge1xuICAgICAgICB2YXIgaWR4ID0gZnJvbTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxzKGxpc3RbaWR4XSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICB2YXIgX3N0ZXBDYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfc3RlcENhdEFycmF5ID0ge1xuICAgICAgICAgICAgJ0BAdHJhbnNkdWNlci9pbml0JzogQXJyYXksXG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAoeHMsIHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmNhdCh4cywgW3hdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IF9pZGVudGl0eVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3N0ZXBDYXRTdHJpbmcgPSB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBTdHJpbmcsXG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IF9pZGVudGl0eVxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3N0ZXBDYXRPYmplY3QgPSB7XG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBPYmplY3QsXG4gICAgICAgICAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZShyZXN1bHQsIGlzQXJyYXlMaWtlKGlucHV0KSA/IGNyZWF0ZU1hcEVudHJ5KGlucHV0WzBdLCBpbnB1dFsxXSkgOiBpbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBfaWRlbnRpdHlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9zdGVwQ2F0KG9iaikge1xuICAgICAgICAgICAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0ZXBDYXRBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3RlcENhdFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3RlcENhdE9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSB0cmFuc2Zvcm1lciBmb3IgJyArIG9iaik7XG4gICAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgdmFyIF94Y2hhaW4gPSBfY3VycnkyKGZ1bmN0aW9uIF94Y2hhaW4oZiwgeGYpIHtcbiAgICAgICAgcmV0dXJuIG1hcChmLCBfZmxhdENhdCh4ZikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IG9mIHByZWRpY2F0ZXMgYW5kIHJldHVybnMgYSBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWVcbiAgICAgKiBmb3IgYSBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBldmVyeSBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXNcbiAgICAgKiBpcyBzYXRpc2ZpZWQgYnkgdGhvc2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2ZcbiAgICAgKiB0aGUgaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByZWRzXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQHNlZSBSLmFueVBhc3NcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaXNRdWVlbiA9IFIucHJvcEVxKCdyYW5rJywgJ1EnKTtcbiAgICAgKiAgICAgIHZhciBpc1NwYWRlID0gUi5wcm9wRXEoJ3N1aXQnLCAn4pmg77iOJyk7XG4gICAgICogICAgICB2YXIgaXNRdWVlbk9mU3BhZGVzID0gUi5hbGxQYXNzKFtpc1F1ZWVuLCBpc1NwYWRlXSk7XG4gICAgICpcbiAgICAgKiAgICAgIGlzUXVlZW5PZlNwYWRlcyh7cmFuazogJ1EnLCBzdWl0OiAn4pmj77iOJ30pOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZoO+4jid9KTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGFsbFBhc3MgPSBfY3VycnkxKGZ1bmN0aW9uIGFsbFBhc3MocHJlZHMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgcHJlZHMpKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVuID0gcHJlZHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGlmICghcHJlZHNbaWR4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgYXJlIHVuaXF1ZSwgaW4gYFIuZXF1YWxzYCB0ZXJtcyxcbiAgICAgKiBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTguMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBbYV0gLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgYXJlIHVuaXF1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuYWxsVW5pcShbJzEnLCAxXSk7IC8vPT4gdHJ1ZVxuICAgICAqICAgICAgUi5hbGxVbmlxKFsxLCAxXSk7ICAgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5hbGxVbmlxKFtbNDJdLCBbNDJdXSk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgYWxsVW5pcSA9IF9jdXJyeTEoZnVuY3Rpb24gYWxsVW5pcShsaXN0KSB7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChfaW5kZXhPZihsaXN0LCBsaXN0W2lkeF0sIGlkeCArIDEpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvclxuICAgICAqIGEgZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzXG4gICAgICogc2F0aXNmaWVkIGJ5IHRob3NlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mXG4gICAgICogdGhlIGhpZ2hlc3QtYXJpdHkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnIFsoKi4uLiAtPiBCb29sZWFuKV0gLT4gKCouLi4gLT4gQm9vbGVhbilcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcmVkc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5hbGxQYXNzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGd0ZSA9IFIuYW55UGFzcyhbUi5ndCwgUi5lcXVhbHNdKTtcbiAgICAgKlxuICAgICAqICAgICAgZ3RlKDMsIDIpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIGd0ZSgyLCAyKTsgLy89PiB0cnVlXG4gICAgICogICAgICBndGUoMiwgMyk7IC8vPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgYW55UGFzcyA9IF9jdXJyeTEoZnVuY3Rpb24gYW55UGFzcyhwcmVkcykge1xuICAgICAgICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCBwcmVkcykpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwcmVkcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogYXAgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgYXBgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LiBBbHNvIHRyZWF0c1xuICAgICAqIGZ1bmN0aW9ucyBhcyBhcHBsaWNhdGl2ZXMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgW2ZdIC0+IFthXSAtPiBbZiBhXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZucyBBbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2cyBBbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgcmVzdWx0cyBvZiBhcHBseWluZyBlYWNoIG9mIGBmbnNgIHRvIGFsbCBvZiBgdnNgIGluIHR1cm4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi5hcChbUi5tdWx0aXBseSgyKSwgUi5hZGQoMyldLCBbMSwyLDNdKTsgLy89PiBbMiwgNCwgNiwgNCwgNSwgNl1cbiAgICAgKi9cbiAgICAvLyBlbHNlXG4gICAgdmFyIGFwID0gX2N1cnJ5MihmdW5jdGlvbiBhcChhcHBsaWNhdGl2ZSwgZm4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcHBsaWNhdGl2ZS5hcCA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGxpY2F0aXZlLmFwKGZuKSA6IHR5cGVvZiBhcHBsaWNhdGl2ZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJ5TihNYXRoLm1heChhcHBsaWNhdGl2ZS5sZW5ndGgsIGZuLmxlbmd0aCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBsaWNhdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9KSA6IC8vIGVsc2VcbiAgICAgICAgX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbmNhdChhY2MsIG1hcChmLCBmbikpO1xuICAgICAgICB9LCBbXSwgYXBwbGljYXRpdmUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggdGhlIHJlbWFpbmluZ1xuICAgICAqIGFyZ3VtZW50cy4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgdXNlZnVsIGFzIGEgY29udmVyZ2luZyBmdW5jdGlvbiBmb3JcbiAgICAgKiBgUi5jb252ZXJnZWA6IHRoZSBsZWZ0IGJyYW5jaCBjYW4gcHJvZHVjZSBhIGZ1bmN0aW9uIHdoaWxlIHRoZSByaWdodFxuICAgICAqIGJyYW5jaCBwcm9kdWNlcyBhIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqLi4uIC0+IGEpLCouLi4gLT4gYVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQW55IG51bWJlciBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBzZWUgUi5hcHBseVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBpbmRlbnROID0gUi5waXBlKFIudGltZXMoUi5hbHdheXMoJyAnKSksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLmpvaW4oJycpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5yZXBsYWNlKC9eKD8hJCkvZ20pKTtcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGZvcm1hdCA9IFIuY29udmVyZ2UoUi5jYWxsLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5waXBlKFIucHJvcCgnaW5kZW50JyksIGluZGVudE4pLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5wcm9wKCd2YWx1ZScpKTtcbiAgICAgKlxuICAgICAqICAgICAgZm9ybWF0KHtpbmRlbnQ6IDIsIHZhbHVlOiAnZm9vXFxuYmFyXFxuYmF6XFxuJ30pOyAvLz0+ICcgIGZvb1xcbiAgYmFyXFxuICBiYXpcXG4nXG4gICAgICovXG4gICAgdmFyIGNhbGwgPSBjdXJyeShmdW5jdGlvbiBjYWxsKGZuKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBgY2hhaW5gIG1hcHMgYSBmdW5jdGlvbiBvdmVyIGEgbGlzdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSByZXN1bHRzLlxuICAgICAqIGBjaGFpbmAgaXMgYWxzbyBrbm93biBhcyBgZmxhdE1hcGAgaW4gc29tZSBsaWJyYXJpZXNcbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBjaGFpbmAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBbYl0pIC0+IFthXSAtPiBbYl1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgZHVwbGljYXRlID0gbiA9PiBbbiwgbl07XG4gICAgICogICAgICBSLmNoYWluKGR1cGxpY2F0ZSwgWzEsIDIsIDNdKTsgLy89PiBbMSwgMSwgMiwgMiwgMywgM11cbiAgICAgKi9cbiAgICB2YXIgY2hhaW4gPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2NoYWluJywgX3hjaGFpbiwgZnVuY3Rpb24gY2hhaW4oZm4sIG1vbmFkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9uYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbmFkLmNhbGwodGhpcywgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9tYWtlRmxhdChmYWxzZSkobWFwKGZuLCBtb25hZCkpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGEgbGlzdCBvZiBGdW5jdG9ycyBpbnRvIGEgRnVuY3RvciBvZiBhIGxpc3QsIGFwcGx5aW5nXG4gICAgICogYSBtYXBwaW5nIGZ1bmN0aW9uIHRvIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdCBhbG9uZyB0aGUgd2F5LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzZWUgUi5jb21tdXRlXG4gICAgICogQHNpZyBGdW5jdG9yIGYgPT4gKGEgLT4gZiBiKSAtPiAoeCAtPiBmIHgpIC0+IFthXSAtPiBmIFtiXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9mIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkYXRhIHR5cGUgdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBmdW5jdG9ycyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgYWRkMTAgPSBSLm1hcChSLmFkZCgxMCkpO1xuICAgICAqICAgICAgUi5jb21tdXRlTWFwKGFkZDEwLCBSLm9mLCBbWzFdLCBbMiwgM11dKTsgICAvLz0+IFtbMTEsIDEyXSwgWzExLCAxM11dXG4gICAgICogICAgICBSLmNvbW11dGVNYXAoYWRkMTAsIFIub2YsIFtbMSwgMl0sIFszXV0pOyAgIC8vPT4gW1sxMSwgMTNdLCBbMTIsIDEzXV1cbiAgICAgKiAgICAgIFIuY29tbXV0ZU1hcChhZGQxMCwgUi5vZiwgW1sxXSwgWzJdLCBbM11dKTsgLy89PiBbWzExLCAxMiwgMTNdXVxuICAgICAqICAgICAgUi5jb21tdXRlTWFwKGFkZDEwLCBNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldKTsgICAvLz0+IEp1c3QoWzExLCAxMiwgMTNdKVxuICAgICAqICAgICAgUi5jb21tdXRlTWFwKGFkZDEwLCBNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIE5vdGhpbmcoKV0pOyAvLz0+IE5vdGhpbmcoKVxuICAgICAqXG4gICAgICogICAgICB2YXIgZmV0Y2ggPSB1cmwgPT4gRnV0dXJlKChyZWosIHJlcykgPT4gaHR0cC5nZXQodXJsLCByZXMpLm9uKCdlcnJvcicsIHJlaikpO1xuICAgICAqICAgICAgUi5jb21tdXRlTWFwKGZldGNoLCBGdXR1cmUub2YsIFtcbiAgICAgKiAgICAgICAgJ2h0dHA6Ly9yYW1kYWpzLmNvbScsXG4gICAgICogICAgICAgICdodHRwOi8vZ2l0aHViLmNvbS9yYW1kYSdcbiAgICAgKiAgICAgIF0pOyAvLz0+IEZ1dHVyZShbSW5jb21pbmdNZXNzYWdlLCBJbmNvbWluZ01lc3NhZ2VdKVxuICAgICAqL1xuICAgIHZhciBjb21tdXRlTWFwID0gX2N1cnJ5MyhmdW5jdGlvbiBjb21tdXRlTWFwKGZuLCBvZiwgbGlzdCkge1xuICAgICAgICBmdW5jdGlvbiBjb25zRihhY2MsIHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcChtYXAocHJlcGVuZCwgZm4oeCkpLCBhY2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWR1Y2VSaWdodChjb25zRiwgb2YoW10pLCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCB0aGUgc2FtZVxuICAgICAqIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgc2FtZSB0eXBlLiBUaGUgYXJpdHkgb2YgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIHNwZWNpZmllZFxuICAgICAqIHRvIGFsbG93IHVzaW5nIHZhcmlhZGljIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuNC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gKCogLT4geyp9KSAtPiAoKiAtPiB7Kn0pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGFyaXR5IG9mIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBGbiBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSB3cmFwcGVkLCBjdXJyaWVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC8vIFZhcmlhZGljIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gICAgICogICAgICB2YXIgV2lkZ2V0ID0gKCkgPT4ge1xuICAgICAqICAgICAgICB0aGlzLmNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgV2lkZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICB9O1xuICAgICAqICAgICAgdmFyIGFsbENvbmZpZ3MgPSBbXG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICAgXTtcbiAgICAgKiAgICAgIFIubWFwKFIuY29uc3RydWN0TigxLCBXaWRnZXQpLCBhbGxDb25maWdzKTsgLy8gYSBsaXN0IG9mIFdpZGdldHNcbiAgICAgKi9cbiAgICB2YXIgY29uc3RydWN0TiA9IF9jdXJyeTIoZnVuY3Rpb24gY29uc3RydWN0TihuLCBGbikge1xuICAgICAgICBpZiAobiA+IDEwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cnVjdG9yIHdpdGggZ3JlYXRlciB0aGFuIHRlbiBhcmd1bWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZuKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyeShuQXJ5KG4sIGZ1bmN0aW9uICgkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSkge1xuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigkMCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMik7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMyk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNik7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCwgJDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgY29udmVyZ2luZyBmdW5jdGlvbiBhbmQgYSBsaXN0IG9mIGJyYW5jaGluZyBmdW5jdGlvbnMgYW5kIHJldHVybnMgYSBuZXcgZnVuY3Rpb24uXG4gICAgICogV2hlbiBpbnZva2VkLCB0aGlzIG5ldyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHNvbWUgYXJndW1lbnRzLCBlYWNoIGJyYW5jaGluZ1xuICAgICAqIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gdGhvc2Ugc2FtZSBhcmd1bWVudHMuIFRoZSByZXN1bHRzIG9mIGVhY2ggYnJhbmNoaW5nXG4gICAgICogZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBhcmd1bWVudHMgdG8gdGhlIGNvbnZlcmdpbmcgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC40LjJcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICh4MSAtPiB4MiAtPiAuLi4gLT4geikgLT4gWyhhIC0+IGIgLT4gLi4uIC0+IHgxKSwgKGEgLT4gYiAtPiAuLi4gLT4geDIpLCAuLi5dIC0+IChhIC0+IGIgLT4gLi4uIC0+IHopXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWZ0ZXIgQSBmdW5jdGlvbi4gYGFmdGVyYCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlcyBvZlxuICAgICAqICAgICAgICBgZm4xYCBhbmQgYGZuMmAgYXMgaXRzIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGZ1bmN0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZCA9IChhLCBiKSA9PiBhICsgYjtcbiAgICAgKiAgICAgIHZhciBtdWx0aXBseSA9IChhLCBiKSA9PiBhICogYjtcbiAgICAgKiAgICAgIHZhciBzdWJ0cmFjdCA9IChhLCBiKSA9PiBhIC0gYjtcbiAgICAgKlxuICAgICAqICAgICAgLy/iiYUgbXVsdGlwbHkoIGFkZCgxLCAyKSwgc3VidHJhY3QoMSwgMikgKTtcbiAgICAgKiAgICAgIFIuY29udmVyZ2UobXVsdGlwbHksIFthZGQsIHN1YnRyYWN0XSkoMSwgMik7IC8vPT4gLTNcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFkZDMgPSAoYSwgYiwgYykgPT4gYSArIGIgKyBjO1xuICAgICAqICAgICAgUi5jb252ZXJnZShhZGQzLCBbbXVsdGlwbHksIGFkZCwgc3VidHJhY3RdKSgxLCAyKTsgLy89PiA0XG4gICAgICovXG4gICAgdmFyIGNvbnZlcmdlID0gX2N1cnJ5MihmdW5jdGlvbiBjb252ZXJnZShhZnRlciwgZm5zKSB7XG4gICAgICAgIHJldHVybiBjdXJyeU4oTWF0aC5tYXguYXBwbHkoTWF0aCwgcGx1Y2soJ2xlbmd0aCcsIGZucykpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBhZnRlci5hcHBseShjb250ZXh0LCBfbWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH0sIGZucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gICAgICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgZHJvcGAgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2VlIFIudHJhbnNkdWNlXG4gICAgICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLnRha2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRyb3AoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi5kcm9wKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICAgICAqICAgICAgUi5kcm9wKDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIuZHJvcCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gICAgICogICAgICBSLmRyb3AoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnZGEnXG4gICAgICovXG4gICAgdmFyIGRyb3AgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoJ2Ryb3AnLCBfeGRyb3AsIGZ1bmN0aW9uIGRyb3AobiwgeHMpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKE1hdGgubWF4KDAsIG4pLCBJbmZpbml0eSwgeHMpO1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGBsaXN0YC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIGB4c2AgdG8gc2tpcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAc2VlIFIudGFrZUxhc3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmRyb3BMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKiAgICAgIFIuZHJvcExhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gICAgICogICAgICBSLmRyb3BMYXN0KDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gW11cbiAgICAgKiAgICAgIFIuZHJvcExhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICAgICAqICAgICAgUi5kcm9wTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdyYSdcbiAgICAgKi9cbiAgICB2YXIgZHJvcExhc3QgPSBfY3VycnkyKGZ1bmN0aW9uIGRyb3BMYXN0KG4sIHhzKSB7XG4gICAgICAgIHJldHVybiB0YWtlKG4gPCB4cy5sZW5ndGggPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgYW55IGNvbnNlY3V0aXZlbHkgcmVwZWF0aW5nIGVsZW1lbnRzLiBFcXVhbGl0eSBpc1xuICAgICAqIGRldGVybWluZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0d28gY29uc2VjdXRpdmUgZWxlbWVudHMuXG4gICAgICogVGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzZXJpZXMgb2YgZXF1YWwgZWxlbWVudCBpcyB0aGUgb25lIGJlaW5nIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wUmVwZWF0c1dpdGhgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICAgICAqIEBzZWUgUi50cmFuc2R1Y2VcbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSwgYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBgbGlzdGAgd2l0aG91dCByZXBlYXRpbmcgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGxlbmd0aEVxID0gKHgsIHkpID0+IE1hdGguYWJzKHgpID09PSBNYXRoLmFicyh5KTtcbiAgICAgKiAgICAgIHZhciBsID0gWzEsIC0xLCAxLCAzLCA0LCAtNCwgLTQsIC01LCA1LCAzLCAzXTtcbiAgICAgKiAgICAgIFIuZHJvcFJlcGVhdHNXaXRoKFIuZXFCeShNYXRoLmFicyksIGwpOyAvLz0+IFsxLCAzLCA0LCAtNSwgM11cbiAgICAgKi9cbiAgICB2YXIgZHJvcFJlcGVhdHNXaXRoID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdkcm9wUmVwZWF0c1dpdGgnLCBfeGRyb3BSZXBlYXRzV2l0aCwgZnVuY3Rpb24gZHJvcFJlcGVhdHNXaXRoKHByZWQsIGxpc3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgaWR4ID0gMTtcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSBsaXN0WzBdO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgICAgICAgICAgIGlmICghcHJlZChsYXN0KHJlc3VsdCksIGxpc3RbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMgaW4gaXRzIGRvbWFpbiBhbmQgcmV0dXJucyBgdHJ1ZWAgaWZcbiAgICAgKiB0aGUgdmFsdWVzIG1hcCB0byB0aGUgc2FtZSB2YWx1ZSBpbiB0aGUgY29kb21haW47IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xOC4wXG4gICAgICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gICAgICogQHNpZyAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAgKiBAcGFyYW0geyp9IHhcbiAgICAgKiBAcGFyYW0geyp9IHlcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZXFCeShNYXRoLmFicywgNSwgLTUpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgZXFCeSA9IF9jdXJyeTMoZnVuY3Rpb24gZXFCeShmLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBlcXVhbHMoZih4KSwgZih5KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIHdoZXRoZXIgdHdvIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaW4gYFIuZXF1YWxzYCB0ZXJtcyxcbiAgICAgKiBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS4gVXNlZnVsIGFzIGEgY3VycmllZCBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIGsgLT4ge2s6IHZ9IC0+IHtrOiB2fSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBvMSA9IHsgYTogMSwgYjogMiwgYzogMywgZDogNCB9O1xuICAgICAqICAgICAgdmFyIG8yID0geyBhOiAxMCwgYjogMjAsIGM6IDMsIGQ6IDQwIH07XG4gICAgICogICAgICBSLmVxUHJvcHMoJ2EnLCBvMSwgbzIpOyAvLz0+IGZhbHNlXG4gICAgICogICAgICBSLmVxUHJvcHMoJ2MnLCBvMSwgbzIpOyAvLz0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgZXFQcm9wcyA9IF9jdXJyeTMoZnVuY3Rpb24gZXFQcm9wcyhwcm9wLCBvYmoxLCBvYmoyKSB7XG4gICAgICAgIHJldHVybiBlcXVhbHMob2JqMVtwcm9wXSwgb2JqMltwcm9wXSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAgICAqIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuIGBSLmVxdWFsc2AgaXMgdXNlZCB0b1xuICAgICAqIGRldGVybWluZSBlcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gICAgICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAc2VlIFIubGFzdEluZGV4T2ZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluZGV4T2YoMywgWzEsMiwzLDRdKTsgLy89PiAyXG4gICAgICogICAgICBSLmluZGV4T2YoMTAsIFsxLDIsMyw0XSk7IC8vPT4gLTFcbiAgICAgKi9cbiAgICB2YXIgaW5kZXhPZiA9IF9jdXJyeTIoZnVuY3Rpb24gaW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeHMuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpID8geHMuaW5kZXhPZih0YXJnZXQpIDogX2luZGV4T2YoeHMsIHRhcmdldCwgMCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNlZSBSLmxhc3QsIFIuaGVhZCwgUi50YWlsXG4gICAgICogQHNpZyBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBsaXN0XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmluaXQoWzEsIDIsIDNdKTsgIC8vPT4gWzEsIDJdXG4gICAgICogICAgICBSLmluaXQoWzEsIDJdKTsgICAgIC8vPT4gWzFdXG4gICAgICogICAgICBSLmluaXQoWzFdKTsgICAgICAgIC8vPT4gW11cbiAgICAgKiAgICAgIFIuaW5pdChbXSk7ICAgICAgICAgLy89PiBbXVxuICAgICAqXG4gICAgICogICAgICBSLmluaXQoJ2FiYycpOyAgLy89PiAnYWInXG4gICAgICogICAgICBSLmluaXQoJ2FiJyk7ICAgLy89PiAnYSdcbiAgICAgKiAgICAgIFIuaW5pdCgnYScpOyAgICAvLz0+ICcnXG4gICAgICogICAgICBSLmluaXQoJycpOyAgICAgLy89PiAnJ1xuICAgICAqL1xuICAgIHZhciBpbml0ID0gc2xpY2UoMCwgLTEpO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaXRlbXMgb2YgdGhlIGxpc3Qgd2l0aCB0aGUgdHJhbnNkdWNlciBhbmQgYXBwZW5kcyB0aGUgdHJhbnNmb3JtZWQgaXRlbXMgdG9cbiAgICAgKiB0aGUgYWNjdW11bGF0b3IgdXNpbmcgYW4gYXBwcm9wcmlhdGUgaXRlcmF0b3IgZnVuY3Rpb24gYmFzZWQgb24gdGhlIGFjY3VtdWxhdG9yIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgYWNjdW11bGF0b3IgY2FuIGJlIGFuIGFycmF5LCBzdHJpbmcsIG9iamVjdCBvciBhIHRyYW5zZm9ybWVyLiBJdGVyYXRlZCBpdGVtcyB3aWxsXG4gICAgICogYmUgYXBwZW5kZWQgdG8gYXJyYXlzIGFuZCBjb25jYXRlbmF0ZWQgdG8gc3RyaW5ncy4gT2JqZWN0cyB3aWxsIGJlIG1lcmdlZCBkaXJlY3RseSBvciAyLWl0ZW1cbiAgICAgKiBhcnJheXMgd2lsbCBiZSBtZXJnZWQgYXMga2V5LCB2YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIFRoZSBhY2N1bXVsYXRvciBjYW4gYWxzbyBiZSBhIHRyYW5zZm9ybWVyIG9iamVjdCB0aGF0IHByb3ZpZGVzIGEgMi1hcml0eSByZWR1Y2luZyBpdGVyYXRvclxuICAgICAqIGZ1bmN0aW9uLCBzdGVwLCAwLWFyaXR5IGluaXRpYWwgdmFsdWUgZnVuY3Rpb24sIGluaXQsIGFuZCAxLWFyaXR5IHJlc3VsdCBleHRyYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogcmVzdWx0LiBUaGUgc3RlcCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBpbiByZWR1Y2UuIFRoZSByZXN1bHQgZnVuY3Rpb24gaXNcbiAgICAgKiB1c2VkIHRvIGNvbnZlcnQgdGhlIGZpbmFsIGFjY3VtdWxhdG9yIGludG8gdGhlIHJldHVybiB0eXBlIGFuZCBpbiBtb3N0IGNhc2VzIGlzIFIuaWRlbnRpdHkuXG4gICAgICogVGhlIGluaXQgZnVuY3Rpb24gaXMgdXNlZCB0byBwcm92aWRlIHRoZSBpbml0aWFsIGFjY3VtdWxhdG9yLlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdGlvbiBpcyBwZXJmb3JtZWQgd2l0aCBSLnJlZHVjZSBhZnRlciBpbml0aWFsaXppbmcgdGhlIHRyYW5zZHVjZXIuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgYSAtPiAoYiAtPiBiKSAtPiBbY10gLT4gYVxuICAgICAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBpbml0aWFsIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIFRoZSB0cmFuc2R1Y2VyIGZ1bmN0aW9uLiBSZWNlaXZlcyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGEgdHJhbnNmb3JtZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgbnVtYmVycyA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiAgICAgIHZhciB0cmFuc2R1Y2VyID0gUi5jb21wb3NlKFIubWFwKFIuYWRkKDEpKSwgUi50YWtlKDIpKTtcbiAgICAgKlxuICAgICAqICAgICAgUi5pbnRvKFtdLCB0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGludG9BcnJheSA9IFIuaW50byhbXSk7XG4gICAgICogICAgICBpbnRvQXJyYXkodHJhbnNkdWNlciwgbnVtYmVycyk7IC8vPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludG8gPSBfY3VycnkzKGZ1bmN0aW9uIGludG8oYWNjLCB4ZiwgbGlzdCkge1xuICAgICAgICByZXR1cm4gX2lzVHJhbnNmb3JtZXIoYWNjKSA/IF9yZWR1Y2UoeGYoYWNjKSwgYWNjWydAQHRyYW5zZHVjZXIvaW5pdCddKCksIGxpc3QpIDogX3JlZHVjZSh4Zihfc3RlcENhdChhY2MpKSwgYWNjLCBsaXN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBhcmUgdW5pcXVlLCBpbiBgUi5lcXVhbHNgIHRlcm1zLFxuICAgICAqIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjFcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgW2FdIC0+IEJvb2xlYW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIFIuYWxsVW5pcVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjE4LjBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmlzU2V0KFsnMScsIDFdKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmlzU2V0KFsxLCAxXSk7ICAgLy89PiBmYWxzZVxuICAgICAqICAgICAgUi5pc1NldChbWzQyXSwgWzQyXV0pOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gYWxsVW5pcTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsZW5zIGZvciB0aGUgZ2l2ZW4gZ2V0dGVyIGFuZCBzZXR0ZXIgZnVuY3Rpb25zLiBUaGUgZ2V0dGVyIFwiZ2V0c1wiXG4gICAgICogdGhlIHZhbHVlIG9mIHRoZSBmb2N1czsgdGhlIHNldHRlciBcInNldHNcIiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzLiBUaGUgc2V0dGVyXG4gICAgICogc2hvdWxkIG5vdCBtdXRhdGUgdGhlIGRhdGEgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIChzIC0+IGEpIC0+ICgoYSwgcykgLT4gcykgLT4gTGVucyBzIGFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKiBAcmV0dXJuIHtMZW5zfVxuICAgICAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4TGVucyA9IFIubGVucyhSLnByb3AoJ3gnKSwgUi5hc3NvYygneCcpKTtcbiAgICAgKlxuICAgICAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICAgICAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gICAgICogICAgICBSLm92ZXIoeExlbnMsIFIubmVnYXRlLCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogLTEsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIGxlbnMgPSBfY3VycnkyKGZ1bmN0aW9uIGxlbnMoZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0ZXIodiwgcyk7XG4gICAgICAgICAgICAgICAgfSwgZihnZXR0ZXIocykpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gICAgICogQHNpZyBOdW1iZXIgLT4gTGVucyBzIGFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgICAqIEByZXR1cm4ge0xlbnN9XG4gICAgICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAgICAgKlxuICAgICAqICAgICAgUi52aWV3KGhlYWRMZW5zLCBbJ2EnLCAnYicsICdjJ10pOyAgICAgICAgICAgIC8vPT4gJ2EnXG4gICAgICogICAgICBSLnNldChoZWFkTGVucywgJ3gnLCBbJ2EnLCAnYicsICdjJ10pOyAgICAgICAgLy89PiBbJ3gnLCAnYicsICdjJ11cbiAgICAgKiAgICAgIFIub3ZlcihoZWFkTGVucywgUi50b1VwcGVyLCBbJ2EnLCAnYicsICdjJ10pOyAvLz0+IFsnQScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciBsZW5zSW5kZXggPSBfY3VycnkxKGZ1bmN0aW9uIGxlbnNJbmRleChuKSB7XG4gICAgICAgIHJldHVybiBsZW5zKG50aChuKSwgdXBkYXRlKG4pKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsZW5zIHdob3NlIGZvY3VzIGlzIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBMZW5zIHMgYVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrXG4gICAgICogQHJldHVybiB7TGVuc31cbiAgICAgKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciB4TGVucyA9IFIubGVuc1Byb3AoJ3gnKTtcbiAgICAgKlxuICAgICAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICAgICAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gICAgICogICAgICBSLm92ZXIoeExlbnMsIFIubmVnYXRlLCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogLTEsIHk6IDJ9XG4gICAgICovXG4gICAgdmFyIGxlbnNQcm9wID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5zUHJvcChrKSB7XG4gICAgICAgIHJldHVybiBsZW5zKHByb3AoayksIGFzc29jKGspKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFwibGlmdHNcIiBhIGZ1bmN0aW9uIHRvIGJlIHRoZSBzcGVjaWZpZWQgYXJpdHksIHNvIHRoYXQgaXQgbWF5IFwibWFwIG92ZXJcIiB0aGF0IG1hbnlcbiAgICAgKiBsaXN0cyAob3Igb3RoZXIgRnVuY3RvcnMpLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC43LjBcbiAgICAgKiBAc2VlIFIubGlmdFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgTnVtYmVyIC0+ICgqLi4uIC0+ICopIC0+IChbKl0uLi4gLT4gWypdKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBsaWZ0IGludG8gaGlnaGVyIGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIGBmbmAgYXBwbGljYWJsZSB0byBtYXBwYWJsZSBvYmplY3RzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBtYWRkMyA9IFIubGlmdE4oMywgUi5jdXJyeU4oMywgKCkgPT4gUi5yZWR1Y2UoUi5hZGQsIDAsIGFyZ3VtZW50cykpKTtcbiAgICAgKiAgICAgIG1hZGQzKFsxLDIsM10sIFsxLDIsM10sIFsxXSk7IC8vPT4gWzMsIDQsIDUsIDQsIDUsIDYsIDUsIDYsIDddXG4gICAgICovXG4gICAgdmFyIGxpZnROID0gX2N1cnJ5MihmdW5jdGlvbiBsaWZ0Tihhcml0eSwgZm4pIHtcbiAgICAgICAgdmFyIGxpZnRlZCA9IGN1cnJ5Tihhcml0eSwgZm4pO1xuICAgICAgICByZXR1cm4gY3VycnlOKGFyaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZHVjZShhcCwgbWFwKGxpZnRlZCwgYXJndW1lbnRzWzBdKSwgX3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1lYW4gb2YgdGhlIGdpdmVuIGxpc3Qgb2YgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWVhbihbMiwgNywgOV0pOyAvLz0+IDZcbiAgICAgKiAgICAgIFIubWVhbihbXSk7IC8vPT4gTmFOXG4gICAgICovXG4gICAgdmFyIG1lYW4gPSBfY3VycnkxKGZ1bmN0aW9uIG1lYW4obGlzdCkge1xuICAgICAgICByZXR1cm4gc3VtKGxpc3QpIC8gbGlzdC5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZWRpYW4gb2YgdGhlIGdpdmVuIGxpc3Qgb2YgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIubWVkaWFuKFsyLCA5LCA3XSk7IC8vPT4gN1xuICAgICAqICAgICAgUi5tZWRpYW4oWzcsIDIsIDEwLCA5XSk7IC8vPT4gOFxuICAgICAqICAgICAgUi5tZWRpYW4oW10pOyAvLz0+IE5hTlxuICAgICAqL1xuICAgIHZhciBtZWRpYW4gPSBfY3VycnkxKGZ1bmN0aW9uIG1lZGlhbihsaXN0KSB7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSAyIC0gbGVuICUgMjtcbiAgICAgICAgdmFyIGlkeCA9IChsZW4gLSB3aWR0aCkgLyAyO1xuICAgICAgICByZXR1cm4gbWVhbihfc2xpY2UobGlzdCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICB9KS5zbGljZShpZHgsIGlkeCArIHdpZHRoKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBsaXN0IG9mIG9iamVjdHMgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xMC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFt7azogdn1dIC0+IHtrOiB2fVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gQSBtZXJnZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgUi5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLm1lcmdlQWxsKFt7Zm9vOjF9LHtiYXI6Mn0se2JhejozfV0pOyAvLz0+IHtmb286MSxiYXI6MixiYXo6M31cbiAgICAgKiAgICAgIFIubWVyZ2VBbGwoW3tmb286MX0se2ZvbzoyfSx7YmFyOjJ9XSk7IC8vPT4ge2ZvbzoyLGJhcjoyfVxuICAgICAqL1xuICAgIHZhciBtZXJnZUFsbCA9IF9jdXJyeTEoZnVuY3Rpb24gbWVyZ2VBbGwobGlzdCkge1xuICAgICAgICByZXR1cm4gcmVkdWNlKG1lcmdlLCB7fSwgbGlzdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgbGVmdG1vc3QgZnVuY3Rpb24gbWF5IGhhdmVcbiAgICAgKiBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gICAgICpcbiAgICAgKiBJbiBzb21lIGxpYnJhcmllcyB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBzZXF1ZW5jZWAuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCgoYSwgYiwgLi4uLCBuKSAtPiBvKSwgKG8gLT4gcCksIC4uLiwgKHggLT4geSksICh5IC0+IHopKSAtPiAoKGEsIGIsIC4uLiwgbikgLT4geilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIuY29tcG9zZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBmID0gUi5waXBlKE1hdGgucG93LCBSLm5lZ2F0ZSwgUi5pbmMpO1xuICAgICAqXG4gICAgICogICAgICBmKDMsIDQpOyAvLyAtKDNeNCkgKyAxXG4gICAgICovXG4gICAgdmFyIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCwgcmVkdWNlKF9waXBlLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb25zLiBUaGUgbGVmdG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gICAgICogZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoYSAtPiBQcm9taXNlIGIpLCAoYiAtPiBQcm9taXNlIGMpLCAuLi4sICh5IC0+IFByb21pc2UgeikpIC0+IChhIC0+IFByb21pc2UgeilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIuY29tcG9zZVBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcl1cbiAgICAgKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5waXBlUChkYi5nZXRVc2VyQnlJZCwgZGIuZ2V0Rm9sbG93ZXJzKTtcbiAgICAgKi9cbiAgICB2YXIgcGlwZVAgPSBmdW5jdGlvbiBwaXBlUCgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGlwZVAgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hcml0eShhcmd1bWVudHNbMF0ubGVuZ3RoLCByZWR1Y2UoX3BpcGVQLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJvZHVjdCBvZiBhbGwgdGhlIG51bWJlcnMgaW4gdGhlIGxpc3QuXG4gICAgICogQHNlZSBSLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIucHJvZHVjdChbMiw0LDYsOCwxMDAsMV0pOyAvLz0+IDM4NDAwXG4gICAgICovXG4gICAgdmFyIHByb2R1Y3QgPSByZWR1Y2UobXVsdGlwbHksIDEpO1xuXG4gICAgLyoqXG4gICAgICogUmVhc29uYWJsZSBhbmFsb2cgdG8gU1FMIGBzZWxlY3RgIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgW2tdIC0+IFt7azogdn1dIC0+IFt7azogdn1dXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHByb2plY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpzIFRoZSBvYmplY3RzIHRvIHF1ZXJ5XG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBqdXN0IHRoZSBgcHJvcHNgIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGFiYnkgPSB7bmFtZTogJ0FiYnknLCBhZ2U6IDcsIGhhaXI6ICdibG9uZCcsIGdyYWRlOiAyfTtcbiAgICAgKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJywgZ3JhZGU6IDd9O1xuICAgICAqICAgICAgdmFyIGtpZHMgPSBbYWJieSwgZnJlZF07XG4gICAgICogICAgICBSLnByb2plY3QoWyduYW1lJywgJ2dyYWRlJ10sIGtpZHMpOyAvLz0+IFt7bmFtZTogJ0FiYnknLCBncmFkZTogMn0sIHtuYW1lOiAnRnJlZCcsIGdyYWRlOiA3fV1cbiAgICAgKi9cbiAgICAvLyBwYXNzaW5nIGBpZGVudGl0eWAgZ2l2ZXMgY29ycmVjdCBhcml0eVxuICAgIHZhciBwcm9qZWN0ID0gdXNlV2l0aChfbWFwLCBbXG4gICAgICAgIHBpY2tBbGwsXG4gICAgICAgIGlkZW50aXR5XG4gICAgXSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gICAgICogSWYgYG4gPiBsaXN0Lmxlbmd0aGAsIHJldHVybnMgYSBsaXN0IG9mIGBsaXN0Lmxlbmd0aGAgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE2LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAgICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gY29uc2lkZXIuXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQHNlZSBSLmRyb3BMYXN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50YWtlTGFzdCgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnYmF6J11cbiAgICAgKiAgICAgIFIudGFrZUxhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAgICAqICAgICAgUi50YWtlTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdtZGEnXG4gICAgICovXG4gICAgdmFyIHRha2VMYXN0ID0gX2N1cnJ5MihmdW5jdGlvbiB0YWtlTGFzdChuLCB4cykge1xuICAgICAgICByZXR1cm4gZHJvcChuID49IDAgPyB4cy5sZW5ndGggLSBuIDogMCwgeHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2hvcnRoYW5kIGZvciBgUi5jaGFpbihSLmlkZW50aXR5KWAsIHdoaWNoIHJlbW92ZXMgb25lIGxldmVsIG9mIG5lc3RpbmdcbiAgICAgKiBmcm9tIGFueSBbQ2hhaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW4pLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzaWcgQ2hhaW4gYyA9PiBjIChjIGEpIC0+IGMgYVxuICAgICAqIEBwYXJhbSB7Kn0gbGlzdFxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHNlZSBSLmZsYXR0ZW4sIFIuY2hhaW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVubmVzdChbMSwgWzJdLCBbWzNdXV0pOyAvLz0+IFsxLCAyLCBbM11dXG4gICAgICogICAgICBSLnVubmVzdChbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV0pOyAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2XVxuICAgICAqL1xuICAgIHZhciB1bm5lc3QgPSBjaGFpbihfaWRlbnRpdHkpO1xuXG4gICAgdmFyIF9jb250YWlucyA9IGZ1bmN0aW9uIF9jb250YWlucyhhLCBsaXN0KSB7XG4gICAgICAgIHJldHVybiBfaW5kZXhPZihsaXN0LCBhLCAwKSA+PSAwO1xuICAgIH07XG5cbiAgICAvLyAgbWFwUGFpcnMgOjogKE9iamVjdCwgW1N0cmluZ10pIC0+IFtTdHJpbmddXG4gICAgLy8gRnVuY3Rpb24sIFJlZ0V4cCwgdXNlci1kZWZpbmVkIHR5cGVzXG4gICAgdmFyIF90b1N0cmluZyA9IGZ1bmN0aW9uIF90b1N0cmluZyh4LCBzZWVuKSB7XG4gICAgICAgIHZhciByZWN1ciA9IGZ1bmN0aW9uIHJlY3VyKHkpIHtcbiAgICAgICAgICAgIHZhciB4cyA9IHNlZW4uY29uY2F0KFt4XSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRhaW5zKHksIHhzKSA/ICc8Q2lyY3VsYXI+JyA6IF90b1N0cmluZyh5LCB4cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vICBtYXBQYWlycyA6OiAoT2JqZWN0LCBbU3RyaW5nXSkgLT4gW1N0cmluZ11cbiAgICAgICAgdmFyIG1hcFBhaXJzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIF9tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3F1b3RlKGspICsgJzogJyArIHJlY3VyKG9ialtrXSk7XG4gICAgICAgICAgICB9LCBrZXlzLnNsaWNlKCkuc29ydCgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkpIHtcbiAgICAgICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzpcbiAgICAgICAgICAgIHJldHVybiAnKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCcgKyBfbWFwKHJlY3VyLCB4KS5qb2luKCcsICcpICsgJykpJztcbiAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgICAgICAgcmV0dXJuICdbJyArIF9tYXAocmVjdXIsIHgpLmNvbmNhdChtYXBQYWlycyh4LCByZWplY3QoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gL15cXGQrJC8udGVzdChrKTtcbiAgICAgICAgICAgIH0sIGtleXMoeCkpKSkuam9pbignLCAnKSArICddJztcbiAgICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBCb29sZWFuKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiB4LnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgICAgICAgcmV0dXJuICduZXcgRGF0ZSgnICsgX3F1b3RlKF90b0lTT1N0cmluZyh4KSkgKyAnKSc7XG4gICAgICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOlxuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IE51bWJlcignICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogMSAvIHggPT09IC1JbmZpbml0eSA/ICctMCcgOiB4LnRvU3RyaW5nKDEwKTtcbiAgICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IFN0cmluZygnICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogX3F1b3RlKHgpO1xuICAgICAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmIHguY29uc3RydWN0b3IubmFtZSAhPT0gJ09iamVjdCcgJiYgdHlwZW9mIHgudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgeC50b1N0cmluZygpICE9PSAnW29iamVjdCBPYmplY3RdJyA/IHgudG9TdHJpbmcoKSA6IC8vIEZ1bmN0aW9uLCBSZWdFeHAsIHVzZXItZGVmaW5lZCB0eXBlc1xuICAgICAgICAgICAgJ3snICsgbWFwUGFpcnMoeCwga2V5cyh4KSkuam9pbignLCAnKSArICd9JztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBhIGxpc3Qgb2YgRnVuY3RvcnMgaW50byBhIEZ1bmN0b3Igb2YgYSBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGlzdFxuICAgICAqIEBzZWUgUi5jb21tdXRlTWFwXG4gICAgICogQHNpZyBGdW5jdG9yIGYgPT4gKHggLT4gZiB4KSAtPiBbZiBhXSAtPiBmIFthXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9mIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkYXRhIHR5cGUgdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBmdW5jdG9ycyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmNvbW11dGUoUi5vZiwgW1sxXSwgWzIsIDNdXSk7ICAgLy89PiBbWzEsIDJdLCBbMSwgM11dXG4gICAgICogICAgICBSLmNvbW11dGUoUi5vZiwgW1sxLCAyXSwgWzNdXSk7ICAgLy89PiBbWzEsIDNdLCBbMiwgM11dXG4gICAgICogICAgICBSLmNvbW11dGUoUi5vZiwgW1sxXSwgWzJdLCBbM11dKTsgLy89PiBbWzEsIDIsIDNdXVxuICAgICAqICAgICAgUi5jb21tdXRlKE1heWJlLm9mLCBbSnVzdCgxKSwgSnVzdCgyKSwgSnVzdCgzKV0pOyAgIC8vPT4gSnVzdChbMSwgMiwgM10pXG4gICAgICogICAgICBSLmNvbW11dGUoTWF5YmUub2YsIFtKdXN0KDEpLCBKdXN0KDIpLCBOb3RoaW5nKCldKTsgLy89PiBOb3RoaW5nKClcbiAgICAgKi9cbiAgICB2YXIgY29tbXV0ZSA9IGNvbW11dGVNYXAoaWRlbnRpdHkpO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICAgICAqIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbykpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5waXBlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGYgPSBSLmNvbXBvc2UoUi5pbmMsIFIubmVnYXRlLCBNYXRoLnBvdyk7XG4gICAgICpcbiAgICAgKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZSA9IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvc2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGUuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmlnaHQtdG8tbGVmdCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogZWFjaCBvZiB3aGljaCBtdXN0IHJldHVybiBhIHZhbHVlIG9mIGEgdHlwZSBzdXBwb3J0ZWQgYnkgW2BjaGFpbmBdKCNjaGFpbikuXG4gICAgICpcbiAgICAgKiBgUi5jb21wb3NlSyhoLCBnLCBmKWAgaXMgZXF1aXZhbGVudCB0byBgUi5jb21wb3NlKFIuY2hhaW4oaCksIFIuY2hhaW4oZyksIFIuY2hhaW4oZikpYC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzZWUgUi5waXBlS1xuICAgICAqIEBzaWcgQ2hhaW4gbSA9PiAoKHkgLT4gbSB6KSwgKHggLT4gbSB5KSwgLi4uLCAoYSAtPiBtIGIpKSAtPiAobSBhIC0+IG0geilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBwYXJzZUpzb24gOjogU3RyaW5nIC0+IE1heWJlICpcbiAgICAgKiAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gICAgICpcbiAgICAgKiAgICAgIC8vICBnZXRTdGF0ZUNvZGUgOjogTWF5YmUgU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICAgICAqICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIuY29tcG9zZUsoXG4gICAgICogICAgICAgIFIuY29tcG9zZShNYXliZS5vZiwgUi50b1VwcGVyKSxcbiAgICAgKiAgICAgICAgZ2V0KCdzdGF0ZScpLFxuICAgICAqICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAgICAgKiAgICAgICAgZ2V0KCd1c2VyJyksXG4gICAgICogICAgICAgIHBhcnNlSnNvblxuICAgICAqICAgICAgKTtcbiAgICAgKlxuICAgICAqICAgICAgZ2V0U3RhdGVDb2RlKE1heWJlLm9mKCd7XCJ1c2VyXCI6e1wiYWRkcmVzc1wiOntcInN0YXRlXCI6XCJueVwifX19JykpO1xuICAgICAqICAgICAgLy89PiBKdXN0KCdOWScpXG4gICAgICogICAgICBnZXRTdGF0ZUNvZGUoTWF5YmUub2YoJ1tJbnZhbGlkIEpTT05dJykpO1xuICAgICAqICAgICAgLy89PiBOb3RoaW5nKClcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZUsgPSBmdW5jdGlvbiBjb21wb3NlSygpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkodGhpcywgcHJlcGVuZChpZGVudGl0eSwgbWFwKGNoYWluLCBhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHJpZ2h0LXRvLWxlZnQgY29tcG9zaXRpb24gb2Ygb25lIG9yIG1vcmUgUHJvbWlzZS1yZXR1cm5pbmdcbiAgICAgKiBmdW5jdGlvbnMuIFRoZSByaWdodG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gICAgICogZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgoeSAtPiBQcm9taXNlIHopLCAoeCAtPiBQcm9taXNlIHkpLCAuLi4sIChhIC0+IFByb21pc2UgYikpIC0+IChhIC0+IFByb21pc2UgeilcbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKiBAc2VlIFIucGlwZVBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcl1cbiAgICAgKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5jb21wb3NlUChkYi5nZXRGb2xsb3dlcnMsIGRiLmdldFVzZXJCeUlkKTtcbiAgICAgKi9cbiAgICB2YXIgY29tcG9zZVAgPSBmdW5jdGlvbiBjb21wb3NlUCgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZVAgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVQLmFwcGx5KHRoaXMsIHJldmVyc2UoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCB0aGUgc2FtZVxuICAgICAqIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgc2FtZSB0eXBlLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAc2lnICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAgKiAgICAgIHZhciBXaWRnZXQgPSBjb25maWcgPT4ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICBXaWRnZXQucHJvdG90eXBlID0ge1xuICAgICAqICAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgIH07XG4gICAgICogICAgICB2YXIgYWxsQ29uZmlncyA9IFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgICBdO1xuICAgICAqICAgICAgUi5tYXAoUi5jb25zdHJ1Y3QoV2lkZ2V0KSwgYWxsQ29uZmlncyk7IC8vIGEgbGlzdCBvZiBXaWRnZXRzXG4gICAgICovXG4gICAgdmFyIGNvbnN0cnVjdCA9IF9jdXJyeTEoZnVuY3Rpb24gY29uc3RydWN0KEZuKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3ROKEZuLmxlbmd0aCwgRm4pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBlcXVhbCwgaW4gYFIuZXF1YWxzYCB0ZXJtcyxcbiAgICAgKiB0byBhdCBsZWFzdCBvbmUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyBhIC0+IFthXSAtPiBCb29sZWFuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIGl0ZW0gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaXRlbSBpcyBpbiB0aGUgbGlzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogQHNlZSBSLmFueVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuY29udGFpbnMoMywgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLmNvbnRhaW5zKDQsIFsxLCAyLCAzXSk7IC8vPT4gZmFsc2VcbiAgICAgKiAgICAgIFIuY29udGFpbnMoWzQyXSwgW1s0Ml1dKTsgLy89PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGNvbnRhaW5zID0gX2N1cnJ5MihfY29udGFpbnMpO1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90IGNvbnRhaW5lZCBpbiB0aGUgc2Vjb25kIGxpc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgW2FdIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIHRoYXQgYXJlIG5vdCBpbiBgbGlzdDJgLlxuICAgICAqIEBzZWUgUi5kaWZmZXJlbmNlV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuZGlmZmVyZW5jZShbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbMSwyXVxuICAgICAqICAgICAgUi5kaWZmZXJlbmNlKFs3LDYsNSw0LDNdLCBbMSwyLDMsNF0pOyAvLz0+IFs3LDYsNV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IF9jdXJyeTIoZnVuY3Rpb24gZGlmZmVyZW5jZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBmaXJzdExlbiA9IGZpcnN0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgICAgICAgICBpZiAoIV9jb250YWlucyhmaXJzdFtpZHhdLCBzZWNvbmQpICYmICFfY29udGFpbnMoZmlyc3RbaWR4XSwgb3V0KSkge1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IGZpcnN0W2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgYW55IGNvbnNlY3V0aXZlbHkgcmVwZWF0aW5nIGVsZW1lbnRzLlxuICAgICAqIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgZHJvcFJlcGVhdHNgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gICAgICogQHNlZSBSLnRyYW5zZHVjZVxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYGxpc3RgIHdpdGhvdXQgcmVwZWF0aW5nIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgUi5kcm9wUmVwZWF0cyhbMSwgMSwgMSwgMiwgMywgNCwgNCwgMiwgMl0pOyAvLz0+IFsxLCAyLCAzLCA0LCAyXVxuICAgICAqL1xuICAgIHZhciBkcm9wUmVwZWF0cyA9IF9jdXJyeTEoX2Rpc3BhdGNoYWJsZSgnZHJvcFJlcGVhdHMnLCBfeGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpLCBkcm9wUmVwZWF0c1dpdGgoZXF1YWxzKSkpO1xuXG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhvc2UgZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICAgICAqIEBzaWcgW2FdIC0+IFthXSAtPiBbYV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gICAgICogQHNlZSBSLmludGVyc2VjdGlvbldpdGhcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZWxlbWVudHMgZm91bmQgaW4gYm90aCBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIuaW50ZXJzZWN0aW9uKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFs0LCAzXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBfY3VycnkyKGZ1bmN0aW9uIGludGVyc2VjdGlvbihsaXN0MSwgbGlzdDIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXEoX2ZpbHRlcihmbGlwKF9jb250YWlucykobGlzdDEpLCBsaXN0MikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogXCJsaWZ0c1wiIGEgZnVuY3Rpb24gb2YgYXJpdHkgPiAxIHNvIHRoYXQgaXQgbWF5IFwibWFwIG92ZXJcIiBhbiBBcnJheSBvclxuICAgICAqIG90aGVyIEZ1bmN0b3IuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjcuMFxuICAgICAqIEBzZWUgUi5saWZ0TlxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBzaWcgKCouLi4gLT4gKikgLT4gKFsqXS4uLiAtPiBbKl0pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGxpZnQgaW50byBoaWdoZXIgY29udGV4dFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gYGZuYCBhcHBsaWNhYmxlIHRvIG1hcHBhYmxlIG9iamVjdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG1hZGQzID0gUi5saWZ0KFIuY3VycnkoKGEsIGIsIGMpID0+IGEgKyBiICsgYykpO1xuICAgICAqXG4gICAgICogICAgICBtYWRkMyhbMSwyLDNdLCBbMSwyLDNdLCBbMV0pOyAvLz0+IFszLCA0LCA1LCA0LCA1LCA2LCA1LCA2LCA3XVxuICAgICAqXG4gICAgICogICAgICB2YXIgbWFkZDUgPSBSLmxpZnQoUi5jdXJyeSgoYSwgYiwgYywgZCwgZSkgPT4gYSArIGIgKyBjICsgZCArIGUpKTtcbiAgICAgKlxuICAgICAqICAgICAgbWFkZDUoWzEsMl0sIFszXSwgWzQsIDVdLCBbNl0sIFs3LCA4XSk7IC8vPT4gWzIxLCAyMiwgMjIsIDIzLCAyMiwgMjMsIDIzLCAyNF1cbiAgICAgKi9cbiAgICB2YXIgbGlmdCA9IF9jdXJyeTEoZnVuY3Rpb24gbGlmdChmbikge1xuICAgICAgICByZXR1cm4gbGlmdE4oZm4ubGVuZ3RoLCBmbik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBvbWl0dGluZyB0aGUga2V5cyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAc2lnIFtTdHJpbmddIC0+IHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9XG4gICAgICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIG9taXQgZnJvbSB0aGUgbmV3IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG5vdCBvbiBpdC5cbiAgICAgKiBAc2VlIFIucGlja1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIub21pdChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBjOiAzfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gX2N1cnJ5MihmdW5jdGlvbiBvbWl0KG5hbWVzLCBvYmopIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFfY29udGFpbnMocHJvcCwgbmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZWZ0LXRvLXJpZ2h0IEtsZWlzbGkgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAgICAgKlxuICAgICAqIGBSLnBpcGVLKGYsIGcsIGgpYCBpcyBlcXVpdmFsZW50IHRvIGBSLnBpcGUoUi5jaGFpbihmKSwgUi5jaGFpbihnKSwgUi5jaGFpbihoKSlgLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xNi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNlZSBSLmNvbXBvc2VLXG4gICAgICogQHNpZyBDaGFpbiBtID0+ICgoYSAtPiBtIGIpLCAoYiAtPiBtIGMpLCAuLi4sICh5IC0+IG0geikpIC0+IChtIGEgLT4gbSB6KVxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgLy8gIHBhcnNlSnNvbiA6OiBTdHJpbmcgLT4gTWF5YmUgKlxuICAgICAqICAgICAgLy8gIGdldCA6OiBTdHJpbmcgLT4gT2JqZWN0IC0+IE1heWJlICpcbiAgICAgKlxuICAgICAqICAgICAgLy8gIGdldFN0YXRlQ29kZSA6OiBNYXliZSBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gICAgICogICAgICB2YXIgZ2V0U3RhdGVDb2RlID0gUi5waXBlSyhcbiAgICAgKiAgICAgICAgcGFyc2VKc29uLFxuICAgICAqICAgICAgICBnZXQoJ3VzZXInKSxcbiAgICAgKiAgICAgICAgZ2V0KCdhZGRyZXNzJyksXG4gICAgICogICAgICAgIGdldCgnc3RhdGUnKSxcbiAgICAgKiAgICAgICAgUi5jb21wb3NlKE1heWJlLm9mLCBSLnRvVXBwZXIpXG4gICAgICogICAgICApO1xuICAgICAqXG4gICAgICogICAgICBnZXRTdGF0ZUNvZGUoTWF5YmUub2YoJ3tcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0nKSk7XG4gICAgICogICAgICAvLz0+IEp1c3QoJ05ZJylcbiAgICAgKiAgICAgIGdldFN0YXRlQ29kZShNYXliZS5vZignW0ludmFsaWQgSlNPTl0nKSk7XG4gICAgICogICAgICAvLz0+IE5vdGhpbmcoKVxuICAgICAqL1xuICAgIHZhciBwaXBlSyA9IGZ1bmN0aW9uIHBpcGVLKCkge1xuICAgICAgICByZXR1cm4gY29tcG9zZUsuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS4gYGV2YWxgJ2luZyB0aGUgb3V0cHV0XG4gICAgICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICAgICAqIGB0b1N0cmluZ2AgbWV0aG9kcyBkbyBub3Qgc2F0aXNmeSB0aGlzIHJlcXVpcmVtZW50LlxuICAgICAqXG4gICAgICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICAgICAqIHRoYW4gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLCB0aGlzIG1ldGhvZCBpcyBpbnZva2VkIHdpdGggbm8gYXJndW1lbnRzXG4gICAgICogdG8gcHJvZHVjZSB0aGUgcmV0dXJuIHZhbHVlLiBUaGlzIG1lYW5zIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3RvciBmdW5jdGlvbnNcbiAgICAgKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgICogICAgICAgdGhpcy54ID0geDtcbiAgICAgKiAgICAgICB0aGlzLnkgPSB5O1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgcmV0dXJuICduZXcgUG9pbnQoJyArIHRoaXMueCArICcsICcgKyB0aGlzLnkgKyAnKSc7XG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiAgICAgUi50b1N0cmluZyhuZXcgUG9pbnQoMSwgMikpOyAvLz0+ICduZXcgUG9pbnQoMSwgMiknXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyAqIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIFIudG9TdHJpbmcoNDIpOyAvLz0+ICc0MidcbiAgICAgKiAgICAgIFIudG9TdHJpbmcoJ2FiYycpOyAvLz0+ICdcImFiY1wiJ1xuICAgICAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gICAgICogICAgICBSLnRvU3RyaW5nKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSk7IC8vPT4gJ3tcImJhclwiOiAyLCBcImJhelwiOiAzLCBcImZvb1wiOiAxfSdcbiAgICAgKiAgICAgIFIudG9TdHJpbmcobmV3IERhdGUoJzIwMDEtMDItMDNUMDQ6MDU6MDZaJykpOyAvLz0+ICduZXcgRGF0ZShcIjIwMDEtMDItMDNUMDQ6MDU6MDYuMDAwWlwiKSdcbiAgICAgKi9cbiAgICB2YXIgdG9TdHJpbmcgPSBfY3VycnkxKGZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nKHZhbCwgW10pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBsaXN0LlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAgICAgKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXMgVGhlIGZpcnN0IGxpc3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYnMgVGhlIHNlY29uZCBsaXN0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmlyc3QgYW5kIHNlY29uZCBsaXN0cyBjb25jYXRlbmF0ZWQsIHdpdGhcbiAgICAgKiAgICAgICAgIGR1cGxpY2F0ZXMgcmVtb3ZlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnVuaW9uKFsxLCAyLCAzXSwgWzIsIDMsIDRdKTsgLy89PiBbMSwgMiwgMywgNF1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBfY3VycnkyKGNvbXBvc2UodW5pcSwgX2NvbmNhdCkpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSBvbmUgY29weSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlXG4gICAgICogb3JpZ2luYWwgbGlzdCwgYmFzZWQgdXBvbiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkXG4gICAgICogZnVuY3Rpb24gdG8gZWFjaCBsaXN0IGVsZW1lbnQuIFByZWZlcnMgdGhlIGZpcnN0IGl0ZW0gaWYgdGhlIHN1cHBsaWVkXG4gICAgICogZnVuY3Rpb24gcHJvZHVjZXMgdGhlIHNhbWUgdmFsdWUgb24gdHdvIGl0ZW1zLiBgUi5lcXVhbHNgIGlzIHVzZWQgZm9yXG4gICAgICogY29tcGFyaXNvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTYuMFxuICAgICAqIEBjYXRlZ29yeSBMaXN0XG4gICAgICogQHNpZyAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB1c2VkIHRvIHByb2R1Y2UgYSB2YWx1ZSB0byB1c2UgZHVyaW5nIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi51bmlxQnkoTWF0aC5hYnMsIFstMSwgLTUsIDIsIDEwLCAxLCAyXSk7IC8vPT4gWy0xLCAtNSwgMiwgMTBdXG4gICAgICovXG4gICAgdmFyIHVuaXFCeSA9IF9jdXJyeTIoZnVuY3Rpb24gdW5pcUJ5KGZuLCBsaXN0KSB7XG4gICAgICAgIHZhciBpZHggPSAwLCBhcHBsaWVkID0gW10sIHJlc3VsdCA9IFtdLCBhcHBsaWVkSXRlbSwgaXRlbTtcbiAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgYXBwbGllZEl0ZW0gPSBmbihpdGVtKTtcbiAgICAgICAgICAgIGlmICghX2NvbnRhaW5zKGFwcGxpZWRJdGVtLCBhcHBsaWVkKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGFwcGxpZWQucHVzaChhcHBsaWVkSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3cmFwcGluZyBjYWxscyB0byB0aGUgdHdvIGZ1bmN0aW9ucyBpbiBhbiBgJiZgIG9wZXJhdGlvbiwgcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0XG4gICAgICogZnVuY3Rpb24gaWYgaXQgaXMgZmFsc2UteSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIGBSLmJvdGhgIHdpbGwgd29yayBvbiBhbGwgb3RoZXIgYXBwbGljYXRpdmVzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBhIHByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGcgYW5vdGhlciBwcmVkaWNhdGVcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgaXRzIGFyZ3VtZW50cyB0byBgZmAgYW5kIGBnYCBhbmQgYCYmYHMgdGhlaXIgb3V0cHV0cyB0b2dldGhlci5cbiAgICAgKiBAc2VlIFIuYW5kXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGd0MTAgPSB4ID0+IHggPiAxMDtcbiAgICAgKiAgICAgIHZhciBldmVuID0geCA9PiB4ICUgMiA9PT0gMDtcbiAgICAgKiAgICAgIHZhciBmID0gUi5ib3RoKGd0MTAsIGV2ZW4pO1xuICAgICAqICAgICAgZigxMDApOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIGYoMTAxKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBib3RoID0gbGlmdChhbmQpO1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBmdW5jdGlvbiBgZmAgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2Agc3VjaCB0aGF0OlxuICAgICAqXG4gICAgICogICAtIGFwcGx5aW5nIGBnYCB0byB6ZXJvIG9yIG1vcmUgYXJndW1lbnRzIHdpbGwgZ2l2ZSBfX3RydWVfXyBpZiBhcHBseWluZ1xuICAgICAqICAgICB0aGUgc2FtZSBhcmd1bWVudHMgdG8gYGZgIGdpdmVzIGEgbG9naWNhbCBfX2ZhbHNlX18gdmFsdWU7IGFuZFxuICAgICAqXG4gICAgICogICAtIGFwcGx5aW5nIGBnYCB0byB6ZXJvIG9yIG1vcmUgYXJndW1lbnRzIHdpbGwgZ2l2ZSBfX2ZhbHNlX18gaWYgYXBwbHlpbmdcbiAgICAgKiAgICAgdGhlIHNhbWUgYXJndW1lbnRzIHRvIGBmYCBnaXZlcyBhIGxvZ2ljYWwgX190cnVlX18gdmFsdWUuXG4gICAgICpcbiAgICAgKiBgUi5jb21wbGVtZW50YCB3aWxsIHdvcmsgb24gYWxsIG90aGVyIGZ1bmN0b3JzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTG9naWNcbiAgICAgKiBAc2lnICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEBzZWUgUi5ub3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgaXNFdmVuID0gbiA9PiBuICUgMiA9PT0gMDtcbiAgICAgKiAgICAgIHZhciBpc09kZCA9IFIuY29tcGxlbWVudChpc0V2ZW4pO1xuICAgICAqICAgICAgaXNPZGQoMjEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIGlzT2RkKDQyKTsgLy89PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBjb21wbGVtZW50ID0gbGlmdChub3QpO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB3cmFwcGluZyBjYWxscyB0byB0aGUgdHdvIGZ1bmN0aW9ucyBpbiBhbiBgfHxgIG9wZXJhdGlvbiwgcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0XG4gICAgICogZnVuY3Rpb24gaWYgaXQgaXMgdHJ1dGgteSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIGBSLmVpdGhlcmAgd2lsbCB3b3JrIG9uIGFsbCBvdGhlciBhcHBsaWNhdGl2ZXMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMb2dpY1xuICAgICAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIGEgcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZyBhbm90aGVyIHByZWRpY2F0ZVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBpdHMgYXJndW1lbnRzIHRvIGBmYCBhbmQgYGdgIGFuZCBgfHxgcyB0aGVpciBvdXRwdXRzIHRvZ2V0aGVyLlxuICAgICAqIEBzZWUgUi5vclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBndDEwID0geCA9PiB4ID4gMTA7XG4gICAgICogICAgICB2YXIgZXZlbiA9IHggPT4geCAlIDIgPT09IDA7XG4gICAgICogICAgICB2YXIgZiA9IFIuZWl0aGVyKGd0MTAsIGV2ZW4pO1xuICAgICAqICAgICAgZigxMDEpOyAvLz0+IHRydWVcbiAgICAgKiAgICAgIGYoOCk7IC8vPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBlaXRoZXIgPSBsaWZ0KG9yKTtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGEgbmFtZWQgbWV0aG9kIHdpdGggYSBzcGVjaWZpZWQgYXJpdHkgaW50byBhIGZ1bmN0aW9uXG4gICAgICogdGhhdCBjYW4gYmUgY2FsbGVkIGRpcmVjdGx5IHN1cHBsaWVkIHdpdGggYXJndW1lbnRzIGFuZCBhIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgY3VycmllZCBhbmQgYWNjZXB0cyBgYXJpdHkgKyAxYCBwYXJhbWV0ZXJzIHdoZXJlXG4gICAgICogdGhlIGZpbmFsIHBhcmFtZXRlciBpcyB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IChhIC0+IGIgLT4gLi4uIC0+IG4gLT4gT2JqZWN0IC0+ICopXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyaXR5IE51bWJlciBvZiBhcmd1bWVudHMgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHNob3VsZCB0YWtlXG4gICAgICogICAgICAgIGJlZm9yZSB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgTmFtZSBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNsaWNlRnJvbSA9IFIuaW52b2tlcigxLCAnc2xpY2UnKTtcbiAgICAgKiAgICAgIHNsaWNlRnJvbSg2LCAnYWJjZGVmZ2hpamtsbScpOyAvLz0+ICdnaGlqa2xtJ1xuICAgICAqICAgICAgdmFyIHNsaWNlRnJvbTYgPSBSLmludm9rZXIoMiwgJ3NsaWNlJykoNik7XG4gICAgICogICAgICBzbGljZUZyb202KDgsICdhYmNkZWZnaGlqa2xtJyk7IC8vPT4gJ2doJ1xuICAgICAqL1xuICAgIHZhciBpbnZva2VyID0gX2N1cnJ5MihmdW5jdGlvbiBpbnZva2VyKGFyaXR5LCBtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5Tihhcml0eSArIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbYXJpdHldO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsICYmIGlzKEZ1bmN0aW9uLCB0YXJnZXRbbWV0aG9kXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W21ldGhvZF0uYXBwbHkodGFyZ2V0LCBfc2xpY2UoYXJndW1lbnRzLCAwLCBhcml0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyh0YXJnZXQpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgbWFkZSBieSBpbnNlcnRpbmcgdGhlIGBzZXBhcmF0b3JgIGJldHdlZW4gZWFjaFxuICAgICAqIGVsZW1lbnQgYW5kIGNvbmNhdGVuYXRpbmcgYWxsIHRoZSBlbGVtZW50cyBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBbYV0gLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBzZXBhcmF0b3IgVGhlIHN0cmluZyB1c2VkIHRvIHNlcGFyYXRlIHRoZSBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgZWxlbWVudHMgdG8gam9pbiBpbnRvIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgbWFkZSBieSBjb25jYXRlbmF0aW5nIGB4c2Agd2l0aCBgc2VwYXJhdG9yYC5cbiAgICAgKiBAc2VlIFIuc3BsaXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICB2YXIgc3BhY2VyID0gUi5qb2luKCcgJyk7XG4gICAgICogICAgICBzcGFjZXIoWydhJywgMiwgMy40XSk7ICAgLy89PiAnYSAyIDMuNCdcbiAgICAgKiAgICAgIFIuam9pbignfCcsIFsxLCAyLCAzXSk7ICAgIC8vPT4gJzF8MnwzJ1xuICAgICAqL1xuICAgIHZhciBqb2luID0gaW52b2tlcigxLCAnam9pbicpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIGNhY2hlcyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZuYCBmb3IgYSBnaXZlblxuICAgICAqIGFyZ3VtZW50IHNldCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBtZW1vaXplZCBgZm5gIHdpdGggdGhlIHNhbWVcbiAgICAgKiBhcmd1bWVudCBzZXQgd2lsbCBub3QgcmVzdWx0IGluIGFuIGFkZGl0aW9uYWwgY2FsbCB0byBgZm5gOyBpbnN0ZWFkLCB0aGUgY2FjaGVkIHJlc3VsdFxuICAgICAqIGZvciB0aGF0IHNldCBvZiBhcmd1bWVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHNpZyAoKi4uLiAtPiBhKSAtPiAoKi4uLiAtPiBhKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBNZW1vaXplZCB2ZXJzaW9uIG9mIGBmbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgKiAgICAgIHZhciBmYWN0b3JpYWwgPSBSLm1lbW9pemUobiA9PiB7XG4gICAgICogICAgICAgIGNvdW50ICs9IDE7XG4gICAgICogICAgICAgIHJldHVybiBSLnByb2R1Y3QoUi5yYW5nZSgxLCBuICsgMSkpO1xuICAgICAqICAgICAgfSk7XG4gICAgICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gICAgICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gICAgICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gICAgICogICAgICBjb3VudDsgLy89PiAxXG4gICAgICovXG4gICAgdmFyIG1lbW9pemUgPSBfY3VycnkxKGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICAgICAgdmFyIGNhY2hlID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdG9TdHJpbmcoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICghX2hhcyhrZXksIGNhY2hlKSkge1xuICAgICAgICAgICAgICAgIGNhY2hlW2tleV0gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBnaXZlblxuICAgICAqIHNlcGFyYXRvci5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBzaWcgKFN0cmluZyB8IFJlZ0V4cCkgLT4gU3RyaW5nIC0+IFtTdHJpbmddXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBzZXAgVGhlIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHNlcGFyYXRlIGludG8gYW4gYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBhcnJheSBvZiBzdHJpbmdzIGZyb20gYHN0cmAgc2VwYXJhdGVkIGJ5IGBzdHJgLlxuICAgICAqIEBzZWUgUi5qb2luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHBhdGhDb21wb25lbnRzID0gUi5zcGxpdCgnLycpO1xuICAgICAqICAgICAgUi50YWlsKHBhdGhDb21wb25lbnRzKCcvdXNyL2xvY2FsL2Jpbi9ub2RlJykpOyAvLz0+IFsndXNyJywgJ2xvY2FsJywgJ2JpbicsICdub2RlJ11cbiAgICAgKlxuICAgICAqICAgICAgUi5zcGxpdCgnLicsICdhLmIuYy54eXouZCcpOyAvLz0+IFsnYScsICdiJywgJ2MnLCAneHl6JywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBzcGxpdCA9IGludm9rZXIoMSwgJ3NwbGl0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMTIuMFxuICAgICAqIEBzZWUgUi5tYXRjaFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFJlZ0V4cCAtPiBTdHJpbmcgLT4gQm9vbGVhblxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50ZXN0KC9eeC8sICd4eXonKTsgLy89PiB0cnVlXG4gICAgICogICAgICBSLnRlc3QoL155LywgJ3h5eicpOyAvLz0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIHRlc3QgPSBfY3VycnkyKGZ1bmN0aW9uIHRlc3QocGF0dGVybiwgc3RyKSB7XG4gICAgICAgIGlmICghX2lzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXHUyMDE4dGVzdFxcdTIwMTkgcmVxdWlyZXMgYSB2YWx1ZSBvZiB0eXBlIFJlZ0V4cCBhcyBpdHMgZmlyc3QgYXJndW1lbnQ7IHJlY2VpdmVkICcgKyB0b1N0cmluZyhwYXR0ZXJuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jbG9uZVJlZ0V4cChwYXR0ZXJuKS50ZXN0KHN0cik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGZ1bmNcbiAgICAgKiBAbWVtYmVyT2YgUlxuICAgICAqIEBzaW5jZSB2MC45LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIGBzdHJgLlxuICAgICAqIEBzZWUgUi50b1VwcGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgUi50b0xvd2VyKCdYWVonKTsgLy89PiAneHl6J1xuICAgICAqL1xuICAgIHZhciB0b0xvd2VyID0gaW52b2tlcigwLCAndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZnVuY1xuICAgICAqIEBtZW1iZXJPZiBSXG4gICAgICogQHNpbmNlIHYwLjkuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB1cHBlciBjYXNlIHZlcnNpb24gb2YgYHN0cmAuXG4gICAgICogQHNlZSBSLnRvTG93ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLnRvVXBwZXIoJ2FiYycpOyAvLz0+ICdBQkMnXG4gICAgICovXG4gICAgdmFyIHRvVXBwZXIgPSBpbnZva2VyKDAsICd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxpc3RzIG9yIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaGVzIHRvIHRoZSBgY29uY2F0YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEBmdW5jXG4gICAgICogQG1lbWJlck9mIFJcbiAgICAgKiBAc2luY2UgdjAuMS4wXG4gICAgICogQGNhdGVnb3J5IExpc3RcbiAgICAgKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gICAgICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBhXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGJcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBSLmNvbmNhdChbXSwgW10pOyAvLz0+IFtdXG4gICAgICogICAgICBSLmNvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gICAgICogICAgICBSLmNvbmNhdCgnQUJDJywgJ0RFRicpOyAvLyAnQUJDREVGJ1xuICAgICAqL1xuICAgIHZhciBjb25jYXQgPSBmbGlwKGludm9rZXIoMSwgJ2NvbmNhdCcpKTtcblxuICAgIHZhciBSID0ge1xuICAgICAgICBGOiBGLFxuICAgICAgICBUOiBULFxuICAgICAgICBfXzogX18sXG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBhZGRJbmRleDogYWRkSW5kZXgsXG4gICAgICAgIGFkanVzdDogYWRqdXN0LFxuICAgICAgICBhbGw6IGFsbCxcbiAgICAgICAgYWxsUGFzczogYWxsUGFzcyxcbiAgICAgICAgYWxsVW5pcTogYWxsVW5pcSxcbiAgICAgICAgYWx3YXlzOiBhbHdheXMsXG4gICAgICAgIGFuZDogYW5kLFxuICAgICAgICBhbnk6IGFueSxcbiAgICAgICAgYW55UGFzczogYW55UGFzcyxcbiAgICAgICAgYXA6IGFwLFxuICAgICAgICBhcGVydHVyZTogYXBlcnR1cmUsXG4gICAgICAgIGFwcGVuZDogYXBwZW5kLFxuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgIGFzc29jOiBhc3NvYyxcbiAgICAgICAgYXNzb2NQYXRoOiBhc3NvY1BhdGgsXG4gICAgICAgIGJpbmFyeTogYmluYXJ5LFxuICAgICAgICBiaW5kOiBiaW5kLFxuICAgICAgICBib3RoOiBib3RoLFxuICAgICAgICBjYWxsOiBjYWxsLFxuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIGNsb25lOiBjbG9uZSxcbiAgICAgICAgY29tbXV0ZTogY29tbXV0ZSxcbiAgICAgICAgY29tbXV0ZU1hcDogY29tbXV0ZU1hcCxcbiAgICAgICAgY29tcGFyYXRvcjogY29tcGFyYXRvcixcbiAgICAgICAgY29tcGxlbWVudDogY29tcGxlbWVudCxcbiAgICAgICAgY29tcG9zZTogY29tcG9zZSxcbiAgICAgICAgY29tcG9zZUs6IGNvbXBvc2VLLFxuICAgICAgICBjb21wb3NlUDogY29tcG9zZVAsXG4gICAgICAgIGNvbmNhdDogY29uY2F0LFxuICAgICAgICBjb25kOiBjb25kLFxuICAgICAgICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdCxcbiAgICAgICAgY29uc3RydWN0TjogY29uc3RydWN0TixcbiAgICAgICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgICAgICBjb250YWluc1dpdGg6IGNvbnRhaW5zV2l0aCxcbiAgICAgICAgY29udmVyZ2U6IGNvbnZlcmdlLFxuICAgICAgICBjb3VudEJ5OiBjb3VudEJ5LFxuICAgICAgICBjcmVhdGVNYXBFbnRyeTogY3JlYXRlTWFwRW50cnksXG4gICAgICAgIGN1cnJ5OiBjdXJyeSxcbiAgICAgICAgY3VycnlOOiBjdXJyeU4sXG4gICAgICAgIGRlYzogZGVjLFxuICAgICAgICBkZWZhdWx0VG86IGRlZmF1bHRUbyxcbiAgICAgICAgZGlmZmVyZW5jZTogZGlmZmVyZW5jZSxcbiAgICAgICAgZGlmZmVyZW5jZVdpdGg6IGRpZmZlcmVuY2VXaXRoLFxuICAgICAgICBkaXNzb2M6IGRpc3NvYyxcbiAgICAgICAgZGlzc29jUGF0aDogZGlzc29jUGF0aCxcbiAgICAgICAgZGl2aWRlOiBkaXZpZGUsXG4gICAgICAgIGRyb3A6IGRyb3AsXG4gICAgICAgIGRyb3BMYXN0OiBkcm9wTGFzdCxcbiAgICAgICAgZHJvcExhc3RXaGlsZTogZHJvcExhc3RXaGlsZSxcbiAgICAgICAgZHJvcFJlcGVhdHM6IGRyb3BSZXBlYXRzLFxuICAgICAgICBkcm9wUmVwZWF0c1dpdGg6IGRyb3BSZXBlYXRzV2l0aCxcbiAgICAgICAgZHJvcFdoaWxlOiBkcm9wV2hpbGUsXG4gICAgICAgIGVpdGhlcjogZWl0aGVyLFxuICAgICAgICBlbXB0eTogZW1wdHksXG4gICAgICAgIGVxQnk6IGVxQnksXG4gICAgICAgIGVxUHJvcHM6IGVxUHJvcHMsXG4gICAgICAgIGVxdWFsczogZXF1YWxzLFxuICAgICAgICBldm9sdmU6IGV2b2x2ZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGZpbmQ6IGZpbmQsXG4gICAgICAgIGZpbmRJbmRleDogZmluZEluZGV4LFxuICAgICAgICBmaW5kTGFzdDogZmluZExhc3QsXG4gICAgICAgIGZpbmRMYXN0SW5kZXg6IGZpbmRMYXN0SW5kZXgsXG4gICAgICAgIGZsYXR0ZW46IGZsYXR0ZW4sXG4gICAgICAgIGZsaXA6IGZsaXAsXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2gsXG4gICAgICAgIGZyb21QYWlyczogZnJvbVBhaXJzLFxuICAgICAgICBmdW5jdGlvbnM6IGZ1bmN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb25zSW46IGZ1bmN0aW9uc0luLFxuICAgICAgICBncm91cEJ5OiBncm91cEJ5LFxuICAgICAgICBndDogZ3QsXG4gICAgICAgIGd0ZTogZ3RlLFxuICAgICAgICBoYXM6IGhhcyxcbiAgICAgICAgaGFzSW46IGhhc0luLFxuICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICBpZGVudGljYWw6IGlkZW50aWNhbCxcbiAgICAgICAgaWRlbnRpdHk6IGlkZW50aXR5LFxuICAgICAgICBpZkVsc2U6IGlmRWxzZSxcbiAgICAgICAgaW5jOiBpbmMsXG4gICAgICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgICAgIGluaXQ6IGluaXQsXG4gICAgICAgIGluc2VydDogaW5zZXJ0LFxuICAgICAgICBpbnNlcnRBbGw6IGluc2VydEFsbCxcbiAgICAgICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gICAgICAgIGludGVyc2VjdGlvbldpdGg6IGludGVyc2VjdGlvbldpdGgsXG4gICAgICAgIGludGVyc3BlcnNlOiBpbnRlcnNwZXJzZSxcbiAgICAgICAgaW50bzogaW50byxcbiAgICAgICAgaW52ZXJ0OiBpbnZlcnQsXG4gICAgICAgIGludmVydE9iajogaW52ZXJ0T2JqLFxuICAgICAgICBpbnZva2VyOiBpbnZva2VyLFxuICAgICAgICBpczogaXMsXG4gICAgICAgIGlzQXJyYXlMaWtlOiBpc0FycmF5TGlrZSxcbiAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgaXNOaWw6IGlzTmlsLFxuICAgICAgICBpc1NldDogaXNTZXQsXG4gICAgICAgIGpvaW46IGpvaW4sXG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIGtleXNJbjoga2V5c0luLFxuICAgICAgICBsYXN0OiBsYXN0LFxuICAgICAgICBsYXN0SW5kZXhPZjogbGFzdEluZGV4T2YsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBsZW5zOiBsZW5zLFxuICAgICAgICBsZW5zSW5kZXg6IGxlbnNJbmRleCxcbiAgICAgICAgbGVuc1Byb3A6IGxlbnNQcm9wLFxuICAgICAgICBsaWZ0OiBsaWZ0LFxuICAgICAgICBsaWZ0TjogbGlmdE4sXG4gICAgICAgIGx0OiBsdCxcbiAgICAgICAgbHRlOiBsdGUsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICBtYXBBY2N1bTogbWFwQWNjdW0sXG4gICAgICAgIG1hcEFjY3VtUmlnaHQ6IG1hcEFjY3VtUmlnaHQsXG4gICAgICAgIG1hcE9iajogbWFwT2JqLFxuICAgICAgICBtYXBPYmpJbmRleGVkOiBtYXBPYmpJbmRleGVkLFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG1hdGhNb2Q6IG1hdGhNb2QsXG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBtYXhCeTogbWF4QnksXG4gICAgICAgIG1lYW46IG1lYW4sXG4gICAgICAgIG1lZGlhbjogbWVkaWFuLFxuICAgICAgICBtZW1vaXplOiBtZW1vaXplLFxuICAgICAgICBtZXJnZTogbWVyZ2UsXG4gICAgICAgIG1lcmdlQWxsOiBtZXJnZUFsbCxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1pbkJ5OiBtaW5CeSxcbiAgICAgICAgbW9kdWxvOiBtb2R1bG8sXG4gICAgICAgIG11bHRpcGx5OiBtdWx0aXBseSxcbiAgICAgICAgbkFyeTogbkFyeSxcbiAgICAgICAgbmVnYXRlOiBuZWdhdGUsXG4gICAgICAgIG5vbmU6IG5vbmUsXG4gICAgICAgIG5vdDogbm90LFxuICAgICAgICBudGg6IG50aCxcbiAgICAgICAgbnRoQXJnOiBudGhBcmcsXG4gICAgICAgIG9iak9mOiBvYmpPZixcbiAgICAgICAgb2Y6IG9mLFxuICAgICAgICBvbWl0OiBvbWl0LFxuICAgICAgICBvbmNlOiBvbmNlLFxuICAgICAgICBvcjogb3IsXG4gICAgICAgIG92ZXI6IG92ZXIsXG4gICAgICAgIHBhaXI6IHBhaXIsXG4gICAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICAgIHBhcnRpYWxSaWdodDogcGFydGlhbFJpZ2h0LFxuICAgICAgICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgcGF0aEVxOiBwYXRoRXEsXG4gICAgICAgIHBhdGhPcjogcGF0aE9yLFxuICAgICAgICBwaWNrOiBwaWNrLFxuICAgICAgICBwaWNrQWxsOiBwaWNrQWxsLFxuICAgICAgICBwaWNrQnk6IHBpY2tCeSxcbiAgICAgICAgcGlwZTogcGlwZSxcbiAgICAgICAgcGlwZUs6IHBpcGVLLFxuICAgICAgICBwaXBlUDogcGlwZVAsXG4gICAgICAgIHBsdWNrOiBwbHVjayxcbiAgICAgICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgcHJvamVjdDogcHJvamVjdCxcbiAgICAgICAgcHJvcDogcHJvcCxcbiAgICAgICAgcHJvcEVxOiBwcm9wRXEsXG4gICAgICAgIHByb3BJczogcHJvcElzLFxuICAgICAgICBwcm9wT3I6IHByb3BPcixcbiAgICAgICAgcHJvcFNhdGlzZmllczogcHJvcFNhdGlzZmllcyxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgICByZWR1Y2VSaWdodDogcmVkdWNlUmlnaHQsXG4gICAgICAgIHJlZHVjZWQ6IHJlZHVjZWQsXG4gICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICAgIHJldmVyc2U6IHJldmVyc2UsXG4gICAgICAgIHNjYW46IHNjYW4sXG4gICAgICAgIHNldDogc2V0LFxuICAgICAgICBzbGljZTogc2xpY2UsXG4gICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgIHNvcnRCeTogc29ydEJ5LFxuICAgICAgICBzcGxpdDogc3BsaXQsXG4gICAgICAgIHNwbGl0RXZlcnk6IHNwbGl0RXZlcnksXG4gICAgICAgIHN1YnRyYWN0OiBzdWJ0cmFjdCxcbiAgICAgICAgc3VtOiBzdW0sXG4gICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgIHRha2U6IHRha2UsXG4gICAgICAgIHRha2VMYXN0OiB0YWtlTGFzdCxcbiAgICAgICAgdGFrZUxhc3RXaGlsZTogdGFrZUxhc3RXaGlsZSxcbiAgICAgICAgdGFrZVdoaWxlOiB0YWtlV2hpbGUsXG4gICAgICAgIHRhcDogdGFwLFxuICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICB0aW1lczogdGltZXMsXG4gICAgICAgIHRvTG93ZXI6IHRvTG93ZXIsXG4gICAgICAgIHRvUGFpcnM6IHRvUGFpcnMsXG4gICAgICAgIHRvUGFpcnNJbjogdG9QYWlyc0luLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIHRvVXBwZXI6IHRvVXBwZXIsXG4gICAgICAgIHRyYW5zZHVjZTogdHJhbnNkdWNlLFxuICAgICAgICB0cmltOiB0cmltLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB1bmFwcGx5OiB1bmFwcGx5LFxuICAgICAgICB1bmFyeTogdW5hcnksXG4gICAgICAgIHVuY3VycnlOOiB1bmN1cnJ5TixcbiAgICAgICAgdW5mb2xkOiB1bmZvbGQsXG4gICAgICAgIHVuaW9uOiB1bmlvbixcbiAgICAgICAgdW5pb25XaXRoOiB1bmlvbldpdGgsXG4gICAgICAgIHVuaXE6IHVuaXEsXG4gICAgICAgIHVuaXFCeTogdW5pcUJ5LFxuICAgICAgICB1bmlxV2l0aDogdW5pcVdpdGgsXG4gICAgICAgIHVubGVzczogdW5sZXNzLFxuICAgICAgICB1bm5lc3Q6IHVubmVzdCxcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIHVzZVdpdGg6IHVzZVdpdGgsXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB2YWx1ZXNJbjogdmFsdWVzSW4sXG4gICAgICAgIHZpZXc6IHZpZXcsXG4gICAgICAgIHdoZW46IHdoZW4sXG4gICAgICAgIHdoZXJlOiB3aGVyZSxcbiAgICAgICAgd2hlcmVFcTogd2hlcmVFcSxcbiAgICAgICAgd3JhcDogd3JhcCxcbiAgICAgICAgeHByb2Q6IHhwcm9kLFxuICAgICAgICB6aXA6IHppcCxcbiAgICAgICAgemlwT2JqOiB6aXBPYmosXG4gICAgICAgIHppcFdpdGg6IHppcFdpdGhcbiAgICB9O1xuXG4gIC8qIFRFU1RfRU5UUllfUE9JTlQgKi9cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIFI7IH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuUiA9IFI7XG4gIH1cblxufS5jYWxsKHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvZGlzdC9yYW1kYS5qcyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2Fuc2ktcmVnZXgvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG52YXIgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbnZhciBhbnNpU3R5bGVzID0gcmVxdWlyZSgnYW5zaS1zdHlsZXMnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgaGFzQW5zaSA9IHJlcXVpcmUoJ2hhcy1hbnNpJyk7XG52YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG52YXIgZGVmaW5lUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBpc1NpbXBsZVdpbmRvd3NUZXJtID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhL154dGVybS9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSk7XG5cbmZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcblx0Ly8gZGV0ZWN0IG1vZGUgaWYgbm90IHNldCBtYW51YWxseVxuXHR0aGlzLmVuYWJsZWQgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHN1cHBvcnRzQ29sb3IgOiBvcHRpb25zLmVuYWJsZWQ7XG59XG5cbi8vIHVzZSBicmlnaHQgYmx1ZSBvbiBXaW5kb3dzIGFzIHRoZSBub3JtYWwgYmx1ZSBjb2xvciBpcyBpbGxlZ2libGVcbmlmIChpc1NpbXBsZVdpbmRvd3NUZXJtKSB7XG5cdGFuc2lTdHlsZXMuYmx1ZS5vcGVuID0gJ1xcdTAwMWJbOTRtJztcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhhbnNpU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG5cblx0XHRyZXRba2V5XSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiByZXQ7XG59KSgpO1xuXG52YXIgcHJvdG8gPSBkZWZpbmVQcm9wcyhmdW5jdGlvbiBjaGFsaygpIHt9LCBzdHlsZXMpO1xuXG5mdW5jdGlvbiBidWlsZChfc3R5bGVzKSB7XG5cdHZhciBidWlsZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0YnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcblx0YnVpbGRlci5lbmFibGVkID0gdGhpcy5lbmFibGVkO1xuXHQvLyBfX3Byb3RvX18gaXMgdXNlZCBiZWNhdXNlIHdlIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24sIGJ1dCB0aGVyZSBpc1xuXHQvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGUuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdGJ1aWxkZXIuX19wcm90b19fID0gcHJvdG87XG5cblx0cmV0dXJuIGJ1aWxkZXI7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG5cdC8vIHN1cHBvcnQgdmFyYWdzLCBidXQgc2ltcGx5IGNhc3QgdG8gc3RyaW5nIGluIGNhc2UgdGhlcmUncyBvbmx5IG9uZSBhcmdcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG5cdHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG5cdGlmIChhcmdzTGVuID4gMSkge1xuXHRcdC8vIGRvbid0IHNsaWNlIGBhcmd1bWVudHNgLCBpdCBwcmV2ZW50cyB2OCBvcHRpbWl6YXRpb25zXG5cdFx0Zm9yICh2YXIgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcblx0XHRcdHN0ciArPSAnICcgKyBhcmdzW2FdO1xuXHRcdH1cblx0fVxuXG5cdGlmICghdGhpcy5lbmFibGVkIHx8ICFzdHIpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0dmFyIG5lc3RlZFN0eWxlcyA9IHRoaXMuX3N0eWxlcztcblx0dmFyIGkgPSBuZXN0ZWRTdHlsZXMubGVuZ3RoO1xuXG5cdC8vIFR1cm5zIG91dCB0aGF0IG9uIFdpbmRvd3MgZGltbWVkIGdyYXkgdGV4dCBiZWNvbWVzIGludmlzaWJsZSBpbiBjbWQuZXhlLFxuXHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL2lzc3Vlcy81OFxuXHQvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblx0dmFyIG9yaWdpbmFsRGltID0gYW5zaVN0eWxlcy5kaW0ub3Blbjtcblx0aWYgKGlzU2ltcGxlV2luZG93c1Rlcm0gJiYgKG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmF5JykgIT09IC0xIHx8IG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmV5JykgIT09IC0xKSkge1xuXHRcdGFuc2lTdHlsZXMuZGltLm9wZW4gPSAnJztcblx0fVxuXG5cdHdoaWxlIChpLS0pIHtcblx0XHR2YXIgY29kZSA9IGFuc2lTdHlsZXNbbmVzdGVkU3R5bGVzW2ldXTtcblxuXHRcdC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuXHRcdC8vIG90aGVyd2lzZSBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBzdHJpbmcgdW50aWwgc2FpZCBjbG9zaW5nIGNvZGVcblx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG5cdH1cblxuXHQvLyBSZXNldCB0aGUgb3JpZ2luYWwgJ2RpbScgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZS5cblx0YW5zaVN0eWxlcy5kaW0ub3BlbiA9IG9yaWdpbmFsRGltO1xuXG5cdHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXRbbmFtZV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgW25hbWVdKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufVxuXG5kZWZpbmVQcm9wcyhDaGFsay5wcm90b3R5cGUsIGluaXQoKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENoYWxrKCk7XG5tb2R1bGUuZXhwb3J0cy5zdHlsZXMgPSBhbnNpU3R5bGVzO1xubW9kdWxlLmV4cG9ydHMuaGFzQ29sb3IgPSBoYXNBbnNpO1xubW9kdWxlLmV4cG9ydHMuc3RyaXBDb2xvciA9IHN0cmlwQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdXBwb3J0c0NvbG9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jaGFsay9pbmRleC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMgKCkge1xuXHR2YXIgc3R5bGVzID0ge1xuXHRcdG1vZGlmaWVyczoge1xuXHRcdFx0cmVzZXQ6IFswLCAwXSxcblx0XHRcdGJvbGQ6IFsxLCAyMl0sIC8vIDIxIGlzbid0IHdpZGVseSBzdXBwb3J0ZWQgYW5kIDIyIGRvZXMgdGhlIHNhbWUgdGhpbmdcblx0XHRcdGRpbTogWzIsIDIyXSxcblx0XHRcdGl0YWxpYzogWzMsIDIzXSxcblx0XHRcdHVuZGVybGluZTogWzQsIDI0XSxcblx0XHRcdGludmVyc2U6IFs3LCAyN10sXG5cdFx0XHRoaWRkZW46IFs4LCAyOF0sXG5cdFx0XHRzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG5cdFx0fSxcblx0XHRjb2xvcnM6IHtcblx0XHRcdGJsYWNrOiBbMzAsIDM5XSxcblx0XHRcdHJlZDogWzMxLCAzOV0sXG5cdFx0XHRncmVlbjogWzMyLCAzOV0sXG5cdFx0XHR5ZWxsb3c6IFszMywgMzldLFxuXHRcdFx0Ymx1ZTogWzM0LCAzOV0sXG5cdFx0XHRtYWdlbnRhOiBbMzUsIDM5XSxcblx0XHRcdGN5YW46IFszNiwgMzldLFxuXHRcdFx0d2hpdGU6IFszNywgMzldLFxuXHRcdFx0Z3JheTogWzkwLCAzOV1cblx0XHR9LFxuXHRcdGJnQ29sb3JzOiB7XG5cdFx0XHRiZ0JsYWNrOiBbNDAsIDQ5XSxcblx0XHRcdGJnUmVkOiBbNDEsIDQ5XSxcblx0XHRcdGJnR3JlZW46IFs0MiwgNDldLFxuXHRcdFx0YmdZZWxsb3c6IFs0MywgNDldLFxuXHRcdFx0YmdCbHVlOiBbNDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YTogWzQ1LCA0OV0sXG5cdFx0XHRiZ0N5YW46IFs0NiwgNDldLFxuXHRcdFx0YmdXaGl0ZTogWzQ3LCA0OV1cblx0XHR9XG5cdH07XG5cblx0Ly8gZml4IGh1bWFuc1xuXHRzdHlsZXMuY29sb3JzLmdyZXkgPSBzdHlsZXMuY29sb3JzLmdyYXk7XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChncm91cE5hbWUpIHtcblx0XHR2YXIgZ3JvdXAgPSBzdHlsZXNbZ3JvdXBOYW1lXTtcblxuXHRcdE9iamVjdC5rZXlzKGdyb3VwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG5cblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0gZ3JvdXBbc3R5bGVOYW1lXSA9IHtcblx0XHRcdFx0b3BlbjogJ1xcdTAwMWJbJyArIHN0eWxlWzBdICsgJ20nLFxuXHRcdFx0XHRjbG9zZTogJ1xcdTAwMWJbJyArIHN0eWxlWzFdICsgJ20nXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgZ3JvdXBOYW1lLCB7XG5cdFx0XHR2YWx1ZTogZ3JvdXAsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeHMsIGYpIHtcbiAgICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0geHNbaV07XG4gICAgICAgIGlmIChoYXNPd24uY2FsbCh4cywgaSkpIHJlcy5wdXNoKGYoeCwgaSwgeHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hcnJheS1tYXAvaW5kZXguanMiLCJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeHMsIGYsIGFjYykge1xuICAgIHZhciBoYXNBY2MgPSBhcmd1bWVudHMubGVuZ3RoID49IDM7XG4gICAgaWYgKGhhc0FjYyAmJiB4cy5yZWR1Y2UpIHJldHVybiB4cy5yZWR1Y2UoZiwgYWNjKTtcbiAgICBpZiAoeHMucmVkdWNlKSByZXR1cm4geHMucmVkdWNlKGYpO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh4cywgaSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWhhc0FjYykge1xuICAgICAgICAgICAgYWNjID0geHNbaV07XG4gICAgICAgICAgICBoYXNBY2MgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYWNjID0gZihhY2MsIHhzW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FycmF5LXJlZHVjZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2O1xuXG52YXIgdGVybWluYXRvciA9IGFyZ3YuaW5kZXhPZignLS0nKTtcbnZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcblx0ZmxhZyA9ICctLScgKyBmbGFnO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKGZsYWcpO1xuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvciAhPT0gLTEgPyBwb3MgPCB0ZXJtaW5hdG9yIDogdHJ1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICgnRk9SQ0VfQ09MT1InIGluIHByb2Nlc3MuZW52KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0pKCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2NoYWxrL34vc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXCQmJyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2ZvcmVhY2gvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xudmFyIHJlID0gbmV3IFJlZ0V4cChhbnNpUmVnZXgoKS5zb3VyY2UpOyAvLyByZW1vdmUgdGhlIGBnYCBmbGFnXG5tb2R1bGUuZXhwb3J0cyA9IHJlLnRlc3QuYmluZChyZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2hhcy1hbnNpL2luZGV4LmpzIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaW5kZXhvZi9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaXNhcnJheS9pbmRleC5qcyIsIi8qISBKU09OIHYzLjMuMCB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKHJvb3QpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQuXG4gIC8vIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvbiBpbnN0ZWFkLlxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdGdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IEEgc2V0IG9mIHByaW1pdGl2ZSB0eXBlcyB1c2VkIGJ5IGBpc0hvc3RUeXBlYC5cbiAgICAgIHZhciBQcmltaXRpdmVUeXBlcyA9IHtcbiAgICAgICAgXCJib29sZWFuXCI6IDEsXG4gICAgICAgIFwibnVtYmVyXCI6IDEsXG4gICAgICAgIFwic3RyaW5nXCI6IDEsXG4gICAgICAgIFwidW5kZWZpbmVkXCI6IDFcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBvYmplY3QgYHByb3BlcnR5YCB2YWx1ZSBpcyBhXG4gICAgICAvLyBub24tcHJpbWl0aXZlLlxuICAgICAgdmFyIGlzSG9zdFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICByZXR1cm4gdHlwZSA9PSBcIm9iamVjdFwiID8gISFvYmplY3RbcHJvcGVydHldIDogIVByaW1pdGl2ZVR5cGVzW3R5cGVdO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIGlzSG9zdFR5cGUob2JqZWN0LCBcImhhc093blByb3BlcnR5XCIpID8gb2JqZWN0Lmhhc093blByb3BlcnR5IDogaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGZpbHRlciA9PSBcIm9iamVjdFwiICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT047XG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KHRoaXMpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vanNvbjMvbGliL2pzb24zLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgIShmbiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHx8IHRvU3RyaW5nLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcblx0aWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHR9XG5cdHZhciBpLCBrLFxuXHRcdGlzU3RyaW5nID0gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycsXG5cdFx0bCA9IG9iai5sZW5ndGgsXG5cdFx0Y29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblx0aWYgKGwgPT09ICtsKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGNvbnRleHQgPT09IG51bGwpIHtcblx0XHRcdFx0Zm4oaXNTdHJpbmcgPyBvYmouY2hhckF0KGkpIDogb2JqW2ldLCBpLCBvYmopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm4uY2FsbChjb250ZXh0LCBpc1N0cmluZyA/IG9iai5jaGFyQXQoaSkgOiBvYmpbaV0sIGksIG9iaik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAoayBpbiBvYmopIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG5cdFx0XHRcdGlmIChjb250ZXh0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Zm4ob2JqW2tdLCBrLCBvYmopO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZuLmNhbGwoY29udGV4dCwgb2JqW2tdLCBrLCBvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L29iamVjdC1rZXlzL2ZvcmVhY2guanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuXHR0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdGZvckVhY2ggPSByZXF1aXJlKCcuL2ZvcmVhY2gnKSxcblx0aXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuXHRoYXNEb250RW51bUJ1ZyA9ICEoeyd0b1N0cmluZyc6IG51bGx9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcblx0aGFzUHJvdG9FbnVtQnVnID0gKGZ1bmN0aW9uICgpIHt9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgncHJvdG90eXBlJyksXG5cdGRvbnRFbnVtcyA9IFtcblx0XHRcInRvU3RyaW5nXCIsXG5cdFx0XCJ0b0xvY2FsZVN0cmluZ1wiLFxuXHRcdFwidmFsdWVPZlwiLFxuXHRcdFwiaGFzT3duUHJvcGVydHlcIixcblx0XHRcImlzUHJvdG90eXBlT2ZcIixcblx0XHRcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXG5cdFx0XCJjb25zdHJ1Y3RvclwiXG5cdF07XG5cbnZhciBrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jyxcblx0XHRpc0Z1bmN0aW9uID0gdG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nLFxuXHRcdGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCksXG5cdFx0dGhlS2V5cyA9IFtdO1xuXG5cdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3RcIik7XG5cdH1cblxuXHRpZiAoaXNBcmd1bWVudHMpIHtcblx0XHRmb3JFYWNoKG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuXHRcdFx0dGhlS2V5cy5wdXNoKGluZGV4KTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXG5cdFx0Zm9yIChuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChuYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHR2YXIgY3RvciA9IG9iamVjdC5jb25zdHJ1Y3Rvcixcblx0XHRcdHNraXBDb25zdHJ1Y3RvciA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG9iamVjdDtcblxuXHRcdGZvckVhY2goZG9udEVudW1zLCBmdW5jdGlvbiAoZG9udEVudW0pIHtcblx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bSkpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gdGhlS2V5cztcbn07XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKCFPYmplY3Qua2V5cykge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9vYmplY3Qta2V5cy9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJndW1lbnRzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3VtZW50cykge1xuXHRcdGlzQXJndW1lbnRzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nXG5cdFx0XHQmJiB2YWx1ZSAhPT0gbnVsbFxuXHRcdFx0JiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuXHRcdFx0JiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcidcblx0XHRcdCYmIHZhbHVlLmxlbmd0aCA+PSAwXG5cdFx0XHQmJiB0b1N0cmluZy5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJndW1lbnRzO1xufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9vYmplY3Qta2V5cy9pc0FyZ3VtZW50cy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc3RyaXAtYW5zaS9pbmRleC5qcyIsInZhciBSICAgICAgICAgPSByZXF1aXJlKCdyYW1kYScpO1xudmFyIGNoYWxrICAgICA9IHJlcXVpcmUoJ2NoYWxrJyk7XG52YXIgdXRpbHMgICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbnZhciBzdHIyY29sb3IgPSByZXF1aXJlKCcuL2xpYi9zdHIyY29sb3InKTtcbnZhciBnZXRGbkFyZ3MgPSByZXF1aXJlKCcuL2xpYi9nZXQtZm4tYXJncycpO1xudmFyIGdldEZuTmFtZSA9IHJlcXVpcmUoJy4vbGliL2dldC1mbi1uYW1lJyk7XG52YXIgaW5zcGVjdCAgID0gdXRpbHMuaW5zcGVjdDtcbnZhciBwcmludCAgICAgPSB1dGlscy5wcmludDtcblxudmFyIG1hcFRhaWwgPSBmdW5jdGlvbihmbiwgYXJyKSB7XG4gIHJldHVybiBSLnNsaWNlKDAsIDEsIGFycikuY29uY2F0KFIubWFwKGZuLCBSLnRhaWwoYXJyKSkpO1xufTtcbnZhciBzdHJSZXBlYXQgPSBSLmNvbXBvc2UoUi5qb2luKCcnKSwgUi5yZXBlYXQpO1xudmFyIGxpbmVzID0gUi5zcGxpdCgnXFxuJyk7XG52YXIgdW5saW5lcyA9IFIuam9pbignXFxuJyk7XG52YXIgaW5kZW50VGFpbExpbmVzID0gZnVuY3Rpb24obiwgc3RyKSB7XG4gIHJldHVybiB1bmxpbmVzKG1hcFRhaWwoUi5jb25jYXQoc3RyUmVwZWF0KCcgJywgbikpLCBsaW5lcyhzdHIpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gbmFtZTtcbiAgICBuYW1lID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigvKiBhcmdzICovKSB7XG4gICAgaWYgKG5hbWUgPT0gbnVsbCkgbmFtZSA9IGdldEZuTmFtZShmbik7XG4gICAgbmFtZSA9IG5hbWUudG9TdHJpbmcoKTtcblxuICAgIHZhciBwcmVmaXggPSBuYW1lID8gc3RyMmNvbG9yKG5hbWUpICsgJyAnIDogJyc7XG4gICAgcHJpbnQocHJlZml4ICsgZm9ybWF0QXJncyhuYW1lLCBmbiwgYXJndW1lbnRzKSk7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcHJpbnQocHJlZml4ICsgJz0+ICcgKyBpbmRlbnRUYWlsTGluZXMobmFtZS5sZW5ndGggKyA0LCBpbnNwZWN0KHJlcykpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuZnVuY3Rpb24gZm9ybWF0QXJncyhuYW1lLCBmbiwgYXJncykge1xuICB2YXIgZm5BcmdOYW1lcyA9IGdldEZuQXJncyhmbik7XG4gIHZhciBnZXRBcmdQYWlycyA9IGZ1bmN0aW9uKGksIHZhbCkge1xuICAgIHJldHVybiBbIGZuQXJnTmFtZXNbaV0gfHwgaS50b1N0cmluZygpLCB2YWwgXTtcbiAgfTtcblxuICB2YXIgcGFpcnMgPSBSLnppcFdpdGgoZ2V0QXJnUGFpcnMsIFIucmFuZ2UoMCwgYXJncy5sZW5ndGgpLCBhcmdzKTtcbiAgdmFyIGFyZ0xpbmVzID0gUi5tYXAoUi5hcHBseShmb3JtYXRBcmcpLCBwYWlycyk7XG4gIHZhciBzcGFjZSA9IHN0clJlcGVhdCgnICcsIG5hbWUubGVuZ3RoICsgMSk7XG4gIHJldHVybiB1bmxpbmVzKG1hcFRhaWwoUi5jb25jYXQoc3BhY2UpLCBhcmdMaW5lcykpO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdEFyZyhhcmdOYW1lLCB2YWwpIHtcbiAgICB2YXIgaW5kZW50TGV2ZWwgPSBuYW1lLmxlbmd0aCArIGFyZ05hbWUubGVuZ3RoICsgMztcbiAgICByZXR1cm4gUi5qb2luKCc6ICcsIFtcbiAgICAgIGNoYWxrLmdyZWVuKGFyZ05hbWUpLFxuICAgICAgaW5kZW50VGFpbExpbmVzKGluZGVudExldmVsLCBpbnNwZWN0KHZhbCkpXG4gICAgXSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdHJlaXMvaW5kZXguanMiLCJ2YXIgUiA9IHJlcXVpcmUoJ3JhbWRhJyk7XG5cbnZhciBwYXJzZVN0cnMgPSBSLmNvbXBvc2UoIFIuZGVmYXVsdFRvKFtdKSwgUi5tYXRjaCgvKFteXFxzLF0rKS9nKSApO1xudmFyIGdldFBhcmVuc0NvbnRlbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIFIuc2xpY2UoXG4gICAgUi5pbmRleE9mKCcoJywgc3RyKSArIDEsXG4gICAgUi5pbmRleE9mKCcpJywgc3RyKSxcbiAgICBzdHJcbiAgKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSLnBpcGUoIFIudG9TdHJpbmcsIGdldFBhcmVuc0NvbnRlbnQsIHBhcnNlU3RycyApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi90cmVpcy9saWIvZ2V0LWZuLWFyZ3MuanMiLCJ2YXIgQ0hBUiA9ICfOuyc7XG52YXIgYW5vbk4gPSAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBmbi5uYW1lIHx8IChDSEFSICsgKCsrYW5vbk4pKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3RyZWlzL2xpYi9nZXQtZm4tbmFtZS5qcyIsInZhciBib2xkID0gcmVxdWlyZSgnY2hhbGsnKS5ib2xkO1xuXG4vLyBkZXRlcm1pbmlzdGljYWxseSBjb2xvciBhIHN0cmluZyB3aXRob3V0IHJldXNpbmcgY29sb3JzIHVudGlsIGFsbCBjb2xvcnNcbi8vIGFyZSB1c2VkIG9uY2Vcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgQ09MT1JTID0gWydyZWQnLCAnZ3JlZW4nLCAneWVsbG93JywgJ2JsdWUnLCAnbWFnZW50YScsICdjeWFuJywgJ3doaXRlJ107XG4gIHZhciB1bnVzZWRDb2xvcnMgPSBDT0xPUlMuc2xpY2UoKTtcbiAgdmFyIGNvbG9yQnlTdHIgPSB7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGNvbG9yID0gY29sb3JCeVN0cltzdHJdIHx8IChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh1bnVzZWRDb2xvcnMubGVuZ3RoID09PSAwKSB1bnVzZWRDb2xvcnMgPSBDT0xPUlMuc2xpY2UoKTtcbiAgICAgIHZhciBjb2xvciA9IHN0clRvRWxlbSh1bnVzZWRDb2xvcnMsIHN0cik7XG4gICAgICBjb2xvckJ5U3RyW3N0cl0gPSBjb2xvcjtcbiAgICAgIHVudXNlZENvbG9ycy5zcGxpY2UodW51c2VkQ29sb3JzLmluZGV4T2YoY29sb3IpLCAxKTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9KCkpO1xuXG4gICAgcmV0dXJuIGJvbGRbY29sb3JdKHN0cik7XG4gIH07XG5cbiAgZnVuY3Rpb24gc3RyVG9FbGVtKGFyciwgc3RyKSB7XG4gICAgcmV0dXJuIGFycltjaGFyQ29kZVN1bShzdHIpICUgYXJyLmxlbmd0aF07XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQ29kZVN1bShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBjKSB7XG4gICAgICByZXR1cm4gc3VtICsgYy5jaGFyQ29kZUF0KCk7XG4gICAgfSwgMCk7XG4gIH1cbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3RyZWlzL2xpYi9zdHIyY29sb3IuanMiLCJ2YXIgUiA9IHJlcXVpcmUoJ3JhbWRhJyk7XG5cbmV4cG9ydHMuaW5zcGVjdCA9IHJlcXVpcmUoJ3V0aWwtaW5zcGVjdCcpO1xuZXhwb3J0cy5wcmludCA9IFIuYmluZChjb25zb2xlLmxvZywgY29uc29sZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3RyZWlzL2xpYi91dGlscy1icm93c2VyLmpzIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIG1hcCA9IHJlcXVpcmUoJ2FycmF5LW1hcCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJ2FycmF5LXJlZHVjZScpO1xudmFyIGdldE9iamVjdEtleXMgPSByZXF1aXJlKCdvYmplY3Qta2V5cycpO1xudmFyIEpTT04gPSByZXF1aXJlKCdqc29uMycpO1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBgT2JqZWN0LmtleXNgIHdvcmsgZm9yIGB1bmRlZmluZWRgXG4gKiB2YWx1ZXMgdGhhdCBhcmUgc3RpbGwgdGhlcmUsIGxpa2UgYGRvY3VtZW50LmFsbGAuXG4gKiBodHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy9wdWJsaWMtaHRtbC8yMDA5SnVuLzA1NDYuaHRtbFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEtleXModmFsKXtcbiAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXModmFsKTtcbiAgcmV0dXJuIGdldE9iamVjdEtleXModmFsKTtcbn1cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKiBAbGljZW5zZSBNSVQgKMKpIEpveWVudClcbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBmb3JFYWNoKGFycmF5LCBmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duKHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGZvckVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGluZGV4T2Yoa2V5cywgJ21lc3NhZ2UnKSA+PSAwIHx8IGluZGV4T2Yoa2V5cywgJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gbWFwKGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0geyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IGRlc2M7XG4gIH1cbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093bih2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoaW5kZXhPZihjdHguc2VlbiwgZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gbWFwKHN0ci5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBtYXAoc3RyLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSByZWR1Y2Uob3V0cHV0LCBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZChvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3V0aWwtaW5zcGVjdC9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=