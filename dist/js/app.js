/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 342);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _isPlaceholder = __webpack_require__(34);

/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var _isPlaceholder = __webpack_require__(34);

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _curry2 = __webpack_require__(0);
var _isPlaceholder = __webpack_require__(34);

/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function (_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var _isArray = __webpack_require__(14);
var _isTransformer = __webpack_require__(52);

/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
module.exports = function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!_isArray(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = {
  init: function init() {
    return this.xf['@@transducer/init']();
  },
  result: function result(_result) {
    return this.xf['@@transducer/result'](_result);
  }
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _curry1 = __webpack_require__(1);
var _curry2 = __webpack_require__(0);
var _curryN = __webpack_require__(32);

/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
module.exports = _curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _map = __webpack_require__(36);
var _reduce = __webpack_require__(8);
var _xmap = __webpack_require__(224);
var curryN = __webpack_require__(5);
var keys = __webpack_require__(12);

/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      var double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */
module.exports = _curry2(_dispatchable(['map'], _xmap, function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return curryN(functor.length, function () {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return _reduce(function (acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, keys(functor));
    default:
      return _map(fn, functor);
  }
}));

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var _xwrap = __webpack_require__(95);
var bind = __webpack_require__(70);
var isArrayLike = __webpack_require__(23);

module.exports = function () {
  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj) {
    return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
  return function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }
    if (isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list);
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }
    throw new TypeError('reduce: list must be array or iterable');
  };
}();

/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
module.exports = function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];

  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }
  return result;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _equals = __webpack_require__(199);

/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
module.exports = _curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };
    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _has = __webpack_require__(6);
var _isArguments = __webpack_require__(88);

/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
module.exports = function () {
  // cover IE < 9 keys issues
  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = function () {
    'use strict';

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : _curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
}();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var _reduce = __webpack_require__(8);

/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * `R.reduced` to shortcut the iteration.
 *
 * The arguments' order of `reduceRight`'s iterator function is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *                -               -10
 *               / \              / \
 *              -   4           -6   4
 *             / \              / \
 *            -   3   ==>     -3   3
 *           / \              / \
 *          -   2           -1   2
 *         / \              / \
 *        0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */
module.exports = _curry3(_reduce);

/***/ }),
/* 14 */
/***/ (function(module, exports) {

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var _indexOf = __webpack_require__(87);

module.exports = function _contains(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__(21);
var _curry3 = __webpack_require__(2);

/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */
module.exports = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Returns a function that always returns the given value. Note that for
 * non-primitives the value returned is a reference to the original value.
 *
 * This function is known as `const`, `constant`, or `K` (for K combinator) in
 * other languages and libraries.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> (* -> a)
 * @param {*} val The value to wrap in a function
 * @return {Function} A Function :: * -> val.
 * @example
 *
 *      var t = R.always('Tee');
 *      t(); //=> 'Tee'
 */
module.exports = _curry1(function always(val) {
  return function () {
    return val;
  };
});

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns the larger of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.maxBy, R.min
 * @example
 *
 *      R.max(789, 123); //=> 789
 *      R.max('a', 'b'); //=> 'b'
 */
module.exports = _curry2(function max(a, b) {
  return b > a ? b : a;
});

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ramda__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ramda___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ramda__);
/* harmony export (immutable) */ __webpack_exports__["g"] = getZones;
/* harmony export (immutable) */ __webpack_exports__["h"] = filterZonesByNumber;
/* harmony export (immutable) */ __webpack_exports__["c"] = maxNum;
/* harmony export (immutable) */ __webpack_exports__["e"] = minNum;
/* unused harmony export getDifference */
/* harmony export (immutable) */ __webpack_exports__["f"] = flatten;
/* unused harmony export journeyToKey */
/* unused harmony export zoneToJourney */
/* unused harmony export getDailyCap */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCap; });
/* harmony export (immutable) */ __webpack_exports__["d"] = getSingleFare;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return met; });


/**
 * Gets Zones
 * @function
 * @param {string} napTan - The naptan of the station we're looking for.
 * @param {object} stations - An object containing stations with napTans as keys.
 * @returns {array}
 * @description Uses the napTan ID to figure out what zone that station is in via station.json
 */
function getZones(napTan, stations) {
  return stations[napTan].zones;
}

/**
 * filters a nested array based on its length 
 * @function
 * @param {number} num - either 1 (for single zone) or 2 (dual zone)
 * @param {nested array} zones - the nested array of arrays (of zones)
 * @returns {nested array} - nested array of all array of zones from stations that only have one zone associated with it (if num = 1) or...
 * @description - zones refers to global allZones / used to filter the station zones by the number of zones it has (dual zone or single zone)
 */
function filterZonesByNumber(num, zones) {
  return zones.filter(function (zone) {
    return zone.length === num;
  });
}

/**
 * Compares Numbers
 * @function
 * @param {array} numbers - the array of number(s)
 * @param {object} operator - what javascript operator passing through (e.g. Math.max)
 * @returns {number} - the single number after all calculations (reduces to one number)
 * @description Associated with minNum and maxNum: where arrayZones refers to zonesFromSingleStations.
 Loops through the array of zones and applies the operator
 */
function compareNumbers(arrayNumbers, operator) {
  return arrayNumbers.reduce(function (a, b) {
    return operator(a, b);
  });
}

function maxNum(arrayZones) {
  return compareNumbers(arrayZones, Math.max);
}

function minNum(arrayZones) {
  return compareNumbers(arrayZones, Math.min);
}

/**
 * Get difference between 2 numbers
 * @function
 * @param {numbers} a,b - the two numbers comparing against
 * @returns {number} - the difference between the 2 numbers (discarding negative numbers)
 * @description
 */
function getDifference(a, b) {
  return Math.abs(a - b);
  // return a - b;
}

/**
 * Flattens a nested array
 * @function
 * @param {array} array that is an array within another array
 * @returns {number} - flattens the array so just one array
 * @description
 */
function flatten(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(b);
  });
}

/**
 * Sort an array of 2 zones chronologically and adds '-'
 * @function
 * @param {array} journey - the array of the 2 zones of that journey
 * @returns {string} - 'x-y'
 * @description - used to get the fares from the json file
 */
function journeyToKey(journey) {
  return journey.sort().join('-');
}

/**
 * Preloads start zone as 1 and changes to 1-x for JSON file reading
 * @function
 * @param {number} - zone x
 * @returns {string} - '1-x'
 * @description - used to get the fares from the json file
 */
function zoneToJourney(zone) {
  // debugger;
  return journeyToKey([1, zone]);
}

/**
 * Gets the daily cap cost
 * @function
 * @param {number} - the (maximum) zone
 * @param {object} dailyCaps - looks at the dailyCaps object in the fares.json file
 * @returns {number} - gets the daily cap between zones 1 and the zone parameter (as daily caps always starts at zone 1)
 * @description
 */
function getDailyCap(maxZonesofar, dailyCaps, type) {
  return dailyCaps[journeyToKey([1, maxZonesofar])][type];
}

var getCap = __WEBPACK_IMPORTED_MODULE_0_ramda___default.a.curry(function (key, type, caps) {
  return caps[typeof key == "array" ? journeyToKey(key) : zoneToJourney(key)][type];
});

/**
 * Gets the single fare
 * @function
 * @param {array} journey - the array of the 2 zones travelling between
 * @param {object} singleFares - looks at the singleFares object in the fares.json file
 * @returns {number} - gets the single fare between those two zones
 * @description
 */
function getSingleFare(journey, singleFares, type) {
  // debugger;
  return singleFares[journeyToKey(journey)][type];
}

/**
 * Determines if a numeric target has been met or surpassed
 * @function
 * @param {number} target - target value to compare against
 * @param {number} value - the value to compare against the target
 * @description
 */
var met = __WEBPACK_IMPORTED_MODULE_0_ramda___default.a.curry(function (target, value) {
  return value >= target;
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var _isArray = __webpack_require__(14);

/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */
module.exports = function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isFunction = __webpack_require__(33);
var curryN = __webpack_require__(5);
var toString = __webpack_require__(27);

/**
 * Turns a named method with a specified arity into a function that can be
 * called directly supplied with arguments and a target object.
 *
 * The returned function is curried and accepts `arity + 1` parameters where
 * the final parameter is the target object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
 * @param {Number} arity Number of arguments the returned function should take
 *        before the target object.
 * @param {String} method Name of the method to call.
 * @return {Function} A new curried function.
 * @example
 *
 *      var sliceFrom = R.invoker(1, 'slice');
 *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
 *      var sliceFrom6 = R.invoker(2, 'slice')(6);
 *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
 * @symb R.invoker(0, 'method')(o) = o['method']()
 * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
 * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
 */
module.exports = _curry2(function invoker(arity, method) {
  return curryN(arity + 1, function () {
    var target = arguments[arity];
    if (target != null && _isFunction(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
  });
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _curry1 = __webpack_require__(1);
var _isArray = __webpack_require__(14);
var _isString = __webpack_require__(35);

/**
 * Tests whether or not an object is similar to an array.
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @deprecated since v0.23.0
 * @example
 *
 *      R.isArrayLike([]); //=> true
 *      R.isArrayLike(true); //=> false
 *      R.isArrayLike({}); //=> false
 *      R.isArrayLike({length: 10}); //=> false
 *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */
module.exports = _curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object') {
    return false;
  }
  if (_isString(x)) {
    return false;
  }
  if (x.nodeType === 1) {
    return !!x.length;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isString = __webpack_require__(35);

/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      var list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */
module.exports = _curry2(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 */
module.exports = _curry2(function path(paths, obj) {
  var val = obj;
  var idx = 0;
  while (idx < paths.length) {
    if (val == null) {
      return;
    }
    val = val[paths[idx]];
    idx += 1;
  }
  return val;
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var map = __webpack_require__(7);
var prop = __webpack_require__(53);

/**
 * Returns a new list by plucking the same named property off all objects in
 * the list supplied.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig k -> [{k: v}] -> [v]
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} list The array to consider.
 * @return {Array} The list of values for the given key.
 * @see R.props
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
 * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
 */
module.exports = _curry2(function pluck(p, list) {
  return map(prop(p), list);
});

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _toString = __webpack_require__(211);

/**
 * Returns the string representation of the given value. `eval`'ing the output
 * should result in a value equivalent to the input value. Many of the built-in
 * `toString` methods do not satisfy this requirement.
 *
 * If the given value is an `[object Object]` with a `toString` method other
 * than `Object.prototype.toString`, this method is invoked with no arguments
 * to produce the return value. This means user-defined constructor functions
 * can provide a suitable `toString` method. For example:
 *
 *     function Point(x, y) {
 *       this.x = x;
 *       this.y = y;
 *     }
 *
 *     Point.prototype.toString = function() {
 *       return 'new Point(' + this.x + ', ' + this.y + ')';
 *     };
 *
 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category String
 * @sig * -> String
 * @param {*} val
 * @return {String}
 * @example
 *
 *      R.toString(42); //=> '42'
 *      R.toString('abc'); //=> '"abc"'
 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
 */
module.exports = _curry1(function toString(val) {
  return _toString(val, []);
});

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
module.exports = _curry2(function add(a, b) {
  return Number(a) + Number(b);
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Makes a shallow clone of an object, setting or overriding the specified
 * property with the given value. Note that this copies and flattens prototype
 * properties onto the new object as well. All non-primitive properties are
 * copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig String -> a -> {k: v} -> {k: v}
 * @param {String} prop The property name to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except for the changed property.
 * @see R.dissoc
 * @example
 *
 *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
 */
module.exports = _curry3(function assoc(prop, val, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  result[prop] = val;
  return result;
});

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var curryN = __webpack_require__(5);

/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
module.exports = _curry1(function curry(fn) {
  return curryN(fn.length, fn);
});

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var curry = __webpack_require__(30);

/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      var mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */
module.exports = _curry1(function flip(fn) {
  return curry(function (a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _isPlaceholder = __webpack_require__(34);

/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
};

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = function _isFunction(x) {
  return Object.prototype.toString.call(x) === '[object Function]';
};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function _isPlaceholder(a) {
       return a != null && (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && a['@@functional/placeholder'] === true;
};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var map = __webpack_require__(7);

/**
 * Returns a lens for the given getter and setter functions. The getter "gets"
 * the value of the focus; the setter "sets" the value of the focus. The setter
 * should not mutate the data structure.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
 * @param {Function} getter
 * @param {Function} setter
 * @return {Lens}
 * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
module.exports = _curry2(function lens(getter, setter) {
  return function (toFunctorFn) {
    return function (target) {
      return map(function (focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
});

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var liftN = __webpack_require__(100);

/**
 * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
 * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.liftN
 * @example
 *
 *      var madd3 = R.lift((a, b, c) => a + b + c);
 *
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 *
 *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
 *
 *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
 */
module.exports = _curry1(function lift(fn) {
  return liftN(fn.length, fn);
});

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly `n` parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} n The desired arity of the new function.
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity `n`.
 * @example
 *
 *      var takesTwoArgs = (a, b) => [a, b];
 *
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.nAry(1, takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only `n` arguments are passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.nAry(0, f)(a, b) = f()
 * @symb R.nAry(1, f)(a, b) = f(a)
 * @symb R.nAry(2, f)(a, b) = f(a, b)
 */
module.exports = _curry2(function nAry(n, fn) {
  switch (n) {
    case 0:
      return function () {
        return fn.call(this);
      };
    case 1:
      return function (a0) {
        return fn.call(this, a0);
      };
    case 2:
      return function (a0, a1) {
        return fn.call(this, a0, a1);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.call(this, a0, a1, a2);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.call(this, a0, a1, a2, a3);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.call(this, a0, a1, a2, a3, a4);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.call(this, a0, a1, a2, a3, a4, a5);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      };
    default:
      throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
  }
});

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var _curryN = __webpack_require__(32);
var _dispatchable = __webpack_require__(3);
var _has = __webpack_require__(6);
var _reduce = __webpack_require__(8);
var _xreduceBy = __webpack_require__(225);

/**
 * Groups the elements of the list according to the result of calling
 * the String-returning function `keyFn` on each element and reduces the elements
 * of each group to a single value via the reducer function `valueFn`.
 *
 * This function is basically a more general `groupBy` function.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category List
 * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
 * @param {Function} valueFn The function that reduces the elements of each group to a single
 *        value. Receives two values, accumulator for a particular group and the current element.
 * @param {*} acc The (initial) accumulator value for each group.
 * @param {Function} keyFn The function that maps the list's element into a key.
 * @param {Array} list The array to group.
 * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
 *         `valueFn` for elements which produced that key when passed to `keyFn`.
 * @see R.groupBy, R.reduce
 * @example
 *
 *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
 *      var namesByGrade = reduceToNamesBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Lucy', score: 92},
 *                      {name: 'Drew', score: 85},
 *                      // ...
 *                      {name: 'Bart', score: 62}];
 *      namesByGrade(students);
 *      // {
 *      //   'A': ['Lucy'],
 *      //   'B': ['Drew']
 *      //   // ...,
 *      //   'F': ['Bart']
 *      // }
 */
module.exports = _curryN(4, [], _dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
  return _reduce(function (acc, elt) {
    var key = keyFn(elt);
    acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
    return acc;
  }, {}, list);
}));

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var _complement = __webpack_require__(84);
var _curry2 = __webpack_require__(0);
var filter = __webpack_require__(47);

/**
 * The complement of `filter`.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      var isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
module.exports = _curry2(function reject(pred, filterable) {
  return filter(_complement(pred), filterable);
});

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _isString = __webpack_require__(35);

/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */
module.exports = _curry1(function reverse(list) {
  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry2 = __webpack_require__(0);
var _reduce = __webpack_require__(8);
var map = __webpack_require__(7);

/**
 * ap applies a list of functions to a list of values.
 *
 * Dispatches to the `ap` method of the second argument, if present. Also
 * treats curried functions as applicatives.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig [a -> b] -> [a] -> [b]
 * @sig Apply f => f (a -> b) -> f a -> f b
 * @param {Array} fns An array of functions
 * @param {Array} vs An array of values
 * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
 * @example
 *
 *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
 *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
 * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
 */
module.exports = _curry2(function ap(applicative, fn) {
  return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? function (x) {
    return applicative(x)(fn(x));
  } :
  // else
  _reduce(function (acc, f) {
    return _concat(acc, map(f, fn));
  }, [], applicative);
});

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _makeFlat = __webpack_require__(92);
var _xchain = __webpack_require__(214);
var map = __webpack_require__(7);

/**
 * `chain` maps a function over a list and concatenates the results. `chain`
 * is also known as `flatMap` in some libraries
 *
 * Dispatches to the `chain` method of the second argument, if present,
 * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain m => (a -> m b) -> m a -> m b
 * @param {Function} fn The function to map with
 * @param {Array} list The list to map over
 * @return {Array} The result of flat-mapping `list` with `fn`
 * @example
 *
 *      var duplicate = n => [n, n];
 *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
 *
 *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
 */
module.exports = _curry2(_dispatchable(['chain'], _xchain, function chain(fn, monad) {
  if (typeof monad === 'function') {
    return function (x) {
      return fn(monad(x))(x);
    };
  }
  return _makeFlat(false)(map(fn, monad));
}));

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var pipe = __webpack_require__(109);
var reverse = __webpack_require__(42);

/**
 * Performs right-to-left function composition. The rightmost function may have
 * any arity; the remaining functions must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */
module.exports = function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }
  return pipe.apply(this, reverse(arguments));
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isArray = __webpack_require__(14);
var _isFunction = __webpack_require__(33);
var toString = __webpack_require__(27);

/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `R.concat` expects both arguments to be of the same type,
 * unlike the native `Array.prototype.concat` method. It will throw
 * an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} firstList The first list
 * @param {Array|String} secondList The second list
 * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
 * `secondList`.
 *
 * @example
 *
 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 *      R.concat([], []); //=> []
 */
module.exports = _curry2(function concat(a, b) {
  if (a == null || !_isFunction(a.concat)) {
    throw new TypeError(toString(a) + ' does not have a method named "concat"');
  }
  if (_isArray(a) && !_isArray(b)) {
    throw new TypeError(toString(b) + ' is not an array');
  }
  return a.concat(b);
});

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _filter = __webpack_require__(86);
var _isObject = __webpack_require__(91);
var _reduce = __webpack_require__(8);
var _xfilter = __webpack_require__(219);
var keys = __webpack_require__(12);

/**
 * Takes a predicate and a "filterable", and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
module.exports = _curry2(_dispatchable(['filter'], _xfilter, function (pred, filterable) {
  return _isObject(filterable) ? _reduce(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }
    return acc;
  }, {}, keys(filterable)) :
  // else
  _filter(pred, filterable);
}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _identity = __webpack_require__(51);

/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      var obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */
module.exports = _curry1(_identity);

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var _objectAssign = __webpack_require__(204);

module.exports = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = function _containsWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
};

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = function _identity(x) {
  return x;
};

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */
module.exports = _curry2(function prop(p, obj) {
  return obj[p];
});

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__(21);
var _curry1 = __webpack_require__(1);
var slice = __webpack_require__(17);

/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */
module.exports = _curry1(_checkForMethod('tail', slice(1, Infinity)));

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 */
module.exports = _curry1(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(48);
var uniqBy = __webpack_require__(117);

/**
 * Returns a new list containing only one copy of each element in the original
 * list. `R.equals` is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */
module.exports = uniqBy(identity);

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var _containsWith = __webpack_require__(50);
var _curry2 = __webpack_require__(0);

/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied predicate to
 * two list elements. Prefers the first item if two items compare equal based
 * on the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category List
 * @sig (a, a -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      var strEq = R.eqBy(String);
 *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
 *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
 *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
 *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
 */
module.exports = _curry2(function uniqWith(pred, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var item;
  while (idx < len) {
    item = list[idx];
    if (!_containsWith(pred, item, result)) {
      result[result.length] = item;
    }
    idx += 1;
  }
  return result;
});

/***/ }),
/* 58 */,
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_utility__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__splitOrFullFare__ = __webpack_require__(340);
/* harmony export (immutable) */ __webpack_exports__["a"] = extensionFares;




// /**
//  * Calculates the extension fare (or none) of a journey
//  * @function
//  * @param {object} see below
//  * @param {singleFares} uses the singleFares json data
//  * @returns {number} - returns the extension fare for the journey
//  * @description
//
// 	FOR DAILY CAPS: ALWAYS START AT 1 SO MOST OF THIS CODE TOO COMPLEX: but would still work
// 	FOR WEEKLY CAPS: this works out fare without any daily caps or mix daily and weekly where there are no gap zones (so between 1 and max zone of either daily or weekly cap) -- unless you add in MaxDaily
//  // this is overly complicated for daily caps (as only deals with zone 1 to x) but still works. RELIES ON THE FACT DAILY ALWAYS STARTS AT 1
//  */

function extensionFares() {
	var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	var singleFares = arguments[1];

	var maxDaily = options.maxDaily || null;
	// by default: just one travelcard (weekly without daily or just daily cap) for either oyster or contactless, or oyster with weekly cap (doesn't cut off daily section of the journey)

	var zones = options.zones,
	    type = options.type,
	    minTravelcard = options.minTravelcard,
	    maxTravelcard = options.maxTravelcard;
	// same as var minSingle = options.minSingle;

	var finalCondition = null;
	var minSingle = zones[0];
	var maxSingle = zones[1];
	var minChargedZone = minSingle;

	if (maxDaily) {
		// If contactless, daily and weekly combo (hence adding in maxDaily as argument_
		if (maxDaily >= minTravelcard - 1) {
			// if no gap zones between max daily and min travelcard
			minTravelcard = 1; // since anytime daily caps always start at zone 1
			maxTravelcard = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["c" /* maxNum */])([maxDaily, maxTravelcard]); // max travelcard is whichever is largest max daily or max travelcard
			// else if contactless, daily and weekly combo, and there are gap zones between max daily and min travelcard, have a min charged zone (not charge the daily cap - the front)
		} else {
			// IF difference bw min weekly and max daily cap > 1 -- THEN THERE ARE GAP ZONES
			minChargedZone = minSingle <= maxDaily ? maxDaily + 1 : minSingle;
			finalCondition = minSingle <= maxDaily && maxSingle <= maxDaily;
		}
	}

	// if min single isnt within travelcard zones but max single is(NB not needed for daily cap) - charge front
	if (minSingle < minTravelcard && minTravelcard <= maxSingle && maxSingle <= maxTravelcard) {
		// debugger;
		return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* getSingleFare */])([minChargedZone, minTravelcard - 1], singleFares, type);

		//if min single within travelcard zones but max single isnt - charge end
	} else if (minTravelcard <= minSingle && minSingle <= maxTravelcard && maxSingle > maxTravelcard) {
		// debugger;
		return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* getSingleFare */])([maxTravelcard + 1, maxSingle], singleFares, type);

		//if min single less than min travelcard and max single more than max travelcard (NB not needed for daily cap) - charge front and end
	} else if (minSingle < minTravelcard && maxSingle > maxTravelcard) {
		// debugger;
		return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__splitOrFullFare__["a" /* default */])(minChargedZone, maxSingle, minTravelcard, maxTravelcard, singleFares, type);

		// both single zones within travelcard zones
	} else if (minTravelcard <= minSingle && minSingle <= maxTravelcard && minTravelcard <= maxSingle && maxSingle <= maxTravelcard || finalCondition) {
		// debugger;
		return 0;
		// both single zones are outside travelcard zones
	}

	return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* getSingleFare */])([minChargedZone, maxSingle], singleFares, type);
	// ELSE min single and max single both > max weekly zone (or both < min daily) OR min single zone > min gap zone && max single zone < max gap zone
}

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets fares.json file
 */
var fetchFareData = function () {
	var data = null;

	return function () {
		if (data) {
			console.log('oh! we are getting the cached data!');
			return Promise.resolve(data);
		}

		return fetch('/data/fares.json').then(function (resp) {
			data = resp.json();
			return data;
		});
	};
}();

// Gets station.json - listing what zones each station is
var fetchStationsData = function () {
	var data = null;

	return function () {
		if (data) {
			console.log('oh! we are getting the cached data!');
			return Promise.resolve(data);
		}

		return fetch('/data/stations.json').then(function (resp) {
			data = resp.json();
			return data;
		});
	};
}();

//Fetches the json file from TFL API
var fetchJourneyData = function fetchJourneyData(from, to) {
	return fetch('https://api.tfl.gov.uk/journey/journeyresults/' + from + '/to/' + to + '?app_id=8acd79a9&app_key=d433a2d6d9a9c8e8b1b4a6dd4371c69b').then(function (e) {
		return e.json();
	});
};

/* harmony default export */ __webpack_exports__["a"] = {
	fares: fetchFareData,
	stations: fetchStationsData,
	journey: fetchJourneyData
};

/***/ }),
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  F: __webpack_require__(137),
  T: __webpack_require__(138),
  __: __webpack_require__(139),
  add: __webpack_require__(28),
  addIndex: __webpack_require__(140),
  adjust: __webpack_require__(65),
  all: __webpack_require__(141),
  allPass: __webpack_require__(142),
  always: __webpack_require__(18),
  and: __webpack_require__(66),
  any: __webpack_require__(67),
  anyPass: __webpack_require__(143),
  ap: __webpack_require__(43),
  aperture: __webpack_require__(144),
  append: __webpack_require__(145),
  apply: __webpack_require__(68),
  applySpec: __webpack_require__(146),
  ascend: __webpack_require__(147),
  assoc: __webpack_require__(29),
  assocPath: __webpack_require__(69),
  binary: __webpack_require__(148),
  bind: __webpack_require__(70),
  both: __webpack_require__(149),
  call: __webpack_require__(150),
  chain: __webpack_require__(44),
  clamp: __webpack_require__(151),
  clone: __webpack_require__(152),
  comparator: __webpack_require__(153),
  complement: __webpack_require__(154),
  compose: __webpack_require__(45),
  composeK: __webpack_require__(71),
  composeP: __webpack_require__(155),
  concat: __webpack_require__(46),
  cond: __webpack_require__(156),
  construct: __webpack_require__(157),
  constructN: __webpack_require__(72),
  contains: __webpack_require__(158),
  converge: __webpack_require__(73),
  countBy: __webpack_require__(159),
  curry: __webpack_require__(30),
  curryN: __webpack_require__(5),
  dec: __webpack_require__(160),
  descend: __webpack_require__(161),
  defaultTo: __webpack_require__(74),
  difference: __webpack_require__(75),
  differenceWith: __webpack_require__(76),
  dissoc: __webpack_require__(77),
  dissocPath: __webpack_require__(162),
  divide: __webpack_require__(163),
  drop: __webpack_require__(78),
  dropLast: __webpack_require__(164),
  dropLastWhile: __webpack_require__(165),
  dropRepeats: __webpack_require__(166),
  dropRepeatsWith: __webpack_require__(79),
  dropWhile: __webpack_require__(167),
  either: __webpack_require__(168),
  empty: __webpack_require__(80),
  eqBy: __webpack_require__(169),
  eqProps: __webpack_require__(170),
  equals: __webpack_require__(10),
  evolve: __webpack_require__(171),
  filter: __webpack_require__(47),
  find: __webpack_require__(172),
  findIndex: __webpack_require__(173),
  findLast: __webpack_require__(174),
  findLastIndex: __webpack_require__(175),
  flatten: __webpack_require__(176),
  flip: __webpack_require__(31),
  forEach: __webpack_require__(177),
  forEachObjIndexed: __webpack_require__(178),
  fromPairs: __webpack_require__(179),
  groupBy: __webpack_require__(180),
  groupWith: __webpack_require__(181),
  gt: __webpack_require__(182),
  gte: __webpack_require__(183),
  has: __webpack_require__(184),
  hasIn: __webpack_require__(185),
  head: __webpack_require__(186),
  identical: __webpack_require__(81),
  identity: __webpack_require__(48),
  ifElse: __webpack_require__(187),
  inc: __webpack_require__(188),
  indexBy: __webpack_require__(189),
  indexOf: __webpack_require__(190),
  init: __webpack_require__(191),
  insert: __webpack_require__(192),
  insertAll: __webpack_require__(193),
  intersection: __webpack_require__(228),
  intersectionWith: __webpack_require__(229),
  intersperse: __webpack_require__(230),
  into: __webpack_require__(231),
  invert: __webpack_require__(232),
  invertObj: __webpack_require__(233),
  invoker: __webpack_require__(22),
  is: __webpack_require__(96),
  isArrayLike: __webpack_require__(23),
  isEmpty: __webpack_require__(234),
  isNil: __webpack_require__(235),
  join: __webpack_require__(236),
  juxt: __webpack_require__(97),
  keys: __webpack_require__(12),
  keysIn: __webpack_require__(237),
  last: __webpack_require__(98),
  lastIndexOf: __webpack_require__(238),
  length: __webpack_require__(99),
  lens: __webpack_require__(37),
  lensIndex: __webpack_require__(239),
  lensPath: __webpack_require__(240),
  lensProp: __webpack_require__(241),
  lift: __webpack_require__(38),
  liftN: __webpack_require__(100),
  lt: __webpack_require__(242),
  lte: __webpack_require__(243),
  map: __webpack_require__(7),
  mapAccum: __webpack_require__(244),
  mapAccumRight: __webpack_require__(245),
  mapObjIndexed: __webpack_require__(246),
  match: __webpack_require__(247),
  mathMod: __webpack_require__(248),
  max: __webpack_require__(19),
  maxBy: __webpack_require__(249),
  mean: __webpack_require__(101),
  median: __webpack_require__(250),
  memoize: __webpack_require__(251),
  merge: __webpack_require__(252),
  mergeAll: __webpack_require__(253),
  mergeWith: __webpack_require__(254),
  mergeWithKey: __webpack_require__(102),
  min: __webpack_require__(255),
  minBy: __webpack_require__(256),
  modulo: __webpack_require__(257),
  multiply: __webpack_require__(103),
  nAry: __webpack_require__(39),
  negate: __webpack_require__(258),
  none: __webpack_require__(259),
  not: __webpack_require__(104),
  nth: __webpack_require__(24),
  nthArg: __webpack_require__(260),
  objOf: __webpack_require__(105),
  of: __webpack_require__(261),
  omit: __webpack_require__(262),
  once: __webpack_require__(263),
  or: __webpack_require__(106),
  over: __webpack_require__(107),
  pair: __webpack_require__(264),
  partial: __webpack_require__(265),
  partialRight: __webpack_require__(266),
  partition: __webpack_require__(267),
  path: __webpack_require__(25),
  pathEq: __webpack_require__(268),
  pathOr: __webpack_require__(269),
  pathSatisfies: __webpack_require__(270),
  pick: __webpack_require__(271),
  pickAll: __webpack_require__(108),
  pickBy: __webpack_require__(272),
  pipe: __webpack_require__(109),
  pipeK: __webpack_require__(273),
  pipeP: __webpack_require__(110),
  pluck: __webpack_require__(26),
  prepend: __webpack_require__(111),
  product: __webpack_require__(274),
  project: __webpack_require__(275),
  prop: __webpack_require__(53),
  propEq: __webpack_require__(276),
  propIs: __webpack_require__(277),
  propOr: __webpack_require__(278),
  propSatisfies: __webpack_require__(279),
  props: __webpack_require__(280),
  range: __webpack_require__(281),
  reduce: __webpack_require__(13),
  reduceBy: __webpack_require__(40),
  reduceRight: __webpack_require__(112),
  reduceWhile: __webpack_require__(282),
  reduced: __webpack_require__(283),
  reject: __webpack_require__(41),
  remove: __webpack_require__(284),
  repeat: __webpack_require__(285),
  replace: __webpack_require__(286),
  reverse: __webpack_require__(42),
  scan: __webpack_require__(287),
  sequence: __webpack_require__(113),
  set: __webpack_require__(288),
  slice: __webpack_require__(17),
  sort: __webpack_require__(289),
  sortBy: __webpack_require__(290),
  sortWith: __webpack_require__(291),
  split: __webpack_require__(292),
  splitAt: __webpack_require__(293),
  splitEvery: __webpack_require__(294),
  splitWhen: __webpack_require__(295),
  subtract: __webpack_require__(296),
  sum: __webpack_require__(114),
  symmetricDifference: __webpack_require__(297),
  symmetricDifferenceWith: __webpack_require__(298),
  tail: __webpack_require__(54),
  take: __webpack_require__(115),
  takeLast: __webpack_require__(299),
  takeLastWhile: __webpack_require__(300),
  takeWhile: __webpack_require__(301),
  tap: __webpack_require__(302),
  test: __webpack_require__(303),
  times: __webpack_require__(116),
  toLower: __webpack_require__(304),
  toPairs: __webpack_require__(305),
  toPairsIn: __webpack_require__(306),
  toString: __webpack_require__(27),
  toUpper: __webpack_require__(307),
  transduce: __webpack_require__(308),
  transpose: __webpack_require__(309),
  traverse: __webpack_require__(310),
  trim: __webpack_require__(311),
  tryCatch: __webpack_require__(312),
  type: __webpack_require__(55),
  unapply: __webpack_require__(313),
  unary: __webpack_require__(314),
  uncurryN: __webpack_require__(315),
  unfold: __webpack_require__(316),
  union: __webpack_require__(317),
  unionWith: __webpack_require__(318),
  uniq: __webpack_require__(56),
  uniqBy: __webpack_require__(117),
  uniqWith: __webpack_require__(57),
  unless: __webpack_require__(319),
  unnest: __webpack_require__(320),
  until: __webpack_require__(321),
  update: __webpack_require__(118),
  useWith: __webpack_require__(119),
  values: __webpack_require__(120),
  valuesIn: __webpack_require__(322),
  view: __webpack_require__(323),
  when: __webpack_require__(324),
  where: __webpack_require__(121),
  whereEq: __webpack_require__(325),
  without: __webpack_require__(326),
  xprod: __webpack_require__(327),
  zip: __webpack_require__(328),
  zipObj: __webpack_require__(329),
  zipWith: __webpack_require__(330)
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry3 = __webpack_require__(2);

/**
 * Applies a function to the value at the given index of an array, returning a
 * new copy of the array with the element at the given index replaced with the
 * result of the function application.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig (a -> a) -> Number -> [a] -> [a]
 * @param {Function} fn The function to apply.
 * @param {Number} idx The index.
 * @param {Array|Arguments} list An array-like object whose value
 *        at the supplied index will be replaced.
 * @return {Array} A copy of the supplied array-like object with
 *         the element at index `idx` replaced with the value
 *         returned by applying `fn` to the existing element.
 * @see R.update
 * @example
 *
 *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
 *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
 * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
 * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
 */
module.exports = _curry3(function adjust(fn, idx, list) {
  if (idx >= list.length || idx < -list.length) {
    return list;
  }
  var start = idx < 0 ? list.length : 0;
  var _idx = start + idx;
  var _list = _concat(list);
  _list[_idx] = fn(list[_idx]);
  return _list;
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if both arguments are `true`; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if it is falsy, otherwise the second argument.
 * @see R.both
 * @example
 *
 *      R.and(true, true); //=> true
 *      R.and(true, false); //=> false
 *      R.and(false, true); //=> false
 *      R.and(false, false); //=> false
 */
module.exports = _curry2(function and(a, b) {
  return a && b;
});

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xany = __webpack_require__(93);

/**
 * Returns `true` if at least one of elements of the list match the predicate,
 * `false` otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
 *         otherwise.
 * @see R.all, R.none, R.transduce
 * @example
 *
 *      var lessThan0 = R.flip(R.lt)(0);
 *      var lessThan2 = R.flip(R.lt)(2);
 *      R.any(lessThan0)([1, 2]); //=> false
 *      R.any(lessThan2)([1, 2]); //=> true
 */
module.exports = _curry2(_dispatchable(['any'], _xany, function any(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (fn(list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}));

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Applies function `fn` to the argument list `args`. This is useful for
 * creating a fixed-arity function from a variadic function. `fn` should be a
 * bound function if context is significant.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig (*... -> a) -> [*] -> a
 * @param {Function} fn The function which will be called with `args`
 * @param {Array} args The arguments to call `fn` with
 * @return {*} result The result, equivalent to `fn(...args)`
 * @see R.call, R.unapply
 * @example
 *
 *      var nums = [1, 2, 3, -99, 42, 6, 7];
 *      R.apply(Math.max, nums); //=> 42
 * @symb R.apply(f, [a, b, c]) = f(a, b, c)
 */
module.exports = _curry2(function apply(fn, args) {
  return fn.apply(this, args);
});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var _has = __webpack_require__(6);
var _isArray = __webpack_require__(14);
var _isInteger = __webpack_require__(89);
var assoc = __webpack_require__(29);

/**
 * Makes a shallow clone of an object, setting or overriding the nodes required
 * to create the given path, and placing the specific value at the tail end of
 * that path. Note that this copies and flattens prototype properties onto the
 * new object as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> {a}
 * @param {Array} path the path to set
 * @param {*} val The new value
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original except along the specified path.
 * @see R.dissocPath
 * @example
 *
 *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
 *
 *      // Any missing or non-object keys in path will be overridden
 *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
 */
module.exports = _curry3(function assocPath(path, val, obj) {
  if (path.length === 0) {
    return val;
  }
  var idx = path[0];
  if (path.length > 1) {
    var nextObj = _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
    val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
  }
  if (_isInteger(idx) && _isArray(obj)) {
    var arr = [].concat(obj);
    arr[idx] = val;
    return arr;
  } else {
    return assoc(idx, val, obj);
  }
});

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _curry2 = __webpack_require__(0);

/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */
module.exports = _curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var chain = __webpack_require__(44);
var compose = __webpack_require__(45);
var map = __webpack_require__(7);

/**
 * Returns the right-to-left Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipeK
 * @example
 *
 *       //  get :: String -> Object -> Maybe *
 *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
 *
 *       //  getStateCode :: Maybe String -> Maybe String
 *       var getStateCode = R.composeK(
 *         R.compose(Maybe.of, R.toUpper),
 *         get('state'),
 *         get('address'),
 *         get('user'),
 *       );
 *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
 *       getStateCode({}); //=> Maybe.Nothing()
 * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
 */
module.exports = function composeK() {
  if (arguments.length === 0) {
    throw new Error('composeK requires at least one argument');
  }
  var init = Array.prototype.slice.call(arguments);
  var last = init.pop();
  return compose(compose.apply(this, map(chain, init)), last);
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var curry = __webpack_require__(30);
var nAry = __webpack_require__(39);

/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type. The arity of the function
 * returned is specified to allow using variadic constructor functions.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Function
 * @sig Number -> (* -> {*}) -> (* -> {*})
 * @param {Number} n The arity of the constructor function.
 * @param {Function} Fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @example
 *
 *      // Variadic Constructor function
 *      function Salad() {
 *        this.ingredients = arguments;
 *      };
 *      Salad.prototype.recipe = function() {
 *        var instructions = R.map((ingredient) => (
 *          'Add a whollop of ' + ingredient, this.ingredients)
 *        )
 *        return R.join('\n', instructions)
 *      }
 *
 *      var ThreeLayerSalad = R.constructN(3, Salad)
 *
 *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
 *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup')
 *      console.log(salad.recipe());
 *      // Add a whollop of Mayonnaise
 *      // Add a whollop of Potato Chips
 *      // Add a whollop of Potato Ketchup
 */
module.exports = _curry2(function constructN(n, Fn) {
  if (n > 10) {
    throw new Error('Constructor with greater than ten arguments');
  }
  if (n === 0) {
    return function () {
      return new Fn();
    };
  }
  return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (arguments.length) {
      case 1:
        return new Fn($0);
      case 2:
        return new Fn($0, $1);
      case 3:
        return new Fn($0, $1, $2);
      case 4:
        return new Fn($0, $1, $2, $3);
      case 5:
        return new Fn($0, $1, $2, $3, $4);
      case 6:
        return new Fn($0, $1, $2, $3, $4, $5);
      case 7:
        return new Fn($0, $1, $2, $3, $4, $5, $6);
      case 8:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
      case 9:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10:
        return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _map = __webpack_require__(36);
var curryN = __webpack_require__(5);
var max = __webpack_require__(19);
var pluck = __webpack_require__(26);
var reduce = __webpack_require__(13);

/**
 * Accepts a converging function and a list of branching functions and returns
 * a new function. When invoked, this new function is applied to some
 * arguments, each branching function is applied to those same arguments. The
 * results of each branching function are passed as arguments to the converging
 * function to produce the return value.
 *
 * @func
 * @memberOf R
 * @since v0.4.2
 * @category Function
 * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} after A function. `after` will be invoked with the return values of
 *        `fn1` and `fn2` as its arguments.
 * @param {Array} functions A list of functions.
 * @return {Function} A new function.
 * @see R.useWith
 * @example
 *
 *      var average = R.converge(R.divide, [R.sum, R.length])
 *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
 *
 *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
 *      strangeConcat("Yodel") //=> "YODELyodel"
 *
 * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
 */
module.exports = _curry2(function converge(after, fns) {
  return curryN(reduce(max, 0, pluck('length', fns)), function () {
    var args = arguments;
    var context = this;
    return after.apply(context, _map(function (fn) {
      return fn.apply(context, args);
    }, fns));
  });
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`
 * otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {a} default The default value.
 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
 * @example
 *
 *      var defaultTo42 = R.defaultTo(42);
 *
 *      defaultTo42(null);  //=> 42
 *      defaultTo42(undefined);  //=> 42
 *      defaultTo42('Ramda');  //=> 'Ramda'
 *      // parseInt('string') results in NaN
 *      defaultTo42(parseInt('string')); //=> 42
 */
module.exports = _curry2(function defaultTo(d, v) {
  return v == null || v !== v ? d : v;
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var _contains = __webpack_require__(16);
var _curry2 = __webpack_require__(0);

/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Objects and Arrays are compared are compared
 * in terms of value equality, not reference equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith
 * @example
 *
 *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
 *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
 *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
 */
module.exports = _curry2(function difference(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var _containsWith = __webpack_require__(50);
var _curry3 = __webpack_require__(2);

/**
 * Finds the set (i.e. no duplicates) of all elements in the first list not
 * contained in the second list. Duplication is determined according to the
 * value returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` that are not in `list2`.
 * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
 * @example
 *
 *      var cmp = (x, y) => x.a === y.a;
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
 *      var l2 = [{a: 3}, {a: 4}];
 *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
 */
module.exports = _curry3(function differenceWith(pred, first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a new object that does not contain a `prop` property.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Object
 * @sig String -> {k: v} -> {k: v}
 * @param {String} prop The name of the property to dissociate
 * @param {Object} obj The object to clone
 * @return {Object} A new object equivalent to the original but without the specified property
 * @see R.assoc
 * @example
 *
 *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
 */
module.exports = _curry2(function dissoc(prop, obj) {
  var result = {};
  for (var p in obj) {
    result[p] = obj[p];
  }
  delete result[prop];
  return result;
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xdrop = __webpack_require__(215);
var slice = __webpack_require__(17);

/**
 * Returns all but the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `drop` method).
 *
 * Dispatches to the `drop` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {[a]} list
 * @return {[a]} A copy of list without the first `n` elements
 * @see R.take, R.transduce, R.dropLast, R.dropWhile
 * @example
 *
 *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
 *      R.drop(3, 'ramda');               //=> 'da'
 */
module.exports = _curry2(_dispatchable(['drop'], _xdrop, function drop(n, xs) {
  return slice(Math.max(0, n), Infinity, xs);
}));

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xdropRepeatsWith = __webpack_require__(94);
var last = __webpack_require__(98);

/**
 * Returns a new list without any consecutively repeating elements. Equality is
 * determined by applying the supplied predicate to each pair of consecutive elements. The
 * first element in a series of equal elements will be preserved.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig (a, a -> Boolean) -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
 *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
 */
module.exports = _curry2(_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
  var result = [];
  var idx = 1;
  var len = list.length;
  if (len !== 0) {
    result[0] = list[0];
    while (idx < len) {
      if (!pred(last(result), list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
  }
  return result;
}));

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _isArguments = __webpack_require__(88);
var _isArray = __webpack_require__(14);
var _isObject = __webpack_require__(91);
var _isString = __webpack_require__(35);

/**
 * Returns the empty value of its argument's type. Ramda defines the empty
 * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
 * types are supported if they define `<Type>.empty` and/or
 * `<Type>.prototype.empty`.
 *
 * Dispatches to the `empty` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> a
 * @param {*} x
 * @return {*}
 * @example
 *
 *      R.empty(Just(42));      //=> Nothing()
 *      R.empty([1, 2, 3]);     //=> []
 *      R.empty('unicorns');    //=> ''
 *      R.empty({x: 1, y: 2});  //=> {}
 */
module.exports = _curry1(function empty(x) {
  return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
    return arguments;
  }() :
  // else
  void 0;
});

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
module.exports = _curry2(function identical(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var _cloneRegExp = __webpack_require__(83);
var type = __webpack_require__(55);

/**
 * Copies an object.
 *
 * @private
 * @param {*} value The value to be copied
 * @param {Array} refFrom Array containing the source references
 * @param {Array} refTo Array containing the copied source references
 * @param {Boolean} deep Whether or not to perform deep cloning.
 * @return {*} The copied value.
 */
module.exports = function _clone(value, refFrom, refTo, deep) {
  var copy = function copy(copiedValue) {
    var len = refFrom.length;
    var idx = 0;
    while (idx < len) {
      if (value === refFrom[idx]) {
        return refTo[idx];
      }
      idx += 1;
    }
    refFrom[idx + 1] = value;
    refTo[idx + 1] = copiedValue;
    for (var key in value) {
      copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
    }
    return copiedValue;
  };
  switch (type(value)) {
    case 'Object':
      return copy({});
    case 'Array':
      return copy([]);
    case 'Date':
      return new Date(value.valueOf());
    case 'RegExp':
      return _cloneRegExp(value);
    default:
      return value;
  }
};

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = function _cloneRegExp(pattern) {
                                  return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
};

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = function _complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _curry2 = __webpack_require__(0);

module.exports = function _createPartialApplicator(concat) {
  return _curry2(function (fn, args) {
    return _arity(Math.max(0, fn.length - args.length), function () {
      return fn.apply(this, concat(args, arguments));
    });
  });
};

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var equals = __webpack_require__(10);

module.exports = function _indexOf(list, a, idx) {
  var inf, item;
  // Array.prototype.indexOf doesn't exist below IE9
  if (typeof list.indexOf === 'function') {
    switch (typeof a === 'undefined' ? 'undefined' : _typeof(a)) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === 'number' && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        // non-zero numbers can utilise Set
        return list.indexOf(a, idx);

      // all these types can utilise Set
      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }
    }
  }
  // anything else not covered above, defer to R.equals
  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var _has = __webpack_require__(6);

module.exports = function () {
  var toString = Object.prototype.toString;
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has('callee', x);
  };
}();

/***/ }),
/* 89 */
/***/ (function(module, exports) {

/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
module.exports = Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
};

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = function _isNumber(x) {
  return Object.prototype.toString.call(x) === '[object Number]';
};

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(23);

/**
 * `_makeFlat` is a helper function that returns a one-level or fully recursive
 * function based on the flag passed in.
 *
 * @private
 */
module.exports = function _makeFlat(recursive) {
  return function flatt(list) {
    var value, jlen, j;
    var result = [];
    var idx = 0;
    var ilen = list.length;

    while (idx < ilen) {
      if (isArrayLike(list[idx])) {
        value = recursive ? flatt(list[idx]) : list[idx];
        j = 0;
        jlen = value.length;
        while (j < jlen) {
          result[result.length] = value[j];
          j += 1;
        }
      } else {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduced = __webpack_require__(15);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XAny(f, xf) {
    this.xf = xf;
    this.f = f;
    this.any = false;
  }
  XAny.prototype['@@transducer/init'] = _xfBase.init;
  XAny.prototype['@@transducer/result'] = function (result) {
    if (!this.any) {
      result = this.xf['@@transducer/step'](result, false);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAny.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.any = true;
      result = _reduced(this.xf['@@transducer/step'](result, true));
    }
    return result;
  };

  return _curry2(function _xany(f, xf) {
    return new XAny(f, xf);
  });
}();

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XDropRepeatsWith(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = undefined;
    this.seenFirstValue = false;
  }

  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;
  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdropRepeatsWith(pred, xf) {
    return new XDropRepeatsWith(pred, xf);
  });
}();

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = function () {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };
  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return function _xwrap(fn) {
    return new XWrap(fn);
  };
}();

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * See if an object (`val`) is an instance of the supplied constructor. This
 * function will check up the inheritance chain, if any.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Type
 * @sig (* -> {*}) -> a -> Boolean
 * @param {Object} ctor A constructor
 * @param {*} val The value to test
 * @return {Boolean}
 * @example
 *
 *      R.is(Object, {}); //=> true
 *      R.is(Number, 1); //=> true
 *      R.is(Object, 1); //=> false
 *      R.is(String, 's'); //=> true
 *      R.is(String, new String('')); //=> true
 *      R.is(Object, new String('')); //=> true
 *      R.is(Object, 's'); //=> false
 *      R.is(Number, {}); //=> false
 */
module.exports = _curry2(function is(Ctor, val) {
  return val != null && val.constructor === Ctor || val instanceof Ctor;
});

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var converge = __webpack_require__(73);

/**
 * juxt applies a list of functions to a list of values.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Function
 * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
 * @param {Array} fns An array of functions
 * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
 * @see R.applySpec
 * @example
 *
 *      var getRange = R.juxt([Math.min, Math.max]);
 *      getRange(3, 4, 9, -3); //=> [-3, 9]
 * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
 */
module.exports = _curry1(function juxt(fns) {
  return converge(function () {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var nth = __webpack_require__(24);

/**
 * Returns the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.init, R.head, R.tail
 * @example
 *
 *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
 *      R.last([]); //=> undefined
 *
 *      R.last('abc'); //=> 'c'
 *      R.last(''); //=> ''
 */
module.exports = nth(-1);

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _isNumber = __webpack_require__(90);

/**
 * Returns the number of elements in the array by returning `list.length`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [a] -> Number
 * @param {Array} list The array to inspect.
 * @return {Number} The length of the array.
 * @example
 *
 *      R.length([]); //=> 0
 *      R.length([1, 2, 3]); //=> 3
 */
module.exports = _curry1(function length(list) {
  return list != null && _isNumber(list.length) ? list.length : NaN;
});

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduce = __webpack_require__(8);
var ap = __webpack_require__(43);
var curryN = __webpack_require__(5);
var map = __webpack_require__(7);

/**
 * "lifts" a function to be the specified arity, so that it may "map over" that
 * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Function
 * @sig Number -> (*... -> *) -> ([*]... -> [*])
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function.
 * @see R.lift, R.ap
 * @example
 *
 *      var madd3 = R.liftN(3, (...args) => R.sum(args));
 *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
 */
module.exports = _curry2(function liftN(arity, fn) {
  var lifted = curryN(arity, fn);
  return curryN(arity, function () {
    return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var sum = __webpack_require__(114);

/**
 * Returns the mean of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @example
 *
 *      R.mean([2, 7, 9]); //=> 6
 *      R.mean([]); //=> NaN
 */
module.exports = _curry1(function mean(list) {
  return sum(list) / list.length;
});

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var _has = __webpack_require__(6);

/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the key
 * and the values associated with the key in each object, with the result being
 * used as the value associated with the key in the returned object. The key
 * will be excluded from the returned object if the resulting value is
 * `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.merge, R.mergeWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeWithKey(concatValues,
 *                     { a: true, thing: 'foo', values: [10, 20] },
 *                     { b: true, thing: 'bar', values: [15, 35] });
 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
 */
module.exports = _curry3(function mergeWithKey(fn, l, r) {
  var result = {};
  var k;

  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }

  for (k in r) {
    if (_has(k, r) && !_has(k, result)) {
      result[k] = r[k];
    }
  }

  return result;
});

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Multiplies two numbers. Equivalent to `a * b` but curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a * b`.
 * @see R.divide
 * @example
 *
 *      var double = R.multiply(2);
 *      var triple = R.multiply(3);
 *      double(3);       //=>  6
 *      triple(4);       //=> 12
 *      R.multiply(2, 5);  //=> 10
 */
module.exports = _curry2(function multiply(a, b) {
  return a * b;
});

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */
module.exports = _curry1(function not(a) {
  return !a;
});

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Creates an object containing a single key:value pair.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @sig String -> a -> {String:a}
 * @param {String} key
 * @param {*} val
 * @return {Object}
 * @see R.pair
 * @example
 *
 *      var matchPhrases = R.compose(
 *        R.objOf('must'),
 *        R.map(R.objOf('match_phrase'))
 *      );
 *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
 */
module.exports = _curry2(function objOf(key, val) {
  var obj = {};
  obj[key] = val;
  return obj;
});

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if one or both of its arguments are `true`. Returns `false`
 * if both arguments are `false`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {Any} a
 * @param {Any} b
 * @return {Any} the first argument if truthy, otherwise the second argument.
 * @see R.either
 * @example
 *
 *      R.or(true, true); //=> true
 *      R.or(true, false); //=> true
 *      R.or(false, true); //=> true
 *      R.or(false, false); //=> false
 */
module.exports = _curry2(function or(a, b) {
  return a || b;
});

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the result of applying the given function to
 * the focused value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> (a -> a) -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
 */
module.exports = function () {
  // `Identity` is a functor that holds a single value, where `map` simply
  // transforms the held value with the provided function.
  var Identity = function Identity(x) {
    return { value: x, map: function map(f) {
        return Identity(f(x));
      } };
  };

  return _curry3(function over(lens, f, x) {
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    return lens(function (y) {
      return Identity(f(y));
    })(x).value;
  });
}();

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Similar to `pick` except that this one includes a `key: undefined` pair for
 * properties that don't exist.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.pick
 * @example
 *
 *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
 */
module.exports = _curry2(function pickAll(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name = names[idx];
    result[name] = obj[name];
    idx += 1;
  }
  return result;
});

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _pipe = __webpack_require__(206);
var reduce = __webpack_require__(13);
var tail = __webpack_require__(54);

/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */
module.exports = function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _pipeP = __webpack_require__(207);
var reduce = __webpack_require__(13);
var tail = __webpack_require__(54);

/**
 * Performs left-to-right composition of one or more Promise-returning
 * functions. The leftmost function may have any arity; the remaining functions
 * must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.composeP
 * @example
 *
 *      //  followersForUser :: String -> Promise [User]
 *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
 */
module.exports = function pipeP() {
  if (arguments.length === 0) {
    throw new Error('pipeP requires at least one argument');
  }
  return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry2 = __webpack_require__(0);

/**
 * Returns a new list with the given element at the front, followed by the
 * contents of the list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The item to add to the head of the output list.
 * @param {Array} list The array to add to the tail of the output list.
 * @return {Array} A new array.
 * @see R.append
 * @example
 *
 *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
 */
module.exports = _curry2(function prepend(el, list) {
  return _concat([el], list);
});

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * Similar to `reduce`, except moves through the input list from the right to
 * the left.
 *
 * The iterator function receives two values: *(value, acc)*, while the arguments'
 * order of `reduce`'s iterator function is *(acc, value)*.
 *
 * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a, b -> b) -> b -> [a] -> b
 * @param {Function} fn The iterator function. Receives two values, the current element from the array
 *        and the accumulator.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.addIndex
 * @example
 *
 *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
 *          -               -2
 *         / \              / \
 *        1   -            1   3
 *           / \              / \
 *          2   -     ==>    2  -1
 *             / \              / \
 *            3   -            3   4
 *               / \              / \
 *              4   0            4   0
 *
 * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
 */
module.exports = _curry3(function reduceRight(fn, acc, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    acc = fn(list[idx], acc);
    idx -= 1;
  }
  return acc;
});

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var ap = __webpack_require__(43);
var map = __webpack_require__(7);
var prepend = __webpack_require__(111);
var reduceRight = __webpack_require__(112);

/**
 * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
 * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
 * Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
 * @param {Function} of
 * @param {*} traversable
 * @return {*}
 * @see R.traverse
 * @example
 *
 *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
 *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
 *
 *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
 *      R.sequence(R.of, Nothing());       //=> [Nothing()]
 */
module.exports = _curry2(function sequence(of, traversable) {
  return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
    return ap(map(prepend, x), acc);
  }, of([]), traversable);
});

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var add = __webpack_require__(28);
var reduce = __webpack_require__(13);

/**
 * Adds together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The sum of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.sum([2,4,6,8,100,1]); //=> 121
 */
module.exports = reduce(add, 0);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xtake = __webpack_require__(226);
var slice = __webpack_require__(17);

/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      var personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      var takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */
module.exports = _curry2(_dispatchable(['take'], _xtake, function take(n, xs) {
  return slice(0, n < 0 ? Infinity : n, xs);
}));

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Calls an input function `n` times, returning an array containing the results
 * of those function calls.
 *
 * `fn` is passed one argument: The current value of `n`, which begins at `0`
 * and is gradually incremented to `n - 1`.
 *
 * @func
 * @memberOf R
 * @since v0.2.3
 * @category List
 * @sig (Number -> a) -> Number -> [a]
 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
 * @return {Array} An array containing the return values of all calls to `fn`.
 * @example
 *
 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
 * @symb R.times(f, 0) = []
 * @symb R.times(f, 1) = [f(0)]
 * @symb R.times(f, 2) = [f(0), f(1)]
 */
module.exports = _curry2(function times(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;

  if (len < 0 || isNaN(len)) {
    throw new RangeError('n must be a non-negative number');
  }
  list = new Array(len);
  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }
  return list;
});

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var _Set = __webpack_require__(194);
var _curry2 = __webpack_require__(0);

/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. `R.equals` is used for comparison.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */
module.exports = _curry2(function uniqBy(fn, list) {
  var set = new _Set();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);
    if (set.add(appliedItem)) {
      result.push(item);
    }
    idx += 1;
  }
  return result;
});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var adjust = __webpack_require__(65);
var always = __webpack_require__(18);

/**
 * Returns a new copy of the array with the element at the provided index
 * replaced with the given value.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} idx The index to update.
 * @param {*} x The value to exist at the given index of the returned array.
 * @param {Array|Arguments} list The source array-like object to be updated.
 * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
 * @see R.adjust
 * @example
 *
 *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
 *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
 * @symb R.update(-1, a, [b, c]) = [b, a]
 * @symb R.update(0, a, [b, c]) = [a, c]
 * @symb R.update(1, a, [b, c]) = [b, a]
 */
module.exports = _curry3(function update(idx, x, list) {
  return adjust(always(x), idx, list);
});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var curryN = __webpack_require__(5);

/**
 * Accepts a function `fn` and a list of transformer functions and returns a
 * new curried function. When the new function is invoked, it calls the
 * function `fn` with parameters consisting of the result of calling each
 * supplied handler on successive arguments to the new function.
 *
 * If more arguments are passed to the returned function than transformer
 * functions, those arguments are passed directly to `fn` as additional
 * parameters. If you expect additional arguments that don't need to be
 * transformed, although you can ignore them, it's best to pass an identity
 * function so that the new function reports the correct arity.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
 * @param {Function} fn The function to wrap.
 * @param {Array} transformers A list of transformer functions
 * @return {Function} The wrapped function.
 * @see R.converge
 * @example
 *
 *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
 *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
 *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
 *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
 * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
 */
module.exports = _curry2(function useWith(fn, transformers) {
  return curryN(transformers.length, function () {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var keys = __webpack_require__(12);

/**
 * Returns a list of all the enumerable own properties of the supplied object.
 * Note that the order of the output array is not guaranteed across different
 * JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own properties.
 * @example
 *
 *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
 */
module.exports = _curry1(function values(obj) {
  var props = keys(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }
  return vals;
});

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _has = __webpack_require__(6);

/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec. Each of the spec's own properties must be a predicate function.
 * Each predicate is applied to the value of the corresponding property of the
 * test object. `where` returns true if all the predicates return true, false
 * otherwise.
 *
 * `where` is well suited to declaratively expressing constraints for other
 * functions such as `filter` and `find`.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Object
 * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.where({
 *        a: R.equals('foo'),
 *        b: R.complement(R.equals('bar')),
 *        x: R.gt(__, 10),
 *        y: R.lt(__, 20)
 *      });
 *
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
 *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
 *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
 */
module.exports = _curry2(function where(spec, testObj) {
  for (var prop in spec) {
    if (_has(prop, spec) && !spec[prop](testObj[prop])) {
      return false;
    }
  }
  return true;
});

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_getData__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility_utility__ = __webpack_require__(20);
/* unused harmony export default */
//The complete function in order to get the minimum and maximum zones of that journey (taking into consideration dual zones)
// stations is the .json file from fetchStationsData() function
// Need to make it so that it generates it after each journey




function getSingleJourneyZones(from, to, stations) {
	return __WEBPACK_IMPORTED_MODULE_0__utility_getData__["a" /* default */].journey(from, to).then(function (journey) {
		var journey = journey.journeys[0]; // selecting only the first journey from the API
		var legs = journey.legs; //To look at each leg of the journey

		// The array of zones associated with all stations of that journey
		var allZones = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(legs.map(function (leg) {
			var tempZones = [];

			//Gets the zones of the departurePoints and adds them to allZones array
			if (leg.departurePoint && leg.departurePoint.naptanId) {
				tempZones.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["g" /* getZones */])(leg.departurePoint.naptanId, stations));
			}

			//Gets the zones of the StopPoint and adds them to allZones array
			if (leg.path.stopPoints && leg.path.stopPoints.length > 0) {
				leg.path.stopPoints.forEach(function (stopPoint) {
					if (stopPoint.id) {
						tempZones.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["g" /* getZones */])(stopPoint.id, stations));
					}
				});
			}

			return tempZones;
		}));

		//Filters all the stations and split them into zonesFromSingleStations and zonesFromDualStations
		// var zonesFromSingleStations = flatten(filterZonesByNumber(1, allZones));
		var zonesFromSingleStations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["h" /* filterZonesByNumber */])(1, allZones);
		var zonesFromDualStations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["h" /* filterZonesByNumber */])(2, allZones); //NB this is an array within an array
		var finalMaxZone = null;
		var finalMinZone = null;

		if (zonesFromSingleStations.length === 0) {
			//for dual zones to dual zones **ASSUMING CAN ONLY TRAVEL FROM THE SAME DUAL ZONES (2/3 to 2/3 and not 2/3 to 3/4)**
			finalMaxZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(zonesFromDualStations));
			finalMinZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(zonesFromDualStations));
			//**NEED TO ADD A FLAG HERE to say that it is dual to dual zone & what zones (so that can manipulate and pick zones from closest to weekly capped zone rather than min zone)
		} else {
			zonesFromSingleStations = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["f" /* flatten */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["h" /* filterZonesByNumber */])(1, allZones));

			//Calculates the max and min Zones of all the zones that are from stations without any dual zones.
			var singleMax = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["c" /* maxNum */])(zonesFromSingleStations);
			var singleMin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])(zonesFromSingleStations);

			//For each zonesFromDualStations: picks the most appropriate zone and appends to dualZones array 
			// --> Going from 2/3 to 2/3 > charges same single 2, 3 or 2-3 (1.70) but should pick zone based on weekly (could be 3) or cap (always smallest: 2)
			var dualZones = zonesFromDualStations.map(function (z) {
				return z.reduce(function (a, b) {
					if (getDifference(a, singleMin) < getDifference(b, singleMin)) {
						return a;
					}
					return b;
				});
			});

			//Adds dualZones to singleMax into an array and calculates the max and min zone of both
			finalMaxZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["c" /* maxNum */])([singleMax].concat(dualZones));
			finalMinZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])([singleMin].concat(dualZones));
		}

		return [finalMinZone, finalMaxZone];
	});
}

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ramda__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ramda___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_ramda__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility_utility__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extensionFares__ = __webpack_require__(59);
/* harmony export (immutable) */ __webpack_exports__["a"] = oysterDayTotal;
/**
 * Calculates the oyster total fare for the day
 * @function
 * @param {journey} zones and off peak or on peak
 * @param {json data} uses the singleFares json data
 * @returns {number} - returns the total fare
 * @description
 */

// Need set an alert for when reach a Zones 1-4 or Zones 1-6 daily cap, but only travel at off-peak times.







function oysterDayTotal() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var minTravelcard = options.minTravelcard,
      maxTravelcard = options.maxTravelcard;
  var journeys = data.journeys,
      dailyCaps = data.dailyCaps,
      singleFares = data.singleFares;


  var getDailyCap = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["a" /* getCap */])(__WEBPACK_IMPORTED_MODULE_0_ramda___default.a.__, __WEBPACK_IMPORTED_MODULE_0_ramda___default.a.__, dailyCaps);
  var capMet = __WEBPACK_IMPORTED_MODULE_0_ramda___default.a.compose(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["b" /* met */], getDailyCap);

  var totals = journeys.reduce(function (a, b) {
    var singleFare = void 0;
    var maxZone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["c" /* maxNum */])([].concat(a.maxZone, b.zones));
    //     FOR WEEKLY
    if (maxTravelcard && maxZone <= maxTravelcard && maxZone >= minTravelcard - 1) {
      maxZone = minTravelcard - 1; //(ie only compares against daily cap of minSingle to zoneDaily - removes overlap with weekly)

      singleFare = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__extensionFares__["a" /* default */])({ zones: [1, 3], type: "anytime", minTravelcard: minTravelcard, maxTravelcard: maxTravelcard }, singleFares);
    } else {

      singleFare = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["d" /* getSingleFare */])(b.zones, singleFares, b.type); //b.zones = an array
    }

    // console.log(zoneToJourney(maxZone));
    // debugger;

    var metPeak = capMet(maxZone, 'anytime'); //true or false

    var metOffPeak = capMet(maxZone, 'offPeak'); //true or false

    var offPeakTotal = void 0;
    var currentTotal = a.currentTotal + singleFare;

    if (b.type === 'offPeak') {
      offPeakTotal = a.offPeakTotal + singleFare;

      if (metOffPeak(offPeakTotal)) {
        offPeakTotal = getDailyCap(maxZone, 'offPeak'); //and set an alert to say off daily cap reached????!!! (but could be overridden after)
      }

      currentTotal = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utility_utility__["e" /* minNum */])([offPeakTotal, currentTotal]);
    }

    if (metPeak(currentTotal)) {
      currentTotal = getDailyCap(maxZone, 'anytime');
    }

    return {
      currentTotal: currentTotal,
      offPeakTotal: offPeakTotal,
      maxZone: maxZone
    };
  }, {
    currentTotal: 0,
    offPeakTotal: 0,
    maxZone: null
  });

  return totals.currentTotal;
}

/***/ }),
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var always = __webpack_require__(18);

/**
 * A function that always returns `false`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.T
 * @example
 *
 *      R.F(); //=> false
 */
module.exports = always(false);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var always = __webpack_require__(18);

/**
 * A function that always returns `true`. Any passed in parameters are ignored.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig * -> Boolean
 * @param {*}
 * @return {Boolean}
 * @see R.always, R.F
 * @example
 *
 *      R.T(); //=> true
 */
module.exports = always(true);

/***/ }),
/* 139 */
/***/ (function(module, exports) {

/**
 * A special placeholder value used to specify "gaps" within curried functions,
 * allowing partial application of any combination of arguments, regardless of
 * their positions.
 *
 * If `g` is a curried ternary function and `_` is `R.__`, the following are
 * equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2, _)(1, 3)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @constant
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @example
 *
 *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
 *      greet('Alice'); //=> 'Hello, Alice!'
 */
module.exports = { '@@functional/placeholder': true };

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry1 = __webpack_require__(1);
var curryN = __webpack_require__(5);

/**
 * Creates a new list iteration function from an existing one by adding two new
 * parameters to its callback function: the current index, and the entire list.
 *
 * This would turn, for instance, Ramda's simple `map` function into one that
 * more closely resembles `Array.prototype.map`. Note that this will only work
 * for functions in which the iteration callback function is the first
 * parameter, and where the list is the last parameter. (This latter might be
 * unimportant if the list parameter is not used.)
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Function
 * @category List
 * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
 * @param {Function} fn A list iteration function that does not pass index or list to its callback
 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
 * @example
 *
 *      var mapIndexed = R.addIndex(R.map);
 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */
module.exports = _curry1(function addIndex(fn) {
  return curryN(fn.length, function () {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function () {
      var result = origFn.apply(this, _concat(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn.apply(this, args);
  });
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xall = __webpack_require__(212);

/**
 * Returns `true` if all elements of the list match the predicate, `false` if
 * there are any that don't.
 *
 * Dispatches to the `all` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none, R.transduce
 * @example
 *
 *      var equals3 = R.equals(3);
 *      R.all(equals3)([3, 3, 3, 3]); //=> true
 *      R.all(equals3)([3, 3, 1, 3]); //=> false
 */
module.exports = _curry2(_dispatchable(['all'], _xall, function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var curryN = __webpack_require__(5);
var max = __webpack_require__(19);
var pluck = __webpack_require__(26);
var reduce = __webpack_require__(13);

/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if every one of the provided predicates is satisfied
 * by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.anyPass
 * @example
 *
 *      var isQueen = R.propEq('rank', 'Q');
 *      var isSpade = R.propEq('suit', '');
 *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
 *
 *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
 *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
 */
module.exports = _curry1(function allPass(preds) {
  return curryN(reduce(max, 0, pluck('length', preds)), function () {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var curryN = __webpack_require__(5);
var max = __webpack_require__(19);
var pluck = __webpack_require__(26);
var reduce = __webpack_require__(13);

/**
 * Takes a list of predicates and returns a predicate that returns true for a
 * given list of arguments if at least one of the provided predicates is
 * satisfied by those arguments.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see R.allPass
 * @example
 *
 *      var isClub = R.propEq('suit', '');
 *      var isSpade = R.propEq('suit', '');
 *      var isBlackCard = R.anyPass([isClub, isSpade]);
 *
 *      isBlackCard({rank: '10', suit: ''}); //=> true
 *      isBlackCard({rank: 'Q', suit: ''}); //=> true
 *      isBlackCard({rank: 'Q', suit: ''}); //=> false
 */
module.exports = _curry1(function anyPass(preds) {
  return curryN(reduce(max, 0, pluck('length', preds)), function () {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var _aperture = __webpack_require__(195);
var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xaperture = __webpack_require__(213);

/**
 * Returns a new list, composed of n-tuples of consecutive elements If `n` is
 * greater than the length of the list, an empty list is returned.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @param {Number} n The size of the tuples to create
 * @param {Array} list The list to split into `n`-length tuples
 * @return {Array} The resulting list of `n`-length tuples
 * @see R.transduce
 * @example
 *
 *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
 *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
 *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
 */
module.exports = _curry2(_dispatchable([], _xaperture, _aperture));

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry2 = __webpack_require__(0);

/**
 * Returns a new list containing the contents of the given list, followed by
 * the given element.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} el The element to add to the end of the new list.
 * @param {Array} list The list of elements to add a new item to.
 *        list.
 * @return {Array} A new list containing the elements of the old list followed by `el`.
 * @see R.prepend
 * @example
 *
 *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
 *      R.append('tests', []); //=> ['tests']
 *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
 */
module.exports = _curry2(function append(el, list) {
  return _concat(list, [el]);
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var apply = __webpack_require__(68);
var curryN = __webpack_require__(5);
var map = __webpack_require__(7);
var max = __webpack_require__(19);
var pluck = __webpack_require__(26);
var reduce = __webpack_require__(13);
var values = __webpack_require__(120);

/**
 * Given a spec object recursively mapping properties to functions, creates a
 * function producing an object of the same structure, by mapping each property
 * to the result of calling its associated function with the supplied arguments.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
 * @param {Object} spec an object recursively mapping properties to functions for
 *        producing the values for these properties.
 * @return {Function} A function that returns an object of the same structure
 * as `spec', with each property set to the value returned by calling its
 * associated function with the supplied arguments.
 * @see R.converge, R.juxt
 * @example
 *
 *      var getMetrics = R.applySpec({
 *                                      sum: R.add,
 *                                      nested: { mul: R.multiply }
 *                                   });
 *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
 * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
 */
module.exports = _curry1(function applySpec(spec) {
  spec = map(function (v) {
    return typeof v == 'function' ? v : applySpec(v);
  }, spec);
  return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
    var args = arguments;
    return map(function (f) {
      return apply(f, args);
    }, spec);
  });
});

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Makes an ascending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
 * @example
 *
 *      var byAge = R.ascend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByYoungestFirst = R.sort(byAge, people);
 */
module.exports = _curry3(function ascend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa < bb ? -1 : aa > bb ? 1 : 0;
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var nAry = __webpack_require__(39);

/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 2 parameters. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> c) -> (a, b -> c)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 2.
 * @example
 *
 *      var takesThreeArgs = function(a, b, c) {
 *        return [a, b, c];
 *      };
 *      takesThreeArgs.length; //=> 3
 *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
 *
 *      var takesTwoArgs = R.binary(takesThreeArgs);
 *      takesTwoArgs.length; //=> 2
 *      // Only 2 arguments are passed to the wrapped function
 *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
 * @symb R.binary(f)(a, b, c) = f(a, b)
 */
module.exports = _curry1(function binary(fn) {
  return nAry(2, fn);
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isFunction = __webpack_require__(33);
var and = __webpack_require__(66);
var lift = __webpack_require__(38);

/**
 * A function which calls the two provided functions and returns the `&&`
 * of the results.
 * It returns the result of the first function if it is false-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * false-y value.
 *
 * In addition to functions, `R.both` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
 * @see R.and
 * @example
 *
 *      var gt10 = R.gt(R.__, 10)
 *      var lt20 = R.lt(R.__, 20)
 *      var f = R.both(gt10, lt20);
 *      f(15); //=> true
 *      f(30); //=> false
 */
module.exports = _curry2(function both(f, g) {
  return _isFunction(f) ? function _both() {
    return f.apply(this, arguments) && g.apply(this, arguments);
  } : lift(and)(f, g);
});

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var curry = __webpack_require__(30);

/**
 * Returns the result of calling its first argument with the remaining
 * arguments. This is occasionally useful as a converging function for
 * `R.converge`: the left branch can produce a function while the right branch
 * produces a value to be passed to that function as an argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig (*... -> a),*... -> a
 * @param {Function} fn The function to apply to the remaining arguments.
 * @param {...*} args Any number of positional arguments.
 * @return {*}
 * @see R.apply
 * @example
 *
 *      R.call(R.add, 1, 2); //=> 3
 *
 *      var indentN = R.pipe(R.times(R.always(' ')),
 *                           R.join(''),
 *                           R.replace(/^(?!$)/gm));
 *
 *      var format = R.converge(R.call, [
 *                                  R.pipe(R.prop('indent'), indentN),
 *                                  R.prop('value')
 *                              ]);
 *
 *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
 * @symb R.call(f, a, b) = f(a, b)
 */
module.exports = curry(function call(fn) {
  return fn.apply(this, Array.prototype.slice.call(arguments, 1));
});

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Restricts a number to be within a range.
 *
 * Also works for other ordered types such as Strings and Dates.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Relation
 * @sig Ord a => a -> a -> a -> a
 * @param {Number} minimum The lower limit of the clamp (inclusive)
 * @param {Number} maximum The upper limit of the clamp (inclusive)
 * @param {Number} value Value to be clamped
 * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
 * @example
 *
 *      R.clamp(1, 10, -5) // => 1
 *      R.clamp(1, 10, 15) // => 10
 *      R.clamp(1, 10, 4)  // => 4
 */
module.exports = _curry3(function clamp(min, max, value) {
  if (min > max) {
    throw new Error('min must not be greater than max in clamp(min, max, value)');
  }
  return value < min ? min : value > max ? max : value;
});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var _clone = __webpack_require__(82);
var _curry1 = __webpack_require__(1);

/**
 * Creates a deep copy of the value which may contain (nested) `Array`s and
 * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
 * assigned by reference rather than copied
 *
 * Dispatches to a `clone` method if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {*} -> {*}
 * @param {*} value The object or array to clone
 * @return {*} A deeply cloned copy of `val`
 * @example
 *
 *      var objects = [{}, {}, {}];
 *      var objectsClone = R.clone(objects);
 *      objects === objectsClone; //=> false
 *      objects[0] === objectsClone[0]; //=> false
 */
module.exports = _curry1(function clone(value) {
  return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Makes a comparator function out of a function that reports whether the first
 * element is less than the second.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a, b -> Boolean) -> (a, b -> Number)
 * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
 * is less than the second, `false` otherwise
 * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
 * @example
 *
 *      var byAge = R.comparator((a, b) => a.age < b.age);
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByIncreasingAge = R.sort(byAge, people);
 */
module.exports = _curry1(function comparator(pred) {
  return function (a, b) {
    return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
  };
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var lift = __webpack_require__(38);
var not = __webpack_require__(104);

/**
 * Takes a function `f` and returns a function `g` such that if called with the same arguments
 * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
 *
 * `R.complement` may be applied to any functor
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> *) -> (*... -> Boolean)
 * @param {Function} f
 * @return {Function}
 * @see R.not
 * @example
 *
 *      var isNotNil = R.complement(R.isNil);
 *      isNil(null); //=> true
 *      isNotNil(null); //=> false
 *      isNil(7); //=> false
 *      isNotNil(7); //=> true
 */
module.exports = lift(not);

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var pipeP = __webpack_require__(110);
var reverse = __webpack_require__(42);

/**
 * Performs right-to-left composition of one or more Promise-returning
 * functions. The rightmost function may have any arity; the remaining
 * functions must be unary.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
 * @param {...Function} functions The functions to compose
 * @return {Function}
 * @see R.pipeP
 * @example
 *
 *      var db = {
 *        users: {
 *          JOE: {
 *            name: 'Joe',
 *            followers: ['STEVE', 'SUZY']
 *          }
 *        }
 *      }
 *
 *      // We'll pretend to do a db lookup which returns a promise
 *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
 *      var lookupFollowers = (user) => Promise.resolve(user.followers)
 *      lookupUser('JOE').then(lookupFollowers)
 *
 *      //  followersForUser :: String -> Promise [UserId]
 *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
 *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
 *      // Followers: ["STEVE","SUZY"]
 */
module.exports = function composeP() {
  if (arguments.length === 0) {
    throw new Error('composeP requires at least one argument');
  }
  return pipeP.apply(this, reverse(arguments));
};

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _curry1 = __webpack_require__(1);
var map = __webpack_require__(7);
var max = __webpack_require__(19);
var reduce = __webpack_require__(13);

/**
 * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
 * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
 * to `fn` are applied to each of the predicates in turn until one returns a
 * "truthy" value, at which point `fn` returns the result of applying its
 * arguments to the corresponding transformer. If none of the predicates
 * matches, `fn` returns undefined.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Logic
 * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
 * @param {Array} pairs A list of [predicate, transformer]
 * @return {Function}
 * @example
 *
 *      var fn = R.cond([
 *        [R.equals(0),   R.always('water freezes at 0C')],
 *        [R.equals(100), R.always('water boils at 100C')],
 *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
 *      ]);
 *      fn(0); //=> 'water freezes at 0C'
 *      fn(50); //=> 'nothing special happens at 50C'
 *      fn(100); //=> 'water boils at 100C'
 */
module.exports = _curry1(function cond(pairs) {
  var arity = reduce(max, 0, map(function (pair) {
    return pair[0].length;
  }, pairs));
  return _arity(arity, function () {
    var idx = 0;
    while (idx < pairs.length) {
      if (pairs[idx][0].apply(this, arguments)) {
        return pairs[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var constructN = __webpack_require__(72);

/**
 * Wraps a constructor function inside a curried function that can be called
 * with the same arguments and returns the same type.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> {*}) -> (* -> {*})
 * @param {Function} fn The constructor function to wrap.
 * @return {Function} A wrapped, curried constructor function.
 * @example
 *
 *      // Constructor function
 *      function Animal(kind) {
 *        this.kind = kind;
 *      };
 *      Animal.prototype.sighting = function() {
 *        return "It's a " + this.kind + "!";
 *      }
 *
 *      var AnimalConstructor = R.construct(Animal)
 *
 *      // Notice we no longer need the 'new' keyword:
 *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
 *
 *      var animalTypes = ["Lion", "Tiger", "Bear"];
 *      var animalSighting = R.invoker(0, 'sighting');
 *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
 *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
 */
module.exports = _curry1(function construct(Fn) {
  return constructN(Fn.length, Fn);
});

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var _contains = __webpack_require__(16);
var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if the specified value is equal, in `R.equals` terms, to at
 * least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.contains([42], [[42]]); //=> true
 */
module.exports = _curry2(_contains);

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var reduceBy = __webpack_require__(40);

/**
 * Counts the elements of a list according to how many match each value of a
 * key generated by the supplied function. Returns an object mapping the keys
 * produced by `fn` to the number of occurrences in the list. Note that all
 * keys are coerced to strings because of how JavaScript objects work.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> String) -> [a] -> {*}
 * @param {Function} fn The function used to map values to keys.
 * @param {Array} list The list to count elements from.
 * @return {Object} An object mapping keys to number of occurrences in the list.
 * @example
 *
 *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
 *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
 *
 *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
 *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
 */
module.exports = reduceBy(function (acc, elem) {
  return acc + 1;
}, 0);

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var add = __webpack_require__(28);

/**
 * Decrements its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n - 1
 * @see R.inc
 * @example
 *
 *      R.dec(42); //=> 41
 */
module.exports = add(-1);

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Makes a descending comparator function out of a function that returns a value
 * that can be compared with `<` and `>`.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Function
 * @sig Ord b => (a -> b) -> a -> a -> Number
 * @param {Function} fn A function of arity one that returns a value that can be compared
 * @param {*} a The first item to be compared.
 * @param {*} b The second item to be compared.
 * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
 * @example
 *
 *      var byAge = R.descend(R.prop('age'));
 *      var people = [
 *        // ...
 *      ];
 *      var peopleByOldestFirst = R.sort(byAge, people);
 */
module.exports = _curry3(function descend(fn, a, b) {
  var aa = fn(a);
  var bb = fn(b);
  return aa > bb ? -1 : aa < bb ? 1 : 0;
});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var assoc = __webpack_require__(29);
var dissoc = __webpack_require__(77);

/**
 * Makes a shallow clone of an object, omitting the property at the given path.
 * Note that this copies and flattens prototype properties onto the new object
 * as well. All non-primitive properties are copied by reference.
 *
 * @func
 * @memberOf R
 * @since v0.11.0
 * @category Object
 * @sig [String] -> {k: v} -> {k: v}
 * @param {Array} path The path to the value to omit
 * @param {Object} obj The object to clone
 * @return {Object} A new object without the property at path
 * @see R.assocPath
 * @example
 *
 *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
 */
module.exports = _curry2(function dissocPath(path, obj) {
  switch (path.length) {
    case 0:
      return obj;
    case 1:
      return dissoc(path[0], obj);
    default:
      var head = path[0];
      var tail = Array.prototype.slice.call(path, 1);
      return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
  }
});

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Divides two numbers. Equivalent to `a / b`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a / b`.
 * @see R.multiply
 * @example
 *
 *      R.divide(71, 100); //=> 0.71
 *
 *      var half = R.divide(R.__, 2);
 *      half(42); //=> 21
 *
 *      var reciprocal = R.divide(1);
 *      reciprocal(4);   //=> 0.25
 */
module.exports = _curry2(function divide(a, b) {
  return a / b;
});

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _dropLast = __webpack_require__(197);
var _xdropLast = __webpack_require__(216);

/**
 * Returns a list containing all but the last `n` elements of the given `list`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements of `list` to skip.
 * @param {Array} list The list of elements to consider.
 * @return {Array} A copy of the list with only the first `list.length - n` elements
 * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
 * @example
 *
 *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
 *      R.dropLast(3, 'ramda');               //=> 'ra'
 */
module.exports = _curry2(_dispatchable([], _xdropLast, _dropLast));

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _dropLastWhile = __webpack_require__(198);
var _xdropLastWhile = __webpack_require__(217);

/**
 * Returns a new list excluding all the tailing elements of a given list which
 * satisfy the supplied predicate function. It passes each value from the right
 * to the supplied predicate function, skipping elements until the predicate
 * function returns a `falsy` value. The predicate function is applied to one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} predicate The function to be called on each element
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
 * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
 * @example
 *
 *      var lteThree = x => x <= 3;
 *
 *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
 */
module.exports = _curry2(_dispatchable([], _xdropLastWhile, _dropLastWhile));

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _dispatchable = __webpack_require__(3);
var _xdropRepeatsWith = __webpack_require__(94);
var dropRepeatsWith = __webpack_require__(79);
var equals = __webpack_require__(10);

/**
 * Returns a new list without any consecutively repeating elements. `R.equals`
 * is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} `list` without repeating elements.
 * @see R.transduce
 * @example
 *
 *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
 */
module.exports = _curry1(_dispatchable([], _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xdropWhile = __webpack_require__(218);

/**
 * Returns a new list excluding the leading elements of a given list which
 * satisfy the supplied predicate function. It passes each value to the supplied
 * predicate function, skipping elements while the predicate function returns
 * `true`. The predicate function is applied to one argument: *(value)*.
 *
 * Dispatches to the `dropWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} fn The function called per iteration.
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array.
 * @see R.takeWhile, R.transduce, R.addIndex
 * @example
 *
 *      var lteTwo = x => x <= 2;
 *
 *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
 */
module.exports = _curry2(_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len && pred(list[idx])) {
    idx += 1;
  }
  return Array.prototype.slice.call(list, idx);
}));

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isFunction = __webpack_require__(33);
var lift = __webpack_require__(38);
var or = __webpack_require__(106);

/**
 * A function wrapping calls to the two functions in an `||` operation,
 * returning the result of the first function if it is truth-y and the result
 * of the second function otherwise. Note that this is short-circuited,
 * meaning that the second function will not be invoked if the first returns a
 * truth-y value.
 *
 * In addition to functions, `R.either` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f a predicate
 * @param {Function} g another predicate
 * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
 * @see R.or
 * @example
 *
 *      var gt10 = x => x > 10;
 *      var even = x => x % 2 === 0;
 *      var f = R.either(gt10, even);
 *      f(101); //=> true
 *      f(8); //=> true
 */
module.exports = _curry2(function either(f, g) {
  return _isFunction(f) ? function _either() {
    return f.apply(this, arguments) || g.apply(this, arguments);
  } : lift(or)(f, g);
});

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var equals = __webpack_require__(10);

/**
 * Takes a function and two values in its domain and returns `true` if the
 * values map to the same value in the codomain; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Relation
 * @sig (a -> b) -> a -> a -> Boolean
 * @param {Function} f
 * @param {*} x
 * @param {*} y
 * @return {Boolean}
 * @example
 *
 *      R.eqBy(Math.abs, 5, -5); //=> true
 */
module.exports = _curry3(function eqBy(f, x, y) {
  return equals(f(x), f(y));
});

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var equals = __webpack_require__(10);

/**
 * Reports whether two objects have the same value, in `R.equals` terms, for
 * the specified property. Useful as a curried predicate.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig k -> {k: v} -> {k: v} -> Boolean
 * @param {String} prop The name of the property to compare
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {Boolean}
 *
 * @example
 *
 *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
 *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
 *      R.eqProps('a', o1, o2); //=> false
 *      R.eqProps('c', o1, o2); //=> true
 */
module.exports = _curry3(function eqProps(prop, obj1, obj2) {
  return equals(obj1[prop], obj2[prop]);
});

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _curry2 = __webpack_require__(0);

/**
 * Creates a new object by recursively evolving a shallow copy of `object`,
 * according to the `transformation` functions. All non-primitive properties
 * are copied by reference.
 *
 * A `transformation` function will not be invoked if its corresponding key
 * does not exist in the evolved object.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {k: (v -> v)} -> {k: v} -> {k: v}
 * @param {Object} transformations The object specifying transformation functions to apply
 *        to the object.
 * @param {Object} object The object to be transformed.
 * @return {Object} The transformed object.
 * @example
 *
 *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
 *      var transformations = {
 *        firstName: R.trim,
 *        lastName: R.trim, // Will not get invoked.
 *        data: {elapsed: R.add(1), remaining: R.add(-1)}
 *      };
 *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
 */
module.exports = _curry2(function evolve(transformations, object) {
  var result = {};
  var transformation, key, type;
  for (key in object) {
    transformation = transformations[key];
    type = typeof transformation === 'undefined' ? 'undefined' : _typeof(transformation);
    result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
  }
  return result;
});

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xfind = __webpack_require__(220);

/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */
module.exports = _curry2(_dispatchable(['find'], _xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx += 1;
  }
}));

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xfindIndex = __webpack_require__(221);

/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */
module.exports = _curry2(_dispatchable([], _xfindIndex, function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}));

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xfindLast = __webpack_require__(222);

/**
 * Returns the last element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
 *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
 */
module.exports = _curry2(_dispatchable([], _xfindLast, function findLast(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx -= 1;
  }
}));

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xfindLastIndex = __webpack_require__(223);

/**
 * Returns the index of the last element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
 *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
 *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
 */
module.exports = _curry2(_dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0) {
    if (fn(list[idx])) {
      return idx;
    }
    idx -= 1;
  }
  return -1;
}));

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _makeFlat = __webpack_require__(92);

/**
 * Returns a new list by pulling every item out of it (and all its sub-arrays)
 * and putting them in a new array, depth-first.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b]
 * @param {Array} list The array to consider.
 * @return {Array} The flattened list.
 * @see R.unnest
 * @example
 *
 *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
 *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
 */
module.exports = _curry1(_makeFlat(true));

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__(21);
var _curry2 = __webpack_require__(0);

/**
 * Iterate over an input `list`, calling a provided function `fn` for each
 * element in the list.
 *
 * `fn` receives one argument: *(value)*.
 *
 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.forEach` method. For more
 * details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
 *
 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
 * the original array. In some libraries this function is named `each`.
 *
 * Dispatches to the `forEach` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> *) -> [a] -> [a]
 * @param {Function} fn The function to invoke. Receives one argument, `value`.
 * @param {Array} list The list to iterate over.
 * @return {Array} The original list.
 * @see R.addIndex
 * @example
 *
 *      var printXPlusFive = x => console.log(x + 5);
 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
 *      // logs 6
 *      // logs 7
 *      // logs 8
 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
 */
module.exports = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
  var len = list.length;
  var idx = 0;
  while (idx < len) {
    fn(list[idx]);
    idx += 1;
  }
  return list;
}));

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var keys = __webpack_require__(12);

/**
 * Iterate over an input `object`, calling a provided function `fn` for each
 * key and value in the object.
 *
 * `fn` receives three argument: *(value, key, obj)*.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Object
 * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
 * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
 * @param {Object} obj The object to iterate over.
 * @return {Object} The original object.
 * @example
 *
 *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
 *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
 *      // logs x:1
 *      // logs y:2
 * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
 */
module.exports = _curry2(function forEachObjIndexed(fn, obj) {
  var keyList = keys(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key = keyList[idx];
    fn(obj[key], key, obj);
    idx += 1;
  }
  return obj;
});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Creates a new object from a list key-value pairs. If a key appears in
 * multiple pairs, the rightmost pair is included in the object.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [[k,v]] -> {k: v}
 * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
 * @return {Object} The object made by pairing up `keys` and `values`.
 * @see R.toPairs, R.pair
 * @example
 *
 *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
 */
module.exports = _curry1(function fromPairs(pairs) {
  var result = {};
  var idx = 0;
  while (idx < pairs.length) {
    result[pairs[idx][0]] = pairs[idx][1];
    idx += 1;
  }
  return result;
});

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__(21);
var _curry2 = __webpack_require__(0);
var reduceBy = __webpack_require__(40);

/**
 * Splits a list into sub-lists stored in an object, based on the result of
 * calling a String-returning function on each element, and grouping the
 * results according to values returned.
 *
 * Dispatches to the `groupBy` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> String) -> [a] -> {String: [a]}
 * @param {Function} fn Function :: a -> String
 * @param {Array} list The array to group
 * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
 *         that produced that key when passed to `fn`.
 * @see R.transduce
 * @example
 *
 *      var byGrade = R.groupBy(function(student) {
 *        var score = student.score;
 *        return score < 65 ? 'F' :
 *               score < 70 ? 'D' :
 *               score < 80 ? 'C' :
 *               score < 90 ? 'B' : 'A';
 *      });
 *      var students = [{name: 'Abby', score: 84},
 *                      {name: 'Eddy', score: 58},
 *                      // ...
 *                      {name: 'Jack', score: 69}];
 *      byGrade(students);
 *      // {
 *      //   'A': [{name: 'Dianne', score: 99}],
 *      //   'B': [{name: 'Abby', score: 84}]
 *      //   // ...,
 *      //   'F': [{name: 'Eddy', score: 58}]
 *      // }
 */
module.exports = _curry2(_checkForMethod('groupBy', reduceBy(function (acc, item) {
  if (acc == null) {
    acc = [];
  }
  acc.push(item);
  return acc;
}, null)));

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Takes a list and returns a list of lists where each sublist's elements are
 * all "equal" according to the provided equality function.
 *
 * @func
 * @memberOf R
 * @since v0.21.0
 * @category List
 * @sig ((a, a)  Boolean)  [a]  [[a]]
 * @param {Function} fn Function for determining whether two given (adjacent)
 *        elements should be in the same group
 * @param {Array} list The array to group. Also accepts a string, which will be
 *        treated as a list of characters.
 * @return {List} A list that contains sublists of equal elements,
 *         whose concatenations are equal to the original list.
 * @example
 *
 * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
 *
 * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
 * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
 *
 * R.groupWith(R.eqBy(isVowel), 'aestiou')
 * //=> ['ae', 'st', 'iou']
 */
module.exports = _curry2(function (fn, list) {
  var res = [];
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn(list[idx], list[nextidx])) {
      nextidx += 1;
    }
    res.push(list.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if the first argument is greater than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.lt
 * @example
 *
 *      R.gt(2, 1); //=> true
 *      R.gt(2, 2); //=> false
 *      R.gt(2, 3); //=> false
 *      R.gt('a', 'z'); //=> false
 *      R.gt('z', 'a'); //=> true
 */
module.exports = _curry2(function gt(a, b) {
  return a > b;
});

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if the first argument is greater than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.lte
 * @example
 *
 *      R.gte(2, 1); //=> true
 *      R.gte(2, 2); //=> true
 *      R.gte(2, 3); //=> false
 *      R.gte('a', 'z'); //=> false
 *      R.gte('z', 'a'); //=> true
 */
module.exports = _curry2(function gte(a, b) {
  return a >= b;
});

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _has = __webpack_require__(6);

/**
 * Returns whether or not an object has an own property with the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
module.exports = _curry2(_has);

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns whether or not an object or its prototype chain has a property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      function Rectangle(width, height) {
 *        this.width = width;
 *        this.height = height;
 *      }
 *      Rectangle.prototype.area = function() {
 *        return this.width * this.height;
 *      };
 *
 *      var square = new Rectangle(2, 2);
 *      R.hasIn('width', square);  //=> true
 *      R.hasIn('area', square);  //=> true
 */
module.exports = _curry2(function hasIn(prop, obj) {
  return prop in obj;
});

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var nth = __webpack_require__(24);

/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {Array|String} list
 * @return {*}
 * @see R.tail, R.init, R.last
 * @example
 *
 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      R.head([]); //=> undefined
 *
 *      R.head('abc'); //=> 'a'
 *      R.head(''); //=> ''
 */
module.exports = nth(0);

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var curryN = __webpack_require__(5);

/**
 * Creates a function that will process either the `onTrue` or the `onFalse`
 * function depending upon the result of the `condition` predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
 * @param {Function} condition A predicate function
 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
 * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
 *                    function depending upon the result of the `condition` predicate.
 * @see R.unless, R.when
 * @example
 *
 *      var incCount = R.ifElse(
 *        R.has('count'),
 *        R.over(R.lensProp('count'), R.inc),
 *        R.assoc('count', 1)
 *      );
 *      incCount({});           //=> { count: 1 }
 *      incCount({ count: 1 }); //=> { count: 2 }
 */
module.exports = _curry3(function ifElse(condition, onTrue, onFalse) {
  return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var add = __webpack_require__(28);

/**
 * Increments its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number} n + 1
 * @see R.dec
 * @example
 *
 *      R.inc(42); //=> 43
 */
module.exports = add(1);

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var reduceBy = __webpack_require__(40);

/**
 * Given a function that generates a key, turns a list of objects into an
 * object indexing the objects by the given key. Note that if multiple
 * objects generate the same value for the indexing key only the last value
 * will be included in the generated object.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
 * @param {Function} fn Function :: a -> String
 * @param {Array} array The array of objects to index
 * @return {Object} An object indexing each array element by the given property.
 * @example
 *
 *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
 *      R.indexBy(R.prop('id'), list);
 *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
 */
module.exports = reduceBy(function (acc, elem) {
  return elem;
}, null);

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _indexOf = __webpack_require__(87);
var _isArray = __webpack_require__(14);

/**
 * Returns the position of the first occurrence of an item in an array, or -1
 * if the item is not included in the array. `R.equals` is used to determine
 * equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.lastIndexOf
 * @example
 *
 *      R.indexOf(3, [1,2,3,4]); //=> 2
 *      R.indexOf(10, [1,2,3,4]); //=> -1
 */
module.exports = _curry2(function indexOf(target, xs) {
  return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
});

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var slice = __webpack_require__(17);

/**
 * Returns all but the last element of the given list or string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.last, R.head, R.tail
 * @example
 *
 *      R.init([1, 2, 3]);  //=> [1, 2]
 *      R.init([1, 2]);     //=> [1]
 *      R.init([1]);        //=> []
 *      R.init([]);         //=> []
 *
 *      R.init('abc');  //=> 'ab'
 *      R.init('ab');   //=> 'a'
 *      R.init('a');    //=> ''
 *      R.init('');     //=> ''
 */
module.exports = slice(0, -1);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Inserts the supplied element into the list, at index `index`. _Note that
 * this is not destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> a -> [a] -> [a]
 * @param {Number} index The position to insert the element
 * @param {*} elt The element to insert into the Array
 * @param {Array} list The list to insert into
 * @return {Array} A new Array with `elt` inserted at `index`.
 * @example
 *
 *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
 */
module.exports = _curry3(function insert(idx, elt, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  var result = Array.prototype.slice.call(list, 0);
  result.splice(idx, 0, elt);
  return result;
});

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Inserts the sub-list into the list, at index `index`. _Note that this is not
 * destructive_: it returns a copy of the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category List
 * @sig Number -> [a] -> [a] -> [a]
 * @param {Number} index The position to insert the sub-list
 * @param {Array} elts The sub-list to insert into the Array
 * @param {Array} list The list to insert the sub-list into
 * @return {Array} A new Array with `elts` inserted starting at `index`.
 * @example
 *
 *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
 */
module.exports = _curry3(function insertAll(idx, elts, list) {
  idx = idx < list.length && idx >= 0 ? idx : list.length;
  return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
});

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _contains = __webpack_require__(16);

// A simple Set type that honours R.equals semantics
module.exports = function () {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function (item) {
    return !hasOrAdd(item, true, this);
  };

  //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //
  _Set.prototype.has = function (item) {
    return hasOrAdd(item, false, this);
  };

  //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //
  function hasOrAdd(item, shouldAdd, set) {
    var type = typeof item === 'undefined' ? 'undefined' : _typeof(item);
    var prevSize, newSize;
    switch (type) {
      case 'string':
      case 'number':
        // distinguish between +0 and -0
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items['-0']) {
            return true;
          } else {
            if (shouldAdd) {
              set._items['-0'] = true;
            }
            return false;
          }
        }
        // these types can all utilise the native Set
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = {};
              set._items[type][item] = true;
            }
            return false;
          } else if (item in set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][item] = true;
            }
            return false;
          }
        }

      case 'boolean':
        // set._items['boolean'] holds a two element array
        // representing [ falseExists, trueExists ]
        if (type in set._items) {
          var bIdx = item ? 1 : 0;
          if (set._items[type][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type] = item ? [false, true] : [true, false];
          }
          return false;
        }

      case 'function':
        // compare functions for reference equality
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }
            return false;
          }
          if (!_contains(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }
            return false;
          }
          return true;
        }

      case 'undefined':
        if (set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type] = true;
          }
          return false;
        }

      case 'object':
        if (item === null) {
          if (!set._items['null']) {
            if (shouldAdd) {
              set._items['null'] = true;
            }
            return false;
          }
          return true;
        }
      /* falls through */
      default:
        // reduce the search size of heterogeneous sets by creating buckets
        // for each type.
        type = Object.prototype.toString.call(item);
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }
          return false;
        }
        // scan through all previously applied items
        if (!_contains(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }
          return false;
        }
        return true;
    }
  }
  return _Set;
}();

/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = function _aperture(n, list) {
  var idx = 0;
  var limit = list.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
    idx += 1;
  }
  return acc;
};

/***/ }),
/* 196 */
/***/ (function(module, exports) {

module.exports = function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var take = __webpack_require__(115);

module.exports = function dropLast(n, xs) {
  return take(n < xs.length ? xs.length - n : 0, xs);
};

/***/ }),
/* 198 */
/***/ (function(module, exports) {

module.exports = function dropLastWhile(pred, list) {
  var idx = list.length - 1;
  while (idx >= 0 && pred(list[idx])) {
    idx -= 1;
  }
  return Array.prototype.slice.call(list, 0, idx + 1);
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _arrayFromIterator = __webpack_require__(196);
var _functionName = __webpack_require__(202);
var _has = __webpack_require__(6);
var identical = __webpack_require__(81);
var keys = __webpack_require__(12);
var type = __webpack_require__(55);

module.exports = function _equals(a, b, stackA, stackB) {
  if (identical(a, b)) {
    return true;
  }

  if (type(a) !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (type(a)) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
        return a === b;
      }
      break;
    case 'Boolean':
    case 'Number':
    case 'String':
      if (!((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b)) && identical(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case 'Date':
      if (!identical(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case 'Error':
      return a.name === b.name && a.message === b.message;
    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
    case 'Map':
    case 'Set':
      if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
        return false;
      }
      break;
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
      break;
    case 'ArrayBuffer':
      break;
    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys(a);
  if (keysA.length !== keys(b).length) {
    return false;
  }

  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }

  stackA.push(a);
  stackB.push(b);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
      return false;
    }
    idx -= 1;
  }
  stackA.pop();
  stackB.pop();
  return true;
};

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var _forceReduced = __webpack_require__(201);
var _reduce = __webpack_require__(8);
var _xfBase = __webpack_require__(4);
var isArrayLike = __webpack_require__(23);

module.exports = function () {
  var preservingReduced = function preservingReduced(xf) {
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function transducerResult(result) {
        return xf['@@transducer/result'](result);
      },
      '@@transducer/step': function transducerStep(result, input) {
        var ret = xf['@@transducer/step'](result, input);
        return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
      }
    };
  };

  return function _xcat(xf) {
    var rxf = preservingReduced(xf);
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function transducerResult(result) {
        return rxf['@@transducer/result'](result);
      },
      '@@transducer/step': function transducerStep(result, input) {
        return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
      }
    };
  };
}();

/***/ }),
/* 201 */
/***/ (function(module, exports) {

module.exports = function _forceReduced(x) {
  return {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
};

/***/ }),
/* 202 */
/***/ (function(module, exports) {

module.exports = function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
};

/***/ }),
/* 203 */
/***/ (function(module, exports) {

module.exports = function _isRegExp(x) {
  return Object.prototype.toString.call(x) === '[object RegExp]';
};

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var _has = __webpack_require__(6);

// Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
module.exports = function _objectAssign(target) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  var idx = 1;
  var length = arguments.length;
  while (idx < length) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
};

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = function _of(x) {
  return [x];
};

/***/ }),
/* 206 */
/***/ (function(module, exports) {

module.exports = function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
};

/***/ }),
/* 207 */
/***/ (function(module, exports) {

module.exports = function _pipeP(f, g) {
  return function () {
    var ctx = this;
    return f.apply(ctx, arguments).then(function (x) {
      return g.call(ctx, x);
    });
  };
};

/***/ }),
/* 208 */
/***/ (function(module, exports) {

module.exports = function _quote(s) {
  var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
  .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');

  return '"' + escaped.replace(/"/g, '\\"') + '"';
};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assign = __webpack_require__(49);
var _identity = __webpack_require__(51);
var _isTransformer = __webpack_require__(52);
var isArrayLike = __webpack_require__(23);
var objOf = __webpack_require__(105);

module.exports = function () {
  var _stepCatArray = {
    '@@transducer/init': Array,
    '@@transducer/step': function transducerStep(xs, x) {
      xs.push(x);
      return xs;
    },
    '@@transducer/result': _identity
  };
  var _stepCatString = {
    '@@transducer/init': String,
    '@@transducer/step': function transducerStep(a, b) {
      return a + b;
    },
    '@@transducer/result': _identity
  };
  var _stepCatObject = {
    '@@transducer/init': Object,
    '@@transducer/step': function transducerStep(result, input) {
      return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
    },
    '@@transducer/result': _identity
  };

  return function _stepCat(obj) {
    if (_isTransformer(obj)) {
      return obj;
    }
    if (isArrayLike(obj)) {
      return _stepCatArray;
    }
    if (typeof obj === 'string') {
      return _stepCatString;
    }
    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
      return _stepCatObject;
    }
    throw new Error('Cannot create transformer for ' + obj);
  };
}();

/***/ }),
/* 210 */
/***/ (function(module, exports) {

/**
 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
 */
module.exports = function () {
  var pad = function pad(n) {
    return (n < 10 ? '0' : '') + n;
  };

  return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
    return d.toISOString();
  } : function _toISOString(d) {
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
  };
}();

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _contains = __webpack_require__(16);
var _map = __webpack_require__(36);
var _quote = __webpack_require__(208);
var _toISOString = __webpack_require__(210);
var keys = __webpack_require__(12);
var reject = __webpack_require__(41);

module.exports = function _toString(x, seen) {
  var recur = function recur(y) {
    var xs = seen.concat([x]);
    return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
  };

  //  mapPairs :: (Object, [String]) -> [String]
  var mapPairs = function mapPairs(obj, keys) {
    return _map(function (k) {
      return _quote(k) + ': ' + recur(obj[k]);
    }, keys.slice().sort());
  };

  switch (Object.prototype.toString.call(x)) {
    case '[object Arguments]':
      return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
    case '[object Array]':
      return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
        return (/^\d+$/.test(k)
        );
      }, keys(x)))).join(', ') + ']';
    case '[object Boolean]':
      return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
    case '[object Date]':
      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
    case '[object Null]':
      return 'null';
    case '[object Number]':
      return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
    case '[object String]':
      return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
    case '[object Undefined]':
      return 'undefined';
    default:
      if (typeof x.toString === 'function') {
        var repr = x.toString();
        if (repr !== '[object Object]') {
          return repr;
        }
      }
      return '{' + mapPairs(x, keys(x)).join(', ') + '}';
  }
};

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduced = __webpack_require__(15);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase.init;
  XAll.prototype['@@transducer/result'] = function (result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function (result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return _curry2(function _xall(f, xf) {
    return new XAll(f, xf);
  });
}();

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XAperture(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XAperture.prototype['@@transducer/init'] = _xfBase.init;
  XAperture.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XAperture.prototype['@@transducer/step'] = function (result, input) {
    this.store(input);
    return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
  };
  XAperture.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture.prototype.getCopy = function () {
    return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };

  return _curry2(function _xaperture(n, xf) {
    return new XAperture(n, xf);
  });
}();

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _flatCat = __webpack_require__(200);
var map = __webpack_require__(7);

module.exports = _curry2(function _xchain(f, xf) {
  return map(f, _flatCat(xf));
});

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XDrop(n, xf) {
    this.xf = xf;
    this.n = n;
  }
  XDrop.prototype['@@transducer/init'] = _xfBase.init;
  XDrop.prototype['@@transducer/result'] = _xfBase.result;
  XDrop.prototype['@@transducer/step'] = function (result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdrop(n, xf) {
    return new XDrop(n, xf);
  });
}();

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XDropLast(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XDropLast.prototype['@@transducer/init'] = _xfBase.init;
  XDropLast.prototype['@@transducer/result'] = function (result) {
    this.acc = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.full) {
      result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast.prototype.store = function (input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };

  return _curry2(function _xdropLast(n, xf) {
    return new XDropLast(n, xf);
  });
}();

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduce = __webpack_require__(8);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XDropLastWhile(fn, xf) {
    this.f = fn;
    this.retained = [];
    this.xf = xf;
  }
  XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
  XDropLastWhile.prototype['@@transducer/result'] = function (result) {
    this.retained = null;
    return this.xf['@@transducer/result'](result);
  };
  XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };
  XDropLastWhile.prototype.flush = function (result, input) {
    result = _reduce(this.xf['@@transducer/step'], result, this.retained);
    this.retained = [];
    return this.xf['@@transducer/step'](result, input);
  };
  XDropLastWhile.prototype.retain = function (result, input) {
    this.retained.push(input);
    return result;
  };

  return _curry2(function _xdropLastWhile(fn, xf) {
    return new XDropLastWhile(fn, xf);
  });
}();

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XDropWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
  XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
  XDropWhile.prototype['@@transducer/step'] = function (result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf['@@transducer/step'](result, input);
  };

  return _curry2(function _xdropWhile(f, xf) {
    return new XDropWhile(f, xf);
  });
}();

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;
  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return _curry2(function _xfilter(f, xf) {
    return new XFilter(f, xf);
  });
}();

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduced = __webpack_require__(15);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }
  XFind.prototype['@@transducer/init'] = _xfBase.init;
  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, input));
    }
    return result;
  };

  return _curry2(function _xfind(f, xf) {
    return new XFind(f, xf);
  });
}();

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduced = __webpack_require__(15);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
  XFindIndex.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, this.idx));
    }
    return result;
  };

  return _curry2(function _xfindIndex(f, xf) {
    return new XFindIndex(f, xf);
  });
}();

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XFindLast(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFindLast.prototype['@@transducer/init'] = _xfBase.init;
  XFindLast.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
  };
  XFindLast.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };

  return _curry2(function _xfindLast(f, xf) {
    return new XFindLast(f, xf);
  });
}();

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XFindLastIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
  XFindLastIndex.prototype['@@transducer/result'] = function (result) {
    return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
  };
  XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };

  return _curry2(function _xfindLastIndex(f, xf) {
    return new XFindLastIndex(f, xf);
  });
}();

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function (result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2(function _xmap(f, xf) {
    return new XMap(f, xf);
  });
}();

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var _curryN = __webpack_require__(32);
var _has = __webpack_require__(6);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XReduceBy(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }
  XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
  XReduceBy.prototype['@@transducer/result'] = function (result) {
    var key;
    for (key in this.inputs) {
      if (_has(key, this.inputs)) {
        result = this.xf['@@transducer/step'](result, this.inputs[key]);
        if (result['@@transducer/reduced']) {
          result = result['@@transducer/value'];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf['@@transducer/result'](result);
  };
  XReduceBy.prototype['@@transducer/step'] = function (result, input) {
    var key = this.keyFn(input);
    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
    return result;
  };

  return _curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
    return new XReduceBy(valueFn, valueAcc, keyFn, xf);
  });
}();

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduced = __webpack_require__(15);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }
  XTake.prototype['@@transducer/init'] = _xfBase.init;
  XTake.prototype['@@transducer/result'] = _xfBase.result;
  XTake.prototype['@@transducer/step'] = function (result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.i >= this.n ? _reduced(ret) : ret;
  };

  return _curry2(function _xtake(n, xf) {
    return new XTake(n, xf);
  });
}();

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduced = __webpack_require__(15);
var _xfBase = __webpack_require__(4);

module.exports = function () {
  function XTakeWhile(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
  XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
  XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
  };

  return _curry2(function _xtakeWhile(f, xf) {
    return new XTakeWhile(f, xf);
  });
}();

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var _contains = __webpack_require__(16);
var _curry2 = __webpack_require__(0);
var _filter = __webpack_require__(86);
var flip = __webpack_require__(31);
var uniq = __webpack_require__(56);

/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The list of elements found in both `list1` and `list2`.
 * @see R.intersectionWith
 * @example
 *
 *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
 */
module.exports = _curry2(function intersection(list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  return uniq(_filter(flip(_contains)(lookupList), filteredList));
});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var _containsWith = __webpack_require__(50);
var _curry3 = __webpack_require__(2);
var uniqWith = __webpack_require__(57);

/**
 * Combines two lists into a set (i.e. no duplicates) composed of those
 * elements common to both lists. Duplication is determined according to the
 * value returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate function that determines whether
 *        the two supplied elements are equal.
 * @param {Array} list1 One list of items to compare
 * @param {Array} list2 A second list of items to compare
 * @return {Array} A new list containing those elements common to both lists.
 * @see R.intersection
 * @example
 *
 *      var buffaloSpringfield = [
 *        {id: 824, name: 'Richie Furay'},
 *        {id: 956, name: 'Dewey Martin'},
 *        {id: 313, name: 'Bruce Palmer'},
 *        {id: 456, name: 'Stephen Stills'},
 *        {id: 177, name: 'Neil Young'}
 *      ];
 *      var csny = [
 *        {id: 204, name: 'David Crosby'},
 *        {id: 456, name: 'Stephen Stills'},
 *        {id: 539, name: 'Graham Nash'},
 *        {id: 177, name: 'Neil Young'}
 *      ];
 *
 *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
 *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
 */
module.exports = _curry3(function intersectionWith(pred, list1, list2) {
  var lookupList, filteredList;
  if (list1.length > list2.length) {
    lookupList = list1;
    filteredList = list2;
  } else {
    lookupList = list2;
    filteredList = list1;
  }
  var results = [];
  var idx = 0;
  while (idx < filteredList.length) {
    if (_containsWith(pred, filteredList[idx], lookupList)) {
      results[results.length] = filteredList[idx];
    }
    idx += 1;
  }
  return uniqWith(pred, results);
});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = __webpack_require__(21);
var _curry2 = __webpack_require__(0);

/**
 * Creates a new list with the separator interposed between elements.
 *
 * Dispatches to the `intersperse` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category List
 * @sig a -> [a] -> [a]
 * @param {*} separator The element to add to the list.
 * @param {Array} list The list to be interposed.
 * @return {Array} The new list.
 * @example
 *
 *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
 */
module.exports = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
  var out = [];
  var idx = 0;
  var length = list.length;
  while (idx < length) {
    if (idx === length - 1) {
      out.push(list[idx]);
    } else {
      out.push(list[idx], separator);
    }
    idx += 1;
  }
  return out;
}));

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var _clone = __webpack_require__(82);
var _curry3 = __webpack_require__(2);
var _isTransformer = __webpack_require__(52);
var _reduce = __webpack_require__(8);
var _stepCat = __webpack_require__(209);

/**
 * Transforms the items of the list with the transducer and appends the
 * transformed items to the accumulator using an appropriate iterator function
 * based on the accumulator type.
 *
 * The accumulator can be an array, string, object or a transformer. Iterated
 * items will be appended to arrays and concatenated to strings. Objects will
 * be merged directly or 2-item arrays will be merged as key, value pairs.
 *
 * The accumulator can also be a transformer object that provides a 2-arity
 * reducing iterator function, step, 0-arity initial value function, init, and
 * 1-arity result extraction function result. The step function is used as the
 * iterator function in reduce. The result function is used to convert the
 * final accumulator into the return type and in most cases is R.identity. The
 * init function is used to provide the initial accumulator.
 *
 * The iteration is performed with R.reduce after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig a -> (b -> b) -> [c] -> a
 * @param {*} acc The initial accumulator value.
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.into([], transducer, numbers); //=> [2, 3]
 *
 *      var intoArray = R.into([]);
 *      intoArray(transducer, numbers); //=> [2, 3]
 */
module.exports = _curry3(function into(acc, xf, list) {
  return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _has = __webpack_require__(6);
var keys = __webpack_require__(12);

/**
 * Same as R.invertObj, however this accounts for objects with duplicate values
 * by putting the values into an array.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: [ s, ... ]}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object with keys
 * in an array.
 * @example
 *
 *      var raceResultsByFirstName = {
 *        first: 'alice',
 *        second: 'jake',
 *        third: 'alice',
 *      };
 *      R.invert(raceResultsByFirstName);
 *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
 */
module.exports = _curry1(function invert(obj) {
  var props = keys(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    var val = obj[key];
    var list = _has(val, out) ? out[val] : out[val] = [];
    list[list.length] = key;
    idx += 1;
  }
  return out;
});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var keys = __webpack_require__(12);

/**
 * Returns a new object with the keys of the given object as values, and the
 * values of the given object, which are coerced to strings, as keys. Note
 * that the last key found is preferred when handling the same value.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig {s: x} -> {x: s}
 * @param {Object} obj The object or array to invert
 * @return {Object} out A new object
 * @example
 *
 *      var raceResults = {
 *        first: 'alice',
 *        second: 'jake'
 *      };
 *      R.invertObj(raceResults);
 *      //=> { 'alice': 'first', 'jake':'second' }
 *
 *      // Alternatively:
 *      var raceResults = ['alice', 'jake'];
 *      R.invertObj(raceResults);
 *      //=> { 'alice': '0', 'jake':'1' }
 */
module.exports = _curry1(function invertObj(obj) {
  var props = keys(obj);
  var len = props.length;
  var idx = 0;
  var out = {};

  while (idx < len) {
    var key = props[idx];
    out[obj[key]] = key;
    idx += 1;
  }
  return out;
});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var empty = __webpack_require__(80);
var equals = __webpack_require__(10);

/**
 * Returns `true` if the given value is its type's empty value; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig a -> Boolean
 * @param {*} x
 * @return {Boolean}
 * @see R.empty
 * @example
 *
 *      R.isEmpty([1, 2, 3]);   //=> false
 *      R.isEmpty([]);          //=> true
 *      R.isEmpty('');          //=> true
 *      R.isEmpty(null);        //=> false
 *      R.isEmpty({});          //=> true
 *      R.isEmpty({length: 0}); //=> false
 */
module.exports = _curry1(function isEmpty(x) {
  return x != null && equals(x, empty(x));
});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */
module.exports = _curry1(function isNil(x) {
  return x == null;
});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var invoker = __webpack_require__(22);

/**
 * Returns a string made by inserting the `separator` between each element and
 * concatenating all the elements into a single string.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig String -> [a] -> String
 * @param {Number|String} separator The string used to separate the elements.
 * @param {Array} xs The elements to join into a string.
 * @return {String} str The string made by concatenating `xs` with `separator`.
 * @see R.split
 * @example
 *
 *      var spacer = R.join(' ');
 *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
 *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
 */
module.exports = invoker(1, 'join');

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Returns a list containing the names of all the properties of the supplied
 * object, including prototype properties.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.keysIn(f); //=> ['x', 'y']
 */
module.exports = _curry1(function keysIn(obj) {
  var prop;
  var ks = [];
  for (prop in obj) {
    ks[ks.length] = prop;
  }
  return ks;
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isArray = __webpack_require__(14);
var equals = __webpack_require__(10);

/**
 * Returns the position of the last occurrence of an item in an array, or -1 if
 * the item is not included in the array. `R.equals` is used to determine
 * equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig a -> [a] -> Number
 * @param {*} target The item to find.
 * @param {Array} xs The array to search in.
 * @return {Number} the index of the target, or -1 if the target is not found.
 * @see R.indexOf
 * @example
 *
 *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
 *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
 */
module.exports = _curry2(function lastIndexOf(target, xs) {
  if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
    return xs.lastIndexOf(target);
  } else {
    var idx = xs.length - 1;
    while (idx >= 0) {
      if (equals(xs[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var lens = __webpack_require__(37);
var nth = __webpack_require__(24);
var update = __webpack_require__(118);

/**
 * Returns a lens whose focus is the specified index.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Number -> Lens s a
 * @param {Number} n
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var headLens = R.lensIndex(0);
 *
 *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
 *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
 *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
 */
module.exports = _curry1(function lensIndex(n) {
  return lens(nth(n), update(n));
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var assocPath = __webpack_require__(69);
var lens = __webpack_require__(37);
var path = __webpack_require__(25);

/**
 * Returns a lens whose focus is the specified path.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @typedefn Idx = String | Int
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig [Idx] -> Lens s a
 * @param {Array} path The path to use.
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
 *
 *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> 2
 *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
 *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
 *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
 */
module.exports = _curry1(function lensPath(p) {
  return lens(path(p), assocPath(p));
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var assoc = __webpack_require__(29);
var lens = __webpack_require__(37);
var prop = __webpack_require__(53);

/**
 * Returns a lens whose focus is the specified property.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig String -> Lens s a
 * @param {String} k
 * @return {Lens}
 * @see R.view, R.set, R.over
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});            //=> 1
 *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
 *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
 */
module.exports = _curry1(function lensProp(k) {
  return lens(prop(k), assoc(k));
});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if the first argument is less than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.gt
 * @example
 *
 *      R.lt(2, 1); //=> false
 *      R.lt(2, 2); //=> false
 *      R.lt(2, 3); //=> true
 *      R.lt('a', 'z'); //=> true
 *      R.lt('z', 'a'); //=> false
 */
module.exports = _curry2(function lt(a, b) {
  return a < b;
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns `true` if the first argument is less than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.gte
 * @example
 *
 *      R.lte(2, 1); //=> false
 *      R.lte(2, 2); //=> true
 *      R.lte(2, 3); //=> true
 *      R.lte('a', 'z'); //=> true
 *      R.lte('z', 'a'); //=> false
 */
module.exports = _curry2(function lte(a, b) {
  return a <= b;
});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * The mapAccum function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from left to right, and returning a final value of this
 * accumulator together with the new list.
 *
 * The iterator function receives two arguments, *acc* and *value*, and should
 * return a tuple *[acc, value]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccumRight
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var appender = (a, b) => [a + b, a + b];
 *
 *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
 * @symb R.mapAccum(f, a, [b, c, d]) = [
 *   f(f(f(a, b)[0], c)[0], d)[0],
 *   [
 *     f(a, b)[1],
 *     f(f(a, b)[0], c)[1],
 *     f(f(f(a, b)[0], c)[0], d)[1]
 *   ]
 * ]
 */
module.exports = _curry3(function mapAccum(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  var tuple = [acc];
  while (idx < len) {
    tuple = fn(tuple[0], list[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * The mapAccumRight function behaves like a combination of map and reduce; it
 * applies a function to each element of a list, passing an accumulating
 * parameter from right to left, and returning a final value of this
 * accumulator together with the new list.
 *
 * Similar to `mapAccum`, except moves through the input list from the right to
 * the left.
 *
 * The iterator function receives two arguments, *value* and *acc*, and should
 * return a tuple *[value, acc]*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (x-> acc -> (y, acc)) -> acc -> [x] -> ([y], acc)
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.addIndex, R.mapAccum
 * @example
 *
 *      var digits = ['1', '2', '3', '4'];
 *      var append = (a, b) => [a + b, a + b];
 *
 *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
 * @symb R.mapAccumRight(f, a, [b, c, d]) = [
 *   [
 *     f(b, f(c, f(d, a)[0])[0])[1],
 *     f(c, f(d, a)[0])[1],
 *     f(d, a)[1],
 *   ]
 *   f(b, f(c, f(d, a)[0])[0])[0],
 * ]
 */
module.exports = _curry3(function mapAccumRight(fn, acc, list) {
  var idx = list.length - 1;
  var result = [];
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn(list[idx], tuple[0]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [result, tuple[0]];
});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _reduce = __webpack_require__(8);
var keys = __webpack_require__(12);

/**
 * An Object-specific version of `map`. The function is applied to three
 * arguments: *(value, key, obj)*. If only the value is significant, use
 * `map` instead.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Object
 * @sig ((*, String, Object) -> *) -> Object -> Object
 * @param {Function} fn
 * @param {Object} obj
 * @return {Object}
 * @see R.map
 * @example
 *
 *      var values = { x: 1, y: 2, z: 3 };
 *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
 *
 *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
 */
module.exports = _curry2(function mapObjIndexed(fn, obj) {
  return _reduce(function (acc, key) {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {}, keys(obj));
});

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Tests a regular expression against a String. Note that this function will
 * return an empty array when there are no matches. This differs from
 * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
 * which returns `null` when there are no matches.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig RegExp -> String -> [String | Undefined]
 * @param {RegExp} rx A regular expression.
 * @param {String} str The string to match against
 * @return {Array} The list of matches or empty array.
 * @see R.test
 * @example
 *
 *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
 *      R.match(/a/, 'b'); //=> []
 *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
 */
module.exports = _curry2(function match(rx, str) {
  return str.match(rx) || [];
});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isInteger = __webpack_require__(89);

/**
 * mathMod behaves like the modulo operator should mathematically, unlike the
 * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
 * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
 * when the modulus is zero or negative.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} m The dividend.
 * @param {Number} p the modulus.
 * @return {Number} The result of `b mod a`.
 * @example
 *
 *      R.mathMod(-17, 5);  //=> 3
 *      R.mathMod(17, 5);   //=> 2
 *      R.mathMod(17, -5);  //=> NaN
 *      R.mathMod(17, 0);   //=> NaN
 *      R.mathMod(17.2, 5); //=> NaN
 *      R.mathMod(17, 5.3); //=> NaN
 *
 *      var clock = R.mathMod(R.__, 12);
 *      clock(15); //=> 3
 *      clock(24); //=> 0
 *
 *      var seventeenMod = R.mathMod(17);
 *      seventeenMod(3);  //=> 2
 *      seventeenMod(4);  //=> 1
 *      seventeenMod(10); //=> 7
 */
module.exports = _curry2(function mathMod(m, p) {
  if (!_isInteger(m)) {
    return NaN;
  }
  if (!_isInteger(p) || p < 1) {
    return NaN;
  }
  return (m % p + p) % p;
});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Takes a function and two values, and returns whichever value produces the
 * larger result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.max, R.minBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.maxBy(square, -3, 2); //=> -3
 *
 *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
 *      R.reduce(R.maxBy(square), 0, []); //=> 0
 */
module.exports = _curry3(function maxBy(f, a, b) {
  return f(b) > f(a) ? b : a;
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var mean = __webpack_require__(101);

/**
 * Returns the median of the given list of numbers.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list
 * @return {Number}
 * @example
 *
 *      R.median([2, 9, 7]); //=> 7
 *      R.median([7, 2, 10, 9]); //=> 8
 *      R.median([]); //=> NaN
 */
module.exports = _curry1(function median(list) {
  var len = list.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }).slice(idx, idx + width));
});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _curry1 = __webpack_require__(1);
var _has = __webpack_require__(6);
var toString = __webpack_require__(27);

/**
 * Creates a new function that, when invoked, caches the result of calling `fn`
 * for a given argument set and returns the result. Subsequent calls to the
 * memoized `fn` with the same argument set will not result in an additional
 * call to `fn`; instead, the cached result for that set of arguments will be
 * returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (*... -> a) -> (*... -> a)
 * @param {Function} fn The function to memoize.
 * @return {Function} Memoized version of `fn`.
 * @example
 *
 *      var count = 0;
 *      var factorial = R.memoize(n => {
 *        count += 1;
 *        return R.product(R.range(1, n + 1));
 *      });
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      factorial(5); //=> 120
 *      count; //=> 1
 */
module.exports = _curry1(function memoize(fn) {
  var cache = {};
  return _arity(fn.length, function () {
    var key = toString(arguments);
    if (!_has(key, cache)) {
      cache[key] = fn.apply(this, arguments);
    }
    return cache[key];
  });
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var _assign = __webpack_require__(49);
var _curry2 = __webpack_require__(0);

/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      var resetToDefault = R.merge(R.__, {x: 0});
 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
 * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
 */
module.exports = _curry2(function merge(l, r) {
  return _assign({}, l, r);
});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var _assign = __webpack_require__(49);
var _curry1 = __webpack_require__(1);

/**
 * Merges a list of objects together into one object.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig [{k: v}] -> {k: v}
 * @param {Array} list An array of objects
 * @return {Object} A merged object.
 * @see R.reduce
 * @example
 *
 *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
 *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
 * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
 */
module.exports = _curry1(function mergeAll(list) {
  return _assign.apply(null, [{}].concat(list));
});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var mergeWithKey = __webpack_require__(102);

/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the values
 * associated with the key in each object, with the result being used as the
 * value associated with the key in the returned object. The key will be
 * excluded from the returned object if the resulting value is `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig (a -> a -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.merge, R.mergeWithKey
 * @example
 *
 *      R.mergeWith(R.concat,
 *                  { a: true, values: [10, 20] },
 *                  { b: true, values: [15, 35] });
 *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
 */
module.exports = _curry3(function mergeWith(fn, l, r) {
  return mergeWithKey(function (_, _l, _r) {
    return fn(_l, _r);
  }, l, r);
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns the smaller of its two arguments.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> a
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.minBy, R.max
 * @example
 *
 *      R.min(789, 123); //=> 123
 *      R.min('a', 'b'); //=> 'a'
 */
module.exports = _curry2(function min(a, b) {
  return b < a ? b : a;
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Takes a function and two values, and returns whichever value produces the
 * smaller result when passed to the provided function.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Relation
 * @sig Ord b => (a -> b) -> a -> a -> a
 * @param {Function} f
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @see R.min, R.maxBy
 * @example
 *
 *      //  square :: Number -> Number
 *      var square = n => n * n;
 *
 *      R.minBy(square, -3, 2); //=> 2
 *
 *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
 *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
 */
module.exports = _curry3(function minBy(f, a, b) {
  return f(b) < f(a) ? b : a;
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Divides the first parameter by the second and returns the remainder. Note
 * that this function preserves the JavaScript-style behavior for modulo. For
 * mathematical modulo see `mathMod`.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The value to the divide.
 * @param {Number} b The pseudo-modulus
 * @return {Number} The result of `b % a`.
 * @see R.mathMod
 * @example
 *
 *      R.modulo(17, 3); //=> 2
 *      // JS behavior:
 *      R.modulo(-17, 3); //=> -2
 *      R.modulo(17, -3); //=> 2
 *
 *      var isOdd = R.modulo(R.__, 2);
 *      isOdd(42); //=> 0
 *      isOdd(21); //=> 1
 */
module.exports = _curry2(function modulo(a, b) {
  return a % b;
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Negates its argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Math
 * @sig Number -> Number
 * @param {Number} n
 * @return {Number}
 * @example
 *
 *      R.negate(42); //=> -42
 */
module.exports = _curry1(function negate(n) {
  return -n;
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

var _complement = __webpack_require__(84);
var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xany = __webpack_require__(93);
var any = __webpack_require__(67);

/**
 * Returns `true` if no elements of the list match the predicate, `false`
 * otherwise.
 *
 * Dispatches to the `any` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
 * @see R.all, R.any
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
 *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
 */
module.exports = _curry2(_complement(_dispatchable(['any'], _xany, any)));

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var curryN = __webpack_require__(5);
var nth = __webpack_require__(24);

/**
 * Returns a function which returns its nth argument.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Function
 * @sig Number -> *... -> *
 * @param {Number} n
 * @return {Function}
 * @example
 *
 *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
 *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
 * @symb R.nthArg(-1)(a, b, c) = c
 * @symb R.nthArg(0)(a, b, c) = a
 * @symb R.nthArg(1)(a, b, c) = b
 */
module.exports = _curry1(function nthArg(n) {
  var arity = n < 0 ? 1 : n + 1;
  return curryN(arity, function () {
    return nth(n, arguments);
  });
});

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _of = __webpack_require__(205);

/**
 * Returns a singleton array containing the value provided.
 *
 * Note this `of` is different from the ES6 `of`; See
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category Function
 * @sig a -> [a]
 * @param {*} x any value
 * @return {Array} An array wrapping `x`.
 * @example
 *
 *      R.of(null); //=> [null]
 *      R.of([42]); //=> [[42]]
 */
module.exports = _curry1(_of);

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var _contains = __webpack_require__(16);
var _curry2 = __webpack_require__(0);

/**
 * Returns a partial copy of an object omitting the keys specified.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [String] -> {String: *} -> {String: *}
 * @param {Array} names an array of String property names to omit from the new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with properties from `names` not on it.
 * @see R.pick
 * @example
 *
 *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
 */
module.exports = _curry2(function omit(names, obj) {
  var result = {};
  for (var prop in obj) {
    if (!_contains(prop, names)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _curry1 = __webpack_require__(1);

/**
 * Accepts a function `fn` and returns a function that guards invocation of
 * `fn` such that `fn` can only ever be called once, no matter how many times
 * the returned function is invoked. The first value calculated is returned in
 * subsequent invocations.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a... -> b) -> (a... -> b)
 * @param {Function} fn The function to wrap in a call-only-once wrapper.
 * @return {Function} The wrapped function.
 * @example
 *
 *      var addOneOnce = R.once(x => x + 1);
 *      addOneOnce(10); //=> 11
 *      addOneOnce(addOneOnce(50)); //=> 11
 */
module.exports = _curry1(function once(fn) {
  var called = false;
  var result;
  return _arity(fn.length, function () {
    if (called) {
      return result;
    }
    called = true;
    result = fn.apply(this, arguments);
    return result;
  });
});

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category List
 * @sig a -> b -> (a,b)
 * @param {*} fst
 * @param {*} snd
 * @return {Array}
 * @see R.objOf, R.of
 * @example
 *
 *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
 */
module.exports = _curry2(function pair(fst, snd) {
  return [fst, snd];
});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _createPartialApplicator = __webpack_require__(85);

/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided initially followed by the arguments provided to `g`.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partialRight
 * @example
 *
 *      var multiply2 = (a, b) => a * b;
 *      var double = R.partial(multiply2, [2]);
 *      double(2); //=> 4
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var sayHello = R.partial(greet, ['Hello']);
 *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
 *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
 */
module.exports = _createPartialApplicator(_concat);

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _createPartialApplicator = __webpack_require__(85);
var flip = __webpack_require__(31);

/**
 * Takes a function `f` and a list of arguments, and returns a function `g`.
 * When applied, `g` returns the result of applying `f` to the arguments
 * provided to `g` followed by the arguments provided initially.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Function
 * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
 * @param {Function} f
 * @param {Array} args
 * @return {Function}
 * @see R.partial
 * @example
 *
 *      var greet = (salutation, title, firstName, lastName) =>
 *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
 *
 *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
 *
 *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
 * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
 */
module.exports = _createPartialApplicator(flip(_concat));

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var filter = __webpack_require__(47);
var juxt = __webpack_require__(97);
var reject = __webpack_require__(41);

/**
 * Takes a predicate and a list or other "filterable" object and returns the
 * pair of filterable objects of the same type of elements which do and do not
 * satisfy, the predicate, respectively.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
 * @param {Function} pred A predicate to determine which side the element belongs to.
 * @param {Array} filterable the list (or other filterable) to partition.
 * @return {Array} An array, containing first the subset of elements that satisfy the
 *         predicate, and second the subset of elements that do not satisfy.
 * @see R.filter, R.reject
 * @example
 *
 *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
 *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
 *
 *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
 *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
 */
module.exports = juxt([filter, reject]);

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var equals = __webpack_require__(10);
var path = __webpack_require__(25);

/**
 * Determines whether a nested path on an object has a specific value, in
 * `R.equals` terms. Most likely used to filter a list.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category Relation
 * @typedefn Idx = String | Int
 * @sig [Idx] -> a -> {a} -> Boolean
 * @param {Array} path The path of the nested property to use
 * @param {*} val The value to compare the nested property with
 * @param {Object} obj The object to check the nested property in
 * @return {Boolean} `true` if the value equals the nested object property,
 *         `false` otherwise.
 * @example
 *
 *      var user1 = { address: { zipCode: 90210 } };
 *      var user2 = { address: { zipCode: 55555 } };
 *      var user3 = { name: 'Bob' };
 *      var users = [ user1, user2, user3 ];
 *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
 *      R.filter(isFamous, users); //=> [ user1 ]
 */
module.exports = _curry3(function pathEq(_path, val, obj) {
  return equals(path(_path, obj), val);
});

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var defaultTo = __webpack_require__(74);
var path = __webpack_require__(25);

/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig a -> [Idx] -> {a} -> a
 * @param {*} d The default value.
 * @param {Array} p The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path` of the supplied object or the default value.
 * @example
 *
 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */
module.exports = _curry3(function pathOr(d, p, obj) {
  return defaultTo(d, path(p, obj));
});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var path = __webpack_require__(25);

/**
 * Returns `true` if the specified object property at given path satisfies the
 * given predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Logic
 * @typedefn Idx = String | Int
 * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
 * @param {Function} pred
 * @param {Array} propPath
 * @param {*} obj
 * @return {Boolean}
 * @see R.propSatisfies, R.path
 * @example
 *
 *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
 */
module.exports = _curry3(function pathSatisfies(pred, propPath, obj) {
  return propPath.length > 0 && pred(path(propPath, obj));
});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a partial copy of an object containing only the keys specified. If
 * the key does not exist, the property is ignored.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.omit, R.props
 * @example
 *
 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
 */
module.exports = _curry2(function pick(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a partial copy of an object containing only the keys that satisfy
 * the supplied predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Object
 * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
 * @param {Function} pred A predicate to determine whether or not a key
 *        should be included on the output object.
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties that satisfy `pred`
 *         on it.
 * @see R.pick, R.filter
 * @example
 *
 *      var isUpperCase = (val, key) => key.toUpperCase() === key;
 *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
 */
module.exports = _curry2(function pickBy(test, obj) {
  var result = {};
  for (var prop in obj) {
    if (test(obj[prop], prop, obj)) {
      result[prop] = obj[prop];
    }
  }
  return result;
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var composeK = __webpack_require__(71);
var reverse = __webpack_require__(42);

/**
 * Returns the left-to-right Kleisli composition of the provided functions,
 * each of which must return a value of a type supported by [`chain`](#chain).
 *
 * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Function
 * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
 * @param {...Function}
 * @return {Function}
 * @see R.composeK
 * @example
 *
 *      //  parseJson :: String -> Maybe *
 *      //  get :: String -> Object -> Maybe *
 *
 *      //  getStateCode :: Maybe String -> Maybe String
 *      var getStateCode = R.pipeK(
 *        parseJson,
 *        get('user'),
 *        get('address'),
 *        get('state'),
 *        R.compose(Maybe.of, R.toUpper)
 *      );
 *
 *      getStateCode('{"user":{"address":{"state":"ny"}}}');
 *      //=> Just('NY')
 *      getStateCode('[Invalid JSON]');
 *      //=> Nothing()
 * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
 */
module.exports = function pipeK() {
  if (arguments.length === 0) {
    throw new Error('pipeK requires at least one argument');
  }
  return composeK.apply(this, reverse(arguments));
};

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var multiply = __webpack_require__(103);
var reduce = __webpack_require__(13);

/**
 * Multiplies together all the elements of a list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig [Number] -> Number
 * @param {Array} list An array of numbers
 * @return {Number} The product of all the numbers in the list.
 * @see R.reduce
 * @example
 *
 *      R.product([2,4,6,8,100,1]); //=> 38400
 */
module.exports = reduce(multiply, 1);

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var _map = __webpack_require__(36);
var identity = __webpack_require__(48);
var pickAll = __webpack_require__(108);
var useWith = __webpack_require__(119);

/**
 * Reasonable analog to SQL `select` statement.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @category Relation
 * @sig [k] -> [{k: v}] -> [{k: v}]
 * @param {Array} props The property names to project
 * @param {Array} objs The objects to query
 * @return {Array} An array of objects with just the `props` properties.
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
 *      var kids = [abby, fred];
 *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
 */
module.exports = useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var equals = __webpack_require__(10);

/**
 * Returns `true` if the specified object property is equal, in `R.equals`
 * terms, to the given value; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.equals, R.propSatisfies
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      var kids = [abby, fred, rusty, alois];
 *      var hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */
module.exports = _curry3(function propEq(name, val, obj) {
  return equals(val, obj[name]);
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var is = __webpack_require__(96);

/**
 * Returns `true` if the specified object property is of the given type;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Type
 * @sig Type -> String -> Object -> Boolean
 * @param {Function} type
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.is, R.propSatisfies
 * @example
 *
 *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
 *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
 *      R.propIs(Number, 'x', {});            //=> false
 */
module.exports = _curry3(function propIs(type, name, obj) {
  return is(type, obj[name]);
});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var _has = __webpack_require__(6);

/**
 * If the given, non-null object has an own property with the specified name,
 * returns the value of that property. Otherwise returns the provided default
 * value.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Object
 * @sig a -> String -> Object -> a
 * @param {*} val The default value.
 * @param {String} p The name of the property to return.
 * @param {Object} obj The object to query.
 * @return {*} The value of given property of the supplied object or the default value.
 * @example
 *
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var favorite = R.prop('favoriteLibrary');
 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
 *
 *      favorite(alice);  //=> undefined
 *      favoriteWithDefault(alice);  //=> 'Ramda'
 */
module.exports = _curry3(function propOr(val, p, obj) {
  return obj != null && _has(p, obj) ? obj[p] : val;
});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Returns `true` if the specified object property satisfies the given
 * predicate; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Logic
 * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
 * @param {Function} pred
 * @param {String} name
 * @param {*} obj
 * @return {Boolean}
 * @see R.propEq, R.propIs
 * @example
 *
 *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
 */
module.exports = _curry3(function propSatisfies(pred, name, obj) {
  return pred(obj[name]);
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Acts as multiple `prop`: array of keys in, array of values out. Preserves
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> [v]
 * @param {Array} ps The property names to fetch
 * @param {Object} obj The object to query
 * @return {Array} The corresponding values or partially applied function.
 * @example
 *
 *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
 *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
 *
 *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
 *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
 */
module.exports = _curry2(function props(ps, obj) {
  var len = ps.length;
  var out = [];
  var idx = 0;

  while (idx < len) {
    out[idx] = obj[ps[idx]];
    idx += 1;
  }

  return out;
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _isNumber = __webpack_require__(90);

/**
 * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> Number -> [Number]
 * @param {Number} from The first number in the list.
 * @param {Number} to One more than the last number in the list.
 * @return {Array} The list of numbers in tthe set `[a, b)`.
 * @example
 *
 *      R.range(1, 5);    //=> [1, 2, 3, 4]
 *      R.range(50, 53);  //=> [50, 51, 52]
 */
module.exports = _curry2(function range(from, to) {
  if (!(_isNumber(from) && _isNumber(to))) {
    throw new TypeError('Both arguments to range must be numbers');
  }
  var result = [];
  var n = from;
  while (n < to) {
    result.push(n);
    n += 1;
  }
  return result;
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var _curryN = __webpack_require__(32);
var _reduce = __webpack_require__(8);
var _reduced = __webpack_require__(15);

/**
 * Like `reduce`, `reduceWhile` returns a single item by iterating through
 * the list, successively calling the iterator function. `reduceWhile` also
 * takes a predicate that is evaluated before each step. If the predicate returns
 * `false`, it "short-circuits" the iteration and returns the current value
 * of the accumulator.
 *
 * @func
 * @memberOf R
 * @since v0.22.0
 * @category List
 * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} pred The predicate. It is passed the accumulator and the
 *        current element.
 * @param {Function} fn The iterator function. Receives two values, the
 *        accumulator and the current element.
 * @param {*} a The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced
 * @example
 *
 *      var isOdd = (acc, x) => x % 2 === 1;
 *      var xs = [1, 3, 5, 60, 777, 800];
 *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
 *
 *      var ys = [2, 4, 6]
 *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
 */
module.exports = _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
  return _reduce(function (acc, x) {
    return pred(acc, x) ? fn(acc, x) : _reduced(acc);
  }, a, list);
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _reduced = __webpack_require__(15);

/**
 * Returns a value wrapped to indicate that it is the final value of the reduce
 * and transduce functions. The returned value should be considered a black
 * box: the internal structure is not guaranteed to be stable.
 *
 * Note: this optimization is unavailable to functions not explicitly listed
 * above. For instance, it is not currently supported by reduceRight.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category List
 * @sig a -> *
 * @param {*} x The final value of the reduce.
 * @return {*} The wrapped value.
 * @see R.reduce, R.transduce
 * @example
 *
 *      R.reduce(
 *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
 *        0,
 *        [1, 2, 3, 4, 5]) // 10
 */

module.exports = _curry1(_reduced);

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Removes the sub-list of `list` starting at index `start` and containing
 * `count` elements. _Note that this is not destructive_: it returns a copy of
 * the list with the changes.
 * <small>No lists have been harmed in the application of this function.</small>
 *
 * @func
 * @memberOf R
 * @since v0.2.2
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @param {Number} start The position to start removing elements
 * @param {Number} count The number of elements to remove
 * @param {Array} list The list to remove from
 * @return {Array} A new Array with `count` elements from `start` removed.
 * @example
 *
 *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
 */
module.exports = _curry3(function remove(start, count, list) {
  var result = Array.prototype.slice.call(list, 0);
  result.splice(start, count);
  return result;
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var always = __webpack_require__(18);
var times = __webpack_require__(116);

/**
 * Returns a fixed list of size `n` containing a specified identical value.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig a -> n -> [a]
 * @param {*} value The value to repeat.
 * @param {Number} n The desired size of the output list.
 * @return {Array} A new array containing `n` `value`s.
 * @example
 *
 *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
 *
 *      var obj = {};
 *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
 *      repeatedObjs[0] === repeatedObjs[1]; //=> true
 * @symb R.repeat(a, 0) = []
 * @symb R.repeat(a, 1) = [a]
 * @symb R.repeat(a, 2) = [a, a]
 */
module.exports = _curry2(function repeat(value, n) {
  return times(always(value), n);
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Replace a substring or regex match in a string with a replacement.
 *
 * @func
 * @memberOf R
 * @since v0.7.0
 * @category String
 * @sig RegExp|String -> String -> String -> String
 * @param {RegExp|String} pattern A regular expression or a substring to match.
 * @param {String} replacement The string to replace the matches with.
 * @param {String} str The String to do the search and replacement in.
 * @return {String} The result.
 * @example
 *
 *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
 *
 *      // Use the "g" (global) flag to replace all occurrences:
 *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
 */
module.exports = _curry3(function replace(regex, replacement, str) {
  return str.replace(regex, replacement);
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Scan is similar to reduce, but returns a list of successively reduced values
 * from the left
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (a,b -> a) -> a -> [b] -> [a]
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {Array} A list of all intermediately reduced values.
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
 * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
 */
module.exports = _curry3(function scan(fn, acc, list) {
  var idx = 0;
  var len = list.length;
  var result = [acc];
  while (idx < len) {
    acc = fn(acc, list[idx]);
    result[idx + 1] = acc;
    idx += 1;
  }
  return result;
});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var always = __webpack_require__(18);
var over = __webpack_require__(107);

/**
 * Returns the result of "setting" the portion of the given data structure
 * focused by the given lens to the given value.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> a -> s -> s
 * @param {Lens} lens
 * @param {*} v
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
 *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
 */
module.exports = _curry3(function set(lens, v, x) {
  return over(lens, always(v), x);
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a copy of the list, sorted according to the comparator function,
 * which should accept two values at a time and return a negative number if the
 * first value is smaller, a positive number if it's larger, and zero if they
 * are equal. Please note that this is a **copy** of the list. It does not
 * modify the original.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a,a -> Number) -> [a] -> [a]
 * @param {Function} comparator A sorting function :: a -> b -> Int
 * @param {Array} list The list to sort
 * @return {Array} a new array with its elements sorted by the comparator function.
 * @example
 *
 *      var diff = function(a, b) { return a - b; };
 *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
 */
module.exports = _curry2(function sort(comparator, list) {
  return Array.prototype.slice.call(list, 0).sort(comparator);
});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Sorts the list according to the supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord b => (a -> b) -> [a] -> [a]
 * @param {Function} fn
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted by the keys generated by `fn`.
 * @example
 *
 *      var sortByFirstItem = R.sortBy(R.prop(0));
 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var bob = {
 *        name: 'Bob',
 *        age: -10
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 314.159
 *      };
 *      var people = [clara, bob, alice];
 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
 */
module.exports = _curry2(function sortBy(fn, list) {
  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Sorts a list according to a list of comparators.
 *
 * @func
 * @memberOf R
 * @since v0.23.0
 * @category Relation
 * @sig [a -> a -> Number] -> [a] -> [a]
 * @param {Array} functions A list of comparator functions.
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted according to the comarator functions.
 * @example
 *
 *      var alice = {
 *        name: 'alice',
 *        age: 40
 *      };
 *      var bob = {
 *        name: 'bob',
 *        age: 30
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 40
 *      };
 *      var people = [clara, bob, alice];
 *      var ageNameSort = R.sortWith([
 *        R.descend(R.prop('age')),
 *        R.ascend(R.prop('name'))
 *      ]);
 *      ageNameSort(people); //=> [alice, clara, bob]
 */
module.exports = _curry2(function sortWith(fns, list) {
  return Array.prototype.slice.call(list, 0).sort(function (a, b) {
    var result = 0;
    var i = 0;
    while (result === 0 && i < fns.length) {
      result = fns[i](a, b);
      i += 1;
    }
    return result;
  });
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

var invoker = __webpack_require__(22);

/**
 * Splits a string into an array of strings based on the given
 * separator.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category String
 * @sig (String | RegExp) -> String -> [String]
 * @param {String|RegExp} sep The pattern.
 * @param {String} str The string to separate into an array.
 * @return {Array} The array of strings from `str` separated by `str`.
 * @see R.join
 * @example
 *
 *      var pathComponents = R.split('/');
 *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
 *
 *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
 */
module.exports = invoker(1, 'split');

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var length = __webpack_require__(99);
var slice = __webpack_require__(17);

/**
 * Splits a given list or string at a given index.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig Number -> [a] -> [[a], [a]]
 * @sig Number -> String -> [String, String]
 * @param {Number} index The index where the array/string is split.
 * @param {Array|String} array The array/string to be split.
 * @return {Array}
 * @example
 *
 *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
 *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
 *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
 */
module.exports = _curry2(function splitAt(index, array) {
  return [slice(0, index, array), slice(index, length(array), array)];
});

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var slice = __webpack_require__(17);

/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */
module.exports = _curry2(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }
  var result = [];
  var idx = 0;
  while (idx < list.length) {
    result.push(slice(idx, idx += n, list));
  }
  return result;
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Takes a list and a predicate and returns a pair of lists with the following properties:
 *
 *  - the result of concatenating the two output lists is equivalent to the input list;
 *  - none of the elements of the first output list satisfies the predicate; and
 *  - if the second output list is non-empty, its first element satisfies the predicate.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [[a], [a]]
 * @param {Function} pred The predicate that determines where the array is split.
 * @param {Array} list The array to be split.
 * @return {Array}
 * @example
 *
 *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
 */
module.exports = _curry2(function splitWhen(pred, list) {
  var idx = 0;
  var len = list.length;
  var prefix = [];

  while (idx < len && !pred(list[idx])) {
    prefix.push(list[idx]);
    idx += 1;
  }

  return [prefix, Array.prototype.slice.call(list, idx)];
});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Subtracts its second argument from its first argument.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a The first value.
 * @param {Number} b The second value.
 * @return {Number} The result of `a - b`.
 * @see R.add
 * @example
 *
 *      R.subtract(10, 8); //=> 2
 *
 *      var minus5 = R.subtract(R.__, 5);
 *      minus5(17); //=> 12
 *
 *      var complementaryAngle = R.subtract(90);
 *      complementaryAngle(30); //=> 60
 *      complementaryAngle(72); //=> 18
 */
module.exports = _curry2(function subtract(a, b) {
  return Number(a) - Number(b);
});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var concat = __webpack_require__(46);
var difference = __webpack_require__(75);

/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
 * @example
 *
 *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
 *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
 */
module.exports = _curry2(function symmetricDifference(list1, list2) {
  return concat(difference(list1, list2), difference(list2, list1));
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var concat = __webpack_require__(46);
var differenceWith = __webpack_require__(76);

/**
 * Finds the set (i.e. no duplicates) of all elements contained in the first or
 * second list, but not both. Duplication is determined according to the value
 * returned by applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Relation
 * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The elements in `list1` or `list2`, but not both.
 * @see R.symmetricDifference, R.difference, R.differenceWith
 * @example
 *
 *      var eqA = R.eqBy(R.prop('a'));
 *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
 *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
 *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
 */
module.exports = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
  return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var drop = __webpack_require__(78);

/**
 * Returns a new list containing the last `n` elements of the given list.
 * If `n > list.length`, returns a list of `list.length` elements.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n The number of elements to return.
 * @param {Array} xs The collection to consider.
 * @return {Array}
 * @see R.dropLast
 * @example
 *
 *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
 *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
 *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.takeLast(3, 'ramda');               //=> 'mda'
 */
module.exports = _curry2(function takeLast(n, xs) {
  return drop(n >= 0 ? xs.length - n : 0, xs);
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a new list containing the last `n` elements of a given list, passing
 * each value to the supplied predicate function, and terminating when the
 * predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} fn The function called per iteration.
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropLastWhile, R.addIndex
 * @example
 *
 *      var isNotOne = x => x !== 1;
 *
 *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
 */
module.exports = _curry2(function takeLastWhile(fn, list) {
  var idx = list.length - 1;
  while (idx >= 0 && fn(list[idx])) {
    idx -= 1;
  }
  return Array.prototype.slice.call(list, idx + 1);
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var _dispatchable = __webpack_require__(3);
var _xtakeWhile = __webpack_require__(227);

/**
 * Returns a new list containing the first `n` elements of a given list,
 * passing each value to the supplied predicate function, and terminating when
 * the predicate function returns `false`. Excludes the element that caused the
 * predicate function to fail. The predicate function is passed one argument:
 * *(value)*.
 *
 * Dispatches to the `takeWhile` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> [a]
 * @param {Function} fn The function called per iteration.
 * @param {Array} list The collection to iterate over.
 * @return {Array} A new array.
 * @see R.dropWhile, R.transduce, R.addIndex
 * @example
 *
 *      var isNotFour = x => x !== 4;
 *
 *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
 */
module.exports = _curry2(_dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len && fn(list[idx])) {
    idx += 1;
  }
  return Array.prototype.slice.call(list, 0, idx);
}));

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Runs the given function with the supplied object, then returns the object.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (a -> *) -> a -> a
 * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
 * @param {*} x
 * @return {*} `x`.
 * @example
 *
 *      var sayX = x => console.log('x is ' + x);
 *      R.tap(sayX, 100); //=> 100
 *      // logs 'x is 100'
 * @symb R.tap(f, a) = a
 */
module.exports = _curry2(function tap(fn, x) {
  fn(x);
  return x;
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var _cloneRegExp = __webpack_require__(83);
var _curry2 = __webpack_require__(0);
var _isRegExp = __webpack_require__(203);
var toString = __webpack_require__(27);

/**
 * Determines whether a given string matches a given regular expression.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category String
 * @sig RegExp -> String -> Boolean
 * @param {RegExp} pattern
 * @param {String} str
 * @return {Boolean}
 * @see R.match
 * @example
 *
 *      R.test(/^x/, 'xyz'); //=> true
 *      R.test(/^y/, 'xyz'); //=> false
 */
module.exports = _curry2(function test(pattern, str) {
  if (!_isRegExp(pattern)) {
    throw new TypeError('test requires a value of type RegExp as its first argument; received ' + toString(pattern));
  }
  return _cloneRegExp(pattern).test(str);
});

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var invoker = __webpack_require__(22);

/**
 * The lower case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to lower case.
 * @return {String} The lower case version of `str`.
 * @see R.toUpper
 * @example
 *
 *      R.toLower('XYZ'); //=> 'xyz'
 */
module.exports = invoker(0, 'toLowerCase');

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var _has = __webpack_require__(6);

/**
 * Converts an object into an array of key, value arrays. Only the object's
 * own properties are used.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own properties.
 * @see R.fromPairs
 * @example
 *
 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
 */
module.exports = _curry1(function toPairs(obj) {
  var pairs = [];
  for (var prop in obj) {
    if (_has(prop, obj)) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
  }
  return pairs;
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Converts an object into an array of key, value arrays. The object's own
 * properties and prototype properties are used. Note that the order of the
 * output array is not guaranteed to be consistent across different JS
 * platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own
 *         and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
 */
module.exports = _curry1(function toPairsIn(obj) {
  var pairs = [];
  for (var prop in obj) {
    pairs[pairs.length] = [prop, obj[prop]];
  }
  return pairs;
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var invoker = __webpack_require__(22);

/**
 * The upper case version of a string.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to upper case.
 * @return {String} The upper case version of `str`.
 * @see R.toLower
 * @example
 *
 *      R.toUpper('abc'); //=> 'ABC'
 */
module.exports = invoker(0, 'toUpperCase');

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var _reduce = __webpack_require__(8);
var _xwrap = __webpack_require__(95);
var curryN = __webpack_require__(5);

/**
 * Initializes a transducer using supplied iterator function. Returns a single
 * item by iterating through the list, successively calling the transformed
 * iterator function and passing it an accumulator value and the current value
 * from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It will be
 * wrapped as a transformer to initialize the transducer. A transformer can be
 * passed directly in place of an iterator function. In both cases, iteration
 * may be stopped early with the `R.reduced` function.
 *
 * A transducer is a function that accepts a transformer and returns a
 * transformer and can be composed directly.
 *
 * A transformer is an an object that provides a 2-arity reducing iterator
 * function, step, 0-arity initial value function, init, and 1-arity result
 * extraction function, result. The step function is used as the iterator
 * function in reduce. The result function is used to convert the final
 * accumulator into the return type and in most cases is R.identity. The init
 * function can be used to provide an initial accumulator, but is ignored by
 * transduce.
 *
 * The iteration is performed with R.reduce after initializing the transducer.
 *
 * @func
 * @memberOf R
 * @since v0.12.0
 * @category List
 * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
 * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array. Wrapped as transformer, if necessary, and used to
 *        initialize the transducer
 * @param {*} acc The initial accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduce, R.reduced, R.into
 * @example
 *
 *      var numbers = [1, 2, 3, 4];
 *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
 *
 *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
 */
module.exports = curryN(4, function transduce(xf, fn, acc, list) {
  return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Transposes the rows and columns of a 2D list.
 * When passed a list of `n` lists of length `x`,
 * returns a list of `x` lists of length `n`.
 *
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [[a]] -> [[a]]
 * @param {Array} list A 2D list
 * @return {Array} A 2D list
 * @example
 *
 *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
 *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 *
 * If some of the rows are shorter than the following rows, their elements are skipped:
 *
 *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
 * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
 * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
 * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
 */
module.exports = _curry1(function transpose(outerlist) {
  var i = 0;
  var result = [];
  while (i < outerlist.length) {
    var innerlist = outerlist[i];
    var j = 0;
    while (j < innerlist.length) {
      if (typeof result[j] === 'undefined') {
        result[j] = [];
      }
      result[j].push(innerlist[j]);
      j += 1;
    }
    i += 1;
  }
  return result;
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);
var map = __webpack_require__(7);
var sequence = __webpack_require__(113);

/**
 * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
 * into an Applicative of Traversable.
 *
 * Dispatches to the `sequence` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
 * @param {Function} of
 * @param {Function} f
 * @param {*} traversable
 * @return {*}
 * @see R.sequence
 * @example
 *
 *      // Returns `Nothing` if the given divisor is `0`
 *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
 *
 *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
 *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
 */
module.exports = _curry3(function traverse(of, f, traversable) {
  return sequence(of, map(f, traversable));
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Removes (strips) whitespace from both ends of the string.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category String
 * @sig String -> String
 * @param {String} str The string to trim.
 * @return {String} Trimmed version of `str`.
 * @example
 *
 *      R.trim('   xyz  '); //=> 'xyz'
 *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
 */
module.exports = function () {
  var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
  var zeroWidth = '\u200B';
  var hasProtoTrim = typeof String.prototype.trim === 'function';
  if (!hasProtoTrim || ws.trim() || !zeroWidth.trim()) {
    return _curry1(function trim(str) {
      var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
      var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
      return str.replace(beginRx, '').replace(endRx, '');
    });
  } else {
    return _curry1(function trim(str) {
      return str.trim();
    });
  }
}();

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

var _arity = __webpack_require__(11);
var _concat = __webpack_require__(9);
var _curry2 = __webpack_require__(0);

/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
 * function evaluates the `tryer`; if it does not throw, it simply returns the
 * result. If the `tryer` *does* throw, the returned function evaluates the
 * `catcher` function and returns its result. Note that for effective
 * composition with this function, both the `tryer` and `catcher` functions
 * must return the same type of results.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
 * @param {Function} tryer The function that may throw.
 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
 * @return {Function} A new function that will catch exceptions and send then to the catcher.
 * @example
 *
 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
 *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
 */
module.exports = _curry2(function _tryCatch(tryer, catcher) {
  return _arity(tryer.length, function () {
    try {
      return tryer.apply(this, arguments);
    } catch (e) {
      return catcher.apply(this, _concat([e], arguments));
    }
  });
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Takes a function `fn`, which takes a single array argument, and returns a
 * function which:
 *
 *   - takes any number of positional arguments;
 *   - passes these arguments to `fn` as an array; and
 *   - returns the result.
 *
 * In other words, R.unapply derives a variadic function from a function which
 * takes an array. R.unapply is the inverse of R.apply.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Function
 * @sig ([*...] -> a) -> (*... -> a)
 * @param {Function} fn
 * @return {Function}
 * @see R.apply
 * @example
 *
 *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
 * @symb R.unapply(f)(a, b) = f([a, b])
 */
module.exports = _curry1(function unapply(fn) {
  return function () {
    return fn(Array.prototype.slice.call(arguments, 0));
  };
});

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);
var nAry = __webpack_require__(39);

/**
 * Wraps a function of any arity (including nullary) in a function that accepts
 * exactly 1 parameter. Any extraneous parameters will not be passed to the
 * supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Function
 * @sig (* -> b) -> (a -> b)
 * @param {Function} fn The function to wrap.
 * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
 *         arity 1.
 * @example
 *
 *      var takesTwoArgs = function(a, b) {
 *        return [a, b];
 *      };
 *      takesTwoArgs.length; //=> 2
 *      takesTwoArgs(1, 2); //=> [1, 2]
 *
 *      var takesOneArg = R.unary(takesTwoArgs);
 *      takesOneArg.length; //=> 1
 *      // Only 1 argument is passed to the wrapped function
 *      takesOneArg(1, 2); //=> [1, undefined]
 * @symb R.unary(f)(a, b, c) = f(a)
 */
module.exports = _curry1(function unary(fn) {
  return nAry(1, fn);
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var curryN = __webpack_require__(5);

/**
 * Returns a function of arity `n` from a (manually) curried function.
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Function
 * @sig Number -> (a -> b) -> (a -> c)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to uncurry.
 * @return {Function} A new function.
 * @see R.curry
 * @example
 *
 *      var addFour = a => b => c => d => a + b + c + d;
 *
 *      var uncurriedAddFour = R.uncurryN(4, addFour);
 *      uncurriedAddFour(1, 2, 3, 4); //=> 10
 */
module.exports = _curry2(function uncurryN(depth, fn) {
  return curryN(depth, function () {
    var currentDepth = 1;
    var value = fn;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === 'function') {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Builds a list from a seed value. Accepts an iterator function, which returns
 * either false to stop iteration or an array of length 2 containing the value
 * to add to the resulting list and the seed to be used in the next call to the
 * iterator function.
 *
 * The iterator function receives one argument: *(seed)*.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category List
 * @sig (a -> [b]) -> * -> [b]
 * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
 *        either false to quit iteration or an array of length two to proceed. The element
 *        at index 0 of this array will be added to the resulting array, and the element
 *        at index 1 will be passed to the next call to `fn`.
 * @param {*} seed The seed value.
 * @return {Array} The final list.
 * @example
 *
 *      var f = n => n > 50 ? false : [-n, n + 10];
 *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
 * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
 */
module.exports = _curry2(function unfold(fn, seed) {
  var pair = fn(seed);
  var result = [];
  while (pair && pair.length) {
    result[result.length] = pair[0];
    pair = fn(pair[1]);
  }
  return result;
});

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry2 = __webpack_require__(0);
var compose = __webpack_require__(45);
var uniq = __webpack_require__(56);

/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */
module.exports = _curry2(compose(uniq, _concat));

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var _concat = __webpack_require__(9);
var _curry3 = __webpack_require__(2);
var uniqWith = __webpack_require__(57);

/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list. Duplication is determined according to the value returned by
 * applying the supplied predicate to two list elements.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
 * @param {Function} pred A predicate used to test whether two items are equal.
 * @param {Array} list1 The first list.
 * @param {Array} list2 The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @see R.union
 * @example
 *
 *      var l1 = [{a: 1}, {a: 2}];
 *      var l2 = [{a: 1}, {a: 4}];
 *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
 */
module.exports = _curry3(function unionWith(pred, list1, list2) {
  return uniqWith(pred, _concat(list1, list2));
});

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is not satisfied, the function will return the result of
 * calling the `whenFalseFn` function with the same argument. If the predicate
 * is satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred        A predicate function
 * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
 *                               to a falsy value.
 * @param {*}        x           An object to test with the `pred` function and
 *                               pass to `whenFalseFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
 * @see R.ifElse, R.when
 * @example
 *
 *      // coerceArray :: (a|[a]) -> [a]
 *      var coerceArray = R.unless(R.isArrayLike, R.of);
 *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
 *      coerceArray(1);         //=> [1]
 */
module.exports = _curry3(function unless(pred, whenFalseFn, x) {
  return pred(x) ? x : whenFalseFn(x);
});

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

var _identity = __webpack_require__(51);
var chain = __webpack_require__(44);

/**
 * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
 * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig Chain c => c (c a) -> c a
 * @param {*} list
 * @return {*}
 * @see R.flatten, R.chain
 * @example
 *
 *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
 *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
 */
module.exports = chain(_identity);

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Takes a predicate, a transformation function, and an initial value,
 * and returns a value of the same type as the initial value.
 * It does so by applying the transformation until the predicate is satisfied,
 * at which point it returns the satisfactory value.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred A predicate function
 * @param {Function} fn The iterator function
 * @param {*} init Initial value
 * @return {*} Final value that satisfies predicate
 * @example
 *
 *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
 */
module.exports = _curry3(function until(pred, fn, init) {
  var val = init;
  while (!pred(val)) {
    val = fn(val);
  }
  return val;
});

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = __webpack_require__(1);

/**
 * Returns a list of all the properties, including prototype properties, of the
 * supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig {k: v} -> [v]
 * @param {Object} obj The object to extract values from
 * @return {Array} An array of the values of the object's own and prototype properties.
 * @example
 *
 *      var F = function() { this.x = 'X'; };
 *      F.prototype.y = 'Y';
 *      var f = new F();
 *      R.valuesIn(f); //=> ['X', 'Y']
 */
module.exports = _curry1(function valuesIn(obj) {
  var prop;
  var vs = [];
  for (prop in obj) {
    vs[vs.length] = obj[prop];
  }
  return vs;
});

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Returns a "view" of the given data structure, determined by the given lens.
 * The lens's focus determines which portion of the data structure is visible.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category Object
 * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> s -> a
 * @param {Lens} lens
 * @param {*} x
 * @return {*}
 * @see R.prop, R.lensIndex, R.lensProp
 * @example
 *
 *      var xLens = R.lensProp('x');
 *
 *      R.view(xLens, {x: 1, y: 2});  //=> 1
 *      R.view(xLens, {x: 4, y: 2});  //=> 4
 */
module.exports = function () {
  // `Const` is a functor that effectively ignores the function given to `map`.
  var Const = function Const(x) {
    return { value: x, map: function map() {
        return this;
      } };
  };

  return _curry2(function view(lens, x) {
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    return lens(Const)(x).value;
  });
}();

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Tests the final argument by passing it to the given predicate function. If
 * the predicate is satisfied, the function will return the result of calling
 * the `whenTrueFn` function with the same argument. If the predicate is not
 * satisfied, the argument is returned as is.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Logic
 * @sig (a -> Boolean) -> (a -> a) -> a -> a
 * @param {Function} pred       A predicate function
 * @param {Function} whenTrueFn A function to invoke when the `condition`
 *                              evaluates to a truthy value.
 * @param {*}        x          An object to test with the `pred` function and
 *                              pass to `whenTrueFn` if necessary.
 * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
 * @see R.ifElse, R.unless
 * @example
 *
 *      // truncate :: String -> String
 *      var truncate = R.when(
 *        R.propSatisfies(R.gt(R.__, 10), 'length'),
 *        R.pipe(R.take(10), R.append(''), R.join(''))
 *      );
 *      truncate('12345');         //=> '12345'
 *      truncate('0123456789ABC'); //=> '0123456789'
 */
module.exports = _curry3(function when(pred, whenTrueFn, x) {
  return pred(x) ? whenTrueFn(x) : x;
});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);
var equals = __webpack_require__(10);
var map = __webpack_require__(7);
var where = __webpack_require__(121);

/**
 * Takes a spec object and a test object; returns true if the test satisfies
 * the spec, false otherwise. An object satisfies the spec if, for each of the
 * spec's own properties, accessing that property of the object gives the same
 * value (in `R.equals` terms) as accessing that property of the spec.
 *
 * `whereEq` is a specialization of [`where`](#where).
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category Object
 * @sig {String: *} -> {String: *} -> Boolean
 * @param {Object} spec
 * @param {Object} testObj
 * @return {Boolean}
 * @see R.where
 * @example
 *
 *      // pred :: Object -> Boolean
 *      var pred = R.whereEq({a: 1, b: 2});
 *
 *      pred({a: 1});              //=> false
 *      pred({a: 1, b: 2});        //=> true
 *      pred({a: 1, b: 2, c: 3});  //=> true
 *      pred({a: 1, b: 1});        //=> false
 */
module.exports = _curry2(function whereEq(spec, testObj) {
  return where(map(equals, spec), testObj);
});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var _contains = __webpack_require__(16);
var _curry2 = __webpack_require__(0);
var flip = __webpack_require__(31);
var reject = __webpack_require__(41);

/**
 * Returns a new list without values in the first argument.
 * `R.equals` is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */
module.exports = _curry2(function (xs, list) {
  return reject(flip(_contains)(xs), list);
});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Creates a new list out of the two supplied by creating each possible pair
 * from the lists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The list made by combining each possible pair from
 *         `as` and `bs` into pairs (`[a, b]`).
 * @example
 *
 *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
 * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
 */
module.exports = _curry2(function xprod(a, b) {
  // = xprodWith(prepend); (takes about 3 times as long...)
  var idx = 0;
  var ilen = a.length;
  var j;
  var jlen = b.length;
  var result = [];
  while (idx < ilen) {
    j = 0;
    while (j < jlen) {
      result[result.length] = [a[idx], b[j]];
      j += 1;
    }
    idx += 1;
  }
  return result;
});

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Creates a new list out of the two supplied by pairing up equally-positioned
 * items from both lists. The returned list is truncated to the length of the
 * shorter of the two input lists.
 * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [b] -> [[a,b]]
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
 * @example
 *
 *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
 * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
 */
module.exports = _curry2(function zip(a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = [a[idx], b[idx]];
    idx += 1;
  }
  return rv;
});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = __webpack_require__(0);

/**
 * Creates a new object out of a list of keys and a list of values.
 * Key/value pairing is truncated to the length of the shorter of the two lists.
 * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
 *
 * @func
 * @memberOf R
 * @since v0.3.0
 * @category List
 * @sig [String] -> [*] -> {String: *}
 * @param {Array} keys The array that will be properties on the output object.
 * @param {Array} values The list of values on the output object.
 * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
 * @example
 *
 *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
 */
module.exports = _curry2(function zipObj(keys, values) {
  var idx = 0;
  var len = Math.min(keys.length, values.length);
  var out = {};
  while (idx < len) {
    out[keys[idx]] = values[idx];
    idx += 1;
  }
  return out;
});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = __webpack_require__(2);

/**
 * Creates a new list out of the two supplied by applying the function to each
 * equally-positioned pair in the lists. The returned list is truncated to the
 * length of the shorter of the two input lists.
 *
 * @function
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a,b -> c) -> [a] -> [b] -> [c]
 * @param {Function} fn The function used to combine the two elements into one value.
 * @param {Array} list1 The first array to consider.
 * @param {Array} list2 The second array to consider.
 * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
 *         using `fn`.
 * @example
 *
 *      var f = (x, y) => {
 *        // ...
 *      };
 *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
 *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
 * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
 */
module.exports = _curry3(function zipWith(fn, a, b) {
  var rv = [];
  var idx = 0;
  var len = Math.min(a.length, b.length);
  while (idx < len) {
    rv[idx] = fn(a[idx], b[idx]);
    idx += 1;
  }
  return rv;
});

/***/ }),
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_utility__ = __webpack_require__(20);
/* harmony export (immutable) */ __webpack_exports__["a"] = splitOrFullFare;
/**
 * If min single less than min travelcard and max single more than max travelcard - calculates whichever is cheaper:
 * 	either two split singles or full fare without travelcard
 * @function
 * @param {numbers} minChargedZone - the min zone that will charge between this min chargable zone to min travelcard - 1 (as single) and  max chargeable zone (to charge beween max travelcard +1 to max chargeable zone)
 * @returns {number} - returns the cheapest fare
 * @description
 */



function splitOrFullFare(minChargedZone, maxSingle, minTravelcard, maxTravelcard, singleFares, type) {
	return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["e" /* minNum */])([__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* getSingleFare */])([minChargedZone, maxSingle], singleFares, type), __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* getSingleFare */])([minChargedZone, minTravelcard - 1], singleFares, type) + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utility_utility__["d" /* getSingleFare */])([maxTravelcard + 1, maxSingle], singleFares, type)]);
}

/***/ }),
/* 341 */,
/* 342 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_utility__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility_getData__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__partials_getSingleJourneyZones__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__partials_extensionFares__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__partials_oysterDayTotal__ = __webpack_require__(123);







// TO DO
// Off peak vs on peak singles (esp including out of zone 1 to zone 1 in evening is offpeak exception)
// Offpeak daily cap discounts - keep track when daily cap reached but only travelled off peak (if going to do off peak oyster cum totals then would know this)
// possibility of altering oyster so reflects off peak -- then could add  the Railcard or Gold card discount to your Oyster and 1-8  zones or to 9 without watford
// CAN DO APPRENTICE, 18+ STUDENT, 16+ ZIP, JOB CENTRE ON OYSTER - as no diff bw off peak / on peak daily caps
// NB Weekly capping is always anytime & daily capping always starts at zone 1

// getData.stations().then(function (stations) {
// 	getSingleJourneyZones('1000029', '1000138', stations).then((resp) => {
// 		// console.log(resp);
// 	});
// });

__WEBPACK_IMPORTED_MODULE_1__utility_getData__["a" /* default */].fares().then(function (fareData) {
  var singleFares = fareData.singleFares;
  var dailyCaps = fareData.dailyCaps;

  var journeys = [{
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "offPeak"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "offPeak"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "offPeak"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "offPeak"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }, {
    zones: [1, 2],
    dualZoneOverlap: false,
    type: "anytime"
  }];

  console.log(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__partials_oysterDayTotal__["a" /* default */])({
    minTravelcard: 3,
    maxTravelcard: 4
  }, {
    journeys: journeys,
    dailyCaps: dailyCaps, //JSON
    singleFares: singleFares
  }));
});
// //---------------------------------
// // - CONTACTLESS Cheapest Fare = with daily caps
// 	//The array of all combination prices to be reduce to cheapest one
// 	let conAllFares = [];

// 	// for without any daily caps, only singles added together
// 	let conFares = null;
// 	journeys.forEach(function(journey) {
// 		conFares += getSingleFare(journey.zones, singleFares);
// 	});
// 	conAllFares.push(conFares);

// 	// 	Then for each Zone range (from Zone 1-3 until Zone 1 to max) repeat same calculation.
// 	 let conMaxZone = maxNum(flatten(journeys.map(j => j.zones)));
// 	 for (let i = 2; i <= conMaxZone; i++) {
// 	 	//console.log('for daily cap 1 to ' + i);
// 	 	let conCumTotal = getDailyCap(i, dailyCaps);
// 	 	 for (let x = 0; x < journeys.length; x++) {
// 	 	 	//adding extension fares to cumTotal
// 	 		conCumTotal += extensionFares(1, i, journeys[x][0], journeys[x][1], singleFares);
// 	 	 };
// 	 	conAllFares.push(conCumTotal);
// 	 }

// 	// 	---> Compare all the possibilities and select the cheapest (including total single).
// 	return minNum(conAllFares);
// 	//this returns the final contactless daily fare
// });

//CONTACTLESS
//For just daily caps OR weekly cap without daily cap: use extension fares without max daily
//For combo of daily cap and weekly cap: use extension fares with max daily cap
//
// OFF PEAK DAILY and WEEKLY: For off peak daily cap combos: if off peak, use extension fares to calculate using both daily and weekly caps
// --- whilst if peak travel then use extension fares with only weekly travel card caps and add to total
// ANYTIME DAILY and WEEKLY: use the extension fare to calculate all fares with daily anytime cap and weekly cap (current set up)

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODM0ZDJlZWM4YjQxNTkxYzlmOTIiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Mi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkxLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGZCYXNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2N1cnJ5Ti5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faGFzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZXF1YWxzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19hcml0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9rZXlzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYWx3YXlzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21heC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbGl0eS9fdXRpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW52b2tlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9udGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wbHVjay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9hZGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYXNzb2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvY3VycnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZmxpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnlOLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pc1BsYWNlaG9sZGVyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fbWFwLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2xlbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbGlmdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9uQXJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlZHVjZUJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9yZXZlcnNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2FwLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NoYWluLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvY29uY2F0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19jb250YWluc1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdGFpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90eXBlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3VuaXEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdW5pcVdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19leHRlbnNpb25GYXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbGl0eS9fZ2V0RGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2FkanVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9hbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYW55LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2FwcGx5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Fzc29jUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9iaW5kLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NvbXBvc2VLLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NvbnN0cnVjdE4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvY29udmVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZGVmYXVsdFRvLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZGlmZmVyZW5jZVdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZGlzc29jLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZHJvcFJlcGVhdHNXaXRoLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2VtcHR5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2lkZW50aWNhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19jb21wbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19jcmVhdGVQYXJ0aWFsQXBwbGljYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pbmRleE9mLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faXNJbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19pc051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX21ha2VGbGF0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194YW55LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194d3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9qdXh0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2xhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2xpZnROLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21lYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbWVyZ2VXaXRoS2V5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL211bHRpcGx5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL25vdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9vYmpPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9vci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9vdmVyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3BpY2tBbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcGlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9waXBlUC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wcmVwZW5kLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlZHVjZVJpZ2h0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3NlcXVlbmNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90YWtlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3RpbWVzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3VuaXFCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy91cGRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdXNlV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvd2hlcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19nZXRTaW5nbGVKb3VybmV5Wm9uZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhcnRpYWxzL19veXN0ZXJEYXlUb3RhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9GLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL1QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvX18uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYWRkSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYWxsLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2FsbFBhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYW55UGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9hcGVydHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9hcHBlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYXBwbHlTcGVjLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2FzY2VuZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvYm90aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9jYWxsLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NsYW1wLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NvbXBhcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvY29tcGxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9jb21wb3NlUC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9jb25kLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9jb3VudEJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2RlYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9kZXNjZW5kLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Rpc3NvY1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZGl2aWRlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Ryb3BMYXN0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Ryb3BMYXN0V2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZHJvcFJlcGVhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZHJvcFdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2VpdGhlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9lcUJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2VxUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZXZvbHZlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ZpbmRMYXN0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ZpbmRMYXN0SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9mb3JFYWNoLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ZvckVhY2hPYmpJbmRleGVkLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2Zyb21QYWlycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9ncm91cEJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2dyb3VwV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9ndC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9ndGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaGFzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2hhc0luLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2hlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaWZFbHNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2luYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbmRleEJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnNlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW5zZXJ0QWxsLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19TZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2FwZXJ0dXJlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19hcnJheUZyb21JdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZHJvcExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Ryb3BMYXN0V2hpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2VxdWFscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZmxhdENhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZm9yY2VSZWR1Y2VkLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19mdW5jdGlvbk5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzUmVnRXhwLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19vYmplY3RBc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX29mLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19waXBlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL19waXBlUC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3N0ZXBDYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3RvSVNPU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL190b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGFwZXJ0dXJlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194Y2hhaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hkcm9wLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcExhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hkcm9wTGFzdFdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcFdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194ZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194ZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGZpbmRMYXN0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194ZmluZExhc3RJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feG1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feHJlZHVjZUJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludGVybmFsL194dGFrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feHRha2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaW50ZXJzZWN0aW9uV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRlcnNwZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnRvLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2ludmVydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pbnZlcnRPYmouanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9pc05pbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9qb2luLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9sYXN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9sZW5zSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbGVuc1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbGVuc1Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbHRlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21hcEFjY3VtLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21hcEFjY3VtUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbWFwT2JqSW5kZXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9tYXRoTW9kLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21heEJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21lZGlhbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21lcmdlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21lcmdlQWxsLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL21lcmdlV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbWluQnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvbW9kdWxvLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9ub25lLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL250aEFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9vbWl0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL29uY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcGFpci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wYXJ0aWFsLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3BhcnRpYWxSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wYXJ0aXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcGF0aEVxLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3BhdGhPci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wYXRoU2F0aXNmaWVzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcGlja0J5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3BpcGVLLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3Byb2R1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcHJvamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wcm9wRXEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcHJvcElzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3Byb3BPci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9wcm9wU2F0aXNmaWVzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3Byb3BzLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JhbmdlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlZHVjZVdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlZHVjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvcmVtb3ZlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3JlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3NjYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvc2V0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3NvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvc29ydEJ5LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3NvcnRXaXRoLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3NwbGl0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3NwbGl0QXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvc3BsaXRFdmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9zcGxpdFdoZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvc3ltbWV0cmljRGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy9zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90YWtlTGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90YWtlTGFzdFdoaWxlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3Rha2VXaGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90YXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90b0xvd2VyLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3RvUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdG9QYWlyc0luLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3RvVXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdHJhbnNkdWNlLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90cmF2ZXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy90cmltLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3RyeUNhdGNoLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3VuYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdW5jdXJyeU4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdW5mb2xkLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3VuaW9uLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3VuaW9uV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy91bmxlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvdW5uZXN0LmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3VudGlsLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3ZhbHVlc0luLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvd2hlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy93aGVyZUVxLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3dpdGhvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMveHByb2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yYW1kYS9zcmMvemlwLmpzIiwid2VicGFjazovLy8uL34vcmFtZGEvc3JjL3ppcE9iai5qcyIsIndlYnBhY2s6Ly8vLi9+L3JhbWRhL3NyYy96aXBXaXRoLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9wYXJ0aWFscy9fc3BsaXRPckZ1bGxGYXJlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9hcHAuanMiXSwibmFtZXMiOlsiX2N1cnJ5MSIsInJlcXVpcmUiLCJfaXNQbGFjZWhvbGRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJfY3VycnkyIiwiZm4iLCJmMiIsImEiLCJiIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX2IiLCJfYSIsImYxIiwiYXBwbHkiLCJfY3VycnkzIiwiZjMiLCJjIiwiX2MiLCJfaXNBcnJheSIsIl9pc1RyYW5zZm9ybWVyIiwiX2Rpc3BhdGNoYWJsZSIsIm1ldGhvZE5hbWVzIiwieGYiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJvYmoiLCJwb3AiLCJpZHgiLCJ0cmFuc2R1Y2VyIiwiaW5pdCIsInJlc3VsdCIsIl9hcml0eSIsIl9jdXJyeU4iLCJjdXJyeU4iLCJfaGFzIiwicHJvcCIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiX21hcCIsIl9yZWR1Y2UiLCJfeG1hcCIsImtleXMiLCJtYXAiLCJmdW5jdG9yIiwidG9TdHJpbmciLCJhY2MiLCJrZXkiLCJfeHdyYXAiLCJiaW5kIiwiaXNBcnJheUxpa2UiLCJfYXJyYXlSZWR1Y2UiLCJsaXN0IiwibGVuIiwiX2l0ZXJhYmxlUmVkdWNlIiwiaXRlciIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwiX21ldGhvZFJlZHVjZSIsInJlZHVjZSIsInN5bUl0ZXJhdG9yIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJUeXBlRXJyb3IiLCJfY29uY2F0Iiwic2V0MSIsInNldDIiLCJsZW4xIiwibGVuMiIsIl9lcXVhbHMiLCJlcXVhbHMiLCJuIiwiYTAiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJFcnJvciIsIl9pc0FyZ3VtZW50cyIsImhhc0VudW1CdWciLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm5vbkVudW1lcmFibGVQcm9wcyIsImhhc0FyZ3NFbnVtQnVnIiwiY29udGFpbnMiLCJpdGVtIiwibklkeCIsImtzIiwiY2hlY2tBcmdzTGVuZ3RoIiwiaXNBcnJheSIsInZhbCIsIl9yZWR1Y2VkIiwieCIsIl9pbmRleE9mIiwiX2NvbnRhaW5zIiwiX2NoZWNrRm9yTWV0aG9kIiwiZnJvbUluZGV4IiwidG9JbmRleCIsImFsd2F5cyIsIm1heCIsImdldFpvbmVzIiwibmFwVGFuIiwic3RhdGlvbnMiLCJ6b25lcyIsImZpbHRlclpvbmVzQnlOdW1iZXIiLCJudW0iLCJmaWx0ZXIiLCJ6b25lIiwiY29tcGFyZU51bWJlcnMiLCJhcnJheU51bWJlcnMiLCJvcGVyYXRvciIsIm1heE51bSIsImFycmF5Wm9uZXMiLCJNYXRoIiwibWluTnVtIiwibWluIiwiZ2V0RGlmZmVyZW5jZSIsImFicyIsImZsYXR0ZW4iLCJhcnIiLCJjb25jYXQiLCJqb3VybmV5VG9LZXkiLCJqb3VybmV5Iiwic29ydCIsImpvaW4iLCJ6b25lVG9Kb3VybmV5IiwiZ2V0RGFpbHlDYXAiLCJtYXhab25lc29mYXIiLCJkYWlseUNhcHMiLCJ0eXBlIiwiZ2V0Q2FwIiwiXyIsImN1cnJ5IiwiY2FwcyIsImdldFNpbmdsZUZhcmUiLCJzaW5nbGVGYXJlcyIsIm1ldCIsInRhcmdldCIsIm1ldGhvZG5hbWUiLCJfaXNGdW5jdGlvbiIsImludm9rZXIiLCJhcml0eSIsIm1ldGhvZCIsIl9pc1N0cmluZyIsIm5vZGVUeXBlIiwibnRoIiwib2Zmc2V0IiwiY2hhckF0IiwicGF0aCIsInBhdGhzIiwicGx1Y2siLCJwIiwiX3RvU3RyaW5nIiwiYWRkIiwiTnVtYmVyIiwiYXNzb2MiLCJmbGlwIiwicmVjZWl2ZWQiLCJjb21iaW5lZCIsImFyZ3NJZHgiLCJsZWZ0IiwiY29tYmluZWRJZHgiLCJsZW5zIiwiZ2V0dGVyIiwic2V0dGVyIiwidG9GdW5jdG9yRm4iLCJmb2N1cyIsImxpZnROIiwibGlmdCIsIm5BcnkiLCJfeHJlZHVjZUJ5IiwicmVkdWNlQnkiLCJ2YWx1ZUZuIiwidmFsdWVBY2MiLCJrZXlGbiIsImVsdCIsIl9jb21wbGVtZW50IiwicmVqZWN0IiwicHJlZCIsImZpbHRlcmFibGUiLCJyZXZlcnNlIiwic3BsaXQiLCJhcCIsImFwcGxpY2F0aXZlIiwiZiIsIl9tYWtlRmxhdCIsIl94Y2hhaW4iLCJjaGFpbiIsIm1vbmFkIiwicGlwZSIsImNvbXBvc2UiLCJfZmlsdGVyIiwiX2lzT2JqZWN0IiwiX3hmaWx0ZXIiLCJfaWRlbnRpdHkiLCJfb2JqZWN0QXNzaWduIiwiYXNzaWduIiwiX2NvbnRhaW5zV2l0aCIsIkluZmluaXR5IiwidW5kZWZpbmVkIiwiaWRlbnRpdHkiLCJ1bmlxQnkiLCJ1bmlxV2l0aCIsImV4dGVuc2lvbkZhcmVzIiwib3B0aW9ucyIsIm1heERhaWx5IiwibWluVHJhdmVsY2FyZCIsIm1heFRyYXZlbGNhcmQiLCJmaW5hbENvbmRpdGlvbiIsIm1pblNpbmdsZSIsIm1heFNpbmdsZSIsIm1pbkNoYXJnZWRab25lIiwic3BsaXRPckZ1bGxGYXJlIiwiZmV0Y2hGYXJlRGF0YSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmZXRjaCIsInRoZW4iLCJyZXNwIiwianNvbiIsImZldGNoU3RhdGlvbnNEYXRhIiwiZmV0Y2hKb3VybmV5RGF0YSIsImZyb20iLCJ0byIsImUiLCJmYXJlcyIsIkYiLCJUIiwiX18iLCJhZGRJbmRleCIsImFkanVzdCIsImFsbCIsImFsbFBhc3MiLCJhbmQiLCJhbnkiLCJhbnlQYXNzIiwiYXBlcnR1cmUiLCJhcHBlbmQiLCJhcHBseVNwZWMiLCJhc2NlbmQiLCJhc3NvY1BhdGgiLCJiaW5hcnkiLCJib3RoIiwiY2xhbXAiLCJjbG9uZSIsImNvbXBhcmF0b3IiLCJjb21wbGVtZW50IiwiY29tcG9zZUsiLCJjb21wb3NlUCIsImNvbmQiLCJjb25zdHJ1Y3QiLCJjb25zdHJ1Y3ROIiwiY29udmVyZ2UiLCJjb3VudEJ5IiwiZGVjIiwiZGVzY2VuZCIsImRlZmF1bHRUbyIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlV2l0aCIsImRpc3NvYyIsImRpc3NvY1BhdGgiLCJkaXZpZGUiLCJkcm9wIiwiZHJvcExhc3QiLCJkcm9wTGFzdFdoaWxlIiwiZHJvcFJlcGVhdHMiLCJkcm9wUmVwZWF0c1dpdGgiLCJkcm9wV2hpbGUiLCJlaXRoZXIiLCJlbXB0eSIsImVxQnkiLCJlcVByb3BzIiwiZXZvbHZlIiwiZmluZCIsImZpbmRJbmRleCIsImZpbmRMYXN0IiwiZmluZExhc3RJbmRleCIsImZvckVhY2giLCJmb3JFYWNoT2JqSW5kZXhlZCIsImZyb21QYWlycyIsImdyb3VwQnkiLCJncm91cFdpdGgiLCJndCIsImd0ZSIsImhhcyIsImhhc0luIiwiaGVhZCIsImlkZW50aWNhbCIsImlmRWxzZSIsImluYyIsImluZGV4QnkiLCJpbmRleE9mIiwiaW5zZXJ0IiwiaW5zZXJ0QWxsIiwiaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0aW9uV2l0aCIsImludGVyc3BlcnNlIiwiaW50byIsImludmVydCIsImludmVydE9iaiIsImlzIiwiaXNFbXB0eSIsImlzTmlsIiwianV4dCIsImtleXNJbiIsImxhc3QiLCJsYXN0SW5kZXhPZiIsImxlbnNJbmRleCIsImxlbnNQYXRoIiwibGVuc1Byb3AiLCJsdCIsImx0ZSIsIm1hcEFjY3VtIiwibWFwQWNjdW1SaWdodCIsIm1hcE9iakluZGV4ZWQiLCJtYXRjaCIsIm1hdGhNb2QiLCJtYXhCeSIsIm1lYW4iLCJtZWRpYW4iLCJtZW1vaXplIiwibWVyZ2UiLCJtZXJnZUFsbCIsIm1lcmdlV2l0aCIsIm1lcmdlV2l0aEtleSIsIm1pbkJ5IiwibW9kdWxvIiwibXVsdGlwbHkiLCJuZWdhdGUiLCJub25lIiwibm90IiwibnRoQXJnIiwib2JqT2YiLCJvZiIsIm9taXQiLCJvbmNlIiwib3IiLCJvdmVyIiwicGFpciIsInBhcnRpYWwiLCJwYXJ0aWFsUmlnaHQiLCJwYXJ0aXRpb24iLCJwYXRoRXEiLCJwYXRoT3IiLCJwYXRoU2F0aXNmaWVzIiwicGljayIsInBpY2tBbGwiLCJwaWNrQnkiLCJwaXBlSyIsInBpcGVQIiwicHJlcGVuZCIsInByb2R1Y3QiLCJwcm9qZWN0IiwicHJvcEVxIiwicHJvcElzIiwicHJvcE9yIiwicHJvcFNhdGlzZmllcyIsInByb3BzIiwicmFuZ2UiLCJyZWR1Y2VSaWdodCIsInJlZHVjZVdoaWxlIiwicmVkdWNlZCIsInJlbW92ZSIsInJlcGVhdCIsInJlcGxhY2UiLCJzY2FuIiwic2VxdWVuY2UiLCJzZXQiLCJzb3J0QnkiLCJzb3J0V2l0aCIsInNwbGl0QXQiLCJzcGxpdEV2ZXJ5Iiwic3BsaXRXaGVuIiwic3VidHJhY3QiLCJzdW0iLCJzeW1tZXRyaWNEaWZmZXJlbmNlIiwic3ltbWV0cmljRGlmZmVyZW5jZVdpdGgiLCJ0YWlsIiwidGFrZSIsInRha2VMYXN0IiwidGFrZUxhc3RXaGlsZSIsInRha2VXaGlsZSIsInRhcCIsInRlc3QiLCJ0aW1lcyIsInRvTG93ZXIiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwidG9VcHBlciIsInRyYW5zZHVjZSIsInRyYW5zcG9zZSIsInRyYXZlcnNlIiwidHJpbSIsInRyeUNhdGNoIiwidW5hcHBseSIsInVuYXJ5IiwidW5jdXJyeU4iLCJ1bmZvbGQiLCJ1bmlvbiIsInVuaW9uV2l0aCIsInVuaXEiLCJ1bmxlc3MiLCJ1bm5lc3QiLCJ1bnRpbCIsInVwZGF0ZSIsInVzZVdpdGgiLCJ2YWx1ZXMiLCJ2YWx1ZXNJbiIsInZpZXciLCJ3aGVuIiwid2hlcmUiLCJ3aGVyZUVxIiwid2l0aG91dCIsInhwcm9kIiwiemlwIiwiemlwT2JqIiwiemlwV2l0aCIsInN0YXJ0IiwiX2lkeCIsIl9saXN0IiwiX3hhbnkiLCJfaXNJbnRlZ2VyIiwibmV4dE9iaiIsInRoaXNPYmoiLCJGbiIsIiQwIiwiJDEiLCIkMiIsIiQzIiwiJDQiLCIkNSIsIiQ2IiwiJDciLCIkOCIsIiQ5IiwiYWZ0ZXIiLCJmbnMiLCJjb250ZXh0IiwiZCIsInYiLCJmaXJzdCIsInNlY29uZCIsIm91dCIsImZpcnN0TGVuIiwicHVzaCIsIl94ZHJvcCIsInhzIiwiX3hkcm9wUmVwZWF0c1dpdGgiLCJjb25zdHJ1Y3RvciIsIl9jbG9uZVJlZ0V4cCIsIl9jbG9uZSIsInJlZkZyb20iLCJyZWZUbyIsImRlZXAiLCJjb3B5IiwiY29waWVkVmFsdWUiLCJEYXRlIiwidmFsdWVPZiIsInBhdHRlcm4iLCJSZWdFeHAiLCJzb3VyY2UiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwic3RpY2t5IiwidW5pY29kZSIsIl9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvciIsImluZiIsImlzSW50ZWdlciIsIl9pc051bWJlciIsInJlY3Vyc2l2ZSIsImZsYXR0IiwiamxlbiIsImoiLCJpbGVuIiwiX3hmQmFzZSIsIlhBbnkiLCJpbnB1dCIsIlhEcm9wUmVwZWF0c1dpdGgiLCJsYXN0VmFsdWUiLCJzZWVuRmlyc3RWYWx1ZSIsInNhbWVBc0xhc3QiLCJYV3JhcCIsIkN0b3IiLCJOYU4iLCJsaWZ0ZWQiLCJsIiwiciIsImsiLCJJZGVudGl0eSIsInkiLCJuYW1lcyIsIm5hbWUiLCJfcGlwZSIsIl9waXBlUCIsImVsIiwidHJhdmVyc2FibGUiLCJfeHRha2UiLCJpc05hTiIsIlJhbmdlRXJyb3IiLCJfU2V0IiwiYXBwbGllZEl0ZW0iLCJ0cmFuc2Zvcm1lcnMiLCJ2YWxzIiwic3BlYyIsInRlc3RPYmoiLCJnZXRTaW5nbGVKb3VybmV5Wm9uZXMiLCJnZXREYXRhIiwiam91cm5leXMiLCJsZWdzIiwiYWxsWm9uZXMiLCJsZWciLCJ0ZW1wWm9uZXMiLCJkZXBhcnR1cmVQb2ludCIsIm5hcHRhbklkIiwic3RvcFBvaW50cyIsInN0b3BQb2ludCIsImlkIiwiem9uZXNGcm9tU2luZ2xlU3RhdGlvbnMiLCJ6b25lc0Zyb21EdWFsU3RhdGlvbnMiLCJmaW5hbE1heFpvbmUiLCJmaW5hbE1pblpvbmUiLCJzaW5nbGVNYXgiLCJzaW5nbGVNaW4iLCJkdWFsWm9uZXMiLCJ6Iiwib3lzdGVyRGF5VG90YWwiLCJjYXBNZXQiLCJ0b3RhbHMiLCJzaW5nbGVGYXJlIiwibWF4Wm9uZSIsIm1ldFBlYWsiLCJtZXRPZmZQZWFrIiwib2ZmUGVha1RvdGFsIiwiY3VycmVudFRvdGFsIiwib3JpZ0ZuIiwiX3hhbGwiLCJwcmVkcyIsIl9hcGVydHVyZSIsIl94YXBlcnR1cmUiLCJhYSIsImJiIiwiZyIsIl9ib3RoIiwicGFpcnMiLCJlbGVtIiwiX2Ryb3BMYXN0IiwiX3hkcm9wTGFzdCIsIl9kcm9wTGFzdFdoaWxlIiwiX3hkcm9wTGFzdFdoaWxlIiwiX3hkcm9wV2hpbGUiLCJfZWl0aGVyIiwib2JqMSIsIm9iajIiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJvYmplY3QiLCJ0cmFuc2Zvcm1hdGlvbiIsIl94ZmluZCIsIl94ZmluZEluZGV4IiwiX3hmaW5kTGFzdCIsIl94ZmluZExhc3RJbmRleCIsImtleUxpc3QiLCJyZXMiLCJuZXh0aWR4IiwiY29uZGl0aW9uIiwib25UcnVlIiwib25GYWxzZSIsIl9pZkVsc2UiLCJzcGxpY2UiLCJlbHRzIiwiX25hdGl2ZVNldCIsIlNldCIsIl9pdGVtcyIsImhhc09yQWRkIiwic2hvdWxkQWRkIiwicHJldlNpemUiLCJuZXdTaXplIiwic2l6ZSIsImJJZHgiLCJsaW1pdCIsIl9hcnJheUZyb21JdGVyYXRvciIsIl9mdW5jdGlvbk5hbWUiLCJzdGFja0EiLCJzdGFja0IiLCJtZXNzYWdlIiwiZW50cmllcyIsImtleXNBIiwiX2ZvcmNlUmVkdWNlZCIsInByZXNlcnZpbmdSZWR1Y2VkIiwicmV0IiwiX3hjYXQiLCJyeGYiLCJTdHJpbmciLCJfaXNSZWdFeHAiLCJvdXRwdXQiLCJuZXh0S2V5IiwiX29mIiwiY3R4IiwiX3F1b3RlIiwicyIsImVzY2FwZWQiLCJfYXNzaWduIiwiX3N0ZXBDYXRBcnJheSIsIl9zdGVwQ2F0U3RyaW5nIiwiX3N0ZXBDYXRPYmplY3QiLCJfc3RlcENhdCIsInBhZCIsInRvSVNPU3RyaW5nIiwiX3RvSVNPU3RyaW5nIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwidG9GaXhlZCIsInNlZW4iLCJyZWN1ciIsIm1hcFBhaXJzIiwicmVwciIsIlhBbGwiLCJYQXBlcnR1cmUiLCJwb3MiLCJmdWxsIiwic3RvcmUiLCJnZXRDb3B5IiwiX2ZsYXRDYXQiLCJYRHJvcCIsIlhEcm9wTGFzdCIsIlhEcm9wTGFzdFdoaWxlIiwicmV0YWluZWQiLCJyZXRhaW4iLCJmbHVzaCIsIlhEcm9wV2hpbGUiLCJYRmlsdGVyIiwiWEZpbmQiLCJmb3VuZCIsIlhGaW5kSW5kZXgiLCJYRmluZExhc3QiLCJYRmluZExhc3RJbmRleCIsImxhc3RJZHgiLCJYTWFwIiwiWFJlZHVjZUJ5IiwiaW5wdXRzIiwiWFRha2UiLCJpIiwiWFRha2VXaGlsZSIsIl94dGFrZVdoaWxlIiwibGlzdDEiLCJsaXN0MiIsImxvb2t1cExpc3QiLCJmaWx0ZXJlZExpc3QiLCJyZXN1bHRzIiwic2VwYXJhdG9yIiwidHVwbGUiLCJyeCIsInN0ciIsIm0iLCJ3aWR0aCIsImNhY2hlIiwiX2wiLCJfciIsImNhbGxlZCIsImZzdCIsInNuZCIsIl9wYXRoIiwicHJvcFBhdGgiLCJwcyIsIl9yZWR1Y2VXaGlsZSIsImNvdW50IiwicmVnZXgiLCJyZXBsYWNlbWVudCIsImluZGV4IiwiYXJyYXkiLCJwcmVmaXgiLCJvdXRlcmxpc3QiLCJpbm5lcmxpc3QiLCJ3cyIsInplcm9XaWR0aCIsImhhc1Byb3RvVHJpbSIsImJlZ2luUngiLCJlbmRSeCIsIl90cnlDYXRjaCIsInRyeWVyIiwiY2F0Y2hlciIsImRlcHRoIiwiY3VycmVudERlcHRoIiwiZW5kSWR4Iiwic2VlZCIsIndoZW5GYWxzZUZuIiwidnMiLCJD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QU07QUFIUixHQU5lLEVBV2Y7QUFDRTFCLFdBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixDQURUO0FBRUVvbEIscUJBQWlCLEtBRm5CO0FBR0UxakIsVUFBTTtBQUhSLEdBWGUsRUFnQmY7QUFDRTFCLFdBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixDQURUO0FBRUVvbEIscUJBQWlCLEtBRm5CO0FBR0UxakIsVUFBTTtBQUhSLEdBaEJlLEVBcUJmO0FBQ0UxQixXQUFPLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FEVDtBQUVFb2xCLHFCQUFpQixLQUZuQjtBQUdFMWpCLFVBQU07QUFIUixHQXJCZSxFQTBCZjtBQUNFMUIsV0FBTyxDQUFDLENBQUQsRUFBSSxDQUFKLENBRFQ7QUFFRW9sQixxQkFBaUIsS0FGbkI7QUFHRTFqQixVQUFNO0FBSFIsR0ExQmUsQ0FBakI7O0FBaUNEc0YsVUFBUUMsR0FBUixDQUNLLGdHQUFBeVQsQ0FBZTtBQUNmblUsbUJBQWUsQ0FEQTtBQUVmQyxtQkFBZTtBQUZBLEdBQWYsRUFHRTtBQUNBZ1Qsc0JBREE7QUFFQS9YLHdCQUZBLEVBRVc7QUFDWE87QUFIQSxHQUhGLENBREw7QUFVQSxDQS9DRDtBQWdEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSSIsImZpbGUiOiIuL2Rpc3QvanMvYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzQyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA4MzRkMmVlYzhiNDE1OTFjOWY5MiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9fY3VycnkxJyk7XG52YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdHdvLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMihhLCBiKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjJcbiAgICAgICAgICAgICA6IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iKTsgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMlxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uKF9hKSB7IHJldHVybiBmbihfYSwgYik7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iKTsgfSlcbiAgICAgICAgICAgICA6IGZuKGEsIGIpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkyLmpzIiwidmFyIF9pc1BsYWNlaG9sZGVyID0gcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5MShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjEoYSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IF9pc1BsYWNlaG9sZGVyKGEpKSB7XG4gICAgICByZXR1cm4gZjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkxLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL19jdXJyeTEnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdGhyZWUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jdXJyeTMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYzKGEsIGIsIGMpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGYzO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmM1xuICAgICAgICAgICAgIDogX2N1cnJ5MihmdW5jdGlvbihfYiwgX2MpIHsgcmV0dXJuIGZuKGEsIF9iLCBfYyk7IH0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmM1xuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkyKGZ1bmN0aW9uKF9hLCBfYykgeyByZXR1cm4gZm4oX2EsIGIsIF9jKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbihfYiwgX2MpIHsgcmV0dXJuIGZuKGEsIF9iLCBfYyk7IH0pXG4gICAgICAgICAgICAgOiBfY3VycnkxKGZ1bmN0aW9uKF9jKSB7IHJldHVybiBmbihhLCBiLCBfYyk7IH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gZjNcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbihfYSwgX2IpIHsgcmV0dXJuIGZuKF9hLCBfYiwgYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2EsIF9jKSB7IHJldHVybiBmbihfYSwgYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykgeyByZXR1cm4gZm4oYSwgX2IsIF9jKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbihfYSkgeyByZXR1cm4gZm4oX2EsIGIsIGMpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkxKGZ1bmN0aW9uKF9iKSB7IHJldHVybiBmbihhLCBfYiwgYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2MpIHsgcmV0dXJuIGZuKGEsIGIsIF9jKTsgfSlcbiAgICAgICAgICAgICA6IGZuKGEsIGIsIGMpO1xuICAgIH1cbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkzLmpzIiwidmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9faXNBcnJheScpO1xudmFyIF9pc1RyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9faXNUcmFuc2Zvcm1lcicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyB3aXRoIGRpZmZlcmVudCBzdHJhdGVnaWVzIGJhc2VkIG9uIHRoZVxuICogb2JqZWN0IGluIGxpc3QgcG9zaXRpb24gKGxhc3QgYXJndW1lbnQpLiBJZiBpdCBpcyBhbiBhcnJheSwgZXhlY3V0ZXMgW2ZuXS5cbiAqIE90aGVyd2lzZSwgaWYgaXQgaGFzIGEgZnVuY3Rpb24gd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG1ldGhvZCBuYW1lcywgaXQgd2lsbFxuICogZXhlY3V0ZSB0aGF0IGZ1bmN0aW9uIChmdW5jdG9yIGNhc2UpLiBPdGhlcndpc2UsIGlmIGl0IGlzIGEgdHJhbnNmb3JtZXIsXG4gKiB1c2VzIHRyYW5zZHVjZXIgW3hmXSB0byByZXR1cm4gYSBuZXcgdHJhbnNmb3JtZXIgKHRyYW5zZHVjZXIgY2FzZSkuXG4gKiBPdGhlcndpc2UsIGl0IHdpbGwgZGVmYXVsdCB0byBleGVjdXRpbmcgW2ZuXS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gbWV0aG9kTmFtZXMgcHJvcGVydGllcyB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIHRyYW5zZHVjZXIgdG8gaW5pdGlhbGl6ZSBpZiBvYmplY3QgaXMgdHJhbnNmb3JtZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGRlZmF1bHQgcmFtZGEgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyBvbiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9kaXNwYXRjaGFibGUobWV0aG9kTmFtZXMsIHhmLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgdmFyIG9iaiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKCFfaXNBcnJheShvYmopKSB7XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIHdoaWxlIChpZHggPCBtZXRob2ROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbbWV0aG9kTmFtZXNbaWR4XV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZE5hbWVzW2lkeF1dLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWR4ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoX2lzVHJhbnNmb3JtZXIob2JqKSkge1xuICAgICAgICB2YXIgdHJhbnNkdWNlciA9IHhmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJhbnNkdWNlcihvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmQmFzZS5qcyIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2N1cnJ5TiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5TicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIHdpdGggdGhlIHNwZWNpZmllZFxuICogYXJpdHkuIFRoZSBjdXJyaWVkIGZ1bmN0aW9uIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHNcbiAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSkoMikoMylgXG4gKiAgIC0gYGcoMSkoMiwgMylgXG4gKiAgIC0gYGcoMSwgMikoMylgXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKlxuICogU2Vjb25kbHksIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIGBSLl9fYCBtYXkgYmUgdXNlZCB0byBzcGVjaWZ5XG4gKiBcImdhcHNcIiwgYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLFxuICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIGBSLl9fYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzdW1BcmdzID0gKC4uLmFyZ3MpID0+IFIuc3VtKGFyZ3MpO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnlOKDQsIHN1bUFyZ3MpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBjdXJyeU4obGVuZ3RoLCBmbikge1xuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZm4pO1xuICB9XG4gIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2N1cnJ5Ti5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2hhcyhwcm9wLCBvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19oYXMuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfbWFwID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fbWFwJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xudmFyIF94bWFwID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feG1hcCcpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBhbmRcbiAqIGEgW2Z1bmN0b3JdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZnVuY3RvciksXG4gKiBhcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBlYWNoIG9mIHRoZSBmdW5jdG9yJ3MgdmFsdWVzLCBhbmQgcmV0dXJuc1xuICogYSBmdW5jdG9yIG9mIHRoZSBzYW1lIHNoYXBlLlxuICpcbiAqIFJhbWRhIHByb3ZpZGVzIHN1aXRhYmxlIGBtYXBgIGltcGxlbWVudGF0aW9ucyBmb3IgYEFycmF5YCBhbmQgYE9iamVjdGAsXG4gKiBzbyB0aGlzIGZ1bmN0aW9uIG1heSBiZSBhcHBsaWVkIHRvIGBbMSwgMiwgM11gIG9yIGB7eDogMSwgeTogMiwgejogM31gLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBtYXBgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBBbHNvIHRyZWF0cyBmdW5jdGlvbnMgYXMgZnVuY3RvcnMgYW5kIHdpbGwgY29tcG9zZSB0aGVtIHRvZ2V0aGVyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgaW5wdXQgYGxpc3RgLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBiZSBpdGVyYXRlZCBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAqIEBzZWUgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZG91YmxlID0geCA9PiB4ICogMjtcbiAqXG4gKiAgICAgIFIubWFwKGRvdWJsZSwgWzEsIDIsIDNdKTsgLy89PiBbMiwgNCwgNl1cbiAqXG4gKiAgICAgIFIubWFwKGRvdWJsZSwge3g6IDEsIHk6IDIsIHo6IDN9KTsgLy89PiB7eDogMiwgeTogNCwgejogNn1cbiAqIEBzeW1iIFIubWFwKGYsIFthLCBiXSkgPSBbZihhKSwgZihiKV1cbiAqIEBzeW1iIFIubWFwKGYsIHsgeDogYSwgeTogYiB9KSA9IHsgeDogZihhKSwgeTogZihiKSB9XG4gKiBAc3ltYiBSLm1hcChmLCBmdW5jdG9yX28pID0gZnVuY3Rvcl9vLm1hcChmKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbJ21hcCddLCBfeG1hcCwgZnVuY3Rpb24gbWFwKGZuLCBmdW5jdG9yKSB7XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0b3IpKSB7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgcmV0dXJuIGN1cnJ5TihmdW5jdG9yLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGZ1bmN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9KTtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBmbihmdW5jdG9yW2tleV0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30sIGtleXMoZnVuY3RvcikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX21hcChmbiwgZnVuY3Rvcik7XG4gIH1cbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21hcC5qcyIsInZhciBfeHdyYXAgPSByZXF1aXJlKCcuL194d3JhcCcpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9iaW5kJyk7XG52YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pc0FycmF5TGlrZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIGxpc3RbaWR4XSk7XG4gICAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgICB2YXIgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICAgIHdoaWxlICghc3RlcC5kb25lKSB7XG4gICAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIHN0ZXAudmFsdWUpO1xuICAgICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGVwID0gaXRlci5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG4gIH1cblxuICBmdW5jdGlvbiBfbWV0aG9kUmVkdWNlKHhmLCBhY2MsIG9iaikge1xuICAgIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKG9iai5yZWR1Y2UoYmluZCh4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSwgeGYpLCBhY2MpKTtcbiAgfVxuXG4gIHZhciBzeW1JdGVyYXRvciA9ICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7XG4gIHJldHVybiBmdW5jdGlvbiBfcmVkdWNlKGZuLCBhY2MsIGxpc3QpIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbiA9IF94d3JhcChmbik7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShsaXN0KSkge1xuICAgICAgcmV0dXJuIF9hcnJheVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaXN0LnJlZHVjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgfVxuICAgIGlmIChsaXN0W3N5bUl0ZXJhdG9yXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3Rbc3ltSXRlcmF0b3JdKCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxpc3QubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlOiBsaXN0IG11c3QgYmUgYXJyYXkgb3IgaXRlcmFibGUnKTtcbiAgfTtcbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlLmpzIiwiLyoqXG4gKiBQcml2YXRlIGBjb25jYXRgIGZ1bmN0aW9uIHRvIG1lcmdlIHR3byBhcnJheS1saWtlIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBbc2V0MT1bXV0gQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDI9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3LCBtZXJnZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2NvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NvbmNhdChzZXQxLCBzZXQyKSB7XG4gIHNldDEgPSBzZXQxIHx8IFtdO1xuICBzZXQyID0gc2V0MiB8fCBbXTtcbiAgdmFyIGlkeDtcbiAgdmFyIGxlbjEgPSBzZXQxLmxlbmd0aDtcbiAgdmFyIGxlbjIgPSBzZXQyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsZW4xKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MVtpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsZW4yKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2NvbmNhdC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2VxdWFscyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2VxdWFscycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgZXF1aXZhbGVudCwgYGZhbHNlYCBvdGhlcndpc2UuIEhhbmRsZXNcbiAqIGN5Y2xpY2FsIGRhdGEgc3RydWN0dXJlcy5cbiAqXG4gKiBEaXNwYXRjaGVzIHN5bW1ldHJpY2FsbHkgdG8gdGhlIGBlcXVhbHNgIG1ldGhvZHMgb2YgYm90aCBhcmd1bWVudHMsIGlmXG4gKiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBhIC0+IGIgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5lcXVhbHMoMSwgMSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmVxdWFscygxLCAnMScpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZXF1YWxzKFsxLCAyLCAzXSwgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gKlxuICogICAgICB2YXIgYSA9IHt9OyBhLnYgPSBhO1xuICogICAgICB2YXIgYiA9IHt9OyBiLnYgPSBiO1xuICogICAgICBSLmVxdWFscyhhLCBiKTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gX2VxdWFscyhhLCBiLCBbXSwgW10pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9lcXVhbHMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9hcml0eShuLCBmbikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYTApIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExKSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgNjogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA3OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA4OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGNhc2UgOTogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSAxMDogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7IHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJpdHkuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcbnZhciBfaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FyZ3VtZW50cycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIG9mXG4gKiB0aGUgc3VwcGxpZWQgb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW2tdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5rZXlzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWydhJywgJ2InLCAnYyddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvLyBjb3ZlciBJRSA8IDkga2V5cyBpc3N1ZXNcbiAgdmFyIGhhc0VudW1CdWcgPSAhKHt0b1N0cmluZzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWydjb25zdHJ1Y3RvcicsICd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuICAvLyBTYWZhcmkgYnVnXG4gIHZhciBoYXNBcmdzRW51bUJ1ZyA9IChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnbGVuZ3RoJyk7XG4gIH0oKSk7XG5cbiAgdmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobGlzdCwgaXRlbSkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgaWYgKGxpc3RbaWR4XSA9PT0gaXRlbSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhaGFzQXJnc0VudW1CdWcgP1xuICAgIF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3Qob2JqKSAhPT0gb2JqID8gW10gOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH0pIDpcbiAgICBfY3VycnkxKGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gICAgICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCwgbklkeDtcbiAgICAgIHZhciBrcyA9IFtdO1xuICAgICAgdmFyIGNoZWNrQXJnc0xlbmd0aCA9IGhhc0FyZ3NFbnVtQnVnICYmIF9pc0FyZ3VtZW50cyhvYmopO1xuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoX2hhcyhwcm9wLCBvYmopICYmICghY2hlY2tBcmdzTGVuZ3RoIHx8IHByb3AgIT09ICdsZW5ndGgnKSkge1xuICAgICAgICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzRW51bUJ1Zykge1xuICAgICAgICBuSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChuSWR4ID49IDApIHtcbiAgICAgICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25JZHhdO1xuICAgICAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5JZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtzO1xuICAgIH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2tleXMuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmdcbiAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAqIHZhbHVlIGZyb20gdGhlIGFycmF5LCBhbmQgdGhlbiBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IG1heSB1c2VcbiAqIGBSLnJlZHVjZWRgIHRvIHNob3J0Y3V0IHRoZSBpdGVyYXRpb24uXG4gKlxuICogVGhlIGFyZ3VtZW50cycgb3JkZXIgb2YgYHJlZHVjZVJpZ2h0YCdzIGl0ZXJhdG9yIGZ1bmN0aW9uIGlzICoodmFsdWUsIGFjYykqLlxuICpcbiAqIE5vdGU6IGBSLnJlZHVjZWAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzXG4gKiBvbiB0aGlzIGJlaGF2aW9yLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UjRGVzY3JpcHRpb25cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgcmVkdWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZWQsIFIuYWRkSW5kZXgsIFIucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlZHVjZShSLnN1YnRyYWN0LCAwLCBbMSwgMiwgMywgNF0pIC8vID0+ICgoKCgwIC0gMSkgLSAyKSAtIDMpIC0gNCkgPSAtMTBcbiAqICAgICAgICAgICAgICAgIC0gICAgICAgICAgICAgICAtMTBcbiAqICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgICAgIC0gICA0ICAgICAgICAgICAtNiAgIDRcbiAqICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAgICAgLSAgIDMgICA9PT4gICAgIC0zICAgM1xuICogICAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAgIC0gICAyICAgICAgICAgICAtMSAgIDJcbiAqICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgIDAgICAxICAgICAgICAgICAgMCAgIDFcbiAqXG4gKiBAc3ltYiBSLnJlZHVjZShmLCBhLCBbYiwgYywgZF0pID0gZihmKGYoYSwgYiksIGMpLCBkKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoX3JlZHVjZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9yZWR1Y2UuanMiLCIvKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWxgIGlzIGFuIGFycmF5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBfaXNBcnJheShbXSk7IC8vPT4gdHJ1ZVxuICogICAgICBfaXNBcnJheShudWxsKTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheSh7fSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIF9pc0FycmF5KHZhbCkge1xuICByZXR1cm4gKHZhbCAhPSBudWxsICYmXG4gICAgICAgICAgdmFsLmxlbmd0aCA+PSAwICYmXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19pc0FycmF5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfcmVkdWNlZCh4KSB7XG4gIHJldHVybiB4ICYmIHhbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10gPyB4IDpcbiAgICB7XG4gICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19yZWR1Y2VkLmpzIiwidmFyIF9pbmRleE9mID0gcmVxdWlyZSgnLi9faW5kZXhPZicpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NvbnRhaW5zKGEsIGxpc3QpIHtcbiAgcmV0dXJuIF9pbmRleE9mKGxpc3QsIGEsIDApID49IDA7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2NvbnRhaW5zLmpzIiwidmFyIF9jaGVja0Zvck1ldGhvZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJyk7XG52YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAqIG1ldGhvZCkgZnJvbSBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgc3RhcnQgaW5kZXggKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2xpY2UoMSwgMywgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAgLy89PiBbJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAqICAgICAgUi5zbGljZSgwLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKF9jaGVja0Zvck1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShmcm9tSW5kZXgsIHRvSW5kZXgsIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGZyb21JbmRleCwgdG9JbmRleCk7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9zbGljZS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUuIE5vdGUgdGhhdCBmb3JcbiAqIG5vbi1wcmltaXRpdmVzIHRoZSB2YWx1ZSByZXR1cm5lZCBpcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBrbm93biBhcyBgY29uc3RgLCBgY29uc3RhbnRgLCBvciBgS2AgKGZvciBLIGNvbWJpbmF0b3IpIGluXG4gKiBvdGhlciBsYW5ndWFnZXMgYW5kIGxpYnJhcmllcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBhIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBGdW5jdGlvbiA6OiAqIC0+IHZhbC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdCA9IFIuYWx3YXlzKCdUZWUnKTtcbiAqICAgICAgdCgpOyAvLz0+ICdUZWUnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBhbHdheXModmFsKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9hbHdheXMuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFyZ2VyIG9mIGl0cyB0d28gYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5tYXhCeSwgUi5taW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1heCg3ODksIDEyMyk7IC8vPT4gNzg5XG4gKiAgICAgIFIubWF4KCdhJywgJ2InKTsgLy89PiAnYidcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG1heChhLCBiKSB7IHJldHVybiBiID4gYSA/IGIgOiBhOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21heC5qcyIsImltcG9ydCBfIGZyb20gJ3JhbWRhJztcblxuLyoqXG4gKiBHZXRzIFpvbmVzXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYXBUYW4gLSBUaGUgbmFwdGFuIG9mIHRoZSBzdGF0aW9uIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RhdGlvbnMgd2l0aCBuYXBUYW5zIGFzIGtleXMuXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKiBAZGVzY3JpcHRpb24gVXNlcyB0aGUgbmFwVGFuIElEIHRvIGZpZ3VyZSBvdXQgd2hhdCB6b25lIHRoYXQgc3RhdGlvbiBpcyBpbiB2aWEgc3RhdGlvbi5qc29uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRab25lcyhuYXBUYW4sIHN0YXRpb25zKSB7XG4gIHJldHVybiBzdGF0aW9uc1tuYXBUYW5dLnpvbmVzO1xufVxuXG4vKipcbiAqIGZpbHRlcnMgYSBuZXN0ZWQgYXJyYXkgYmFzZWQgb24gaXRzIGxlbmd0aCBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG51bSAtIGVpdGhlciAxIChmb3Igc2luZ2xlIHpvbmUpIG9yIDIgKGR1YWwgem9uZSlcbiAqIEBwYXJhbSB7bmVzdGVkIGFycmF5fSB6b25lcyAtIHRoZSBuZXN0ZWQgYXJyYXkgb2YgYXJyYXlzIChvZiB6b25lcylcbiAqIEByZXR1cm5zIHtuZXN0ZWQgYXJyYXl9IC0gbmVzdGVkIGFycmF5IG9mIGFsbCBhcnJheSBvZiB6b25lcyBmcm9tIHN0YXRpb25zIHRoYXQgb25seSBoYXZlIG9uZSB6b25lIGFzc29jaWF0ZWQgd2l0aCBpdCAoaWYgbnVtID0gMSkgb3IuLi5cbiAqIEBkZXNjcmlwdGlvbiAtIHpvbmVzIHJlZmVycyB0byBnbG9iYWwgYWxsWm9uZXMgLyB1c2VkIHRvIGZpbHRlciB0aGUgc3RhdGlvbiB6b25lcyBieSB0aGUgbnVtYmVyIG9mIHpvbmVzIGl0IGhhcyAoZHVhbCB6b25lIG9yIHNpbmdsZSB6b25lKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyWm9uZXNCeU51bWJlcihudW0sIHpvbmVzKSB7XG4gIHJldHVybiB6b25lcy5maWx0ZXIoZnVuY3Rpb24oem9uZSkge1xuICAgIHJldHVybiB6b25lLmxlbmd0aCA9PT0gbnVtO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyBOdW1iZXJzXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7YXJyYXl9IG51bWJlcnMgLSB0aGUgYXJyYXkgb2YgbnVtYmVyKHMpXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3IgLSB3aGF0IGphdmFzY3JpcHQgb3BlcmF0b3IgcGFzc2luZyB0aHJvdWdoIChlLmcuIE1hdGgubWF4KVxuICogQHJldHVybnMge251bWJlcn0gLSB0aGUgc2luZ2xlIG51bWJlciBhZnRlciBhbGwgY2FsY3VsYXRpb25zIChyZWR1Y2VzIHRvIG9uZSBudW1iZXIpXG4gKiBAZGVzY3JpcHRpb24gQXNzb2NpYXRlZCB3aXRoIG1pbk51bSBhbmQgbWF4TnVtOiB3aGVyZSBhcnJheVpvbmVzIHJlZmVycyB0byB6b25lc0Zyb21TaW5nbGVTdGF0aW9ucy5cbiBMb29wcyB0aHJvdWdoIHRoZSBhcnJheSBvZiB6b25lcyBhbmQgYXBwbGllcyB0aGUgb3BlcmF0b3JcbiAqL1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYXJyYXlOdW1iZXJzLCBvcGVyYXRvcikge1xuICByZXR1cm4gYXJyYXlOdW1iZXJzLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKGEsIGIpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heE51bShhcnJheVpvbmVzKSB7XG4gIHJldHVybiBjb21wYXJlTnVtYmVycyhhcnJheVpvbmVzLCBNYXRoLm1heCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5OdW0oYXJyYXlab25lcykge1xuICByZXR1cm4gY29tcGFyZU51bWJlcnMoYXJyYXlab25lcywgTWF0aC5taW4pO1xufVxuXG4vKipcbiAqIEdldCBkaWZmZXJlbmNlIGJldHdlZW4gMiBudW1iZXJzXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyc30gYSxiIC0gdGhlIHR3byBudW1iZXJzIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIDIgbnVtYmVycyAoZGlzY2FyZGluZyBuZWdhdGl2ZSBudW1iZXJzKVxuICogQGRlc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaWZmZXJlbmNlKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKTtcbiAgLy8gcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IHRoYXQgaXMgYW4gYXJyYXkgd2l0aGluIGFub3RoZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gZmxhdHRlbnMgdGhlIGFycmF5IHNvIGp1c3Qgb25lIGFycmF5XG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNvcnQgYW4gYXJyYXkgb2YgMiB6b25lcyBjaHJvbm9sb2dpY2FsbHkgYW5kIGFkZHMgJy0nXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7YXJyYXl9IGpvdXJuZXkgLSB0aGUgYXJyYXkgb2YgdGhlIDIgem9uZXMgb2YgdGhhdCBqb3VybmV5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtICd4LXknXG4gKiBAZGVzY3JpcHRpb24gLSB1c2VkIHRvIGdldCB0aGUgZmFyZXMgZnJvbSB0aGUganNvbiBmaWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb3VybmV5VG9LZXkoam91cm5leSkge1xuICByZXR1cm4gam91cm5leS5zb3J0KCkuam9pbignLScpO1xufVxuXG4vKipcbiAqIFByZWxvYWRzIHN0YXJ0IHpvbmUgYXMgMSBhbmQgY2hhbmdlcyB0byAxLXggZm9yIEpTT04gZmlsZSByZWFkaW5nXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSAtIHpvbmUgeFxuICogQHJldHVybnMge3N0cmluZ30gLSAnMS14J1xuICogQGRlc2NyaXB0aW9uIC0gdXNlZCB0byBnZXQgdGhlIGZhcmVzIGZyb20gdGhlIGpzb24gZmlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gem9uZVRvSm91cm5leSh6b25lKSB7XG4gIC8vIGRlYnVnZ2VyO1xuICByZXR1cm4gam91cm5leVRvS2V5KFsxLCB6b25lXSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGFpbHkgY2FwIGNvc3RcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IC0gdGhlIChtYXhpbXVtKSB6b25lXG4gKiBAcGFyYW0ge29iamVjdH0gZGFpbHlDYXBzIC0gbG9va3MgYXQgdGhlIGRhaWx5Q2FwcyBvYmplY3QgaW4gdGhlIGZhcmVzLmpzb24gZmlsZVxuICogQHJldHVybnMge251bWJlcn0gLSBnZXRzIHRoZSBkYWlseSBjYXAgYmV0d2VlbiB6b25lcyAxIGFuZCB0aGUgem9uZSBwYXJhbWV0ZXIgKGFzIGRhaWx5IGNhcHMgYWx3YXlzIHN0YXJ0cyBhdCB6b25lIDEpXG4gKiBAZGVzY3JpcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhaWx5Q2FwKG1heFpvbmVzb2ZhciwgZGFpbHlDYXBzLCB0eXBlKSB7XG4gIHJldHVybiBkYWlseUNhcHNbam91cm5leVRvS2V5KFsxLCBtYXhab25lc29mYXJdKV1bdHlwZV07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDYXAgPSBfLmN1cnJ5KChrZXksIHR5cGUsIGNhcHMpID0+IGNhcHNbdHlwZW9mIGtleSA9PSBcImFycmF5XCIgPyBqb3VybmV5VG9LZXkoa2V5KSA6IHpvbmVUb0pvdXJuZXkoa2V5KV1bdHlwZV0pO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpbmdsZSBmYXJlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7YXJyYXl9IGpvdXJuZXkgLSB0aGUgYXJyYXkgb2YgdGhlIDIgem9uZXMgdHJhdmVsbGluZyBiZXR3ZWVuXG4gKiBAcGFyYW0ge29iamVjdH0gc2luZ2xlRmFyZXMgLSBsb29rcyBhdCB0aGUgc2luZ2xlRmFyZXMgb2JqZWN0IGluIHRoZSBmYXJlcy5qc29uIGZpbGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gZ2V0cyB0aGUgc2luZ2xlIGZhcmUgYmV0d2VlbiB0aG9zZSB0d28gem9uZXNcbiAqIEBkZXNjcmlwdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xlRmFyZShqb3VybmV5LCBzaW5nbGVGYXJlcywgdHlwZSkge1xuICAvLyBkZWJ1Z2dlcjtcbiAgcmV0dXJuIHNpbmdsZUZhcmVzW2pvdXJuZXlUb0tleShqb3VybmV5KV1bdHlwZV07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIG51bWVyaWMgdGFyZ2V0IGhhcyBiZWVuIG1ldCBvciBzdXJwYXNzZWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldCAtIHRhcmdldCB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3QgdGhlIHRhcmdldFxuICogQGRlc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtZXQgPSBfLmN1cnJ5KCh0YXJnZXQsIHZhbHVlKSA9PiB2YWx1ZSA+PSB0YXJnZXQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3V0aWxpdHkvX3V0aWxpdHkuanMiLCJ2YXIgX2lzQXJyYXkgPSByZXF1aXJlKCcuL19pc0FycmF5Jyk7XG5cblxuLyoqXG4gKiBUaGlzIGNoZWNrcyB3aGV0aGVyIGEgZnVuY3Rpb24gaGFzIGEgW21ldGhvZG5hbWVdIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhblxuICogYXJyYXkgaXQgd2lsbCBleGVjdXRlIHRoYXQgZnVuY3Rpb24gb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgcmFtZGFcbiAqIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBXaGF0ZXZlciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBtZXRob2QgaXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tsZW5ndGggLSAxXTtcbiAgICByZXR1cm4gKF9pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9ialttZXRob2RuYW1lXSAhPT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6XG4gICAgICBvYmpbbWV0aG9kbmFtZV0uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNGdW5jdGlvbicpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBUdXJucyBhIG5hbWVkIG1ldGhvZCB3aXRoIGEgc3BlY2lmaWVkIGFyaXR5IGludG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICogY2FsbGVkIGRpcmVjdGx5IHN1cHBsaWVkIHdpdGggYXJndW1lbnRzIGFuZCBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIGN1cnJpZWQgYW5kIGFjY2VwdHMgYGFyaXR5ICsgMWAgcGFyYW1ldGVycyB3aGVyZVxuICogdGhlIGZpbmFsIHBhcmFtZXRlciBpcyB0aGUgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IChhIC0+IGIgLT4gLi4uIC0+IG4gLT4gT2JqZWN0IC0+ICopXG4gKiBAcGFyYW0ge051bWJlcn0gYXJpdHkgTnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gc2hvdWxkIHRha2VcbiAqICAgICAgICBiZWZvcmUgdGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgdGhlIG1ldGhvZCB0byBjYWxsLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHNsaWNlRnJvbSA9IFIuaW52b2tlcigxLCAnc2xpY2UnKTtcbiAqICAgICAgc2xpY2VGcm9tKDYsICdhYmNkZWZnaGlqa2xtJyk7IC8vPT4gJ2doaWprbG0nXG4gKiAgICAgIHZhciBzbGljZUZyb202ID0gUi5pbnZva2VyKDIsICdzbGljZScpKDYpO1xuICogICAgICBzbGljZUZyb202KDgsICdhYmNkZWZnaGlqa2xtJyk7IC8vPT4gJ2doJ1xuICogQHN5bWIgUi5pbnZva2VyKDAsICdtZXRob2QnKShvKSA9IG9bJ21ldGhvZCddKClcbiAqIEBzeW1iIFIuaW52b2tlcigxLCAnbWV0aG9kJykoYSwgbykgPSBvWydtZXRob2QnXShhKVxuICogQHN5bWIgUi5pbnZva2VyKDIsICdtZXRob2QnKShhLCBiLCBvKSA9IG9bJ21ldGhvZCddKGEsIGIpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBpbnZva2VyKGFyaXR5LCBtZXRob2QpIHtcbiAgcmV0dXJuIGN1cnJ5Tihhcml0eSArIDEsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbYXJpdHldO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiBfaXNGdW5jdGlvbih0YXJnZXRbbWV0aG9kXSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbbWV0aG9kXS5hcHBseSh0YXJnZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgYXJpdHkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyh0YXJnZXQpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiJyArIG1ldGhvZCArICdcIicpO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW52b2tlci5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FycmF5Jyk7XG52YXIgX2lzU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNTdHJpbmcnKTtcblxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBzaW1pbGFyIHRvIGFuIGFycmF5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgeGAgaGFzIGEgbnVtZXJpYyBsZW5ndGggcHJvcGVydHkgYW5kIGV4dHJlbWUgaW5kaWNlcyBkZWZpbmVkOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjIzLjBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmlzQXJyYXlMaWtlKFtdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNBcnJheUxpa2UodHJ1ZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0FycmF5TGlrZSh7fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0FycmF5TGlrZSh7bGVuZ3RoOiAxMH0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNBcnJheUxpa2UoezA6ICd6ZXJvJywgOTogJ25pbmUnLCBsZW5ndGg6IDEwfSk7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICBpZiAoX2lzQXJyYXkoeCkpIHsgcmV0dXJuIHRydWU7IH1cbiAgaWYgKCF4KSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAodHlwZW9mIHggIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoX2lzU3RyaW5nKHgpKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoeC5ub2RlVHlwZSA9PT0gMSkgeyByZXR1cm4gISF4Lmxlbmd0aDsgfVxuICBpZiAoeC5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRydWU7IH1cbiAgaWYgKHgubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB4Lmhhc093blByb3BlcnR5KDApICYmIHguaGFzT3duUHJvcGVydHkoeC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2lzQXJyYXlMaWtlLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaXNTdHJpbmcgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc1N0cmluZycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLiBJZiBuIGlzIG5lZ2F0aXZlIHRoZVxuICogZWxlbWVudCBhdCBpbmRleCBsZW5ndGggKyBuIGlzIHJldHVybmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGxpc3QgPSBbJ2ZvbycsICdiYXInLCAnYmF6JywgJ3F1dXgnXTtcbiAqICAgICAgUi5udGgoMSwgbGlzdCk7IC8vPT4gJ2JhcidcbiAqICAgICAgUi5udGgoLTEsIGxpc3QpOyAvLz0+ICdxdXV4J1xuICogICAgICBSLm50aCgtOTksIGxpc3QpOyAvLz0+IHVuZGVmaW5lZFxuICpcbiAqICAgICAgUi5udGgoMiwgJ2FiYycpOyAvLz0+ICdjJ1xuICogICAgICBSLm50aCgzLCAnYWJjJyk7IC8vPT4gJydcbiAqIEBzeW1iIFIubnRoKC0xLCBbYSwgYiwgY10pID0gY1xuICogQHN5bWIgUi5udGgoMCwgW2EsIGIsIGNdKSA9IGFcbiAqIEBzeW1iIFIubnRoKDEsIFthLCBiLCBjXSkgPSBiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBudGgob2Zmc2V0LCBsaXN0KSB7XG4gIHZhciBpZHggPSBvZmZzZXQgPCAwID8gbGlzdC5sZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQ7XG4gIHJldHVybiBfaXNTdHJpbmcobGlzdCkgPyBsaXN0LmNoYXJBdChpZHgpIDogbGlzdFtpZHhdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9udGguanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgW0lkeF0gLT4ge2F9IC0+IGEgfCBVbmRlZmluZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYC5cbiAqIEBzZWUgUi5wcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYiddLCB7Yzoge2I6IDJ9fSk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwYXRoKHBhdGhzLCBvYmopIHtcbiAgdmFyIHZhbCA9IG9iajtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBwYXRocy5sZW5ndGgpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFsID0gdmFsW3BhdGhzW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiB2YWw7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3BhdGguanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgcHJvcCA9IHJlcXVpcmUoJy4vcHJvcCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGJ5IHBsdWNraW5nIHRoZSBzYW1lIG5hbWVkIHByb3BlcnR5IG9mZiBhbGwgb2JqZWN0cyBpblxuICogdGhlIGxpc3Qgc3VwcGxpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBrIC0+IFt7azogdn1dIC0+IFt2XVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgVGhlIGtleSBuYW1lIHRvIHBsdWNrIG9mZiBvZiBlYWNoIG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleS5cbiAqIEBzZWUgUi5wcm9wc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGx1Y2soJ2EnKShbe2E6IDF9LCB7YTogMn1dKTsgLy89PiBbMSwgMl1cbiAqICAgICAgUi5wbHVjaygwKShbWzEsIDJdLCBbMywgNF1dKTsgICAvLz0+IFsxLCAzXVxuICogQHN5bWIgUi5wbHVjaygneCcsIFt7eDogMSwgeTogMn0sIHt4OiAzLCB5OiA0fSwge3g6IDUsIHk6IDZ9XSkgPSBbMSwgMywgNV1cbiAqIEBzeW1iIFIucGx1Y2soMCwgW1sxLCAyXSwgWzMsIDRdLCBbNSwgNl1dKSA9IFsxLCAzLCA1XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcGx1Y2socCwgbGlzdCkge1xuICByZXR1cm4gbWFwKHByb3AocCksIGxpc3QpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wbHVjay5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX3RvU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fdG9TdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuIGBldmFsYCdpbmcgdGhlIG91dHB1dFxuICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICogYHRvU3RyaW5nYCBtZXRob2RzIGRvIG5vdCBzYXRpc2Z5IHRoaXMgcmVxdWlyZW1lbnQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICogdGhhbiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AsIHRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2l0aCBubyBhcmd1bWVudHNcbiAqIHRvIHByb2R1Y2UgdGhlIHJldHVybiB2YWx1ZS4gVGhpcyBtZWFucyB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICogICAgICAgdGhpcy54ID0geDtcbiAqICAgICAgIHRoaXMueSA9IHk7XG4gKiAgICAgfVxuICpcbiAqICAgICBQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAnbmV3IFBvaW50KCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xuICogICAgIH07XG4gKlxuICogICAgIFIudG9TdHJpbmcobmV3IFBvaW50KDEsIDIpKTsgLy89PiAnbmV3IFBvaW50KDEsIDIpJ1xuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgKiAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1N0cmluZyg0Mik7IC8vPT4gJzQyJ1xuICogICAgICBSLnRvU3RyaW5nKCdhYmMnKTsgLy89PiAnXCJhYmNcIidcbiAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gKiAgICAgIFIudG9TdHJpbmcoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9KTsgLy89PiAne1wiYmFyXCI6IDIsIFwiYmF6XCI6IDMsIFwiZm9vXCI6IDF9J1xuICogICAgICBSLnRvU3RyaW5nKG5ldyBEYXRlKCcyMDAxLTAyLTAzVDA0OjA1OjA2WicpKTsgLy89PiAnbmV3IERhdGUoXCIyMDAxLTAyLTAzVDA0OjA1OjA2LjAwMFpcIiknXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0b1N0cmluZyh2YWwpIHsgcmV0dXJuIF90b1N0cmluZyh2YWwsIFtdKTsgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90b1N0cmluZy5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBBZGRzIHR3byB2YWx1ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIuc3VidHJhY3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFkZCgyLCAzKTsgICAgICAgLy89PiAgNVxuICogICAgICBSLmFkZCg3KSgxMCk7ICAgICAgLy89PiAxN1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSArIE51bWJlcihiKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYWRkLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIE1ha2VzIGEgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QsIHNldHRpbmcgb3Igb3ZlcnJpZGluZyB0aGUgc3BlY2lmaWVkXG4gKiBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gTm90ZSB0aGF0IHRoaXMgY29waWVzIGFuZCBmbGF0dGVucyBwcm90b3R5cGVcbiAqIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZVxuICogY29waWVkIGJ5IHJlZmVyZW5jZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgU3RyaW5nIC0+IGEgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgbmV3IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGV4Y2VwdCBmb3IgdGhlIGNoYW5nZWQgcHJvcGVydHkuXG4gKiBAc2VlIFIuZGlzc29jXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hc3NvYygnYycsIDMsIHthOiAxLCBiOiAyfSk7IC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBhc3NvYyhwcm9wLCB2YWwsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgcmVzdWx0W3BdID0gb2JqW3BdO1xuICB9XG4gIHJlc3VsdFtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYXNzb2MuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgY3VycmllZCBlcXVpdmFsZW50IG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gVGhlIGN1cnJpZWQgZnVuY3Rpb25cbiAqIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHMgYXJndW1lbnRzIG5lZWRuJ3QgYmUgcHJvdmlkZWQgb25lXG4gKiBhdCBhIHRpbWUuIElmIGBmYCBpcyBhIHRlcm5hcnkgZnVuY3Rpb24gYW5kIGBnYCBpcyBgUi5jdXJyeShmKWAsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxKSgyKSgzKWBcbiAqICAgLSBgZygxKSgyLCAzKWBcbiAqICAgLSBgZygxLCAyKSgzKWBcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqXG4gKiBTZWNvbmRseSwgdGhlIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUgYFIuX19gIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgYFIuX19gLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCogLT4gYSkgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeU5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWRkRm91ck51bWJlcnMgPSAoYSwgYiwgYywgZCkgPT4gYSArIGIgKyBjICsgZDtcbiAqXG4gKiAgICAgIHZhciBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5KGFkZEZvdXJOdW1iZXJzKTtcbiAqICAgICAgdmFyIGYgPSBjdXJyaWVkQWRkRm91ck51bWJlcnMoMSwgMik7XG4gKiAgICAgIHZhciBnID0gZigzKTtcbiAqICAgICAgZyg0KTsgLy89PiAxMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZuKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY3VycnkuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGN1cnJ5ID0gcmVxdWlyZSgnLi9jdXJyeScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBtdWNoIGxpa2UgdGhlIHN1cHBsaWVkIG9uZSwgZXhjZXB0IHRoYXQgdGhlIGZpcnN0IHR3b1xuICogYXJndW1lbnRzJyBvcmRlciBpcyByZXZlcnNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoYSAtPiBiIC0+IGMgLT4gLi4uIC0+IHopIC0+IChiIC0+IGEgLT4gYyAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMgcmV2ZXJzZWQuXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0IG9mIGludm9raW5nIGBmbmAgd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMnIG9yZGVyIHJldmVyc2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtZXJnZVRocmVlID0gKGEsIGIsIGMpID0+IFtdLmNvbmNhdChhLCBiLCBjKTtcbiAqXG4gKiAgICAgIG1lcmdlVGhyZWUoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gKlxuICogICAgICBSLmZsaXAobWVyZ2VUaHJlZSkoMSwgMiwgMyk7IC8vPT4gWzIsIDEsIDNdXG4gKiBAc3ltYiBSLmZsaXAoZikoYSwgYiwgYykgPSBmKGIsIGEsIGMpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBmbGlwKGZuKSB7XG4gIHJldHVybiBjdXJyeShmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGFyZ3NbMF0gPSBiO1xuICAgIGFyZ3NbMV0gPSBhO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ZsaXAuanMiLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9fYXJpdHknKTtcbnZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIEludGVybmFsIGN1cnJ5TiBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBvZiB0aGUgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnlOKGxlbmd0aCwgcmVjZWl2ZWQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29tYmluZWQgPSBbXTtcbiAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgdmFyIGxlZnQgPSBsZW5ndGg7XG4gICAgdmFyIGNvbWJpbmVkSWR4ID0gMDtcbiAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggJiZcbiAgICAgICAgICAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHxcbiAgICAgICAgICAgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlZFtjb21iaW5lZElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbYXJnc0lkeF07XG4gICAgICAgIGFyZ3NJZHggKz0gMTtcbiAgICAgIH1cbiAgICAgIGNvbWJpbmVkW2NvbWJpbmVkSWR4XSA9IHJlc3VsdDtcbiAgICAgIGlmICghX2lzUGxhY2Vob2xkZXIocmVzdWx0KSkge1xuICAgICAgICBsZWZ0IC09IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZElkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdCA8PSAwID8gZm4uYXBwbHkodGhpcywgY29tYmluZWQpXG4gICAgICAgICAgICAgICAgICAgICA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Ti5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19pc0Z1bmN0aW9uLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNQbGFjZWhvbGRlcihhKSB7XG4gIHJldHVybiBhICE9IG51bGwgJiZcbiAgICAgICAgIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgYVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzUGxhY2Vob2xkZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19pc1N0cmluZy5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX21hcChmbiwgZnVuY3Rvcikge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGZ1bmN0b3IubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19tYXAuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyBmb3IgdGhlIGdpdmVuIGdldHRlciBhbmQgc2V0dGVyIGZ1bmN0aW9ucy4gVGhlIGdldHRlciBcImdldHNcIlxuICogdGhlIHZhbHVlIG9mIHRoZSBmb2N1czsgdGhlIHNldHRlciBcInNldHNcIiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzLiBUaGUgc2V0dGVyXG4gKiBzaG91bGQgbm90IG11dGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyAocyAtPiBhKSAtPiAoKGEsIHMpIC0+IHMpIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4TGVucyA9IFIubGVucyhSLnByb3AoJ3gnKSwgUi5hc3NvYygneCcpKTtcbiAqXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIub3Zlcih4TGVucywgUi5uZWdhdGUsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiAtMSwgeTogMn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGxlbnMoZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRvRnVuY3RvckZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgcmV0dXJuIG1hcChcbiAgICAgICAgZnVuY3Rpb24oZm9jdXMpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKGZvY3VzLCB0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICB0b0Z1bmN0b3JGbihnZXR0ZXIodGFyZ2V0KSlcbiAgICAgICk7XG4gICAgfTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbGVucy5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgbGlmdE4gPSByZXF1aXJlKCcuL2xpZnROJyk7XG5cblxuLyoqXG4gKiBcImxpZnRzXCIgYSBmdW5jdGlvbiBvZiBhcml0eSA+IDEgc28gdGhhdCBpdCBtYXkgXCJtYXAgb3ZlclwiIGEgbGlzdCwgRnVuY3Rpb24gb3Igb3RoZXJcbiAqIG9iamVjdCB0aGF0IHNhdGlzZmllcyB0aGUgW0ZhbnRhc3lMYW5kIEFwcGx5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHkpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+ICopIC0+IChbKl0uLi4gLT4gWypdKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGxpZnQgaW50byBoaWdoZXIgY29udGV4dFxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBsaWZ0ZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIubGlmdE5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbWFkZDMgPSBSLmxpZnQoKGEsIGIsIGMpID0+IGEgKyBiICsgYyk7XG4gKlxuICogICAgICBtYWRkMyhbMSwyLDNdLCBbMSwyLDNdLCBbMV0pOyAvLz0+IFszLCA0LCA1LCA0LCA1LCA2LCA1LCA2LCA3XVxuICpcbiAqICAgICAgdmFyIG1hZGQ1ID0gUi5saWZ0KChhLCBiLCBjLCBkLCBlKSA9PiBhICsgYiArIGMgKyBkICsgZSk7XG4gKlxuICogICAgICBtYWRkNShbMSwyXSwgWzNdLCBbNCwgNV0sIFs2XSwgWzcsIDhdKTsgLy89PiBbMjEsIDIyLCAyMiwgMjMsIDIyLCAyMywgMjMsIDI0XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbGlmdChmbikge1xuICByZXR1cm4gbGlmdE4oZm4ubGVuZ3RoLCBmbik7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2xpZnQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSBgbmAgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBkZXNpcmVkIGFyaXR5IG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgYG5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSAoYSwgYikgPT4gW2EsIGJdO1xuICpcbiAqICAgICAgdGFrZXNUd29BcmdzLmxlbmd0aDsgLy89PiAyXG4gKiAgICAgIHRha2VzVHdvQXJncygxLCAyKTsgLy89PiBbMSwgMl1cbiAqXG4gKiAgICAgIHZhciB0YWtlc09uZUFyZyA9IFIubkFyeSgxLCB0YWtlc1R3b0FyZ3MpO1xuICogICAgICB0YWtlc09uZUFyZy5sZW5ndGg7IC8vPT4gMVxuICogICAgICAvLyBPbmx5IGBuYCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogICAgICB0YWtlc09uZUFyZygxLCAyKTsgLy89PiBbMSwgdW5kZWZpbmVkXVxuICogQHN5bWIgUi5uQXJ5KDAsIGYpKGEsIGIpID0gZigpXG4gKiBAc3ltYiBSLm5BcnkoMSwgZikoYSwgYikgPSBmKGEpXG4gKiBAc3ltYiBSLm5BcnkoMiwgZikoYSwgYikgPSBmKGEsIGIpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBuQXJ5KG4sIGZuKSB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBmbi5jYWxsKHRoaXMpO307XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYTApIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCk7fTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhMCwgYTEpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEpO307XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMikge3JldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIpO307XG4gICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMyk7fTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQpO307XG4gICAgY2FzZSA2OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge3JldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpO307XG4gICAgY2FzZSA3OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNik7fTtcbiAgICBjYXNlIDg6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtyZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO307XG4gICAgY2FzZSA5OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge3JldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpO307XG4gICAgY2FzZSAxMDogcmV0dXJuIGZ1bmN0aW9uKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7cmV0dXJuIGZuLmNhbGwodGhpcywgYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpO307XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBuQXJ5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbkFyeS5qcyIsInZhciBfY3VycnlOID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnlOJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgX3hyZWR1Y2VCeSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hyZWR1Y2VCeScpO1xuXG5cbi8qKlxuICogR3JvdXBzIHRoZSBlbGVtZW50cyBvZiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nXG4gKiB0aGUgU3RyaW5nLXJldHVybmluZyBmdW5jdGlvbiBga2V5Rm5gIG9uIGVhY2ggZWxlbWVudCBhbmQgcmVkdWNlcyB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggZ3JvdXAgdG8gYSBzaW5nbGUgdmFsdWUgdmlhIHRoZSByZWR1Y2VyIGZ1bmN0aW9uIGB2YWx1ZUZuYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2ljYWxseSBhIG1vcmUgZ2VuZXJhbCBgZ3JvdXBCeWAgZnVuY3Rpb24uXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiAoYiAtPiBTdHJpbmcpIC0+IFtiXSAtPiB7U3RyaW5nOiBhfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsdWVGbiBUaGUgZnVuY3Rpb24gdGhhdCByZWR1Y2VzIHRoZSBlbGVtZW50cyBvZiBlYWNoIGdyb3VwIHRvIGEgc2luZ2xlXG4gKiAgICAgICAgdmFsdWUuIFJlY2VpdmVzIHR3byB2YWx1ZXMsIGFjY3VtdWxhdG9yIGZvciBhIHBhcnRpY3VsYXIgZ3JvdXAgYW5kIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgKGluaXRpYWwpIGFjY3VtdWxhdG9yIHZhbHVlIGZvciBlYWNoIGdyb3VwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5Rm4gVGhlIGZ1bmN0aW9uIHRoYXQgbWFwcyB0aGUgbGlzdCdzIGVsZW1lbnQgaW50byBhIGtleS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBrZXlGbmAgZm9yIGtleXMsIG1hcHBlZCB0byB0aGUgb3V0cHV0IG9mXG4gKiAgICAgICAgIGB2YWx1ZUZuYCBmb3IgZWxlbWVudHMgd2hpY2ggcHJvZHVjZWQgdGhhdCBrZXkgd2hlbiBwYXNzZWQgdG8gYGtleUZuYC5cbiAqIEBzZWUgUi5ncm91cEJ5LCBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciByZWR1Y2VUb05hbWVzQnkgPSBSLnJlZHVjZUJ5KChhY2MsIHN0dWRlbnQpID0+IGFjYy5jb25jYXQoc3R1ZGVudC5uYW1lKSwgW10pO1xuICogICAgICB2YXIgbmFtZXNCeUdyYWRlID0gcmVkdWNlVG9OYW1lc0J5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICogICAgICB9KTtcbiAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnTHVjeScsIHNjb3JlOiA5Mn0sXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0RyZXcnLCBzY29yZTogODV9LFxuICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0JhcnQnLCBzY29yZTogNjJ9XTtcbiAqICAgICAgbmFtZXNCeUdyYWRlKHN0dWRlbnRzKTtcbiAqICAgICAgLy8ge1xuICogICAgICAvLyAgICdBJzogWydMdWN5J10sXG4gKiAgICAgIC8vICAgJ0InOiBbJ0RyZXcnXVxuICogICAgICAvLyAgIC8vIC4uLixcbiAqICAgICAgLy8gICAnRic6IFsnQmFydCddXG4gKiAgICAgIC8vIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnlOKDQsIFtdLCBfZGlzcGF0Y2hhYmxlKFtdLCBfeHJlZHVjZUJ5LFxuICBmdW5jdGlvbiByZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIGxpc3QpIHtcbiAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbihhY2MsIGVsdCkge1xuICAgICAgdmFyIGtleSA9IGtleUZuKGVsdCk7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlRm4oX2hhcyhrZXksIGFjYykgPyBhY2Nba2V5XSA6IHZhbHVlQWNjLCBlbHQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSwgbGlzdCk7XG4gIH0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3JlZHVjZUJ5LmpzIiwidmFyIF9jb21wbGVtZW50ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29tcGxlbWVudCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG5cbi8qKlxuICogVGhlIGNvbXBsZW1lbnQgb2YgYGZpbHRlcmAuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLmZpbHRlciwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSAobikgPT4gbiAlIDIgPT09IDE7XG4gKlxuICogICAgICBSLnJlamVjdChpc09kZCwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAqXG4gKiAgICAgIFIucmVqZWN0KGlzT2RkLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcmVqZWN0KHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIGZpbHRlcihfY29tcGxlbWVudChwcmVkKSwgZmlsdGVyYWJsZSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3JlamVjdC5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2lzU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNTdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBvciBzdHJpbmcgd2l0aCB0aGUgZWxlbWVudHMgb3IgY2hhcmFjdGVycyBpbiByZXZlcnNlXG4gKiBvcmRlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ31cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJldmVyc2UoWzEsIDIsIDNdKTsgIC8vPT4gWzMsIDIsIDFdXG4gKiAgICAgIFIucmV2ZXJzZShbMSwgMl0pOyAgICAgLy89PiBbMiwgMV1cbiAqICAgICAgUi5yZXZlcnNlKFsxXSk7ICAgICAgICAvLz0+IFsxXVxuICogICAgICBSLnJldmVyc2UoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIucmV2ZXJzZSgnYWJjJyk7ICAgICAgLy89PiAnY2JhJ1xuICogICAgICBSLnJldmVyc2UoJ2FiJyk7ICAgICAgIC8vPT4gJ2JhJ1xuICogICAgICBSLnJldmVyc2UoJ2EnKTsgICAgICAgIC8vPT4gJ2EnXG4gKiAgICAgIFIucmV2ZXJzZSgnJyk7ICAgICAgICAgLy89PiAnJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gcmV2ZXJzZShsaXN0KSB7XG4gIHJldHVybiBfaXNTdHJpbmcobGlzdCkgPyBsaXN0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkucmV2ZXJzZSgpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9yZXZlcnNlLmpzIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb25jYXQnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cblxuLyoqXG4gKiBhcCBhcHBsaWVzIGEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYSBsaXN0IG9mIHZhbHVlcy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgYXBgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LiBBbHNvXG4gKiB0cmVhdHMgY3VycmllZCBmdW5jdGlvbnMgYXMgYXBwbGljYXRpdmVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIFthIC0+IGJdIC0+IFthXSAtPiBbYl1cbiAqIEBzaWcgQXBwbHkgZiA9PiBmIChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAqIEBwYXJhbSB7QXJyYXl9IGZucyBBbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IHZzIEFuIGFycmF5IG9mIHZhbHVlc1xuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHJlc3VsdHMgb2YgYXBwbHlpbmcgZWFjaCBvZiBgZm5zYCB0byBhbGwgb2YgYHZzYCBpbiB0dXJuLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXAoW1IubXVsdGlwbHkoMiksIFIuYWRkKDMpXSwgWzEsMiwzXSk7IC8vPT4gWzIsIDQsIDYsIDQsIDUsIDZdXG4gKiAgICAgIFIuYXAoW1IuY29uY2F0KCd0YXN0eSAnKSwgUi50b1VwcGVyXSwgWydwaXp6YScsICdzYWxhZCddKTsgLy89PiBbXCJ0YXN0eSBwaXp6YVwiLCBcInRhc3R5IHNhbGFkXCIsIFwiUElaWkFcIiwgXCJTQUxBRFwiXVxuICogQHN5bWIgUi5hcChbZiwgZ10sIFthLCBiXSkgPSBbZihhKSwgZihiKSwgZyhhKSwgZyhiKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGFwKGFwcGxpY2F0aXZlLCBmbikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBhcHBsaWNhdGl2ZS5hcCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBhcHBsaWNhdGl2ZS5hcChmbikgOlxuICAgIHR5cGVvZiBhcHBsaWNhdGl2ZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBhcHBsaWNhdGl2ZSh4KShmbih4KSk7IH0gOlxuICAgIC8vIGVsc2VcbiAgICAgIF9yZWR1Y2UoZnVuY3Rpb24oYWNjLCBmKSB7IHJldHVybiBfY29uY2F0KGFjYywgbWFwKGYsIGZuKSk7IH0sIFtdLCBhcHBsaWNhdGl2ZSlcbiAgKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYXAuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfbWFrZUZsYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19tYWtlRmxhdCcpO1xudmFyIF94Y2hhaW4gPSByZXF1aXJlKCcuL2ludGVybmFsL194Y2hhaW4nKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5cbi8qKlxuICogYGNoYWluYCBtYXBzIGEgZnVuY3Rpb24gb3ZlciBhIGxpc3QgYW5kIGNvbmNhdGVuYXRlcyB0aGUgcmVzdWx0cy4gYGNoYWluYFxuICogaXMgYWxzbyBrbm93biBhcyBgZmxhdE1hcGAgaW4gc29tZSBsaWJyYXJpZXNcbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgY2hhaW5gIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LFxuICogYWNjb3JkaW5nIHRvIHRoZSBbRmFudGFzeUxhbmQgQ2hhaW4gc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbikuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBDaGFpbiBtID0+IChhIC0+IG0gYikgLT4gbSBhIC0+IG0gYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcCB3aXRoXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIG1hcCBvdmVyXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIHJlc3VsdCBvZiBmbGF0LW1hcHBpbmcgYGxpc3RgIHdpdGggYGZuYFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkdXBsaWNhdGUgPSBuID0+IFtuLCBuXTtcbiAqICAgICAgUi5jaGFpbihkdXBsaWNhdGUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDEsIDIsIDIsIDMsIDNdXG4gKlxuICogICAgICBSLmNoYWluKFIuYXBwZW5kLCBSLmhlYWQpKFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDMsIDFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsnY2hhaW4nXSwgX3hjaGFpbiwgZnVuY3Rpb24gY2hhaW4oZm4sIG1vbmFkKSB7XG4gIGlmICh0eXBlb2YgbW9uYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZm4obW9uYWQoeCkpKHgpOyB9O1xuICB9XG4gIHJldHVybiBfbWFrZUZsYXQoZmFsc2UpKG1hcChmbiwgbW9uYWQpKTtcbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2NoYWluLmpzIiwidmFyIHBpcGUgPSByZXF1aXJlKCcuL3BpcGUnKTtcbnZhciByZXZlcnNlID0gcmVxdWlyZSgnLi9yZXZlcnNlJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgcmlnaHRtb3N0IGZ1bmN0aW9uIG1heSBoYXZlXG4gKiBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuXG4gKlxuICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgY29tcG9zZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoeSAtPiB6KSwgKHggLT4geSksIC4uLiwgKG8gLT4gcCksICgoYSwgYiwgLi4uLCBuKSAtPiBvKSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSAuLi5mdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5waXBlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGNsYXNzeUdyZWV0aW5nID0gKGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+IFwiVGhlIG5hbWUncyBcIiArIGxhc3ROYW1lICsgXCIsIFwiICsgZmlyc3ROYW1lICsgXCIgXCIgKyBsYXN0TmFtZVxuICogICAgICB2YXIgeWVsbEdyZWV0aW5nID0gUi5jb21wb3NlKFIudG9VcHBlciwgY2xhc3N5R3JlZXRpbmcpO1xuICogICAgICB5ZWxsR3JlZXRpbmcoJ0phbWVzJywgJ0JvbmQnKTsgLy89PiBcIlRIRSBOQU1FJ1MgQk9ORCwgSkFNRVMgQk9ORFwiXG4gKlxuICogICAgICBSLmNvbXBvc2UoTWF0aC5hYnMsIFIuYWRkKDEpLCBSLm11bHRpcGx5KDIpKSgtNCkgLy89PiA3XG4gKlxuICogQHN5bWIgUi5jb21wb3NlKGYsIGcsIGgpKGEsIGIpID0gZihnKGgoYSwgYikpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb3NlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBwaXBlLmFwcGx5KHRoaXMsIHJldmVyc2UoYXJndW1lbnRzKSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY29tcG9zZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FycmF5Jyk7XG52YXIgX2lzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0Z1bmN0aW9uJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbGlzdHMgb3Igc3RyaW5ncy5cbiAqXG4gKiBOb3RlOiBgUi5jb25jYXRgIGV4cGVjdHMgYm90aCBhcmd1bWVudHMgdG8gYmUgb2YgdGhlIHNhbWUgdHlwZSxcbiAqIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2QuIEl0IHdpbGwgdGhyb3dcbiAqIGFuIGVycm9yIGlmIHlvdSBgY29uY2F0YCBhbiBBcnJheSB3aXRoIGEgbm9uLUFycmF5IHZhbHVlLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBjb25jYXRgIG1ldGhvZCBvZiB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGZpcnN0TGlzdCBUaGUgZmlyc3QgbGlzdFxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHNlY29uZExpc3QgVGhlIHNlY29uZCBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9IEEgbGlzdCBjb25zaXN0aW5nIG9mIHRoZSBlbGVtZW50cyBvZiBgZmlyc3RMaXN0YCBmb2xsb3dlZCBieSB0aGUgZWxlbWVudHMgb2ZcbiAqIGBzZWNvbmRMaXN0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jb25jYXQoJ0FCQycsICdERUYnKTsgLy8gJ0FCQ0RFRidcbiAqICAgICAgUi5jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICogICAgICBSLmNvbmNhdChbXSwgW10pOyAvLz0+IFtdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8ICFfaXNGdW5jdGlvbihhLmNvbmNhdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGEpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiY29uY2F0XCInKTtcbiAgfVxuICBpZiAoX2lzQXJyYXkoYSkgJiYgIV9pc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyhiKSArICcgaXMgbm90IGFuIGFycmF5Jyk7XG4gIH1cbiAgcmV0dXJuIGEuY29uY2F0KGIpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jb25jYXQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZmlsdGVyJyk7XG52YXIgX2lzT2JqZWN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNPYmplY3QnKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgX3hmaWx0ZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL194ZmlsdGVyJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBwcmVkaWNhdGUgYW5kIGEgXCJmaWx0ZXJhYmxlXCIsIGFuZCByZXR1cm5zIGEgbmV3IGZpbHRlcmFibGUgb2YgdGhlXG4gKiBzYW1lIHR5cGUgY29udGFpbmluZyB0aGUgbWVtYmVycyBvZiB0aGUgZ2l2ZW4gZmlsdGVyYWJsZSB3aGljaCBzYXRpc2Z5IHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaWx0ZXJgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5yZWplY3QsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gKlxuICogICAgICBSLmZpbHRlcihpc0V2ZW4sIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDRdXG4gKlxuICogICAgICBSLmZpbHRlcihpc0V2ZW4sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGQ6IDR9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsnZmlsdGVyJ10sIF94ZmlsdGVyLCBmdW5jdGlvbihwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gIHJldHVybiAoXG4gICAgX2lzT2JqZWN0KGZpbHRlcmFibGUpID9cbiAgICAgIF9yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtcbiAgICAgICAgaWYgKHByZWQoZmlsdGVyYWJsZVtrZXldKSkge1xuICAgICAgICAgIGFjY1trZXldID0gZmlsdGVyYWJsZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSwga2V5cyhmaWx0ZXJhYmxlKSkgOlxuICAgIC8vIGVsc2VcbiAgICAgIF9maWx0ZXIocHJlZCwgZmlsdGVyYWJsZSlcbiAgKTtcbn0pKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ZpbHRlci5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2lkZW50aXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faWRlbnRpdHknKTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJldHVybiB0aGUgcGFyYW1ldGVyIHN1cHBsaWVkIHRvIGl0LiBHb29kXG4gKiBhcyBhIGRlZmF1bHQgb3IgcGxhY2Vob2xkZXIgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBhXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHJldHVybi5cbiAqIEByZXR1cm4geyp9IFRoZSBpbnB1dCB2YWx1ZSwgYHhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaWRlbnRpdHkoMSk7IC8vPT4gMVxuICpcbiAqICAgICAgdmFyIG9iaiA9IHt9O1xuICogICAgICBSLmlkZW50aXR5KG9iaikgPT09IG9iajsgLy89PiB0cnVlXG4gKiBAc3ltYiBSLmlkZW50aXR5KGEpID0gYVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoX2lkZW50aXR5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2lkZW50aXR5LmpzIiwidmFyIF9vYmplY3RBc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3RBc3NpZ24nKTtcblxubW9kdWxlLmV4cG9ydHMgPVxuICB0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5hc3NpZ24gOiBfb2JqZWN0QXNzaWduO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Fzc2lnbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2NvbnRhaW5zV2l0aChwcmVkLCB4LCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChwcmVkKHgsIGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2NvbnRhaW5zV2l0aC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lkZW50aXR5KHgpIHsgcmV0dXJuIHg7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faWRlbnRpdHkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1RyYW5zZm9ybWVyKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9ialsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faXNUcmFuc2Zvcm1lci5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIHN1cHBsaWVkIGFuIG9iamVjdCByZXR1cm5zIHRoZSBpbmRpY2F0ZWRcbiAqIHByb3BlcnR5IG9mIHRoYXQgb2JqZWN0LCBpZiBpdCBleGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHMgLT4ge3M6IGF9IC0+IGEgfCBVbmRlZmluZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwIFRoZSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBhdCBgb2JqLnBgLlxuICogQHNlZSBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3AoJ3gnLCB7eDogMTAwfSk7IC8vPT4gMTAwXG4gKiAgICAgIFIucHJvcCgneCcsIHt9KTsgLy89PiB1bmRlZmluZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3AocCwgb2JqKSB7IHJldHVybiBvYmpbcF07IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcHJvcC5qcyIsInZhciBfY2hlY2tGb3JNZXRob2QgPSByZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgKG9yIG9iamVjdFxuICogd2l0aCBhIGB0YWlsYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmhlYWQsIFIuaW5pdCwgUi5sYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50YWlsKFsxLCAyLCAzXSk7ICAvLz0+IFsyLCAzXVxuICogICAgICBSLnRhaWwoWzEsIDJdKTsgICAgIC8vPT4gWzJdXG4gKiAgICAgIFIudGFpbChbMV0pOyAgICAgICAgLy89PiBbXVxuICogICAgICBSLnRhaWwoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIudGFpbCgnYWJjJyk7ICAvLz0+ICdiYydcbiAqICAgICAgUi50YWlsKCdhYicpOyAgIC8vPT4gJ2InXG4gKiAgICAgIFIudGFpbCgnYScpOyAgICAvLz0+ICcnXG4gKiAgICAgIFIudGFpbCgnJyk7ICAgICAvLz0+ICcnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShfY2hlY2tGb3JNZXRob2QoJ3RhaWwnLCBzbGljZSgxLCBJbmZpbml0eSkpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3RhaWwuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogR2l2ZXMgYSBzaW5nbGUtd29yZCBzdHJpbmcgZGVzY3JpcHRpb24gb2YgdGhlIChuYXRpdmUpIHR5cGUgb2YgYSB2YWx1ZSxcbiAqIHJldHVybmluZyBzdWNoIGFuc3dlcnMgYXMgJ09iamVjdCcsICdOdW1iZXInLCAnQXJyYXknLCBvciAnTnVsbCcuIERvZXMgbm90XG4gKiBhdHRlbXB0IHRvIGRpc3Rpbmd1aXNoIHVzZXIgT2JqZWN0IHR5cGVzIGFueSBmdXJ0aGVyLCByZXBvcnRpbmcgdGhlbSBhbGwgYXNcbiAqICdPYmplY3QnLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgKCogLT4geyp9KSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50eXBlKHt9KTsgLy89PiBcIk9iamVjdFwiXG4gKiAgICAgIFIudHlwZSgxKTsgLy89PiBcIk51bWJlclwiXG4gKiAgICAgIFIudHlwZShmYWxzZSk7IC8vPT4gXCJCb29sZWFuXCJcbiAqICAgICAgUi50eXBlKCdzJyk7IC8vPT4gXCJTdHJpbmdcIlxuICogICAgICBSLnR5cGUobnVsbCk7IC8vPT4gXCJOdWxsXCJcbiAqICAgICAgUi50eXBlKFtdKTsgLy89PiBcIkFycmF5XCJcbiAqICAgICAgUi50eXBlKC9bQS16XS8pOyAvLz0+IFwiUmVnRXhwXCJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHR5cGUodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGwgICAgICA/ICdOdWxsJyAgICAgIDpcbiAgICAgICAgIHZhbCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOlxuICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90eXBlLmpzIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIHVuaXFCeSA9IHJlcXVpcmUoJy4vdW5pcUJ5Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAqIGxpc3QuIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmlxKFsxLCAxLCAyLCAxXSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIudW5pcShbMSwgJzEnXSk7ICAgICAvLz0+IFsxLCAnMSddXG4gKiAgICAgIFIudW5pcShbWzQyXSwgWzQyXV0pOyAvLz0+IFtbNDJdXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXFCeShpZGVudGl0eSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91bmlxLmpzIiwidmFyIF9jb250YWluc1dpdGggPSByZXF1aXJlKCcuL2ludGVybmFsL19jb250YWluc1dpdGgnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyBvbmx5IG9uZSBjb3B5IG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgb3JpZ2luYWxcbiAqIGxpc3QsIGJhc2VkIHVwb24gdGhlIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG9cbiAqIHR3byBsaXN0IGVsZW1lbnRzLiBQcmVmZXJzIHRoZSBmaXJzdCBpdGVtIGlmIHR3byBpdGVtcyBjb21wYXJlIGVxdWFsIGJhc2VkXG4gKiBvbiB0aGUgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEsIGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzdHJFcSA9IFIuZXFCeShTdHJpbmcpO1xuICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbMSwgJzEnLCAyLCAxXSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFt7fSwge31dKTsgICAgICAgLy89PiBbe31dXG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDFdKTsgICAgLy89PiBbMV1cbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWycxJywgMSwgMV0pOyAgICAvLz0+IFsnMSddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB1bmlxV2l0aChwcmVkLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGl0ZW07XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgIGlmICghX2NvbnRhaW5zV2l0aChwcmVkLCBpdGVtLCByZXN1bHQpKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBpdGVtO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91bmlxV2l0aC5qcyIsImltcG9ydCB7XG5cdGdldFNpbmdsZUZhcmUsXG5cdG1heE51bSxcbn0gZnJvbSAnLi4vdXRpbGl0eS9fdXRpbGl0eSc7XG5cbmltcG9ydCBzcGxpdE9yRnVsbEZhcmUgZnJvbSAnLi9fc3BsaXRPckZ1bGxGYXJlJztcblxuLy8gLyoqXG4vLyAgKiBDYWxjdWxhdGVzIHRoZSBleHRlbnNpb24gZmFyZSAob3Igbm9uZSkgb2YgYSBqb3VybmV5XG4vLyAgKiBAZnVuY3Rpb25cbi8vICAqIEBwYXJhbSB7b2JqZWN0fSBzZWUgYmVsb3dcbi8vICAqIEBwYXJhbSB7c2luZ2xlRmFyZXN9IHVzZXMgdGhlIHNpbmdsZUZhcmVzIGpzb24gZGF0YVxuLy8gICogQHJldHVybnMge251bWJlcn0gLSByZXR1cm5zIHRoZSBleHRlbnNpb24gZmFyZSBmb3IgdGhlIGpvdXJuZXlcbi8vICAqIEBkZXNjcmlwdGlvblxuLy9cbi8vIFx0Rk9SIERBSUxZIENBUFM6IEFMV0FZUyBTVEFSVCBBVCAxIFNPIE1PU1QgT0YgVEhJUyBDT0RFIFRPTyBDT01QTEVYOiBidXQgd291bGQgc3RpbGwgd29ya1xuLy8gXHRGT1IgV0VFS0xZIENBUFM6IHRoaXMgd29ya3Mgb3V0IGZhcmUgd2l0aG91dCBhbnkgZGFpbHkgY2FwcyBvciBtaXggZGFpbHkgYW5kIHdlZWtseSB3aGVyZSB0aGVyZSBhcmUgbm8gZ2FwIHpvbmVzIChzbyBiZXR3ZWVuIDEgYW5kIG1heCB6b25lIG9mIGVpdGhlciBkYWlseSBvciB3ZWVrbHkgY2FwKSAtLSB1bmxlc3MgeW91IGFkZCBpbiBNYXhEYWlseVxuLy8gIC8vIHRoaXMgaXMgb3Zlcmx5IGNvbXBsaWNhdGVkIGZvciBkYWlseSBjYXBzIChhcyBvbmx5IGRlYWxzIHdpdGggem9uZSAxIHRvIHgpIGJ1dCBzdGlsbCB3b3Jrcy4gUkVMSUVTIE9OIFRIRSBGQUNUIERBSUxZIEFMV0FZUyBTVEFSVFMgQVQgMVxuLy8gICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dGVuc2lvbkZhcmVzKG9wdGlvbnMgPSB7fSwgc2luZ2xlRmFyZXMpIHtcbiAgY29uc3QgbWF4RGFpbHkgPSBvcHRpb25zLm1heERhaWx5IHx8IG51bGw7XG4vLyBieSBkZWZhdWx0OiBqdXN0IG9uZSB0cmF2ZWxjYXJkICh3ZWVrbHkgd2l0aG91dCBkYWlseSBvciBqdXN0IGRhaWx5IGNhcCkgZm9yIGVpdGhlciBveXN0ZXIgb3IgY29udGFjdGxlc3MsIG9yIG95c3RlciB3aXRoIHdlZWtseSBjYXAgKGRvZXNuJ3QgY3V0IG9mZiBkYWlseSBzZWN0aW9uIG9mIHRoZSBqb3VybmV5KVxuXG5cdGxldCB7XG5cdFx0em9uZXMsXG5cdFx0dHlwZSxcbiAgICBcdG1pblRyYXZlbGNhcmQsIC8vIG1pbmltdW0gem9uZSBvZiB0aGUgdHJhdmVsY2FyZCBjdXJyZW50bHkgdGVzdGluZ1xuXHRcdG1heFRyYXZlbGNhcmQsIC8vbWF4aW11bSB6b25lIG9mIHRoZSB0cmF2ZWxjYXJkIGN1cnJlbnRseSB0ZXN0aW5nXG5cdFx0Ly8gaWYgbWF4ZGFpbHkgYWxzbyBpbnZvbHZlZCAoZm9yIGNvbnRhY3RsZXNzIHdlZWtseSBhbmQgZGFpbHkgY29tYm8pOiBzbyB0aGF0IGl0IG9ubHkgY2hhcmdlcyB0aGUgZ2FwIHpvbmVzXG5cdH0gPSBvcHRpb25zO1xuXHQvLyBzYW1lIGFzIHZhciBtaW5TaW5nbGUgPSBvcHRpb25zLm1pblNpbmdsZTtcblxuICBsZXQgZmluYWxDb25kaXRpb24gPSBudWxsO1xuICBsZXQgbWluU2luZ2xlID0gem9uZXNbMF07XG4gIGxldCBtYXhTaW5nbGUgPSB6b25lc1sxXTtcbiAgbGV0IG1pbkNoYXJnZWRab25lID0gbWluU2luZ2xlO1xuXG5cdGlmIChtYXhEYWlseSkgeyAvLyBJZiBjb250YWN0bGVzcywgZGFpbHkgYW5kIHdlZWtseSBjb21ibyAoaGVuY2UgYWRkaW5nIGluIG1heERhaWx5IGFzIGFyZ3VtZW50X1xuXHQgXHRpZiAobWF4RGFpbHkgPj0gKG1pblRyYXZlbGNhcmQgLSAxKSkgeyAvLyBpZiBubyBnYXAgem9uZXMgYmV0d2VlbiBtYXggZGFpbHkgYW5kIG1pbiB0cmF2ZWxjYXJkXG5cdCAgXHRtaW5UcmF2ZWxjYXJkID0gMTsgLy8gc2luY2UgYW55dGltZSBkYWlseSBjYXBzIGFsd2F5cyBzdGFydCBhdCB6b25lIDFcblx0ICAgXHRtYXhUcmF2ZWxjYXJkID0gbWF4TnVtKFttYXhEYWlseSwgbWF4VHJhdmVsY2FyZF0pOyAvLyBtYXggdHJhdmVsY2FyZCBpcyB3aGljaGV2ZXIgaXMgbGFyZ2VzdCBtYXggZGFpbHkgb3IgbWF4IHRyYXZlbGNhcmRcbi8vIGVsc2UgaWYgY29udGFjdGxlc3MsIGRhaWx5IGFuZCB3ZWVrbHkgY29tYm8sIGFuZCB0aGVyZSBhcmUgZ2FwIHpvbmVzIGJldHdlZW4gbWF4IGRhaWx5IGFuZCBtaW4gdHJhdmVsY2FyZCwgaGF2ZSBhIG1pbiBjaGFyZ2VkIHpvbmUgKG5vdCBjaGFyZ2UgdGhlIGRhaWx5IGNhcCAtIHRoZSBmcm9udClcblx0XHR9IGVsc2UgeyAvLyBJRiBkaWZmZXJlbmNlIGJ3IG1pbiB3ZWVrbHkgYW5kIG1heCBkYWlseSBjYXAgPiAxIC0tIFRIRU4gVEhFUkUgQVJFIEdBUCBaT05FU1xuXHRcdFx0XHRtaW5DaGFyZ2VkWm9uZSA9ICgobWluU2luZ2xlIDw9IG1heERhaWx5KSA/IG1heERhaWx5ICsgMSA6IG1pblNpbmdsZSk7XG5cdFx0XHRcdGZpbmFsQ29uZGl0aW9uID0gKG1pblNpbmdsZSA8PSBtYXhEYWlseSAmJiBtYXhTaW5nbGUgPD0gbWF4RGFpbHkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIGlmIG1pbiBzaW5nbGUgaXNudCB3aXRoaW4gdHJhdmVsY2FyZCB6b25lcyBidXQgbWF4IHNpbmdsZSBpcyhOQiBub3QgbmVlZGVkIGZvciBkYWlseSBjYXApIC0gY2hhcmdlIGZyb250XG5cdGlmICgobWluU2luZ2xlIDwgbWluVHJhdmVsY2FyZCkgJiYgKG1pblRyYXZlbGNhcmQgPD0gbWF4U2luZ2xlICYmIG1heFNpbmdsZSA8PSBtYXhUcmF2ZWxjYXJkKSkge1xuXHRcdCAvLyBkZWJ1Z2dlcjtcblx0XHRyZXR1cm4gZ2V0U2luZ2xlRmFyZShbbWluQ2hhcmdlZFpvbmUsIChtaW5UcmF2ZWxjYXJkIC0gMSldLCBzaW5nbGVGYXJlcywgdHlwZSk7XG5cblx0Ly9pZiBtaW4gc2luZ2xlIHdpdGhpbiB0cmF2ZWxjYXJkIHpvbmVzIGJ1dCBtYXggc2luZ2xlIGlzbnQgLSBjaGFyZ2UgZW5kXG4gXHR9IGVsc2UgaWYgKChtaW5UcmF2ZWxjYXJkIDw9IG1pblNpbmdsZSAmJiBtaW5TaW5nbGUgPD0gbWF4VHJhdmVsY2FyZCkgJiYgKG1heFNpbmdsZSA+IG1heFRyYXZlbGNhcmQpKSB7XG4gXHRcdCAvLyBkZWJ1Z2dlcjtcbiBcdFx0cmV0dXJuIGdldFNpbmdsZUZhcmUoWyhtYXhUcmF2ZWxjYXJkICsgMSksIG1heFNpbmdsZV0sIHNpbmdsZUZhcmVzLCB0eXBlKTtcblxuIFx0Ly9pZiBtaW4gc2luZ2xlIGxlc3MgdGhhbiBtaW4gdHJhdmVsY2FyZCBhbmQgbWF4IHNpbmdsZSBtb3JlIHRoYW4gbWF4IHRyYXZlbGNhcmQgKE5CIG5vdCBuZWVkZWQgZm9yIGRhaWx5IGNhcCkgLSBjaGFyZ2UgZnJvbnQgYW5kIGVuZFxuIFx0fSBlbHNlIGlmIChtaW5TaW5nbGUgPCBtaW5UcmF2ZWxjYXJkICYmIG1heFNpbmdsZSA+IG1heFRyYXZlbGNhcmQpIHtcbiBcdFx0IC8vIGRlYnVnZ2VyO1xuIFx0XHRyZXR1cm4gc3BsaXRPckZ1bGxGYXJlKFxuICAgICAgbWluQ2hhcmdlZFpvbmUsIG1heFNpbmdsZSxcbiBcdFx0XHRtaW5UcmF2ZWxjYXJkLCBtYXhUcmF2ZWxjYXJkLFxuIFx0XHRcdHNpbmdsZUZhcmVzLCB0eXBlKTtcblxuXHQvLyBib3RoIHNpbmdsZSB6b25lcyB3aXRoaW4gdHJhdmVsY2FyZCB6b25lc1xuIFx0fSBlbHNlIGlmICgobWluVHJhdmVsY2FyZCA8PSBtaW5TaW5nbGUgJiYgbWluU2luZ2xlIDw9IG1heFRyYXZlbGNhcmQpICYmIChtaW5UcmF2ZWxjYXJkIDw9IG1heFNpbmdsZSAmJiBtYXhTaW5nbGUgPD0gbWF4VHJhdmVsY2FyZCkgfHwgZmluYWxDb25kaXRpb24pIHtcbiBcdFx0IC8vIGRlYnVnZ2VyO1xuIFx0XHRyZXR1cm4gMDtcbiBcdC8vIGJvdGggc2luZ2xlIHpvbmVzIGFyZSBvdXRzaWRlIHRyYXZlbGNhcmQgem9uZXNcbiBcdH1cblxuXG4gIHJldHVybiBnZXRTaW5nbGVGYXJlKFttaW5DaGFyZ2VkWm9uZSwgbWF4U2luZ2xlXSwgc2luZ2xlRmFyZXMsIHR5cGUpO1xuLy8gRUxTRSBtaW4gc2luZ2xlIGFuZCBtYXggc2luZ2xlIGJvdGggPiBtYXggd2Vla2x5IHpvbmUgKG9yIGJvdGggPCBtaW4gZGFpbHkpIE9SIG1pbiBzaW5nbGUgem9uZSA+IG1pbiBnYXAgem9uZSAmJiBtYXggc2luZ2xlIHpvbmUgPCBtYXggZ2FwIHpvbmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9wYXJ0aWFscy9fZXh0ZW5zaW9uRmFyZXMuanMiLCIvKipcbiAqIEdldHMgZmFyZXMuanNvbiBmaWxlXG4gKi9cbnZhciBmZXRjaEZhcmVEYXRhID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIGRhdGEgPSBudWxsO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRpZiAoZGF0YSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ29oISB3ZSBhcmUgZ2V0dGluZyB0aGUgY2FjaGVkIGRhdGEhJyk7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmZXRjaCgnL2RhdGEvZmFyZXMuanNvbicpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuXHRcdFx0ZGF0YSA9IHJlc3AuanNvbigpO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fSk7XG5cdH1cbn0oKSk7XG5cbi8vIEdldHMgc3RhdGlvbi5qc29uIC0gbGlzdGluZyB3aGF0IHpvbmVzIGVhY2ggc3RhdGlvbiBpc1xudmFyIGZldGNoU3RhdGlvbnNEYXRhID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgZGF0YSA9IG51bGw7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChkYXRhKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnb2ghIHdlIGFyZSBnZXR0aW5nIHRoZSBjYWNoZWQgZGF0YSEnKTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZldGNoKCcvZGF0YS9zdGF0aW9ucy5qc29uJykudGhlbihmdW5jdGlvbihyZXNwKSB7XG5cdFx0XHRkYXRhID0gcmVzcC5qc29uKCk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9KTtcblx0fVxufSgpKTtcblxuLy9GZXRjaGVzIHRoZSBqc29uIGZpbGUgZnJvbSBURkwgQVBJXG52YXIgZmV0Y2hKb3VybmV5RGF0YSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdHJldHVybiBmZXRjaCgnaHR0cHM6Ly9hcGkudGZsLmdvdi51ay9qb3VybmV5L2pvdXJuZXlyZXN1bHRzLycgKyBmcm9tICsgJy90by8nICsgdG8gKyAnP2FwcF9pZD04YWNkNzlhOSZhcHBfa2V5PWQ0MzNhMmQ2ZDlhOWM4ZThiMWI0YTZkZDQzNzFjNjliJykudGhlbihmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGUuanNvbigpO1xuXHR9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZmFyZXM6IGZldGNoRmFyZURhdGEsXG5cdHN0YXRpb25zOiBmZXRjaFN0YXRpb25zRGF0YSxcblx0am91cm5leTogZmV0Y2hKb3VybmV5RGF0YSxcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3V0aWxpdHkvX2dldERhdGEuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRjogcmVxdWlyZSgnLi9zcmMvRicpLFxuICBUOiByZXF1aXJlKCcuL3NyYy9UJyksXG4gIF9fOiByZXF1aXJlKCcuL3NyYy9fXycpLFxuICBhZGQ6IHJlcXVpcmUoJy4vc3JjL2FkZCcpLFxuICBhZGRJbmRleDogcmVxdWlyZSgnLi9zcmMvYWRkSW5kZXgnKSxcbiAgYWRqdXN0OiByZXF1aXJlKCcuL3NyYy9hZGp1c3QnKSxcbiAgYWxsOiByZXF1aXJlKCcuL3NyYy9hbGwnKSxcbiAgYWxsUGFzczogcmVxdWlyZSgnLi9zcmMvYWxsUGFzcycpLFxuICBhbHdheXM6IHJlcXVpcmUoJy4vc3JjL2Fsd2F5cycpLFxuICBhbmQ6IHJlcXVpcmUoJy4vc3JjL2FuZCcpLFxuICBhbnk6IHJlcXVpcmUoJy4vc3JjL2FueScpLFxuICBhbnlQYXNzOiByZXF1aXJlKCcuL3NyYy9hbnlQYXNzJyksXG4gIGFwOiByZXF1aXJlKCcuL3NyYy9hcCcpLFxuICBhcGVydHVyZTogcmVxdWlyZSgnLi9zcmMvYXBlcnR1cmUnKSxcbiAgYXBwZW5kOiByZXF1aXJlKCcuL3NyYy9hcHBlbmQnKSxcbiAgYXBwbHk6IHJlcXVpcmUoJy4vc3JjL2FwcGx5JyksXG4gIGFwcGx5U3BlYzogcmVxdWlyZSgnLi9zcmMvYXBwbHlTcGVjJyksXG4gIGFzY2VuZDogcmVxdWlyZSgnLi9zcmMvYXNjZW5kJyksXG4gIGFzc29jOiByZXF1aXJlKCcuL3NyYy9hc3NvYycpLFxuICBhc3NvY1BhdGg6IHJlcXVpcmUoJy4vc3JjL2Fzc29jUGF0aCcpLFxuICBiaW5hcnk6IHJlcXVpcmUoJy4vc3JjL2JpbmFyeScpLFxuICBiaW5kOiByZXF1aXJlKCcuL3NyYy9iaW5kJyksXG4gIGJvdGg6IHJlcXVpcmUoJy4vc3JjL2JvdGgnKSxcbiAgY2FsbDogcmVxdWlyZSgnLi9zcmMvY2FsbCcpLFxuICBjaGFpbjogcmVxdWlyZSgnLi9zcmMvY2hhaW4nKSxcbiAgY2xhbXA6IHJlcXVpcmUoJy4vc3JjL2NsYW1wJyksXG4gIGNsb25lOiByZXF1aXJlKCcuL3NyYy9jbG9uZScpLFxuICBjb21wYXJhdG9yOiByZXF1aXJlKCcuL3NyYy9jb21wYXJhdG9yJyksXG4gIGNvbXBsZW1lbnQ6IHJlcXVpcmUoJy4vc3JjL2NvbXBsZW1lbnQnKSxcbiAgY29tcG9zZTogcmVxdWlyZSgnLi9zcmMvY29tcG9zZScpLFxuICBjb21wb3NlSzogcmVxdWlyZSgnLi9zcmMvY29tcG9zZUsnKSxcbiAgY29tcG9zZVA6IHJlcXVpcmUoJy4vc3JjL2NvbXBvc2VQJyksXG4gIGNvbmNhdDogcmVxdWlyZSgnLi9zcmMvY29uY2F0JyksXG4gIGNvbmQ6IHJlcXVpcmUoJy4vc3JjL2NvbmQnKSxcbiAgY29uc3RydWN0OiByZXF1aXJlKCcuL3NyYy9jb25zdHJ1Y3QnKSxcbiAgY29uc3RydWN0TjogcmVxdWlyZSgnLi9zcmMvY29uc3RydWN0TicpLFxuICBjb250YWluczogcmVxdWlyZSgnLi9zcmMvY29udGFpbnMnKSxcbiAgY29udmVyZ2U6IHJlcXVpcmUoJy4vc3JjL2NvbnZlcmdlJyksXG4gIGNvdW50Qnk6IHJlcXVpcmUoJy4vc3JjL2NvdW50QnknKSxcbiAgY3Vycnk6IHJlcXVpcmUoJy4vc3JjL2N1cnJ5JyksXG4gIGN1cnJ5TjogcmVxdWlyZSgnLi9zcmMvY3VycnlOJyksXG4gIGRlYzogcmVxdWlyZSgnLi9zcmMvZGVjJyksXG4gIGRlc2NlbmQ6IHJlcXVpcmUoJy4vc3JjL2Rlc2NlbmQnKSxcbiAgZGVmYXVsdFRvOiByZXF1aXJlKCcuL3NyYy9kZWZhdWx0VG8nKSxcbiAgZGlmZmVyZW5jZTogcmVxdWlyZSgnLi9zcmMvZGlmZmVyZW5jZScpLFxuICBkaWZmZXJlbmNlV2l0aDogcmVxdWlyZSgnLi9zcmMvZGlmZmVyZW5jZVdpdGgnKSxcbiAgZGlzc29jOiByZXF1aXJlKCcuL3NyYy9kaXNzb2MnKSxcbiAgZGlzc29jUGF0aDogcmVxdWlyZSgnLi9zcmMvZGlzc29jUGF0aCcpLFxuICBkaXZpZGU6IHJlcXVpcmUoJy4vc3JjL2RpdmlkZScpLFxuICBkcm9wOiByZXF1aXJlKCcuL3NyYy9kcm9wJyksXG4gIGRyb3BMYXN0OiByZXF1aXJlKCcuL3NyYy9kcm9wTGFzdCcpLFxuICBkcm9wTGFzdFdoaWxlOiByZXF1aXJlKCcuL3NyYy9kcm9wTGFzdFdoaWxlJyksXG4gIGRyb3BSZXBlYXRzOiByZXF1aXJlKCcuL3NyYy9kcm9wUmVwZWF0cycpLFxuICBkcm9wUmVwZWF0c1dpdGg6IHJlcXVpcmUoJy4vc3JjL2Ryb3BSZXBlYXRzV2l0aCcpLFxuICBkcm9wV2hpbGU6IHJlcXVpcmUoJy4vc3JjL2Ryb3BXaGlsZScpLFxuICBlaXRoZXI6IHJlcXVpcmUoJy4vc3JjL2VpdGhlcicpLFxuICBlbXB0eTogcmVxdWlyZSgnLi9zcmMvZW1wdHknKSxcbiAgZXFCeTogcmVxdWlyZSgnLi9zcmMvZXFCeScpLFxuICBlcVByb3BzOiByZXF1aXJlKCcuL3NyYy9lcVByb3BzJyksXG4gIGVxdWFsczogcmVxdWlyZSgnLi9zcmMvZXF1YWxzJyksXG4gIGV2b2x2ZTogcmVxdWlyZSgnLi9zcmMvZXZvbHZlJyksXG4gIGZpbHRlcjogcmVxdWlyZSgnLi9zcmMvZmlsdGVyJyksXG4gIGZpbmQ6IHJlcXVpcmUoJy4vc3JjL2ZpbmQnKSxcbiAgZmluZEluZGV4OiByZXF1aXJlKCcuL3NyYy9maW5kSW5kZXgnKSxcbiAgZmluZExhc3Q6IHJlcXVpcmUoJy4vc3JjL2ZpbmRMYXN0JyksXG4gIGZpbmRMYXN0SW5kZXg6IHJlcXVpcmUoJy4vc3JjL2ZpbmRMYXN0SW5kZXgnKSxcbiAgZmxhdHRlbjogcmVxdWlyZSgnLi9zcmMvZmxhdHRlbicpLFxuICBmbGlwOiByZXF1aXJlKCcuL3NyYy9mbGlwJyksXG4gIGZvckVhY2g6IHJlcXVpcmUoJy4vc3JjL2ZvckVhY2gnKSxcbiAgZm9yRWFjaE9iakluZGV4ZWQ6IHJlcXVpcmUoJy4vc3JjL2ZvckVhY2hPYmpJbmRleGVkJyksXG4gIGZyb21QYWlyczogcmVxdWlyZSgnLi9zcmMvZnJvbVBhaXJzJyksXG4gIGdyb3VwQnk6IHJlcXVpcmUoJy4vc3JjL2dyb3VwQnknKSxcbiAgZ3JvdXBXaXRoOiByZXF1aXJlKCcuL3NyYy9ncm91cFdpdGgnKSxcbiAgZ3Q6IHJlcXVpcmUoJy4vc3JjL2d0JyksXG4gIGd0ZTogcmVxdWlyZSgnLi9zcmMvZ3RlJyksXG4gIGhhczogcmVxdWlyZSgnLi9zcmMvaGFzJyksXG4gIGhhc0luOiByZXF1aXJlKCcuL3NyYy9oYXNJbicpLFxuICBoZWFkOiByZXF1aXJlKCcuL3NyYy9oZWFkJyksXG4gIGlkZW50aWNhbDogcmVxdWlyZSgnLi9zcmMvaWRlbnRpY2FsJyksXG4gIGlkZW50aXR5OiByZXF1aXJlKCcuL3NyYy9pZGVudGl0eScpLFxuICBpZkVsc2U6IHJlcXVpcmUoJy4vc3JjL2lmRWxzZScpLFxuICBpbmM6IHJlcXVpcmUoJy4vc3JjL2luYycpLFxuICBpbmRleEJ5OiByZXF1aXJlKCcuL3NyYy9pbmRleEJ5JyksXG4gIGluZGV4T2Y6IHJlcXVpcmUoJy4vc3JjL2luZGV4T2YnKSxcbiAgaW5pdDogcmVxdWlyZSgnLi9zcmMvaW5pdCcpLFxuICBpbnNlcnQ6IHJlcXVpcmUoJy4vc3JjL2luc2VydCcpLFxuICBpbnNlcnRBbGw6IHJlcXVpcmUoJy4vc3JjL2luc2VydEFsbCcpLFxuICBpbnRlcnNlY3Rpb246IHJlcXVpcmUoJy4vc3JjL2ludGVyc2VjdGlvbicpLFxuICBpbnRlcnNlY3Rpb25XaXRoOiByZXF1aXJlKCcuL3NyYy9pbnRlcnNlY3Rpb25XaXRoJyksXG4gIGludGVyc3BlcnNlOiByZXF1aXJlKCcuL3NyYy9pbnRlcnNwZXJzZScpLFxuICBpbnRvOiByZXF1aXJlKCcuL3NyYy9pbnRvJyksXG4gIGludmVydDogcmVxdWlyZSgnLi9zcmMvaW52ZXJ0JyksXG4gIGludmVydE9iajogcmVxdWlyZSgnLi9zcmMvaW52ZXJ0T2JqJyksXG4gIGludm9rZXI6IHJlcXVpcmUoJy4vc3JjL2ludm9rZXInKSxcbiAgaXM6IHJlcXVpcmUoJy4vc3JjL2lzJyksXG4gIGlzQXJyYXlMaWtlOiByZXF1aXJlKCcuL3NyYy9pc0FycmF5TGlrZScpLFxuICBpc0VtcHR5OiByZXF1aXJlKCcuL3NyYy9pc0VtcHR5JyksXG4gIGlzTmlsOiByZXF1aXJlKCcuL3NyYy9pc05pbCcpLFxuICBqb2luOiByZXF1aXJlKCcuL3NyYy9qb2luJyksXG4gIGp1eHQ6IHJlcXVpcmUoJy4vc3JjL2p1eHQnKSxcbiAga2V5czogcmVxdWlyZSgnLi9zcmMva2V5cycpLFxuICBrZXlzSW46IHJlcXVpcmUoJy4vc3JjL2tleXNJbicpLFxuICBsYXN0OiByZXF1aXJlKCcuL3NyYy9sYXN0JyksXG4gIGxhc3RJbmRleE9mOiByZXF1aXJlKCcuL3NyYy9sYXN0SW5kZXhPZicpLFxuICBsZW5ndGg6IHJlcXVpcmUoJy4vc3JjL2xlbmd0aCcpLFxuICBsZW5zOiByZXF1aXJlKCcuL3NyYy9sZW5zJyksXG4gIGxlbnNJbmRleDogcmVxdWlyZSgnLi9zcmMvbGVuc0luZGV4JyksXG4gIGxlbnNQYXRoOiByZXF1aXJlKCcuL3NyYy9sZW5zUGF0aCcpLFxuICBsZW5zUHJvcDogcmVxdWlyZSgnLi9zcmMvbGVuc1Byb3AnKSxcbiAgbGlmdDogcmVxdWlyZSgnLi9zcmMvbGlmdCcpLFxuICBsaWZ0TjogcmVxdWlyZSgnLi9zcmMvbGlmdE4nKSxcbiAgbHQ6IHJlcXVpcmUoJy4vc3JjL2x0JyksXG4gIGx0ZTogcmVxdWlyZSgnLi9zcmMvbHRlJyksXG4gIG1hcDogcmVxdWlyZSgnLi9zcmMvbWFwJyksXG4gIG1hcEFjY3VtOiByZXF1aXJlKCcuL3NyYy9tYXBBY2N1bScpLFxuICBtYXBBY2N1bVJpZ2h0OiByZXF1aXJlKCcuL3NyYy9tYXBBY2N1bVJpZ2h0JyksXG4gIG1hcE9iakluZGV4ZWQ6IHJlcXVpcmUoJy4vc3JjL21hcE9iakluZGV4ZWQnKSxcbiAgbWF0Y2g6IHJlcXVpcmUoJy4vc3JjL21hdGNoJyksXG4gIG1hdGhNb2Q6IHJlcXVpcmUoJy4vc3JjL21hdGhNb2QnKSxcbiAgbWF4OiByZXF1aXJlKCcuL3NyYy9tYXgnKSxcbiAgbWF4Qnk6IHJlcXVpcmUoJy4vc3JjL21heEJ5JyksXG4gIG1lYW46IHJlcXVpcmUoJy4vc3JjL21lYW4nKSxcbiAgbWVkaWFuOiByZXF1aXJlKCcuL3NyYy9tZWRpYW4nKSxcbiAgbWVtb2l6ZTogcmVxdWlyZSgnLi9zcmMvbWVtb2l6ZScpLFxuICBtZXJnZTogcmVxdWlyZSgnLi9zcmMvbWVyZ2UnKSxcbiAgbWVyZ2VBbGw6IHJlcXVpcmUoJy4vc3JjL21lcmdlQWxsJyksXG4gIG1lcmdlV2l0aDogcmVxdWlyZSgnLi9zcmMvbWVyZ2VXaXRoJyksXG4gIG1lcmdlV2l0aEtleTogcmVxdWlyZSgnLi9zcmMvbWVyZ2VXaXRoS2V5JyksXG4gIG1pbjogcmVxdWlyZSgnLi9zcmMvbWluJyksXG4gIG1pbkJ5OiByZXF1aXJlKCcuL3NyYy9taW5CeScpLFxuICBtb2R1bG86IHJlcXVpcmUoJy4vc3JjL21vZHVsbycpLFxuICBtdWx0aXBseTogcmVxdWlyZSgnLi9zcmMvbXVsdGlwbHknKSxcbiAgbkFyeTogcmVxdWlyZSgnLi9zcmMvbkFyeScpLFxuICBuZWdhdGU6IHJlcXVpcmUoJy4vc3JjL25lZ2F0ZScpLFxuICBub25lOiByZXF1aXJlKCcuL3NyYy9ub25lJyksXG4gIG5vdDogcmVxdWlyZSgnLi9zcmMvbm90JyksXG4gIG50aDogcmVxdWlyZSgnLi9zcmMvbnRoJyksXG4gIG50aEFyZzogcmVxdWlyZSgnLi9zcmMvbnRoQXJnJyksXG4gIG9iak9mOiByZXF1aXJlKCcuL3NyYy9vYmpPZicpLFxuICBvZjogcmVxdWlyZSgnLi9zcmMvb2YnKSxcbiAgb21pdDogcmVxdWlyZSgnLi9zcmMvb21pdCcpLFxuICBvbmNlOiByZXF1aXJlKCcuL3NyYy9vbmNlJyksXG4gIG9yOiByZXF1aXJlKCcuL3NyYy9vcicpLFxuICBvdmVyOiByZXF1aXJlKCcuL3NyYy9vdmVyJyksXG4gIHBhaXI6IHJlcXVpcmUoJy4vc3JjL3BhaXInKSxcbiAgcGFydGlhbDogcmVxdWlyZSgnLi9zcmMvcGFydGlhbCcpLFxuICBwYXJ0aWFsUmlnaHQ6IHJlcXVpcmUoJy4vc3JjL3BhcnRpYWxSaWdodCcpLFxuICBwYXJ0aXRpb246IHJlcXVpcmUoJy4vc3JjL3BhcnRpdGlvbicpLFxuICBwYXRoOiByZXF1aXJlKCcuL3NyYy9wYXRoJyksXG4gIHBhdGhFcTogcmVxdWlyZSgnLi9zcmMvcGF0aEVxJyksXG4gIHBhdGhPcjogcmVxdWlyZSgnLi9zcmMvcGF0aE9yJyksXG4gIHBhdGhTYXRpc2ZpZXM6IHJlcXVpcmUoJy4vc3JjL3BhdGhTYXRpc2ZpZXMnKSxcbiAgcGljazogcmVxdWlyZSgnLi9zcmMvcGljaycpLFxuICBwaWNrQWxsOiByZXF1aXJlKCcuL3NyYy9waWNrQWxsJyksXG4gIHBpY2tCeTogcmVxdWlyZSgnLi9zcmMvcGlja0J5JyksXG4gIHBpcGU6IHJlcXVpcmUoJy4vc3JjL3BpcGUnKSxcbiAgcGlwZUs6IHJlcXVpcmUoJy4vc3JjL3BpcGVLJyksXG4gIHBpcGVQOiByZXF1aXJlKCcuL3NyYy9waXBlUCcpLFxuICBwbHVjazogcmVxdWlyZSgnLi9zcmMvcGx1Y2snKSxcbiAgcHJlcGVuZDogcmVxdWlyZSgnLi9zcmMvcHJlcGVuZCcpLFxuICBwcm9kdWN0OiByZXF1aXJlKCcuL3NyYy9wcm9kdWN0JyksXG4gIHByb2plY3Q6IHJlcXVpcmUoJy4vc3JjL3Byb2plY3QnKSxcbiAgcHJvcDogcmVxdWlyZSgnLi9zcmMvcHJvcCcpLFxuICBwcm9wRXE6IHJlcXVpcmUoJy4vc3JjL3Byb3BFcScpLFxuICBwcm9wSXM6IHJlcXVpcmUoJy4vc3JjL3Byb3BJcycpLFxuICBwcm9wT3I6IHJlcXVpcmUoJy4vc3JjL3Byb3BPcicpLFxuICBwcm9wU2F0aXNmaWVzOiByZXF1aXJlKCcuL3NyYy9wcm9wU2F0aXNmaWVzJyksXG4gIHByb3BzOiByZXF1aXJlKCcuL3NyYy9wcm9wcycpLFxuICByYW5nZTogcmVxdWlyZSgnLi9zcmMvcmFuZ2UnKSxcbiAgcmVkdWNlOiByZXF1aXJlKCcuL3NyYy9yZWR1Y2UnKSxcbiAgcmVkdWNlQnk6IHJlcXVpcmUoJy4vc3JjL3JlZHVjZUJ5JyksXG4gIHJlZHVjZVJpZ2h0OiByZXF1aXJlKCcuL3NyYy9yZWR1Y2VSaWdodCcpLFxuICByZWR1Y2VXaGlsZTogcmVxdWlyZSgnLi9zcmMvcmVkdWNlV2hpbGUnKSxcbiAgcmVkdWNlZDogcmVxdWlyZSgnLi9zcmMvcmVkdWNlZCcpLFxuICByZWplY3Q6IHJlcXVpcmUoJy4vc3JjL3JlamVjdCcpLFxuICByZW1vdmU6IHJlcXVpcmUoJy4vc3JjL3JlbW92ZScpLFxuICByZXBlYXQ6IHJlcXVpcmUoJy4vc3JjL3JlcGVhdCcpLFxuICByZXBsYWNlOiByZXF1aXJlKCcuL3NyYy9yZXBsYWNlJyksXG4gIHJldmVyc2U6IHJlcXVpcmUoJy4vc3JjL3JldmVyc2UnKSxcbiAgc2NhbjogcmVxdWlyZSgnLi9zcmMvc2NhbicpLFxuICBzZXF1ZW5jZTogcmVxdWlyZSgnLi9zcmMvc2VxdWVuY2UnKSxcbiAgc2V0OiByZXF1aXJlKCcuL3NyYy9zZXQnKSxcbiAgc2xpY2U6IHJlcXVpcmUoJy4vc3JjL3NsaWNlJyksXG4gIHNvcnQ6IHJlcXVpcmUoJy4vc3JjL3NvcnQnKSxcbiAgc29ydEJ5OiByZXF1aXJlKCcuL3NyYy9zb3J0QnknKSxcbiAgc29ydFdpdGg6IHJlcXVpcmUoJy4vc3JjL3NvcnRXaXRoJyksXG4gIHNwbGl0OiByZXF1aXJlKCcuL3NyYy9zcGxpdCcpLFxuICBzcGxpdEF0OiByZXF1aXJlKCcuL3NyYy9zcGxpdEF0JyksXG4gIHNwbGl0RXZlcnk6IHJlcXVpcmUoJy4vc3JjL3NwbGl0RXZlcnknKSxcbiAgc3BsaXRXaGVuOiByZXF1aXJlKCcuL3NyYy9zcGxpdFdoZW4nKSxcbiAgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3JjL3N1YnRyYWN0JyksXG4gIHN1bTogcmVxdWlyZSgnLi9zcmMvc3VtJyksXG4gIHN5bW1ldHJpY0RpZmZlcmVuY2U6IHJlcXVpcmUoJy4vc3JjL3N5bW1ldHJpY0RpZmZlcmVuY2UnKSxcbiAgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGg6IHJlcXVpcmUoJy4vc3JjL3N5bW1ldHJpY0RpZmZlcmVuY2VXaXRoJyksXG4gIHRhaWw6IHJlcXVpcmUoJy4vc3JjL3RhaWwnKSxcbiAgdGFrZTogcmVxdWlyZSgnLi9zcmMvdGFrZScpLFxuICB0YWtlTGFzdDogcmVxdWlyZSgnLi9zcmMvdGFrZUxhc3QnKSxcbiAgdGFrZUxhc3RXaGlsZTogcmVxdWlyZSgnLi9zcmMvdGFrZUxhc3RXaGlsZScpLFxuICB0YWtlV2hpbGU6IHJlcXVpcmUoJy4vc3JjL3Rha2VXaGlsZScpLFxuICB0YXA6IHJlcXVpcmUoJy4vc3JjL3RhcCcpLFxuICB0ZXN0OiByZXF1aXJlKCcuL3NyYy90ZXN0JyksXG4gIHRpbWVzOiByZXF1aXJlKCcuL3NyYy90aW1lcycpLFxuICB0b0xvd2VyOiByZXF1aXJlKCcuL3NyYy90b0xvd2VyJyksXG4gIHRvUGFpcnM6IHJlcXVpcmUoJy4vc3JjL3RvUGFpcnMnKSxcbiAgdG9QYWlyc0luOiByZXF1aXJlKCcuL3NyYy90b1BhaXJzSW4nKSxcbiAgdG9TdHJpbmc6IHJlcXVpcmUoJy4vc3JjL3RvU3RyaW5nJyksXG4gIHRvVXBwZXI6IHJlcXVpcmUoJy4vc3JjL3RvVXBwZXInKSxcbiAgdHJhbnNkdWNlOiByZXF1aXJlKCcuL3NyYy90cmFuc2R1Y2UnKSxcbiAgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3NyYy90cmFuc3Bvc2UnKSxcbiAgdHJhdmVyc2U6IHJlcXVpcmUoJy4vc3JjL3RyYXZlcnNlJyksXG4gIHRyaW06IHJlcXVpcmUoJy4vc3JjL3RyaW0nKSxcbiAgdHJ5Q2F0Y2g6IHJlcXVpcmUoJy4vc3JjL3RyeUNhdGNoJyksXG4gIHR5cGU6IHJlcXVpcmUoJy4vc3JjL3R5cGUnKSxcbiAgdW5hcHBseTogcmVxdWlyZSgnLi9zcmMvdW5hcHBseScpLFxuICB1bmFyeTogcmVxdWlyZSgnLi9zcmMvdW5hcnknKSxcbiAgdW5jdXJyeU46IHJlcXVpcmUoJy4vc3JjL3VuY3VycnlOJyksXG4gIHVuZm9sZDogcmVxdWlyZSgnLi9zcmMvdW5mb2xkJyksXG4gIHVuaW9uOiByZXF1aXJlKCcuL3NyYy91bmlvbicpLFxuICB1bmlvbldpdGg6IHJlcXVpcmUoJy4vc3JjL3VuaW9uV2l0aCcpLFxuICB1bmlxOiByZXF1aXJlKCcuL3NyYy91bmlxJyksXG4gIHVuaXFCeTogcmVxdWlyZSgnLi9zcmMvdW5pcUJ5JyksXG4gIHVuaXFXaXRoOiByZXF1aXJlKCcuL3NyYy91bmlxV2l0aCcpLFxuICB1bmxlc3M6IHJlcXVpcmUoJy4vc3JjL3VubGVzcycpLFxuICB1bm5lc3Q6IHJlcXVpcmUoJy4vc3JjL3VubmVzdCcpLFxuICB1bnRpbDogcmVxdWlyZSgnLi9zcmMvdW50aWwnKSxcbiAgdXBkYXRlOiByZXF1aXJlKCcuL3NyYy91cGRhdGUnKSxcbiAgdXNlV2l0aDogcmVxdWlyZSgnLi9zcmMvdXNlV2l0aCcpLFxuICB2YWx1ZXM6IHJlcXVpcmUoJy4vc3JjL3ZhbHVlcycpLFxuICB2YWx1ZXNJbjogcmVxdWlyZSgnLi9zcmMvdmFsdWVzSW4nKSxcbiAgdmlldzogcmVxdWlyZSgnLi9zcmMvdmlldycpLFxuICB3aGVuOiByZXF1aXJlKCcuL3NyYy93aGVuJyksXG4gIHdoZXJlOiByZXF1aXJlKCcuL3NyYy93aGVyZScpLFxuICB3aGVyZUVxOiByZXF1aXJlKCcuL3NyYy93aGVyZUVxJyksXG4gIHdpdGhvdXQ6IHJlcXVpcmUoJy4vc3JjL3dpdGhvdXQnKSxcbiAgeHByb2Q6IHJlcXVpcmUoJy4vc3JjL3hwcm9kJyksXG4gIHppcDogcmVxdWlyZSgnLi9zcmMvemlwJyksXG4gIHppcE9iajogcmVxdWlyZSgnLi9zcmMvemlwT2JqJyksXG4gIHppcFdpdGg6IHJlcXVpcmUoJy4vc3JjL3ppcFdpdGgnKVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvaW5kZXguanMiLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IG9mIGFuIGFycmF5LCByZXR1cm5pbmcgYVxuICogbmV3IGNvcHkgb2YgdGhlIGFycmF5IHdpdGggdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IHJlcGxhY2VkIHdpdGggdGhlXG4gKiByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IGEpIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gaWR4IFRoZSBpbmRleC5cbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBsaXN0IEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdob3NlIHZhbHVlXG4gKiAgICAgICAgYXQgdGhlIHN1cHBsaWVkIGluZGV4IHdpbGwgYmUgcmVwbGFjZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBjb3B5IG9mIHRoZSBzdXBwbGllZCBhcnJheS1saWtlIG9iamVjdCB3aXRoXG4gKiAgICAgICAgIHRoZSBlbGVtZW50IGF0IGluZGV4IGBpZHhgIHJlcGxhY2VkIHdpdGggdGhlIHZhbHVlXG4gKiAgICAgICAgIHJldHVybmVkIGJ5IGFwcGx5aW5nIGBmbmAgdG8gdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIFIudXBkYXRlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hZGp1c3QoUi5hZGQoMTApLCAxLCBbMSwgMiwgM10pOyAgICAgLy89PiBbMSwgMTIsIDNdXG4gKiAgICAgIFIuYWRqdXN0KFIuYWRkKDEwKSkoMSkoWzEsIDIsIDNdKTsgICAgIC8vPT4gWzEsIDEyLCAzXVxuICogQHN5bWIgUi5hZGp1c3QoZiwgLTEsIFthLCBiXSkgPSBbYSwgZihiKV1cbiAqIEBzeW1iIFIuYWRqdXN0KGYsIDAsIFthLCBiXSkgPSBbZihhKSwgYl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGFkanVzdChmbiwgaWR4LCBsaXN0KSB7XG4gIGlmIChpZHggPj0gbGlzdC5sZW5ndGggfHwgaWR4IDwgLWxpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gaWR4IDwgMCA/IGxpc3QubGVuZ3RoIDogMDtcbiAgdmFyIF9pZHggPSBzdGFydCArIGlkeDtcbiAgdmFyIF9saXN0ID0gX2NvbmNhdChsaXN0KTtcbiAgX2xpc3RbX2lkeF0gPSBmbihsaXN0W19pZHhdKTtcbiAgcmV0dXJuIF9saXN0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9hZGp1c3QuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBhcmd1bWVudHMgYXJlIGB0cnVlYDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgYSAtPiBiIC0+IGEgfCBiXG4gKiBAcGFyYW0ge0FueX0gYVxuICogQHBhcmFtIHtBbnl9IGJcbiAqIEByZXR1cm4ge0FueX0gdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0IGlzIGZhbHN5LCBvdGhlcndpc2UgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIEBzZWUgUi5ib3RoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hbmQodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmFuZCh0cnVlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5hbmQoZmFsc2UsIHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW5kKGZhbHNlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGFuZChhLCBiKSB7XG4gIHJldHVybiBhICYmIGI7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2FuZC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94YW55ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGFueScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIG9mIGVsZW1lbnRzIG9mIHRoZSBsaXN0IG1hdGNoIHRoZSBwcmVkaWNhdGUsXG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgYW55YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkIGJ5IGF0IGxlYXN0IG9uZSBlbGVtZW50LCBgZmFsc2VgXG4gKiAgICAgICAgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbGwsIFIubm9uZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGVzc1RoYW4wID0gUi5mbGlwKFIubHQpKDApO1xuICogICAgICB2YXIgbGVzc1RoYW4yID0gUi5mbGlwKFIubHQpKDIpO1xuICogICAgICBSLmFueShsZXNzVGhhbjApKFsxLCAyXSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5hbnkobGVzc1RoYW4yKShbMSwgMl0pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydhbnknXSwgX3hhbnksIGZ1bmN0aW9uIGFueShmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9hbnkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQXBwbGllcyBmdW5jdGlvbiBgZm5gIHRvIHRoZSBhcmd1bWVudCBsaXN0IGBhcmdzYC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiBjcmVhdGluZyBhIGZpeGVkLWFyaXR5IGZ1bmN0aW9uIGZyb20gYSB2YXJpYWRpYyBmdW5jdGlvbi4gYGZuYCBzaG91bGQgYmUgYVxuICogYm91bmQgZnVuY3Rpb24gaWYgY29udGV4dCBpcyBzaWduaWZpY2FudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiBhKSAtPiBbKl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYGFyZ3NgXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gY2FsbCBgZm5gIHdpdGhcbiAqIEByZXR1cm4geyp9IHJlc3VsdCBUaGUgcmVzdWx0LCBlcXVpdmFsZW50IHRvIGBmbiguLi5hcmdzKWBcbiAqIEBzZWUgUi5jYWxsLCBSLnVuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbnVtcyA9IFsxLCAyLCAzLCAtOTksIDQyLCA2LCA3XTtcbiAqICAgICAgUi5hcHBseShNYXRoLm1heCwgbnVtcyk7IC8vPT4gNDJcbiAqIEBzeW1iIFIuYXBwbHkoZiwgW2EsIGIsIGNdKSA9IGYoYSwgYiwgYylcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGFwcGx5KGZuLCBhcmdzKSB7XG4gIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYXBwbHkuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcbnZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJyYXknKTtcbnZhciBfaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNJbnRlZ2VyJyk7XG52YXIgYXNzb2MgPSByZXF1aXJlKCcuL2Fzc29jJyk7XG5cblxuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBzZXR0aW5nIG9yIG92ZXJyaWRpbmcgdGhlIG5vZGVzIHJlcXVpcmVkXG4gKiB0byBjcmVhdGUgdGhlIGdpdmVuIHBhdGgsIGFuZCBwbGFjaW5nIHRoZSBzcGVjaWZpYyB2YWx1ZSBhdCB0aGUgdGFpbCBlbmQgb2ZcbiAqIHRoYXQgcGF0aC4gTm90ZSB0aGF0IHRoaXMgY29waWVzIGFuZCBmbGF0dGVucyBwcm90b3R5cGUgcHJvcGVydGllcyBvbnRvIHRoZVxuICogbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBbSWR4XSAtPiBhIC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggdGhlIHBhdGggdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgbmV3IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGV4Y2VwdCBhbG9uZyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKiBAc2VlIFIuZGlzc29jUGF0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXNzb2NQYXRoKFsnYScsICdiJywgJ2MnXSwgNDIsIHthOiB7Yjoge2M6IDB9fX0pOyAvLz0+IHthOiB7Yjoge2M6IDQyfX19XG4gKlxuICogICAgICAvLyBBbnkgbWlzc2luZyBvciBub24tb2JqZWN0IGtleXMgaW4gcGF0aCB3aWxsIGJlIG92ZXJyaWRkZW5cbiAqICAgICAgUi5hc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCA0Miwge2E6IDV9KTsgLy89PiB7YToge2I6IHtjOiA0Mn19fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gYXNzb2NQYXRoKHBhdGgsIHZhbCwgb2JqKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFyIGlkeCA9IHBhdGhbMF07XG4gIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbmV4dE9iaiA9IF9oYXMoaWR4LCBvYmopID8gb2JqW2lkeF0gOiBfaXNJbnRlZ2VyKHBhdGhbMV0pID8gW10gOiB7fTtcbiAgICB2YWwgPSBhc3NvY1BhdGgoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocGF0aCwgMSksIHZhbCwgbmV4dE9iaik7XG4gIH1cbiAgaWYgKF9pc0ludGVnZXIoaWR4KSAmJiBfaXNBcnJheShvYmopKSB7XG4gICAgdmFyIGFyciA9IFtdLmNvbmNhdChvYmopO1xuICAgIGFycltpZHhdID0gdmFsO1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc29jKGlkeCwgdmFsLCBvYmopO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2Fzc29jUGF0aC5qcyIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIGJvdW5kIHRvIGEgY29udGV4dC5cbiAqIE5vdGU6IGBSLmJpbmRgIGRvZXMgbm90IHByb3ZpZGUgdGhlIGFkZGl0aW9uYWwgYXJndW1lbnQtYmluZGluZyBjYXBhYmlsaXRpZXMgb2ZcbiAqIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKCogLT4gKikgLT4geyp9IC0+ICgqIC0+ICopXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmluZCB0byBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc09iaiBUaGUgY29udGV4dCB0byBiaW5kIGBmbmAgdG9cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIGluIHRoZSBjb250ZXh0IG9mIGB0aGlzT2JqYC5cbiAqIEBzZWUgUi5wYXJ0aWFsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGxvZyA9IFIuYmluZChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gKiAgICAgIFIucGlwZShSLmFzc29jKCdhJywgMiksIFIudGFwKGxvZyksIFIuYXNzb2MoJ2EnLCAzKSkoe2E6IDF9KTsgLy89PiB7YTogM31cbiAqICAgICAgLy8gbG9ncyB7YTogMn1cbiAqIEBzeW1iIFIuYmluZChmLCBvKShhLCBiKSA9IGYuY2FsbChvLCBhLCBiKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gYmluZChmbiwgdGhpc09iaikge1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmosIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9iaW5kLmpzIiwidmFyIGNoYWluID0gcmVxdWlyZSgnLi9jaGFpbicpO1xudmFyIGNvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmlnaHQtdG8tbGVmdCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAqXG4gKiBgUi5jb21wb3NlSyhoLCBnLCBmKWAgaXMgZXF1aXZhbGVudCB0byBgUi5jb21wb3NlKFIuY2hhaW4oaCksIFIuY2hhaW4oZyksIFIuY2hhaW4oZikpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgQ2hhaW4gbSA9PiAoKHkgLT4gbSB6KSwgKHggLT4gbSB5KSwgLi4uLCAoYSAtPiBtIGIpKSAtPiAoYSAtPiBtIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSAuLi5mdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5waXBlS1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgICAvLyAgZ2V0IDo6IFN0cmluZyAtPiBPYmplY3QgLT4gTWF5YmUgKlxuICogICAgICAgdmFyIGdldCA9IFIuY3VycnkoKHByb3BOYW1lLCBvYmopID0+IE1heWJlKG9ialtwcm9wTmFtZV0pKVxuICpcbiAqICAgICAgIC8vICBnZXRTdGF0ZUNvZGUgOjogTWF5YmUgU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICogICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIuY29tcG9zZUsoXG4gKiAgICAgICAgIFIuY29tcG9zZShNYXliZS5vZiwgUi50b1VwcGVyKSxcbiAqICAgICAgICAgZ2V0KCdzdGF0ZScpLFxuICogICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAqICAgICAgICAgZ2V0KCd1c2VyJyksXG4gKiAgICAgICApO1xuICogICAgICAgZ2V0U3RhdGVDb2RlKHtcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0pOyAvLz0+IE1heWJlLkp1c3QoXCJOWVwiKVxuICogICAgICAgZ2V0U3RhdGVDb2RlKHt9KTsgLy89PiBNYXliZS5Ob3RoaW5nKClcbiAqIEBzeW1iIFIuY29tcG9zZUsoZiwgZywgaCkoYSkgPSBSLmNoYWluKGYsIFIuY2hhaW4oZywgaChhKSkpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcG9zZUsoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb3NlSyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICB2YXIgaW5pdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBsYXN0ID0gaW5pdC5wb3AoKTtcbiAgcmV0dXJuIGNvbXBvc2UoY29tcG9zZS5hcHBseSh0aGlzLCBtYXAoY2hhaW4sIGluaXQpKSwgbGFzdCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY29tcG9zZUsuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGN1cnJ5ID0gcmVxdWlyZSgnLi9jdXJyeScpO1xudmFyIG5BcnkgPSByZXF1aXJlKCcuL25BcnknKTtcblxuXG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBzYW1lIHR5cGUuIFRoZSBhcml0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGlzIHNwZWNpZmllZCB0byBhbGxvdyB1c2luZyB2YXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGFyaXR5IG9mIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgd3JhcHBlZCwgY3VycmllZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBWYXJpYWRpYyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICogICAgICBmdW5jdGlvbiBTYWxhZCgpIHtcbiAqICAgICAgICB0aGlzLmluZ3JlZGllbnRzID0gYXJndW1lbnRzO1xuICogICAgICB9O1xuICogICAgICBTYWxhZC5wcm90b3R5cGUucmVjaXBlID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgdmFyIGluc3RydWN0aW9ucyA9IFIubWFwKChpbmdyZWRpZW50KSA9PiAoXG4gKiAgICAgICAgICAnQWRkIGEgd2hvbGxvcCBvZiAnICsgaW5ncmVkaWVudCwgdGhpcy5pbmdyZWRpZW50cylcbiAqICAgICAgICApXG4gKiAgICAgICAgcmV0dXJuIFIuam9pbignXFxuJywgaW5zdHJ1Y3Rpb25zKVxuICogICAgICB9XG4gKlxuICogICAgICB2YXIgVGhyZWVMYXllclNhbGFkID0gUi5jb25zdHJ1Y3ROKDMsIFNhbGFkKVxuICpcbiAqICAgICAgLy8gTm90aWNlIHdlIG5vIGxvbmdlciBuZWVkIHRoZSAnbmV3JyBrZXl3b3JkLCBhbmQgdGhlIGNvbnN0cnVjdG9yIGlzIGN1cnJpZWQgZm9yIDMgYXJndW1lbnRzLlxuICogICAgICB2YXIgc2FsYWQgPSBUaHJlZUxheWVyU2FsYWQoJ01heW9ubmFpc2UnKSgnUG90YXRvIENoaXBzJykoJ0tldGNodXAnKVxuICogICAgICBjb25zb2xlLmxvZyhzYWxhZC5yZWNpcGUoKSk7XG4gKiAgICAgIC8vIEFkZCBhIHdob2xsb3Agb2YgTWF5b25uYWlzZVxuICogICAgICAvLyBBZGQgYSB3aG9sbG9wIG9mIFBvdGF0byBDaGlwc1xuICogICAgICAvLyBBZGQgYSB3aG9sbG9wIG9mIFBvdGF0byBLZXRjaHVwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBjb25zdHJ1Y3ROKG4sIEZuKSB7XG4gIGlmIChuID4gMTApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cnVjdG9yIHdpdGggZ3JlYXRlciB0aGFuIHRlbiBhcmd1bWVudHMnKTtcbiAgfVxuICBpZiAobiA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBGbigpOyB9O1xuICB9XG4gIHJldHVybiBjdXJyeShuQXJ5KG4sIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgsICQ5KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlICAxOiByZXR1cm4gbmV3IEZuKCQwKTtcbiAgICAgIGNhc2UgIDI6IHJldHVybiBuZXcgRm4oJDAsICQxKTtcbiAgICAgIGNhc2UgIDM6IHJldHVybiBuZXcgRm4oJDAsICQxLCAkMik7XG4gICAgICBjYXNlICA0OiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzKTtcbiAgICAgIGNhc2UgIDU6IHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0KTtcbiAgICAgIGNhc2UgIDY6IHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSk7XG4gICAgICBjYXNlICA3OiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2KTtcbiAgICAgIGNhc2UgIDg6IHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3KTtcbiAgICAgIGNhc2UgIDk6IHJldHVybiBuZXcgRm4oJDAsICQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCk7XG4gICAgICBjYXNlIDEwOiByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgsICQ5KTtcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY29uc3RydWN0Ti5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG52YXIgbWF4ID0gcmVxdWlyZSgnLi9tYXgnKTtcbnZhciBwbHVjayA9IHJlcXVpcmUoJy4vcGx1Y2snKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuXG5cbi8qKlxuICogQWNjZXB0cyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gYW5kIGEgbGlzdCBvZiBicmFuY2hpbmcgZnVuY3Rpb25zIGFuZCByZXR1cm5zXG4gKiBhIG5ldyBmdW5jdGlvbi4gV2hlbiBpbnZva2VkLCB0aGlzIG5ldyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHNvbWVcbiAqIGFyZ3VtZW50cywgZWFjaCBicmFuY2hpbmcgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aG9zZSBzYW1lIGFyZ3VtZW50cy4gVGhlXG4gKiByZXN1bHRzIG9mIGVhY2ggYnJhbmNoaW5nIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIHRoZSBjb252ZXJnaW5nXG4gKiBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSByZXR1cm4gdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4yXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKHgxIC0+IHgyIC0+IC4uLiAtPiB6KSAtPiBbKGEgLT4gYiAtPiAuLi4gLT4geDEpLCAoYSAtPiBiIC0+IC4uLiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFmdGVyIEEgZnVuY3Rpb24uIGBhZnRlcmAgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhlIHJldHVybiB2YWx1ZXMgb2ZcbiAqICAgICAgICBgZm4xYCBhbmQgYGZuMmAgYXMgaXRzIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IGZ1bmN0aW9ucyBBIGxpc3Qgb2YgZnVuY3Rpb25zLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uLlxuICogQHNlZSBSLnVzZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYXZlcmFnZSA9IFIuY29udmVyZ2UoUi5kaXZpZGUsIFtSLnN1bSwgUi5sZW5ndGhdKVxuICogICAgICBhdmVyYWdlKFsxLCAyLCAzLCA0LCA1LCA2LCA3XSkgLy89PiA0XG4gKlxuICogICAgICB2YXIgc3RyYW5nZUNvbmNhdCA9IFIuY29udmVyZ2UoUi5jb25jYXQsIFtSLnRvVXBwZXIsIFIudG9Mb3dlcl0pXG4gKiAgICAgIHN0cmFuZ2VDb25jYXQoXCJZb2RlbFwiKSAvLz0+IFwiWU9ERUx5b2RlbFwiXG4gKlxuICogQHN5bWIgUi5jb252ZXJnZShmLCBbZywgaF0pKGEsIGIpID0gZihnKGEsIGIpLCBoKGEsIGIpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gY29udmVyZ2UoYWZ0ZXIsIGZucykge1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCBmbnMpKSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIHJldHVybiBhZnRlci5hcHBseShjb250ZXh0LCBfbWFwKGZ1bmN0aW9uKGZuKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSwgZm5zKSk7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jb252ZXJnZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWNvbmQgYXJndW1lbnQgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmBcbiAqIG90aGVyd2lzZSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHthfSBkZWZhdWx0IFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtifSB2YWwgYHZhbGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBkZWZhdWx0YCB1bmxlc3MgYHZhbGAgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYC5cbiAqIEByZXR1cm4geyp9IFRoZSBzZWNvbmQgdmFsdWUgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmAsIG90aGVyd2lzZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkZWZhdWx0VG80MiA9IFIuZGVmYXVsdFRvKDQyKTtcbiAqXG4gKiAgICAgIGRlZmF1bHRUbzQyKG51bGwpOyAgLy89PiA0MlxuICogICAgICBkZWZhdWx0VG80Mih1bmRlZmluZWQpOyAgLy89PiA0MlxuICogICAgICBkZWZhdWx0VG80MignUmFtZGEnKTsgIC8vPT4gJ1JhbWRhJ1xuICogICAgICAvLyBwYXJzZUludCgnc3RyaW5nJykgcmVzdWx0cyBpbiBOYU5cbiAqICAgICAgZGVmYXVsdFRvNDIocGFyc2VJbnQoJ3N0cmluZycpKTsgLy89PiA0MlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZGVmYXVsdFRvKGQsIHYpIHtcbiAgcmV0dXJuIHYgPT0gbnVsbCB8fCB2ICE9PSB2ID8gZCA6IHY7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2RlZmF1bHRUby5qcyIsInZhciBfY29udGFpbnMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb250YWlucycpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIEZpbmRzIHRoZSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBmaXJzdCBsaXN0IG5vdFxuICogY29udGFpbmVkIGluIHRoZSBzZWNvbmQgbGlzdC4gT2JqZWN0cyBhbmQgQXJyYXlzIGFyZSBjb21wYXJlZCBhcmUgY29tcGFyZWRcbiAqIGluIHRlcm1zIG9mIHZhbHVlIGVxdWFsaXR5LCBub3QgcmVmZXJlbmNlIGVxdWFsaXR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFsqXSAtPiBbKl0gLT4gWypdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZWxlbWVudHMgaW4gYGxpc3QxYCB0aGF0IGFyZSBub3QgaW4gYGxpc3QyYC5cbiAqIEBzZWUgUi5kaWZmZXJlbmNlV2l0aCwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlLCBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaWZmZXJlbmNlKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFsxLDJdXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbNyw2LDUsNCwzXSwgWzEsMiwzLDRdKTsgLy89PiBbNyw2LDVdXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbe2E6IDF9LCB7YjogMn1dLCBbe2E6IDF9LCB7YzogM31dKSAvLz0+IFt7YjogMn1dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBkaWZmZXJlbmNlKGZpcnN0LCBzZWNvbmQpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGZpcnN0TGVuID0gZmlyc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgZmlyc3RMZW4pIHtcbiAgICBpZiAoIV9jb250YWlucyhmaXJzdFtpZHhdLCBzZWNvbmQpICYmICFfY29udGFpbnMoZmlyc3RbaWR4XSwgb3V0KSkge1xuICAgICAgb3V0W291dC5sZW5ndGhdID0gZmlyc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZGlmZmVyZW5jZS5qcyIsInZhciBfY29udGFpbnNXaXRoID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29udGFpbnNXaXRoJyk7XG52YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gKiBjb250YWluZWQgaW4gdGhlIHNlY29uZCBsaXN0LiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gKiBAc2VlIFIuZGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlLCBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGNtcCA9ICh4LCB5KSA9PiB4LmEgPT09IHkuYTtcbiAqICAgICAgdmFyIGwxID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICogICAgICB2YXIgbDIgPSBbe2E6IDN9LCB7YTogNH1dO1xuICogICAgICBSLmRpZmZlcmVuY2VXaXRoKGNtcCwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn1dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBkaWZmZXJlbmNlV2l0aChwcmVkLCBmaXJzdCwgc2Vjb25kKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBmaXJzdExlbiA9IGZpcnN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgaWYgKCFfY29udGFpbnNXaXRoKHByZWQsIGZpcnN0W2lkeF0sIHNlY29uZCkgJiZcbiAgICAgICAgIV9jb250YWluc1dpdGgocHJlZCwgZmlyc3RbaWR4XSwgb3V0KSkge1xuICAgICAgb3V0LnB1c2goZmlyc3RbaWR4XSk7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2RpZmZlcmVuY2VXaXRoLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgZG9lcyBub3QgY29udGFpbiBhIGBwcm9wYCBwcm9wZXJ0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFN0cmluZyAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZGlzc29jaWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBidXQgd2l0aG91dCB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gKiBAc2VlIFIuYXNzb2NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRpc3NvYygnYicsIHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4ge2E6IDEsIGM6IDN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBkaXNzb2MocHJvcCwgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICByZXN1bHRbcF0gPSBvYmpbcF07XG4gIH1cbiAgZGVsZXRlIHJlc3VsdFtwcm9wXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZGlzc29jLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hkcm9wID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGRyb3AnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gKiB0cmFuc2R1Y2VyL3RyYW5zZm9ybWVyIChvciBvYmplY3Qgd2l0aCBhIGBkcm9wYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBkcm9wYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtbYV19IGxpc3RcbiAqIEByZXR1cm4ge1thXX0gQSBjb3B5IG9mIGxpc3Qgd2l0aG91dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzXG4gKiBAc2VlIFIudGFrZSwgUi50cmFuc2R1Y2UsIFIuZHJvcExhc3QsIFIuZHJvcFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kcm9wKDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXInLCAnYmF6J11cbiAqICAgICAgUi5kcm9wKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICogICAgICBSLmRyb3AoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3AoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3AoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnZGEnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFsnZHJvcCddLCBfeGRyb3AsIGZ1bmN0aW9uIGRyb3AobiwgeHMpIHtcbiAgcmV0dXJuIHNsaWNlKE1hdGgubWF4KDAsIG4pLCBJbmZpbml0eSwgeHMpO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZHJvcC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZHJvcFJlcGVhdHNXaXRoID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGRyb3BSZXBlYXRzV2l0aCcpO1xudmFyIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRob3V0IGFueSBjb25zZWN1dGl2ZWx5IHJlcGVhdGluZyBlbGVtZW50cy4gRXF1YWxpdHkgaXNcbiAqIGRldGVybWluZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byBlYWNoIHBhaXIgb2YgY29uc2VjdXRpdmUgZWxlbWVudHMuIFRoZVxuICogZmlyc3QgZWxlbWVudCBpbiBhIHNlcmllcyBvZiBlcXVhbCBlbGVtZW50cyB3aWxsIGJlIHByZXNlcnZlZC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEsIGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gYGxpc3RgIHdpdGhvdXQgcmVwZWF0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsID0gWzEsIC0xLCAxLCAzLCA0LCAtNCwgLTQsIC01LCA1LCAzLCAzXTtcbiAqICAgICAgUi5kcm9wUmVwZWF0c1dpdGgoUi5lcUJ5KE1hdGguYWJzKSwgbCk7IC8vPT4gWzEsIDMsIDQsIC01LCAzXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbXSwgX3hkcm9wUmVwZWF0c1dpdGgsIGZ1bmN0aW9uIGRyb3BSZXBlYXRzV2l0aChwcmVkLCBsaXN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGlkeCA9IDE7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbiAhPT0gMCkge1xuICAgIHJlc3VsdFswXSA9IGxpc3RbMF07XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKCFwcmVkKGxhc3QocmVzdWx0KSwgbGlzdFtpZHhdKSkge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pKTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZHJvcFJlcGVhdHNXaXRoLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FyZ3VtZW50cycpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc09iamVjdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzT2JqZWN0Jyk7XG52YXIgX2lzU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNTdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVtcHR5IHZhbHVlIG9mIGl0cyBhcmd1bWVudCdzIHR5cGUuIFJhbWRhIGRlZmluZXMgdGhlIGVtcHR5XG4gKiB2YWx1ZSBvZiBBcnJheSAoYFtdYCksIE9iamVjdCAoYHt9YCksIFN0cmluZyAoYCcnYCksIGFuZCBBcmd1bWVudHMuIE90aGVyXG4gKiB0eXBlcyBhcmUgc3VwcG9ydGVkIGlmIHRoZXkgZGVmaW5lIGA8VHlwZT4uZW1wdHlgIGFuZC9vclxuICogYDxUeXBlPi5wcm90b3R5cGUuZW1wdHlgLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBlbXB0eWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBhIC0+IGFcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmVtcHR5KEp1c3QoNDIpKTsgICAgICAvLz0+IE5vdGhpbmcoKVxuICogICAgICBSLmVtcHR5KFsxLCAyLCAzXSk7ICAgICAvLz0+IFtdXG4gKiAgICAgIFIuZW1wdHkoJ3VuaWNvcm5zJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi5lbXB0eSh7eDogMSwgeTogMn0pOyAgLy89PiB7fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gZW1wdHkoeCkge1xuICByZXR1cm4gKFxuICAgICh4ICE9IG51bGwgJiYgdHlwZW9mIHguZW1wdHkgPT09ICdmdW5jdGlvbicpID9cbiAgICAgIHguZW1wdHkoKSA6XG4gICAgKHggIT0gbnVsbCAmJiB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiYgdHlwZW9mIHguY29uc3RydWN0b3IuZW1wdHkgPT09ICdmdW5jdGlvbicpID9cbiAgICAgIHguY29uc3RydWN0b3IuZW1wdHkoKSA6XG4gICAgX2lzQXJyYXkoeCkgP1xuICAgICAgW10gOlxuICAgIF9pc1N0cmluZyh4KSA/XG4gICAgICAnJyA6XG4gICAgX2lzT2JqZWN0KHgpID9cbiAgICAgIHt9IDpcbiAgICBfaXNBcmd1bWVudHMoeCkgP1xuICAgICAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpIDpcbiAgICAvLyBlbHNlXG4gICAgICB2b2lkIDBcbiAgKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZW1wdHkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0cyBhcmd1bWVudHMgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBWYWx1ZXMgYXJlXG4gKiBpZGVudGljYWwgaWYgdGhleSByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5LiBgTmFOYCBpcyBpZGVudGljYWwgdG8gYE5hTmA7XG4gKiBgMGAgYW5kIGAtMGAgYXJlIG5vdCBpZGVudGljYWwuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbyA9IHt9O1xuICogICAgICBSLmlkZW50aWNhbChvLCBvKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pZGVudGljYWwoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChbXSwgW10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDAsIC0wKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChOYU4sIE5hTik7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gaWRlbnRpY2FsKGEsIGIpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoYSA9PT0gYikgeyAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaWRlbnRpY2FsLmpzIiwidmFyIF9jbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuXG4vKipcbiAqIENvcGllcyBhbiBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNvcGllZFxuICogQHBhcmFtIHtBcnJheX0gcmVmRnJvbSBBcnJheSBjb250YWluaW5nIHRoZSBzb3VyY2UgcmVmZXJlbmNlc1xuICogQHBhcmFtIHtBcnJheX0gcmVmVG8gQXJyYXkgY29udGFpbmluZyB0aGUgY29waWVkIHNvdXJjZSByZWZlcmVuY2VzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgV2hldGhlciBvciBub3QgdG8gcGVyZm9ybSBkZWVwIGNsb25pbmcuXG4gKiBAcmV0dXJuIHsqfSBUaGUgY29waWVkIHZhbHVlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jbG9uZSh2YWx1ZSwgcmVmRnJvbSwgcmVmVG8sIGRlZXApIHtcbiAgdmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KGNvcGllZFZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHJlZkZyb20ubGVuZ3RoO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcmVmRnJvbVtpZHhdKSB7XG4gICAgICAgIHJldHVybiByZWZUb1tpZHhdO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJlZkZyb21baWR4ICsgMV0gPSB2YWx1ZTtcbiAgICByZWZUb1tpZHggKyAxXSA9IGNvcGllZFZhbHVlO1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29waWVkVmFsdWVba2V5XSA9IGRlZXAgP1xuICAgICAgICBfY2xvbmUodmFsdWVba2V5XSwgcmVmRnJvbSwgcmVmVG8sIHRydWUpIDogdmFsdWVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcGllZFZhbHVlO1xuICB9O1xuICBzd2l0Y2ggKHR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSAnT2JqZWN0JzogIHJldHVybiBjb3B5KHt9KTtcbiAgICBjYXNlICdBcnJheSc6ICAgcmV0dXJuIGNvcHkoW10pO1xuICAgIGNhc2UgJ0RhdGUnOiAgICByZXR1cm4gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKTtcbiAgICBjYXNlICdSZWdFeHAnOiAgcmV0dXJuIF9jbG9uZVJlZ0V4cCh2YWx1ZSk7XG4gICAgZGVmYXVsdDogICAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19jbG9uZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2Nsb25lUmVnRXhwKHBhdHRlcm4pIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIChwYXR0ZXJuLmdsb2JhbCAgICAgPyAnZycgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGF0dGVybi5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwYXR0ZXJuLnN0aWNreSAgICAgPyAneScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhdHRlcm4udW5pY29kZSAgICA/ICd1JyA6ICcnKSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Nsb25lUmVnRXhwLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY29tcGxlbWVudChmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY29tcGxlbWVudC5qcyIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL19hcml0eScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcihjb25jYXQpIHtcbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICByZXR1cm4gX2FyaXR5KE1hdGgubWF4KDAsIGZuLmxlbmd0aCAtIGFyZ3MubGVuZ3RoKSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgY29uY2F0KGFyZ3MsIGFyZ3VtZW50cykpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9maWx0ZXIoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19maWx0ZXIuanMiLCJ2YXIgZXF1YWxzID0gcmVxdWlyZSgnLi4vZXF1YWxzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaW5kZXhPZihsaXN0LCBhLCBpZHgpIHtcbiAgdmFyIGluZiwgaXRlbTtcbiAgLy8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgZG9lc24ndCBleGlzdCBiZWxvdyBJRTlcbiAgaWYgKHR5cGVvZiBsaXN0LmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgIC8vIG1hbnVhbGx5IGNyYXdsIHRoZSBsaXN0IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gKzAgYW5kIC0wXG4gICAgICAgICAgaW5mID0gMSAvIGE7XG4gICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IDAgJiYgMSAvIGl0ZW0gPT09IGluZikge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhICE9PSBhKSB7XG4gICAgICAgICAgLy8gTmFOXG4gICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyAmJiBpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vbi16ZXJvIG51bWJlcnMgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcblxuICAgICAgLy8gYWxsIHRoZXNlIHR5cGVzIGNhbiB1dGlsaXNlIFNldFxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIG51bGwgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGFueXRoaW5nIGVsc2Ugbm90IGNvdmVyZWQgYWJvdmUsIGRlZmVyIHRvIFIuZXF1YWxzXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChlcXVhbHMobGlzdFtpZHhdLCBhKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19pbmRleE9mLmpzIiwidmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScgP1xuICAgIGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7IHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJzsgfSA6XG4gICAgZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHsgcmV0dXJuIF9oYXMoJ2NhbGxlZScsIHgpOyB9O1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19pc0FyZ3VtZW50cy5qcyIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBwYXNzZWQgYXJndW1lbnQgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBuXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uIF9pc0ludGVnZXIobikge1xuICByZXR1cm4gKG4gPDwgMCkgPT09IG47XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzSW50ZWdlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzTnVtYmVyKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzTnVtYmVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNPYmplY3QoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pc0FycmF5TGlrZScpO1xuXG5cbi8qKlxuICogYF9tYWtlRmxhdGAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgb25lLWxldmVsIG9yIGZ1bGx5IHJlY3Vyc2l2ZVxuICogZnVuY3Rpb24gYmFzZWQgb24gdGhlIGZsYWcgcGFzc2VkIGluLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX21ha2VGbGF0KHJlY3Vyc2l2ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZmxhdHQobGlzdCkge1xuICAgIHZhciB2YWx1ZSwgamxlbiwgajtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGlsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpZHggPCBpbGVuKSB7XG4gICAgICBpZiAoaXNBcnJheUxpa2UobGlzdFtpZHhdKSkge1xuICAgICAgICB2YWx1ZSA9IHJlY3Vyc2l2ZSA/IGZsYXR0KGxpc3RbaWR4XSkgOiBsaXN0W2lkeF07XG4gICAgICAgIGogPSAwO1xuICAgICAgICBqbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZVtqXTtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19tYWtlRmxhdC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL19yZWR1Y2VkJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYQW55KGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5hbnkgPSBmYWxzZTtcbiAgfVxuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5hbnkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWEFueS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuYW55ID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hhbnkoZiwgeGYpIHsgcmV0dXJuIG5ldyBYQW55KGYsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hhbnkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWERyb3BSZXBlYXRzV2l0aChwcmVkLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLnByZWQgPSBwcmVkO1xuICAgIHRoaXMubGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VlbkZpcnN0VmFsdWUgPSBmYWxzZTtcbiAgfVxuXG4gIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHZhciBzYW1lQXNMYXN0ID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLnNlZW5GaXJzdFZhbHVlKSB7XG4gICAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlZCh0aGlzLmxhc3RWYWx1ZSwgaW5wdXQpKSB7XG4gICAgICBzYW1lQXNMYXN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0VmFsdWUgPSBpbnB1dDtcbiAgICByZXR1cm4gc2FtZUFzTGFzdCA/IHJlc3VsdCA6IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHsgcmV0dXJuIG5ldyBYRHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hkcm9wUmVwZWF0c1dpdGguanMiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICB0aGlzLmYgPSBmbjtcbiAgfVxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbm90IGltcGxlbWVudGVkIG9uIFhXcmFwJyk7XG4gIH07XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24oYWNjKSB7IHJldHVybiBhY2M7IH07XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiB0aGlzLmYoYWNjLCB4KTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gX3h3cmFwKGZuKSB7IHJldHVybiBuZXcgWFdyYXAoZm4pOyB9O1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194d3JhcC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBTZWUgaWYgYW4gb2JqZWN0IChgdmFsYCkgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHN1cHBsaWVkIGNvbnN0cnVjdG9yLiBUaGlzXG4gKiBmdW5jdGlvbiB3aWxsIGNoZWNrIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiwgaWYgYW55LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgKCogLT4geyp9KSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdG9yIEEgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXMoT2JqZWN0LCB7fSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE51bWJlciwgMSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE9iamVjdCwgMSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pcyhTdHJpbmcsICdzJyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKFN0cmluZywgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhPYmplY3QsIG5ldyBTdHJpbmcoJycpKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoT2JqZWN0LCAncycpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXMoTnVtYmVyLCB7fSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGlzKEN0b3IsIHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBDdG9yIHx8IHZhbCBpbnN0YW5jZW9mIEN0b3I7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2lzLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBjb252ZXJnZSA9IHJlcXVpcmUoJy4vY29udmVyZ2UnKTtcblxuXG4vKipcbiAqIGp1eHQgYXBwbGllcyBhIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGEgbGlzdCBvZiB2YWx1ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIFsoYSwgYiwgLi4uLCBtKSAtPiBuXSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4gW25dKVxuICogQHBhcmFtIHtBcnJheX0gZm5zIEFuIGFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiB2YWx1ZXMgYWZ0ZXIgYXBwbHlpbmcgZWFjaCBvZiB0aGUgb3JpZ2luYWwgYGZuc2AgdG8gaXRzIHBhcmFtZXRlcnMuXG4gKiBAc2VlIFIuYXBwbHlTcGVjXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdldFJhbmdlID0gUi5qdXh0KFtNYXRoLm1pbiwgTWF0aC5tYXhdKTtcbiAqICAgICAgZ2V0UmFuZ2UoMywgNCwgOSwgLTMpOyAvLz0+IFstMywgOV1cbiAqIEBzeW1iIFIuanV4dChbZiwgZywgaF0pKGEsIGIpID0gW2YoYSwgYiksIGcoYSwgYiksIGgoYSwgYildXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBqdXh0KGZucykge1xuICByZXR1cm4gY29udmVyZ2UoZnVuY3Rpb24oKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApOyB9LCBmbnMpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9qdXh0LmpzIiwidmFyIG50aCA9IHJlcXVpcmUoJy4vbnRoJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmluaXQsIFIuaGVhZCwgUi50YWlsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sYXN0KFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+ICdmdW0nXG4gKiAgICAgIFIubGFzdChbXSk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLmxhc3QoJ2FiYycpOyAvLz0+ICdjJ1xuICogICAgICBSLmxhc3QoJycpOyAvLz0+ICcnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gbnRoKC0xKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2xhc3QuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9pc051bWJlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzTnVtYmVyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5IGJ5IHJldHVybmluZyBgbGlzdC5sZW5ndGhgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sZW5ndGgoW10pOyAvLz0+IDBcbiAqICAgICAgUi5sZW5ndGgoWzEsIDIsIDNdKTsgLy89PiAzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBsZW5ndGgobGlzdCkge1xuICByZXR1cm4gbGlzdCAhPSBudWxsICYmIF9pc051bWJlcihsaXN0Lmxlbmd0aCkgPyBsaXN0Lmxlbmd0aCA6IE5hTjtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbGVuZ3RoLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgYXAgPSByZXF1aXJlKCcuL2FwJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5cbi8qKlxuICogXCJsaWZ0c1wiIGEgZnVuY3Rpb24gdG8gYmUgdGhlIHNwZWNpZmllZCBhcml0eSwgc28gdGhhdCBpdCBtYXkgXCJtYXAgb3ZlclwiIHRoYXRcbiAqIG1hbnkgbGlzdHMsIEZ1bmN0aW9ucyBvciBvdGhlciBvYmplY3RzIHRoYXQgc2F0aXNmeSB0aGUgW0ZhbnRhc3lMYW5kIEFwcGx5IHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHkpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKi4uLiAtPiAqKSAtPiAoWypdLi4uIC0+IFsqXSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBsaWZ0IGludG8gaGlnaGVyIGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgbGlmdGVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmxpZnQsIFIuYXBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbWFkZDMgPSBSLmxpZnROKDMsICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKSk7XG4gKiAgICAgIG1hZGQzKFsxLDIsM10sIFsxLDIsM10sIFsxXSk7IC8vPT4gWzMsIDQsIDUsIDQsIDUsIDYsIDUsIDYsIDddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBsaWZ0Tihhcml0eSwgZm4pIHtcbiAgdmFyIGxpZnRlZCA9IGN1cnJ5Tihhcml0eSwgZm4pO1xuICByZXR1cm4gY3VycnlOKGFyaXR5LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3JlZHVjZShhcCwgbWFwKGxpZnRlZCwgYXJndW1lbnRzWzBdKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9saWZ0Ti5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgc3VtID0gcmVxdWlyZSgnLi9zdW0nKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1lYW4gb2YgdGhlIGdpdmVuIGxpc3Qgb2YgbnVtYmVycy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lYW4oWzIsIDcsIDldKTsgLy89PiA2XG4gKiAgICAgIFIubWVhbihbXSk7IC8vPT4gTmFOXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBtZWFuKGxpc3QpIHtcbiAgcmV0dXJuIHN1bShsaXN0KSAvIGxpc3QubGVuZ3RoO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9tZWFuLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuIElmXG4gKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5XG4gKiBhbmQgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiBlYWNoIG9iamVjdCwgd2l0aCB0aGUgcmVzdWx0IGJlaW5nXG4gKiB1c2VkIGFzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LiBUaGUga2V5XG4gKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJldHVybmVkIG9iamVjdCBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIChTdHJpbmcgLT4gYSAtPiBhIC0+IGEpIC0+IHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2UsIFIubWVyZ2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgbGV0IGNvbmNhdFZhbHVlcyA9IChrLCBsLCByKSA9PiBrID09ICd2YWx1ZXMnID8gUi5jb25jYXQobCwgcikgOiByXG4gKiAgICAgIFIubWVyZ2VXaXRoS2V5KGNvbmNhdFZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgICAgeyBhOiB0cnVlLCB0aGluZzogJ2ZvbycsIHZhbHVlczogWzEwLCAyMF0gfSxcbiAqICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCB0aGluZzogJ2JhcicsIHZhbHVlczogWzE1LCAzNV0gfSk7XG4gKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCB0aGluZzogJ2JhcicsIHZhbHVlczogWzEwLCAyMCwgMTUsIDM1XSB9XG4gKiBAc3ltYiBSLm1lcmdlV2l0aEtleShmLCB7IHg6IDEsIHk6IDIgfSwgeyB5OiA1LCB6OiAzIH0pID0geyB4OiAxLCB5OiBmKCd5JywgMiwgNSksIHo6IDMgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gbWVyZ2VXaXRoS2V5KGZuLCBsLCByKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGs7XG5cbiAgZm9yIChrIGluIGwpIHtcbiAgICBpZiAoX2hhcyhrLCBsKSkge1xuICAgICAgcmVzdWx0W2tdID0gX2hhcyhrLCByKSA/IGZuKGssIGxba10sIHJba10pIDogbFtrXTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGsgaW4gcikge1xuICAgIGlmIChfaGFzKGssIHIpICYmICEoX2hhcyhrLCByZXN1bHQpKSkge1xuICAgICAgcmVzdWx0W2tdID0gcltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9tZXJnZVdpdGhLZXkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAqIGJgIGJ1dCBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgKiBiYC5cbiAqIEBzZWUgUi5kaXZpZGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZG91YmxlID0gUi5tdWx0aXBseSgyKTtcbiAqICAgICAgdmFyIHRyaXBsZSA9IFIubXVsdGlwbHkoMyk7XG4gKiAgICAgIGRvdWJsZSgzKTsgICAgICAgLy89PiAgNlxuICogICAgICB0cmlwbGUoNCk7ICAgICAgIC8vPT4gMTJcbiAqICAgICAgUi5tdWx0aXBseSgyLCA1KTsgIC8vPT4gMTBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHsgcmV0dXJuIGEgKiBiOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL211bHRpcGx5LmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBgIWAgb2YgaXRzIGFyZ3VtZW50LiBJdCB3aWxsIHJldHVybiBgdHJ1ZWAgd2hlblxuICogcGFzc2VkIGZhbHNlLXkgdmFsdWUsIGFuZCBgZmFsc2VgIHdoZW4gcGFzc2VkIGEgdHJ1dGgteSBvbmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGEgYW55IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0aGUgbG9naWNhbCBpbnZlcnNlIG9mIHBhc3NlZCBhcmd1bWVudC5cbiAqIEBzZWUgUi5jb21wbGVtZW50XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5ub3QodHJ1ZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ub3QoZmFsc2UpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ub3QoMCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vdCgxKTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbm90KGEpIHtcbiAgcmV0dXJuICFhO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9ub3QuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBhIHNpbmdsZSBrZXk6dmFsdWUgcGFpci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IHtTdHJpbmc6YX1cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIucGFpclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYXRjaFBocmFzZXMgPSBSLmNvbXBvc2UoXG4gKiAgICAgICAgUi5vYmpPZignbXVzdCcpLFxuICogICAgICAgIFIubWFwKFIub2JqT2YoJ21hdGNoX3BocmFzZScpKVxuICogICAgICApO1xuICogICAgICBtYXRjaFBocmFzZXMoWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiB7bXVzdDogW3ttYXRjaF9waHJhc2U6ICdmb28nfSwge21hdGNoX3BocmFzZTogJ2Jhcid9LCB7bWF0Y2hfcGhyYXNlOiAnYmF6J31dfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gb2JqT2Yoa2V5LCB2YWwpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBvYmpba2V5XSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvb2JqT2YuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggb2YgaXRzIGFyZ3VtZW50cyBhcmUgYHRydWVgLiBSZXR1cm5zIGBmYWxzZWBcbiAqIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgZmFsc2VgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHtBbnl9IGFcbiAqIEBwYXJhbSB7QW55fSBiXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSBmaXJzdCBhcmd1bWVudCBpZiB0cnV0aHksIG90aGVyd2lzZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHNlZSBSLmVpdGhlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIub3IodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm9yKHRydWUsIGZhbHNlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIub3IoZmFsc2UsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5vcihmYWxzZSwgZmFsc2UpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBvcihhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL29yLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBcInNldHRpbmdcIiB0aGUgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmVcbiAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG9cbiAqIHRoZSBmb2N1c2VkIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIExlbnMgcyBhIC0+IChhIC0+IGEpIC0+IHMgLT4gc1xuICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gKiBAcGFyYW0geyp9IHZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBoZWFkTGVucyA9IFIubGVuc0luZGV4KDApO1xuICpcbiAqICAgICAgUi5vdmVyKGhlYWRMZW5zLCBSLnRvVXBwZXIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydGT08nLCAnYmFyJywgJ2JheiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvLyBgSWRlbnRpdHlgIGlzIGEgZnVuY3RvciB0aGF0IGhvbGRzIGEgc2luZ2xlIHZhbHVlLCB3aGVyZSBgbWFwYCBzaW1wbHlcbiAgLy8gdHJhbnNmb3JtcyB0aGUgaGVsZCB2YWx1ZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgdmFyIElkZW50aXR5ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB7dmFsdWU6IHgsIG1hcDogZnVuY3Rpb24oZikgeyByZXR1cm4gSWRlbnRpdHkoZih4KSk7IH19O1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkzKGZ1bmN0aW9uIG92ZXIobGVucywgZiwgeCkge1xuICAgIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIGlzIGZpcnN0IHRyYW5zZm9ybWVkIHdpdGggYGZgLFxuICAgIC8vIHRoZW4gc2V0IGFzIHRoZSB2YWx1ZSBvZiBhbiBgSWRlbnRpdHlgLiBUaGlzIGlzIHRoZW4gbWFwcGVkIG92ZXIgd2l0aCB0aGVcbiAgICAvLyBzZXR0ZXIgZnVuY3Rpb24gb2YgdGhlIGxlbnMuXG4gICAgcmV0dXJuIGxlbnMoZnVuY3Rpb24oeSkgeyByZXR1cm4gSWRlbnRpdHkoZih5KSk7IH0pKHgpLnZhbHVlO1xuICB9KTtcbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9vdmVyLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHBpY2tgIGV4Y2VwdCB0aGF0IHRoaXMgb25lIGluY2x1ZGVzIGEgYGtleTogdW5kZWZpbmVkYCBwYWlyIGZvclxuICogcHJvcGVydGllcyB0aGF0IGRvbid0IGV4aXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkgb250byBhIG5ldyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBvbiBpdC5cbiAqIEBzZWUgUi5waWNrXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5waWNrQWxsKFsnYScsICdkJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2E6IDEsIGQ6IDR9XG4gKiAgICAgIFIucGlja0FsbChbJ2EnLCAnZScsICdmJ10sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2E6IDEsIGU6IHVuZGVmaW5lZCwgZjogdW5kZWZpbmVkfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcGlja0FsbChuYW1lcywgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVzW2lkeF07XG4gICAgcmVzdWx0W25hbWVdID0gb2JqW25hbWVdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3BpY2tBbGwuanMiLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXJpdHknKTtcbnZhciBfcGlwZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3BpcGUnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xudmFyIHRhaWwgPSByZXF1aXJlKCcuL3RhaWwnKTtcblxuXG4vKipcbiAqIFBlcmZvcm1zIGxlZnQtdG8tcmlnaHQgZnVuY3Rpb24gY29tcG9zaXRpb24uIFRoZSBsZWZ0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGZ1bmN0aW9ucyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEluIHNvbWUgbGlicmFyaWVzIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYHNlcXVlbmNlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIHJlc3VsdCBvZiBwaXBlIGlzIG5vdCBhdXRvbWF0aWNhbGx5IGN1cnJpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCgoYSwgYiwgLi4uLCBuKSAtPiBvKSwgKG8gLT4gcCksIC4uLiwgKHggLT4geSksICh5IC0+IHopKSAtPiAoKGEsIGIsIC4uLiwgbikgLT4geilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBmID0gUi5waXBlKE1hdGgucG93LCBSLm5lZ2F0ZSwgUi5pbmMpO1xuICpcbiAqICAgICAgZigzLCA0KTsgLy8gLSgzXjQpICsgMVxuICogQHN5bWIgUi5waXBlKGYsIGcsIGgpKGEsIGIpID0gaChnKGYoYSwgYikpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBpcGUoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWR1Y2UoX3BpcGUsIGFyZ3VtZW50c1swXSwgdGFpbChhcmd1bWVudHMpKSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcGlwZS5qcyIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9waXBlUCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3BpcGVQJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB0YWlsID0gcmVxdWlyZSgnLi90YWlsJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSBsZWZ0bW9zdCBmdW5jdGlvbiBtYXkgaGF2ZSBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zXG4gKiBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEgLT4gUHJvbWlzZSBiKSwgKGIgLT4gUHJvbWlzZSBjKSwgLi4uLCAoeSAtPiBQcm9taXNlIHopKSAtPiAoYSAtPiBQcm9taXNlIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VQXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIGZvbGxvd2Vyc0ZvclVzZXIgOjogU3RyaW5nIC0+IFByb21pc2UgW1VzZXJdXG4gKiAgICAgIHZhciBmb2xsb3dlcnNGb3JVc2VyID0gUi5waXBlUChkYi5nZXRVc2VyQnlJZCwgZGIuZ2V0Rm9sbG93ZXJzKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlUCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBfYXJpdHkoYXJndW1lbnRzWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWR1Y2UoX3BpcGVQLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3BpcGVQLmpzIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb25jYXQnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aCB0aGUgZ2l2ZW4gZWxlbWVudCBhdCB0aGUgZnJvbnQsIGZvbGxvd2VkIGJ5IHRoZVxuICogY29udGVudHMgb2YgdGhlIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0gZWwgVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBoZWFkIG9mIHRoZSBvdXRwdXQgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGFkZCB0byB0aGUgdGFpbCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIuYXBwZW5kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcmVwZW5kKCdmZWUnLCBbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiBbJ2ZlZScsICdmaScsICdmbycsICdmdW0nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcHJlcGVuZChlbCwgbGlzdCkge1xuICByZXR1cm4gX2NvbmNhdChbZWxdLCBsaXN0KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcHJlcGVuZC5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nXG4gKiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogU2ltaWxhciB0byBgcmVkdWNlYCwgZXhjZXB0IG1vdmVzIHRocm91Z2ggdGhlIGlucHV0IGxpc3QgZnJvbSB0aGUgcmlnaHQgdG9cbiAqIHRoZSBsZWZ0LlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKHZhbHVlLCBhY2MpKiwgd2hpbGUgdGhlIGFyZ3VtZW50cydcbiAqIG9yZGVyIG9mIGByZWR1Y2VgJ3MgaXRlcmF0b3IgZnVuY3Rpb24gaXMgKihhY2MsIHZhbHVlKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlUmlnaHRgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlsc1xuICogb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHQjRGVzY3JpcHRpb25cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhLCBiIC0+IGIpIC0+IGIgLT4gW2FdIC0+IGJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICogICAgICAgIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZWR1Y2VSaWdodChSLnN1YnRyYWN0LCAwLCBbMSwgMiwgMywgNF0pIC8vID0+ICgxIC0gKDIgLSAoMyAtICg0IC0gMCkpKSkgPSAtMlxuICogICAgICAgICAgLSAgICAgICAgICAgICAgIC0yXG4gKiAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAxICAgLSAgICAgICAgICAgIDEgICAzXG4gKiAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgMiAgIC0gICAgID09PiAgICAyICAtMVxuICogICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAgICAgICAzICAgLSAgICAgICAgICAgIDMgICA0XG4gKiAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgICAgICAgICA0ICAgMCAgICAgICAgICAgIDQgICAwXG4gKlxuICogQHN5bWIgUi5yZWR1Y2VSaWdodChmLCBhLCBbYiwgYywgZF0pID0gZihiLCBmKGMsIGYoZCwgYSkpKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcmVkdWNlUmlnaHQoZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBhY2MgPSBmbihsaXN0W2lkeF0sIGFjYyk7XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcmVkdWNlUmlnaHQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGFwID0gcmVxdWlyZSgnLi9hcCcpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgcHJlcGVuZCA9IHJlcXVpcmUoJy4vcHJlcGVuZCcpO1xudmFyIHJlZHVjZVJpZ2h0ID0gcmVxdWlyZSgnLi9yZWR1Y2VSaWdodCcpO1xuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIFtUcmF2ZXJzYWJsZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZSlcbiAqIG9mIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSkgaW50byBhblxuICogQXBwbGljYXRpdmUgb2YgVHJhdmVyc2FibGUuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNlcXVlbmNlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKGEgLT4gZiBhKSAtPiB0IChmIGEpIC0+IGYgKHQgYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9mXG4gKiBAcGFyYW0geyp9IHRyYXZlcnNhYmxlXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnRyYXZlcnNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldKTsgICAvLz0+IEp1c3QoWzEsIDIsIDNdKVxuICogICAgICBSLnNlcXVlbmNlKE1heWJlLm9mLCBbSnVzdCgxKSwgSnVzdCgyKSwgTm90aGluZygpXSk7IC8vPT4gTm90aGluZygpXG4gKlxuICogICAgICBSLnNlcXVlbmNlKFIub2YsIEp1c3QoWzEsIDIsIDNdKSk7IC8vPT4gW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldXG4gKiAgICAgIFIuc2VxdWVuY2UoUi5vZiwgTm90aGluZygpKTsgICAgICAgLy89PiBbTm90aGluZygpXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gc2VxdWVuY2Uob2YsIHRyYXZlcnNhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdHJhdmVyc2FibGUuc2VxdWVuY2UgPT09ICdmdW5jdGlvbicgP1xuICAgIHRyYXZlcnNhYmxlLnNlcXVlbmNlKG9mKSA6XG4gICAgcmVkdWNlUmlnaHQoZnVuY3Rpb24oeCwgYWNjKSB7IHJldHVybiBhcChtYXAocHJlcGVuZCwgeCksIGFjYyk7IH0sXG4gICAgICAgICAgICAgICAgb2YoW10pLFxuICAgICAgICAgICAgICAgIHRyYXZlcnNhYmxlKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvc2VxdWVuY2UuanMiLCJ2YXIgYWRkID0gcmVxdWlyZSgnLi9hZGQnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCcuL3JlZHVjZScpO1xuXG5cbi8qKlxuICogQWRkcyB0b2dldGhlciBhbGwgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdW0gb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3VtKFsyLDQsNiw4LDEwMCwxXSk7IC8vPT4gMTIxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlKGFkZCwgMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9zdW0uanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeHRha2UgPSByZXF1aXJlKCcuL2ludGVybmFsL194dGFrZScpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gKiB0cmFuc2R1Y2VyL3RyYW5zZm9ybWVyIChvciBvYmplY3Qgd2l0aCBhIGB0YWtlYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmRyb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRha2UoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gKiAgICAgIFIudGFrZSgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKiAgICAgIFIudGFrZSgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2UoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlKDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqXG4gKiAgICAgIHZhciBwZXJzb25uZWwgPSBbXG4gKiAgICAgICAgJ0RhdmUgQnJ1YmVjaycsXG4gKiAgICAgICAgJ1BhdWwgRGVzbW9uZCcsXG4gKiAgICAgICAgJ0V1Z2VuZSBXcmlnaHQnLFxuICogICAgICAgICdKb2UgTW9yZWxsbycsXG4gKiAgICAgICAgJ0dlcnJ5IE11bGxpZ2FuJyxcbiAqICAgICAgICAnQm9iIEJhdGVzJyxcbiAqICAgICAgICAnSm9lIERvZGdlJyxcbiAqICAgICAgICAnUm9uIENyb3R0eSdcbiAqICAgICAgXTtcbiAqXG4gKiAgICAgIHZhciB0YWtlRml2ZSA9IFIudGFrZSg1KTtcbiAqICAgICAgdGFrZUZpdmUocGVyc29ubmVsKTtcbiAqICAgICAgLy89PiBbJ0RhdmUgQnJ1YmVjaycsICdQYXVsIERlc21vbmQnLCAnRXVnZW5lIFdyaWdodCcsICdKb2UgTW9yZWxsbycsICdHZXJyeSBNdWxsaWdhbiddXG4gKiBAc3ltYiBSLnRha2UoLTEsIFthLCBiXSkgPSBbYSwgYl1cbiAqIEBzeW1iIFIudGFrZSgwLCBbYSwgYl0pID0gW11cbiAqIEBzeW1iIFIudGFrZSgxLCBbYSwgYl0pID0gW2FdXG4gKiBAc3ltYiBSLnRha2UoMiwgW2EsIGJdKSA9IFthLCBiXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbJ3Rha2UnXSwgX3h0YWtlLCBmdW5jdGlvbiB0YWtlKG4sIHhzKSB7XG4gIHJldHVybiBzbGljZSgwLCBuIDwgMCA/IEluZmluaXR5IDogbiwgeHMpO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdGFrZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBDYWxscyBhbiBpbnB1dCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZXN1bHRzXG4gKiBvZiB0aG9zZSBmdW5jdGlvbiBjYWxscy5cbiAqXG4gKiBgZm5gIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IFRoZSBjdXJyZW50IHZhbHVlIG9mIGBuYCwgd2hpY2ggYmVnaW5zIGF0IGAwYFxuICogYW5kIGlzIGdyYWR1YWxseSBpbmNyZW1lbnRlZCB0byBgbiAtIDFgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuM1xuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKE51bWJlciAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBQYXNzZWQgb25lIGFyZ3VtZW50LCB0aGUgY3VycmVudCB2YWx1ZSBvZiBgbmAuXG4gKiBAcGFyYW0ge051bWJlcn0gbiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgbiAtIDFgLiBJbmNyZW1lbnRzIGFmdGVyIGVhY2ggZnVuY3Rpb24gY2FsbC5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiBAc3ltYiBSLnRpbWVzKGYsIDApID0gW11cbiAqIEBzeW1iIFIudGltZXMoZiwgMSkgPSBbZigwKV1cbiAqIEBzeW1iIFIudGltZXMoZiwgMikgPSBbZigwKSwgZigxKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHRpbWVzKGZuLCBuKSB7XG4gIHZhciBsZW4gPSBOdW1iZXIobik7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGlzdDtcblxuICBpZiAobGVuIDwgMCB8fCBpc05hTihsZW4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgfVxuICBsaXN0ID0gbmV3IEFycmF5KGxlbik7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBsaXN0W2lkeF0gPSBmbihpZHgpO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBsaXN0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90aW1lcy5qcyIsInZhciBfU2V0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fU2V0Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSBvbmUgY29weSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gdG9cbiAqIGVhY2ggbGlzdCBlbGVtZW50LiBQcmVmZXJzIHRoZSBmaXJzdCBpdGVtIGlmIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBwcm9kdWNlc1xuICogdGhlIHNhbWUgdmFsdWUgb24gdHdvIGl0ZW1zLiBgUi5lcXVhbHNgIGlzIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gYikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB1c2VkIHRvIHByb2R1Y2UgYSB2YWx1ZSB0byB1c2UgZHVyaW5nIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5pcUJ5KE1hdGguYWJzLCBbLTEsIC01LCAyLCAxMCwgMSwgMl0pOyAvLz0+IFstMSwgLTUsIDIsIDEwXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdW5pcUJ5KGZuLCBsaXN0KSB7XG4gIHZhciBzZXQgPSBuZXcgX1NldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgYXBwbGllZEl0ZW0sIGl0ZW07XG5cbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICBhcHBsaWVkSXRlbSA9IGZuKGl0ZW0pO1xuICAgIGlmIChzZXQuYWRkKGFwcGxpZWRJdGVtKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3VuaXFCeS5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgYWRqdXN0ID0gcmVxdWlyZSgnLi9hZGp1c3QnKTtcbnZhciBhbHdheXMgPSByZXF1aXJlKCcuL2Fsd2F5cycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjb3B5IG9mIHRoZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleFxuICogcmVwbGFjZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBUaGUgaW5kZXggdG8gdXBkYXRlLlxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byBleGlzdCBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgdGhlIHJldHVybmVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IGxpc3QgVGhlIHNvdXJjZSBhcnJheS1saWtlIG9iamVjdCB0byBiZSB1cGRhdGVkLlxuICogQHJldHVybiB7QXJyYXl9IEEgY29weSBvZiBgbGlzdGAgd2l0aCB0aGUgdmFsdWUgYXQgaW5kZXggYGlkeGAgcmVwbGFjZWQgd2l0aCBgeGAuXG4gKiBAc2VlIFIuYWRqdXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51cGRhdGUoMSwgMTEsIFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAqICAgICAgUi51cGRhdGUoMSkoMTEpKFswLCAxLCAyXSk7ICAgICAvLz0+IFswLCAxMSwgMl1cbiAqIEBzeW1iIFIudXBkYXRlKC0xLCBhLCBbYiwgY10pID0gW2IsIGFdXG4gKiBAc3ltYiBSLnVwZGF0ZSgwLCBhLCBbYiwgY10pID0gW2EsIGNdXG4gKiBAc3ltYiBSLnVwZGF0ZSgxLCBhLCBbYiwgY10pID0gW2IsIGFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiB1cGRhdGUoaWR4LCB4LCBsaXN0KSB7XG4gIHJldHVybiBhZGp1c3QoYWx3YXlzKHgpLCBpZHgsIGxpc3QpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91cGRhdGUuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG5cblxuLyoqXG4gKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgYSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9ucyBhbmQgcmV0dXJucyBhXG4gKiBuZXcgY3VycmllZCBmdW5jdGlvbi4gV2hlbiB0aGUgbmV3IGZ1bmN0aW9uIGlzIGludm9rZWQsIGl0IGNhbGxzIHRoZVxuICogZnVuY3Rpb24gYGZuYCB3aXRoIHBhcmFtZXRlcnMgY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZWFjaFxuICogc3VwcGxpZWQgaGFuZGxlciBvbiBzdWNjZXNzaXZlIGFyZ3VtZW50cyB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICpcbiAqIElmIG1vcmUgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRoYW4gdHJhbnNmb3JtZXJcbiAqIGZ1bmN0aW9ucywgdGhvc2UgYXJndW1lbnRzIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gYGZuYCBhcyBhZGRpdGlvbmFsXG4gKiBwYXJhbWV0ZXJzLiBJZiB5b3UgZXhwZWN0IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZVxuICogdHJhbnNmb3JtZWQsIGFsdGhvdWdoIHlvdSBjYW4gaWdub3JlIHRoZW0sIGl0J3MgYmVzdCB0byBwYXNzIGFuIGlkZW50aXR5XG4gKiBmdW5jdGlvbiBzbyB0aGF0IHRoZSBuZXcgZnVuY3Rpb24gcmVwb3J0cyB0aGUgY29ycmVjdCBhcml0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoeDEgLT4geDIgLT4gLi4uIC0+IHopIC0+IFsoYSAtPiB4MSksIChiIC0+IHgyKSwgLi4uXSAtPiAoYSAtPiBiIC0+IC4uLiAtPiB6KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1lcnMgQSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmNvbnZlcmdlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5pZGVudGl0eSwgUi5pZGVudGl0eV0pKDMsIDQpOyAvLz0+IDgxXG4gKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzKSg0KTsgLy89PiA4MVxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmRlYywgUi5pbmNdKSgzLCA0KTsgLy89PiAzMlxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmRlYywgUi5pbmNdKSgzKSg0KTsgLy89PiAzMlxuICogQHN5bWIgUi51c2VXaXRoKGYsIFtnLCBoXSkoYSwgYikgPSBmKGcoYSksIGgoYikpXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB1c2VXaXRoKGZuLCB0cmFuc2Zvcm1lcnMpIHtcbiAgcmV0dXJuIGN1cnJ5Tih0cmFuc2Zvcm1lcnMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCB0cmFuc2Zvcm1lcnMubGVuZ3RoKSB7XG4gICAgICBhcmdzLnB1c2godHJhbnNmb3JtZXJzW2lkeF0uY2FsbCh0aGlzLCBhcmd1bWVudHNbaWR4XSkpO1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIHRyYW5zZm9ybWVycy5sZW5ndGgpKSk7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91c2VXaXRoLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZGlmZmVyZW50XG4gKiBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBbdl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi52YWx1ZXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbMSwgMiwgM11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgdmFscyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhbHNbaWR4XSA9IG9ialtwcm9wc1tpZHhdXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gdmFscztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdmFsdWVzLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gKiB0aGUgc3BlYy4gRWFjaCBvZiB0aGUgc3BlYydzIG93biBwcm9wZXJ0aWVzIG11c3QgYmUgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBFYWNoIHByZWRpY2F0ZSBpcyBhcHBsaWVkIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBvZiB0aGVcbiAqIHRlc3Qgb2JqZWN0LiBgd2hlcmVgIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUsIGZhbHNlXG4gKiBvdGhlcndpc2UuXG4gKlxuICogYHdoZXJlYCBpcyB3ZWxsIHN1aXRlZCB0byBkZWNsYXJhdGl2ZWx5IGV4cHJlc3NpbmcgY29uc3RyYWludHMgZm9yIG90aGVyXG4gKiBmdW5jdGlvbnMgc3VjaCBhcyBgZmlsdGVyYCBhbmQgYGZpbmRgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAoKiAtPiBCb29sZWFuKX0gLT4ge1N0cmluZzogKn0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IHNwZWNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIHByZWQgOjogT2JqZWN0IC0+IEJvb2xlYW5cbiAqICAgICAgdmFyIHByZWQgPSBSLndoZXJlKHtcbiAqICAgICAgICBhOiBSLmVxdWFscygnZm9vJyksXG4gKiAgICAgICAgYjogUi5jb21wbGVtZW50KFIuZXF1YWxzKCdiYXInKSksXG4gKiAgICAgICAgeDogUi5ndChfXywgMTApLFxuICogICAgICAgIHk6IFIubHQoX18sIDIwKVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gdHJ1ZVxuICogICAgICBwcmVkKHthOiAneHh4JywgYjogJ3h4eCcsIHg6IDExLCB5OiAxOX0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAnYmFyJywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICd4eHgnLCB4OiAxMCwgeTogMTl9KTsgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDExLCB5OiAyMH0pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB3aGVyZShzcGVjLCB0ZXN0T2JqKSB7XG4gIGZvciAodmFyIHByb3AgaW4gc3BlYykge1xuICAgIGlmIChfaGFzKHByb3AsIHNwZWMpICYmICFzcGVjW3Byb3BdKHRlc3RPYmpbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy93aGVyZS5qcyIsIi8vVGhlIGNvbXBsZXRlIGZ1bmN0aW9uIGluIG9yZGVyIHRvIGdldCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB6b25lcyBvZiB0aGF0IGpvdXJuZXkgKHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gZHVhbCB6b25lcylcbi8vIHN0YXRpb25zIGlzIHRoZSAuanNvbiBmaWxlIGZyb20gZmV0Y2hTdGF0aW9uc0RhdGEoKSBmdW5jdGlvblxuLy8gTmVlZCB0byBtYWtlIGl0IHNvIHRoYXQgaXQgZ2VuZXJhdGVzIGl0IGFmdGVyIGVhY2ggam91cm5leVxuXG5pbXBvcnQgZ2V0RGF0YSBmcm9tICcuLi91dGlsaXR5L19nZXREYXRhJztcbmltcG9ydCB7XG5cdGZsYXR0ZW4sXG5cdGdldFpvbmVzLFxuXHRmaWx0ZXJab25lc0J5TnVtYmVyLFxuXHRtaW5OdW0sXG5cdG1heE51bVxufSBmcm9tICcuLi91dGlsaXR5L191dGlsaXR5JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2luZ2xlSm91cm5leVpvbmVzKGZyb20sIHRvLCBzdGF0aW9ucykge1xuXHRyZXR1cm4gZ2V0RGF0YS5qb3VybmV5KGZyb20sIHRvKS50aGVuKGZ1bmN0aW9uKGpvdXJuZXkpIHtcblx0XHR2YXIgam91cm5leSA9IGpvdXJuZXkuam91cm5leXNbMF07IC8vIHNlbGVjdGluZyBvbmx5IHRoZSBmaXJzdCBqb3VybmV5IGZyb20gdGhlIEFQSVxuXHRcdHZhciBsZWdzID0gam91cm5leS5sZWdzOyAvL1RvIGxvb2sgYXQgZWFjaCBsZWcgb2YgdGhlIGpvdXJuZXlcblxuXHRcdC8vIFRoZSBhcnJheSBvZiB6b25lcyBhc3NvY2lhdGVkIHdpdGggYWxsIHN0YXRpb25zIG9mIHRoYXQgam91cm5leVxuXHRcdHZhciBhbGxab25lcyA9IGZsYXR0ZW4obGVncy5tYXAoZnVuY3Rpb24obGVnKSB7XG5cdFx0XHR2YXIgdGVtcFpvbmVzID0gW107XG5cblx0XHRcdC8vR2V0cyB0aGUgem9uZXMgb2YgdGhlIGRlcGFydHVyZVBvaW50cyBhbmQgYWRkcyB0aGVtIHRvIGFsbFpvbmVzIGFycmF5XG5cdFx0XHRpZiAobGVnLmRlcGFydHVyZVBvaW50ICYmIGxlZy5kZXBhcnR1cmVQb2ludC5uYXB0YW5JZCkgeyBcblx0XHRcdFx0dGVtcFpvbmVzLnB1c2goZ2V0Wm9uZXMobGVnLmRlcGFydHVyZVBvaW50Lm5hcHRhbklkLCBzdGF0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL0dldHMgdGhlIHpvbmVzIG9mIHRoZSBTdG9wUG9pbnQgYW5kIGFkZHMgdGhlbSB0byBhbGxab25lcyBhcnJheVxuXHRcdFx0aWYgKGxlZy5wYXRoLnN0b3BQb2ludHMgJiYgbGVnLnBhdGguc3RvcFBvaW50cy5sZW5ndGggPiAwKSB7IFxuXHRcdFx0XHRsZWcucGF0aC5zdG9wUG9pbnRzLmZvckVhY2goZnVuY3Rpb24oc3RvcFBvaW50KSB7XG5cdFx0XHRcdFx0aWYgKHN0b3BQb2ludC5pZCkge1xuXHRcdFx0XHRcdFx0dGVtcFpvbmVzLnB1c2goZ2V0Wm9uZXMoc3RvcFBvaW50LmlkLCBzdGF0aW9ucykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZW1wWm9uZXM7XG5cdFx0fSkpO1xuXG5cblx0XHQvL0ZpbHRlcnMgYWxsIHRoZSBzdGF0aW9ucyBhbmQgc3BsaXQgdGhlbSBpbnRvIHpvbmVzRnJvbVNpbmdsZVN0YXRpb25zIGFuZCB6b25lc0Zyb21EdWFsU3RhdGlvbnNcblx0XHQvLyB2YXIgem9uZXNGcm9tU2luZ2xlU3RhdGlvbnMgPSBmbGF0dGVuKGZpbHRlclpvbmVzQnlOdW1iZXIoMSwgYWxsWm9uZXMpKTtcblx0XHR2YXIgem9uZXNGcm9tU2luZ2xlU3RhdGlvbnMgPSBmaWx0ZXJab25lc0J5TnVtYmVyKDEsIGFsbFpvbmVzKTtcblx0XHR2YXIgem9uZXNGcm9tRHVhbFN0YXRpb25zID0gZmlsdGVyWm9uZXNCeU51bWJlcigyLCBhbGxab25lcyk7IC8vTkIgdGhpcyBpcyBhbiBhcnJheSB3aXRoaW4gYW4gYXJyYXlcblx0XHR2YXIgZmluYWxNYXhab25lID0gbnVsbDtcblx0XHR2YXIgZmluYWxNaW5ab25lID0gbnVsbDtcblxuXHRcdGlmICh6b25lc0Zyb21TaW5nbGVTdGF0aW9ucy5sZW5ndGggPT09IDApIHsgLy9mb3IgZHVhbCB6b25lcyB0byBkdWFsIHpvbmVzICoqQVNTVU1JTkcgQ0FOIE9OTFkgVFJBVkVMIEZST00gVEhFIFNBTUUgRFVBTCBaT05FUyAoMi8zIHRvIDIvMyBhbmQgbm90IDIvMyB0byAzLzQpKipcblx0XHRcdGZpbmFsTWF4Wm9uZSA9IG1pbk51bShmbGF0dGVuKHpvbmVzRnJvbUR1YWxTdGF0aW9ucykpO1xuXHRcdFx0ZmluYWxNaW5ab25lID0gbWluTnVtKGZsYXR0ZW4oem9uZXNGcm9tRHVhbFN0YXRpb25zKSk7XG5cdFx0Ly8qKk5FRUQgVE8gQUREIEEgRkxBRyBIRVJFIHRvIHNheSB0aGF0IGl0IGlzIGR1YWwgdG8gZHVhbCB6b25lICYgd2hhdCB6b25lcyAoc28gdGhhdCBjYW4gbWFuaXB1bGF0ZSBhbmQgcGljayB6b25lcyBmcm9tIGNsb3Nlc3QgdG8gd2Vla2x5IGNhcHBlZCB6b25lIHJhdGhlciB0aGFuIG1pbiB6b25lKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR6b25lc0Zyb21TaW5nbGVTdGF0aW9ucyA9IGZsYXR0ZW4oZmlsdGVyWm9uZXNCeU51bWJlcigxLCBhbGxab25lcykpO1xuXHRcdFx0XG5cblx0XHRcdC8vQ2FsY3VsYXRlcyB0aGUgbWF4IGFuZCBtaW4gWm9uZXMgb2YgYWxsIHRoZSB6b25lcyB0aGF0IGFyZSBmcm9tIHN0YXRpb25zIHdpdGhvdXQgYW55IGR1YWwgem9uZXMuXG5cdFx0XHR2YXIgc2luZ2xlTWF4ID0gbWF4TnVtKHpvbmVzRnJvbVNpbmdsZVN0YXRpb25zKTtcblx0XHRcdHZhciBzaW5nbGVNaW4gPSBtaW5OdW0oem9uZXNGcm9tU2luZ2xlU3RhdGlvbnMpO1xuXG5cdFx0XHQvL0ZvciBlYWNoIHpvbmVzRnJvbUR1YWxTdGF0aW9uczogcGlja3MgdGhlIG1vc3QgYXBwcm9wcmlhdGUgem9uZSBhbmQgYXBwZW5kcyB0byBkdWFsWm9uZXMgYXJyYXkgXG5cdFx0XHQvLyAtLT4gR29pbmcgZnJvbSAyLzMgdG8gMi8zIOKAlD4gY2hhcmdlcyBzYW1lIHNpbmdsZSAyLCAzIG9yIDItMyAoMS43MCkgYnV0IHNob3VsZCBwaWNrIHpvbmUgYmFzZWQgb24gd2Vla2x5IChjb3VsZCBiZSAzKSBvciBjYXAgKGFsd2F5cyBzbWFsbGVzdDogMilcblx0XHRcdHZhciBkdWFsWm9uZXMgPSB6b25lc0Zyb21EdWFsU3RhdGlvbnMubWFwKGZ1bmN0aW9uKHopIHtcblx0XHRcdFx0cmV0dXJuIHoucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRpZiAoZ2V0RGlmZmVyZW5jZShhLCBzaW5nbGVNaW4pIDwgZ2V0RGlmZmVyZW5jZShiLCBzaW5nbGVNaW4pKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vQWRkcyBkdWFsWm9uZXMgdG8gc2luZ2xlTWF4IGludG8gYW4gYXJyYXkgYW5kIGNhbGN1bGF0ZXMgdGhlIG1heCBhbmQgbWluIHpvbmUgb2YgYm90aFxuXHRcdFx0ZmluYWxNYXhab25lID0gbWF4TnVtKFtzaW5nbGVNYXhdLmNvbmNhdChkdWFsWm9uZXMpKTtcblx0XHRcdGZpbmFsTWluWm9uZSA9IG1pbk51bShbc2luZ2xlTWluXS5jb25jYXQoZHVhbFpvbmVzKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtmaW5hbE1pblpvbmUsIGZpbmFsTWF4Wm9uZV07XG5cdH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9wYXJ0aWFscy9fZ2V0U2luZ2xlSm91cm5leVpvbmVzLmpzIiwiLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBveXN0ZXIgdG90YWwgZmFyZSBmb3IgdGhlIGRheVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2pvdXJuZXl9IHpvbmVzIGFuZCBvZmYgcGVhayBvciBvbiBwZWFrXG4gKiBAcGFyYW0ge2pzb24gZGF0YX0gdXNlcyB0aGUgc2luZ2xlRmFyZXMganNvbiBkYXRhXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHJldHVybnMgdGhlIHRvdGFsIGZhcmVcbiAqIEBkZXNjcmlwdGlvblxuICovXG5cblxuLy8gTmVlZCBzZXQgYW4gYWxlcnQgZm9yIHdoZW4gcmVhY2ggYSBab25lcyAxLTQgb3IgWm9uZXMgMS02IGRhaWx5IGNhcCwgYnV0IG9ubHkgdHJhdmVsIGF0IG9mZi1wZWFrIHRpbWVzLlxuXG5pbXBvcnQgXyBmcm9tICdyYW1kYSc7XG5cbmltcG9ydCB7XG4gIG1pbk51bSxcbiAgbWF4TnVtLFxuICBnZXRDYXAsXG4gIGdldFNpbmdsZUZhcmUsXG4gIG1ldCxcbiAgem9uZVRvSm91cm5leVxufSBmcm9tICcuLy4uL3V0aWxpdHkvX3V0aWxpdHknO1xuXG5pbXBvcnQgZXh0ZW5zaW9uRmFyZXMgZnJvbSAnLi9fZXh0ZW5zaW9uRmFyZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBveXN0ZXJEYXlUb3RhbChvcHRpb25zID0ge30sIGRhdGEgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbWluVHJhdmVsY2FyZCwgLy9pZiBuZWVkZWQgZm9yIHdlZWtseVxuICAgIG1heFRyYXZlbGNhcmQsIC8vaWYgbmVlZGVkIGZvciB3ZWVrbHlcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qge1xuICAgIGpvdXJuZXlzLCAvL0pTT05cbiAgICBkYWlseUNhcHMsIC8vSlNPTlxuICAgIHNpbmdsZUZhcmVzLCAvL0pTT05cbiAgfSA9IGRhdGE7XG5cbiAgY29uc3QgZ2V0RGFpbHlDYXAgPSBnZXRDYXAoXy5fXywgXy5fXywgZGFpbHlDYXBzKTtcbiAgY29uc3QgY2FwTWV0ID0gXy5jb21wb3NlKG1ldCwgZ2V0RGFpbHlDYXApO1xuICAgIFxuICBjb25zdCB0b3RhbHMgPSBqb3VybmV5cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBsZXQgc2luZ2xlRmFyZTtcbiAgICBsZXQgbWF4Wm9uZSA9IG1heE51bShbXS5jb25jYXQoYS5tYXhab25lLCBiLnpvbmVzKSk7XG4vLyAgICAgRk9SIFdFRUtMWVxuICAgIGlmICgobWF4VHJhdmVsY2FyZCkgJiYgKG1heFpvbmUgPD0gbWF4VHJhdmVsY2FyZCkgJiYgKG1heFpvbmUgPj0gKG1pblRyYXZlbGNhcmQgLSAxKSkpIHtcbiAgICAgIG1heFpvbmUgPSBtaW5UcmF2ZWxjYXJkIC0gMTsgLy8oaWUgb25seSBjb21wYXJlcyBhZ2FpbnN0IGRhaWx5IGNhcCBvZiBtaW5TaW5nbGUgdG8gem9uZURhaWx5IC0gcmVtb3ZlcyBvdmVybGFwIHdpdGggd2Vla2x5KVxuIFxuICAgICAgc2luZ2xlRmFyZSA9IGV4dGVuc2lvbkZhcmVzKHt6b25lczogWzEsIDNdLCB0eXBlOiBcImFueXRpbWVcIiwgbWluVHJhdmVsY2FyZCwgbWF4VHJhdmVsY2FyZCx9LCBzaW5nbGVGYXJlcyk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgc2luZ2xlRmFyZSA9IGdldFNpbmdsZUZhcmUoYi56b25lcywgc2luZ2xlRmFyZXMsIGIudHlwZSk7IC8vYi56b25lcyA9IGFuIGFycmF5XG5cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyh6b25lVG9Kb3VybmV5KG1heFpvbmUpKTtcbiAgICAvLyBkZWJ1Z2dlcjtcblxuICAgIGNvbnN0IG1ldFBlYWsgPSBjYXBNZXQobWF4Wm9uZSwgJ2FueXRpbWUnKTsgLy90cnVlIG9yIGZhbHNlXG4gICAgXG4gICAgY29uc3QgbWV0T2ZmUGVhayA9IGNhcE1ldChtYXhab25lLCAnb2ZmUGVhaycpOyAvL3RydWUgb3IgZmFsc2VcblxuICAgIGxldCBvZmZQZWFrVG90YWw7XG4gICAgbGV0IGN1cnJlbnRUb3RhbCA9IGEuY3VycmVudFRvdGFsICsgc2luZ2xlRmFyZTsgXG5cbiAgICBpZiAoYi50eXBlID09PSAnb2ZmUGVhaycpIHtcbiAgICAgICBvZmZQZWFrVG90YWwgPSBhLm9mZlBlYWtUb3RhbCArIHNpbmdsZUZhcmU7XG5cbiAgICAgIGlmIChtZXRPZmZQZWFrKG9mZlBlYWtUb3RhbCkpIHtcbiAgICAgICAgb2ZmUGVha1RvdGFsID0gZ2V0RGFpbHlDYXAobWF4Wm9uZSwgJ29mZlBlYWsnKTsgLy9hbmQgc2V0IGFuIGFsZXJ0IHRvIHNheSBvZmYgZGFpbHkgY2FwIHJlYWNoZWQ/Pz8/ISEhIChidXQgY291bGQgYmUgb3ZlcnJpZGRlbiBhZnRlcilcbiAgICAgIH1cblxuICAgICAgY3VycmVudFRvdGFsID0gbWluTnVtKFtvZmZQZWFrVG90YWwsIGN1cnJlbnRUb3RhbF0pO1xuICAgIH1cblxuICAgIGlmIChtZXRQZWFrKGN1cnJlbnRUb3RhbCkpIHtcbiAgICAgIGN1cnJlbnRUb3RhbCA9IGdldERhaWx5Q2FwKG1heFpvbmUsICdhbnl0aW1lJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRUb3RhbCxcbiAgICAgIG9mZlBlYWtUb3RhbCxcbiAgICAgIG1heFpvbmUsXG4gICAgfTtcbiAgfSwge1xuICAgIGN1cnJlbnRUb3RhbDogMCxcbiAgICBvZmZQZWFrVG90YWw6IDAsXG4gICAgbWF4Wm9uZTogbnVsbCxcbiAgfSk7XG5cbiAgcmV0dXJuIHRvdGFscy5jdXJyZW50VG90YWw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvcGFydGlhbHMvX295c3RlckRheVRvdGFsLmpzIiwidmFyIGFsd2F5cyA9IHJlcXVpcmUoJy4vYWx3YXlzJyk7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgYGZhbHNlYC4gQW55IHBhc3NlZCBpbiBwYXJhbWV0ZXJzIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5hbHdheXMsIFIuVFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuRigpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYWx3YXlzKGZhbHNlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL0YuanMiLCJ2YXIgYWx3YXlzID0gcmVxdWlyZSgnLi9hbHdheXMnKTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuYWx3YXlzLCBSLkZcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLlQoKTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYWx3YXlzKHRydWUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvVC5qcyIsIi8qKlxuICogQSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIHVzZWQgdG8gc3BlY2lmeSBcImdhcHNcIiB3aXRoaW4gY3VycmllZCBmdW5jdGlvbnMsXG4gKiBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsIHJlZ2FyZGxlc3Mgb2ZcbiAqIHRoZWlyIHBvc2l0aW9ucy5cbiAqXG4gKiBJZiBgZ2AgaXMgYSBjdXJyaWVkIHRlcm5hcnkgZnVuY3Rpb24gYW5kIGBfYCBpcyBgUi5fX2AsIHRoZSBmb2xsb3dpbmcgYXJlXG4gKiBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyLCBfKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAY29uc3RhbnRcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ3JlZXQgPSBSLnJlcGxhY2UoJ3tuYW1lfScsIFIuX18sICdIZWxsbywge25hbWV9IScpO1xuICogICAgICBncmVldCgnQWxpY2UnKTsgLy89PiAnSGVsbG8sIEFsaWNlISdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7J0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlcic6IHRydWV9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvX18uanMiLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiBmcm9tIGFuIGV4aXN0aW5nIG9uZSBieSBhZGRpbmcgdHdvIG5ld1xuICogcGFyYW1ldGVycyB0byBpdHMgY2FsbGJhY2sgZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4LCBhbmQgdGhlIGVudGlyZSBsaXN0LlxuICpcbiAqIFRoaXMgd291bGQgdHVybiwgZm9yIGluc3RhbmNlLCBSYW1kYSdzIHNpbXBsZSBgbWFwYCBmdW5jdGlvbiBpbnRvIG9uZSB0aGF0XG4gKiBtb3JlIGNsb3NlbHkgcmVzZW1ibGVzIGBBcnJheS5wcm90b3R5cGUubWFwYC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmtcbiAqIGZvciBmdW5jdGlvbnMgaW4gd2hpY2ggdGhlIGl0ZXJhdGlvbiBjYWxsYmFjayBmdW5jdGlvbiBpcyB0aGUgZmlyc3RcbiAqIHBhcmFtZXRlciwgYW5kIHdoZXJlIHRoZSBsaXN0IGlzIHRoZSBsYXN0IHBhcmFtZXRlci4gKFRoaXMgbGF0dGVyIG1pZ2h0IGJlXG4gKiB1bmltcG9ydGFudCBpZiB0aGUgbGlzdCBwYXJhbWV0ZXIgaXMgbm90IHVzZWQuKVxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhIC4uLiAtPiBiKSAuLi4gLT4gW2FdIC0+ICopIC0+IChhIC4uLiwgSW50LCBbYV0gLT4gYikgLi4uIC0+IFthXSAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IHBhc3MgaW5kZXggb3IgbGlzdCB0byBpdHMgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBbiBhbHRlcmVkIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIChpdGVtLCBpbmRleCwgbGlzdCkgdG8gaXRzIGNhbGxiYWNrXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG1hcEluZGV4ZWQgPSBSLmFkZEluZGV4KFIubWFwKTtcbiAqICAgICAgbWFwSW5kZXhlZCgodmFsLCBpZHgpID0+IGlkeCArICctJyArIHZhbCwgWydmJywgJ28nLCAnbycsICdiJywgJ2EnLCAnciddKTtcbiAqICAgICAgLy89PiBbJzAtZicsICcxLW8nLCAnMi1vJywgJzMtYicsICc0LWEnLCAnNS1yJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGFkZEluZGV4KGZuKSB7XG4gIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgb3JpZ0ZuID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgYXJnc1swXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9yaWdGbi5hcHBseSh0aGlzLCBfY29uY2F0KGFyZ3VtZW50cywgW2lkeCwgbGlzdF0pKTtcbiAgICAgIGlkeCArPSAxO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2FkZEluZGV4LmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hhbGwgPSByZXF1aXJlKCcuL2ludGVybmFsL194YWxsJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYCBpZlxuICogdGhlcmUgYXJlIGFueSB0aGF0IGRvbid0LlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbGxgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQgYnkgZXZlcnkgZWxlbWVudCwgYGZhbHNlYFxuICogICAgICAgICBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYW55LCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGVxdWFsczMgPSBSLmVxdWFscygzKTtcbiAqICAgICAgUi5hbGwoZXF1YWxzMykoWzMsIDMsIDMsIDNdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuYWxsKGVxdWFsczMpKFszLCAzLCAxLCAzXSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydhbGwnXSwgX3hhbGwsIGZ1bmN0aW9uIGFsbChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaWYgKCFmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYWxsLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBjdXJyeU4gPSByZXF1aXJlKCcuL2N1cnJ5TicpO1xudmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgcGx1Y2sgPSByZXF1aXJlKCcuL3BsdWNrJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBldmVyeSBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXMgc2F0aXNmaWVkXG4gKiBieSB0aG9zZSBhcmd1bWVudHMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gKiBoaWdoZXN0LWFyaXR5IHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBbKCouLi4gLT4gQm9vbGVhbildIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0FycmF5fSBwcmVkaWNhdGVzIEFuIGFycmF5IG9mIHByZWRpY2F0ZXMgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29tYmluZWQgcHJlZGljYXRlXG4gKiBAc2VlIFIuYW55UGFzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc1F1ZWVuID0gUi5wcm9wRXEoJ3JhbmsnLCAnUScpO1xuICogICAgICB2YXIgaXNTcGFkZSA9IFIucHJvcEVxKCdzdWl0JywgJ+KZoO+4jicpO1xuICogICAgICB2YXIgaXNRdWVlbk9mU3BhZGVzID0gUi5hbGxQYXNzKFtpc1F1ZWVuLCBpc1NwYWRlXSk7XG4gKlxuICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZo++4jid9KTsgLy89PiBmYWxzZVxuICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZoO+4jid9KTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBhbGxQYXNzKHByZWRzKSB7XG4gIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBwcmVkcy5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKCFwcmVkc1tpZHhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYWxsUGFzcy5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciBtYXggPSByZXF1aXJlKCcuL21heCcpO1xudmFyIHBsdWNrID0gcmVxdWlyZSgnLi9wbHVjaycpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJy4vcmVkdWNlJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgcHJlZGljYXRlcyBhbmQgcmV0dXJucyBhIHByZWRpY2F0ZSB0aGF0IHJldHVybnMgdHJ1ZSBmb3IgYVxuICogZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzXG4gKiBzYXRpc2ZpZWQgYnkgdGhvc2UgYXJndW1lbnRzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICogaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtBcnJheX0gcHJlZGljYXRlcyBBbiBhcnJheSBvZiBwcmVkaWNhdGVzIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbWJpbmVkIHByZWRpY2F0ZVxuICogQHNlZSBSLmFsbFBhc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNDbHViID0gUi5wcm9wRXEoJ3N1aXQnLCAn4pmjJyk7XG4gKiAgICAgIHZhciBpc1NwYWRlID0gUi5wcm9wRXEoJ3N1aXQnLCAn4pmgJyk7XG4gKiAgICAgIHZhciBpc0JsYWNrQ2FyZCA9IFIuYW55UGFzcyhbaXNDbHViLCBpc1NwYWRlXSk7XG4gKlxuICogICAgICBpc0JsYWNrQ2FyZCh7cmFuazogJzEwJywgc3VpdDogJ+KZoyd9KTsgLy89PiB0cnVlXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnUScsIHN1aXQ6ICfimaAnfSk7IC8vPT4gdHJ1ZVxuICogICAgICBpc0JsYWNrQ2FyZCh7cmFuazogJ1EnLCBzdWl0OiAn4pmmJ30pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBhbnlQYXNzKHByZWRzKSB7XG4gIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBwcmVkcy5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKHByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9hbnlQYXNzLmpzIiwidmFyIF9hcGVydHVyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FwZXJ0dXJlJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGFwZXJ0dXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGFwZXJ0dXJlJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QsIGNvbXBvc2VkIG9mIG4tdHVwbGVzIG9mIGNvbnNlY3V0aXZlIGVsZW1lbnRzIElmIGBuYCBpc1xuICogZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGxpc3QsIGFuIGVtcHR5IGxpc3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW1thXV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSB0dXBsZXMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHNwbGl0IGludG8gYG5gLWxlbmd0aCB0dXBsZXNcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgcmVzdWx0aW5nIGxpc3Qgb2YgYG5gLWxlbmd0aCB0dXBsZXNcbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFwZXJ0dXJlKDIsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW1sxLCAyXSwgWzIsIDNdLCBbMywgNF0sIFs0LCA1XV1cbiAqICAgICAgUi5hcGVydHVyZSgzLCBbMSwgMiwgMywgNCwgNV0pOyAvLz0+IFtbMSwgMiwgM10sIFsyLCAzLCA0XSwgWzMsIDQsIDVdXVxuICogICAgICBSLmFwZXJ0dXJlKDcsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoW10sIF94YXBlcnR1cmUsIF9hcGVydHVyZSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvYXBlcnR1cmUuanMiLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCwgZm9sbG93ZWQgYnlcbiAqIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0geyp9IGVsIFRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gYWRkIGEgbmV3IGl0ZW0gdG8uXG4gKiAgICAgICAgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIG9mIHRoZSBvbGQgbGlzdCBmb2xsb3dlZCBieSBgZWxgLlxuICogQHNlZSBSLnByZXBlbmRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFwcGVuZCgndGVzdHMnLCBbJ3dyaXRlJywgJ21vcmUnXSk7IC8vPT4gWyd3cml0ZScsICdtb3JlJywgJ3Rlc3RzJ11cbiAqICAgICAgUi5hcHBlbmQoJ3Rlc3RzJywgW10pOyAvLz0+IFsndGVzdHMnXVxuICogICAgICBSLmFwcGVuZChbJ3Rlc3RzJ10sIFsnd3JpdGUnLCAnbW9yZSddKTsgLy89PiBbJ3dyaXRlJywgJ21vcmUnLCBbJ3Rlc3RzJ11dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBhcHBlbmQoZWwsIGxpc3QpIHtcbiAgcmV0dXJuIF9jb25jYXQobGlzdCwgW2VsXSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2FwcGVuZC5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgYXBwbHkgPSByZXF1aXJlKCcuL2FwcGx5Jyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xudmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgcGx1Y2sgPSByZXF1aXJlKCcuL3BsdWNrJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB2YWx1ZXMgPSByZXF1aXJlKCcuL3ZhbHVlcycpO1xuXG5cbi8qKlxuICogR2l2ZW4gYSBzcGVjIG9iamVjdCByZWN1cnNpdmVseSBtYXBwaW5nIHByb3BlcnRpZXMgdG8gZnVuY3Rpb25zLCBjcmVhdGVzIGFcbiAqIGZ1bmN0aW9uIHByb2R1Y2luZyBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc3RydWN0dXJlLCBieSBtYXBwaW5nIGVhY2ggcHJvcGVydHlcbiAqIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBpdHMgYXNzb2NpYXRlZCBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIHtrOiAoKGEsIGIsIC4uLiwgbSkgLT4gdil9IC0+ICgoYSwgYiwgLi4uLCBtKSAtPiB7azogdn0pXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlYyBhbiBvYmplY3QgcmVjdXJzaXZlbHkgbWFwcGluZyBwcm9wZXJ0aWVzIHRvIGZ1bmN0aW9ucyBmb3JcbiAqICAgICAgICBwcm9kdWNpbmcgdGhlIHZhbHVlcyBmb3IgdGhlc2UgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc3RydWN0dXJlXG4gKiBhcyBgc3BlYycsIHdpdGggZWFjaCBwcm9wZXJ0eSBzZXQgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5IGNhbGxpbmcgaXRzXG4gKiBhc3NvY2lhdGVkIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAqIEBzZWUgUi5jb252ZXJnZSwgUi5qdXh0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdldE1ldHJpY3MgPSBSLmFwcGx5U3BlYyh7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtOiBSLmFkZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWQ6IHsgbXVsOiBSLm11bHRpcGx5IH1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAqICAgICAgZ2V0TWV0cmljcygyLCA0KTsgLy8gPT4geyBzdW06IDYsIG5lc3RlZDogeyBtdWw6IDggfSB9XG4gKiBAc3ltYiBSLmFwcGx5U3BlYyh7IHg6IGYsIHk6IHsgejogZyB9IH0pKGEsIGIpID0geyB4OiBmKGEsIGIpLCB5OiB7IHo6IGcoYSwgYikgfSB9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBhcHBseVNwZWMoc3BlYykge1xuICBzcGVjID0gbWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHR5cGVvZiB2ID09ICdmdW5jdGlvbicgPyB2IDogYXBwbHlTcGVjKHYpOyB9LFxuICAgICAgICAgICAgIHNwZWMpO1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCB2YWx1ZXMoc3BlYykpKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcChmdW5jdGlvbihmKSB7IHJldHVybiBhcHBseShmLCBhcmdzKTsgfSwgc3BlYyk7XG4gICAgICAgICAgICAgICAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2FwcGx5U3BlYy5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBNYWtlcyBhbiBhc2NlbmRpbmcgY29tcGFyYXRvciBmdW5jdGlvbiBvdXQgb2YgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZVxuICogdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBgPGAgYW5kIGA+YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IE51bWJlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiBvZiBhcml0eSBvbmUgdGhhdCByZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgY29tcGFyZWRcbiAqIEBwYXJhbSB7Kn0gYSBUaGUgZmlyc3QgaXRlbSB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGAtMWAgaWYgZm4oYSkgPCBmbihiKSwgYDFgIGlmIGZuKGIpIDwgZm4oYSksIG90aGVyd2lzZSBgMGBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYnlBZ2UgPSBSLmFzY2VuZChSLnByb3AoJ2FnZScpKTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAqICAgICAgICAvLyAuLi5cbiAqICAgICAgXTtcbiAqICAgICAgdmFyIHBlb3BsZUJ5WW91bmdlc3RGaXJzdCA9IFIuc29ydChieUFnZSwgcGVvcGxlKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGFzY2VuZChmbiwgYSwgYikge1xuICB2YXIgYWEgPSBmbihhKTtcbiAgdmFyIGJiID0gZm4oYik7XG4gIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2FzY2VuZC5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgbkFyeSA9IHJlcXVpcmUoJy4vbkFyeScpO1xuXG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSAyIHBhcmFtZXRlcnMuIEFueSBleHRyYW5lb3VzIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgcGFzc2VkIHRvIHRoZVxuICogc3VwcGxpZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCogLT4gYykgLT4gKGEsIGIgLT4gYylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIGBmbmAuIFRoZSBuZXcgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBiZSBvZlxuICogICAgICAgICBhcml0eSAyLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB0YWtlc1RocmVlQXJncyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAqICAgICAgICByZXR1cm4gW2EsIGIsIGNdO1xuICogICAgICB9O1xuICogICAgICB0YWtlc1RocmVlQXJncy5sZW5ndGg7IC8vPT4gM1xuICogICAgICB0YWtlc1RocmVlQXJncygxLCAyLCAzKTsgLy89PiBbMSwgMiwgM11cbiAqXG4gKiAgICAgIHZhciB0YWtlc1R3b0FyZ3MgPSBSLmJpbmFyeSh0YWtlc1RocmVlQXJncyk7XG4gKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICogICAgICAvLyBPbmx5IDIgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCB1bmRlZmluZWRdXG4gKiBAc3ltYiBSLmJpbmFyeShmKShhLCBiLCBjKSA9IGYoYSwgYilcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGJpbmFyeShmbikge1xuICByZXR1cm4gbkFyeSgyLCBmbik7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2JpbmFyeS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0Z1bmN0aW9uJyk7XG52YXIgYW5kID0gcmVxdWlyZSgnLi9hbmQnKTtcbnZhciBsaWZ0ID0gcmVxdWlyZSgnLi9saWZ0Jyk7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIHRoZSB0d28gcHJvdmlkZWQgZnVuY3Rpb25zIGFuZCByZXR1cm5zIHRoZSBgJiZgXG4gKiBvZiB0aGUgcmVzdWx0cy5cbiAqIEl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgZnVuY3Rpb24gaWYgaXQgaXMgZmFsc2UteSBhbmQgdGhlIHJlc3VsdFxuICogb2YgdGhlIHNlY29uZCBmdW5jdGlvbiBvdGhlcndpc2UuIE5vdGUgdGhhdCB0aGlzIGlzIHNob3J0LWNpcmN1aXRlZCxcbiAqIG1lYW5pbmcgdGhhdCB0aGUgc2Vjb25kIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgdGhlIGZpcnN0IHJldHVybnMgYVxuICogZmFsc2UteSB2YWx1ZS5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBmdW5jdGlvbnMsIGBSLmJvdGhgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAqIGFwcGxpY2F0aXZlIGZ1bmN0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIEEgcHJlZGljYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIEFub3RoZXIgcHJlZGljYXRlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgaXRzIGFyZ3VtZW50cyB0byBgZmAgYW5kIGBnYCBhbmQgYCYmYHMgdGhlaXIgb3V0cHV0cyB0b2dldGhlci5cbiAqIEBzZWUgUi5hbmRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ3QxMCA9IFIuZ3QoUi5fXywgMTApXG4gKiAgICAgIHZhciBsdDIwID0gUi5sdChSLl9fLCAyMClcbiAqICAgICAgdmFyIGYgPSBSLmJvdGgoZ3QxMCwgbHQyMCk7XG4gKiAgICAgIGYoMTUpOyAvLz0+IHRydWVcbiAqICAgICAgZigzMCk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGJvdGgoZiwgZykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oZikgP1xuICAgIGZ1bmN0aW9uIF9ib3RoKCkge1xuICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSA6XG4gICAgbGlmdChhbmQpKGYsIGcpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9ib3RoLmpzIiwidmFyIGN1cnJ5ID0gcmVxdWlyZSgnLi9jdXJyeScpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggdGhlIHJlbWFpbmluZ1xuICogYXJndW1lbnRzLiBUaGlzIGlzIG9jY2FzaW9uYWxseSB1c2VmdWwgYXMgYSBjb252ZXJnaW5nIGZ1bmN0aW9uIGZvclxuICogYFIuY29udmVyZ2VgOiB0aGUgbGVmdCBicmFuY2ggY2FuIHByb2R1Y2UgYSBmdW5jdGlvbiB3aGlsZSB0aGUgcmlnaHQgYnJhbmNoXG4gKiBwcm9kdWNlcyBhIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IGEpLCouLi4gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSByZW1haW5pbmcgYXJndW1lbnRzLlxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFueSBudW1iZXIgb2YgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmFwcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jYWxsKFIuYWRkLCAxLCAyKTsgLy89PiAzXG4gKlxuICogICAgICB2YXIgaW5kZW50TiA9IFIucGlwZShSLnRpbWVzKFIuYWx3YXlzKCcgJykpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLmpvaW4oJycpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBSLnJlcGxhY2UoL14oPyEkKS9nbSkpO1xuICpcbiAqICAgICAgdmFyIGZvcm1hdCA9IFIuY29udmVyZ2UoUi5jYWxsLCBbXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLnBpcGUoUi5wcm9wKCdpbmRlbnQnKSwgaW5kZW50TiksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSLnByb3AoJ3ZhbHVlJylcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gKlxuICogICAgICBmb3JtYXQoe2luZGVudDogMiwgdmFsdWU6ICdmb29cXG5iYXJcXG5iYXpcXG4nfSk7IC8vPT4gJyAgZm9vXFxuICBiYXJcXG4gIGJhelxcbidcbiAqIEBzeW1iIFIuY2FsbChmLCBhLCBiKSA9IGYoYSwgYilcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjdXJyeShmdW5jdGlvbiBjYWxsKGZuKSB7XG4gIHJldHVybiBmbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY2FsbC5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cbi8qKlxuICogUmVzdHJpY3RzIGEgbnVtYmVyIHRvIGJlIHdpdGhpbiBhIHJhbmdlLlxuICpcbiAqIEFsc28gd29ya3MgZm9yIG90aGVyIG9yZGVyZWQgdHlwZXMgc3VjaCBhcyBTdHJpbmdzIGFuZCBEYXRlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbmltdW0gVGhlIGxvd2VyIGxpbWl0IG9mIHRoZSBjbGFtcCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gVGhlIHVwcGVyIGxpbWl0IG9mIHRoZSBjbGFtcCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGJlIGNsYW1wZWRcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBgbWluaW11bWAgd2hlbiBgdmFsIDwgbWluaW11bWAsIGBtYXhpbXVtYCB3aGVuIGB2YWwgPiBtYXhpbXVtYCwgcmV0dXJucyBgdmFsYCBvdGhlcndpc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNsYW1wKDEsIDEwLCAtNSkgLy8gPT4gMVxuICogICAgICBSLmNsYW1wKDEsIDEwLCAxNSkgLy8gPT4gMTBcbiAqICAgICAgUi5jbGFtcCgxLCAxMCwgNCkgIC8vID0+IDRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICBpZiAobWluID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW4gbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBpbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDpcbiAgICAgICAgIHZhbHVlID4gbWF4ID8gbWF4IDpcbiAgICAgICAgIHZhbHVlO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jbGFtcC5qcyIsInZhciBfY2xvbmUgPSByZXF1aXJlKCcuL2ludGVybmFsL19jbG9uZScpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIHZhbHVlIHdoaWNoIG1heSBjb250YWluIChuZXN0ZWQpIGBBcnJheWBzIGFuZFxuICogYE9iamVjdGBzLCBgTnVtYmVyYHMsIGBTdHJpbmdgcywgYEJvb2xlYW5gcyBhbmQgYERhdGVgcy4gYEZ1bmN0aW9uYHMgYXJlXG4gKiBhc3NpZ25lZCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gY29waWVkXG4gKlxuICogRGlzcGF0Y2hlcyB0byBhIGBjbG9uZWAgbWV0aG9kIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHsqfSAtPiB7Kn1cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG9iamVjdCBvciBhcnJheSB0byBjbG9uZVxuICogQHJldHVybiB7Kn0gQSBkZWVwbHkgY2xvbmVkIGNvcHkgb2YgYHZhbGBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgb2JqZWN0cyA9IFt7fSwge30sIHt9XTtcbiAqICAgICAgdmFyIG9iamVjdHNDbG9uZSA9IFIuY2xvbmUob2JqZWN0cyk7XG4gKiAgICAgIG9iamVjdHMgPT09IG9iamVjdHNDbG9uZTsgLy89PiBmYWxzZVxuICogICAgICBvYmplY3RzWzBdID09PSBvYmplY3RzQ2xvbmVbMF07IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5jbG9uZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdmFsdWUuY2xvbmUoKSA6XG4gICAgX2Nsb25lKHZhbHVlLCBbXSwgW10sIHRydWUpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jbG9uZS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXBvcnRzIHdoZXRoZXIgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGlzIGxlc3MgdGhhbiB0aGUgc2Vjb25kLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChhLCBiIC0+IEJvb2xlYW4pIC0+IChhLCBiIC0+IE51bWJlcilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb24gb2YgYXJpdHkgdHdvIHdoaWNoIHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIGlzIGxlc3MgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZVxuICogQHJldHVybiB7RnVuY3Rpb259IEEgRnVuY3Rpb24gOjogYSAtPiBiIC0+IEludCB0aGF0IHJldHVybnMgYC0xYCBpZiBhIDwgYiwgYDFgIGlmIGIgPCBhLCBvdGhlcndpc2UgYDBgXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ5QWdlID0gUi5jb21wYXJhdG9yKChhLCBiKSA9PiBhLmFnZSA8IGIuYWdlKTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtcbiAqICAgICAgICAvLyAuLi5cbiAqICAgICAgXTtcbiAqICAgICAgdmFyIHBlb3BsZUJ5SW5jcmVhc2luZ0FnZSA9IFIuc29ydChieUFnZSwgcGVvcGxlKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGNvbXBhcmF0b3IocHJlZCkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBwcmVkKGEsIGIpID8gLTEgOiBwcmVkKGIsIGEpID8gMSA6IDA7XG4gIH07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2NvbXBhcmF0b3IuanMiLCJ2YXIgbGlmdCA9IHJlcXVpcmUoJy4vbGlmdCcpO1xudmFyIG5vdCA9IHJlcXVpcmUoJy4vbm90Jyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYCBzdWNoIHRoYXQgaWYgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzXG4gKiB3aGVuIGBmYCByZXR1cm5zIGEgXCJ0cnV0aHlcIiB2YWx1ZSwgYGdgIHJldHVybnMgYGZhbHNlYCBhbmQgd2hlbiBgZmAgcmV0dXJucyBhIFwiZmFsc3lcIiB2YWx1ZSBgZ2AgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogYFIuY29tcGxlbWVudGAgbWF5IGJlIGFwcGxpZWQgdG8gYW55IGZ1bmN0b3JcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gKikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLm5vdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc05vdE5pbCA9IFIuY29tcGxlbWVudChSLmlzTmlsKTtcbiAqICAgICAgaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBpc05vdE5pbChudWxsKTsgLy89PiBmYWxzZVxuICogICAgICBpc05pbCg3KTsgLy89PiBmYWxzZVxuICogICAgICBpc05vdE5pbCg3KTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gbGlmdChub3QpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY29tcGxlbWVudC5qcyIsInZhciBwaXBlUCA9IHJlcXVpcmUoJy4vcGlwZVAnKTtcbnZhciByZXZlcnNlID0gcmVxdWlyZSgnLi9yZXZlcnNlJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSByaWdodG1vc3QgZnVuY3Rpb24gbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nXG4gKiBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCh5IC0+IFByb21pc2UgeiksICh4IC0+IFByb21pc2UgeSksIC4uLiwgKGEgLT4gUHJvbWlzZSBiKSkgLT4gKGEgLT4gUHJvbWlzZSB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZVBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGIgPSB7XG4gKiAgICAgICAgdXNlcnM6IHtcbiAqICAgICAgICAgIEpPRToge1xuICogICAgICAgICAgICBuYW1lOiAnSm9lJyxcbiAqICAgICAgICAgICAgZm9sbG93ZXJzOiBbJ1NURVZFJywgJ1NVWlknXVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfVxuICpcbiAqICAgICAgLy8gV2UnbGwgcHJldGVuZCB0byBkbyBhIGRiIGxvb2t1cCB3aGljaCByZXR1cm5zIGEgcHJvbWlzZVxuICogICAgICB2YXIgbG9va3VwVXNlciA9ICh1c2VySWQpID0+IFByb21pc2UucmVzb2x2ZShkYi51c2Vyc1t1c2VySWRdKVxuICogICAgICB2YXIgbG9va3VwRm9sbG93ZXJzID0gKHVzZXIpID0+IFByb21pc2UucmVzb2x2ZSh1c2VyLmZvbGxvd2VycylcbiAqICAgICAgbG9va3VwVXNlcignSk9FJykudGhlbihsb29rdXBGb2xsb3dlcnMpXG4gKlxuICogICAgICAvLyAgZm9sbG93ZXJzRm9yVXNlciA6OiBTdHJpbmcgLT4gUHJvbWlzZSBbVXNlcklkXVxuICogICAgICB2YXIgZm9sbG93ZXJzRm9yVXNlciA9IFIuY29tcG9zZVAobG9va3VwRm9sbG93ZXJzLCBsb29rdXBVc2VyKTtcbiAqICAgICAgZm9sbG93ZXJzRm9yVXNlcignSk9FJykudGhlbihmb2xsb3dlcnMgPT4gY29uc29sZS5sb2coJ0ZvbGxvd2VyczonLCBmb2xsb3dlcnMpKVxuICogICAgICAvLyBGb2xsb3dlcnM6IFtcIlNURVZFXCIsXCJTVVpZXCJdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcG9zZVAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb3NlUCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gcGlwZVAuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jb21wb3NlUC5qcyIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcCcpO1xudmFyIG1heCA9IHJlcXVpcmUoJy4vbWF4Jyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgYGZuYCwgd2hpY2ggZW5jYXBzdWxhdGVzIGBpZi9lbHNlLCBpZi9lbHNlLCAuLi5gIGxvZ2ljLlxuICogYFIuY29uZGAgdGFrZXMgYSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybWVyXSBwYWlycy4gQWxsIG9mIHRoZSBhcmd1bWVudHNcbiAqIHRvIGBmbmAgYXJlIGFwcGxpZWQgdG8gZWFjaCBvZiB0aGUgcHJlZGljYXRlcyBpbiB0dXJuIHVudGlsIG9uZSByZXR1cm5zIGFcbiAqIFwidHJ1dGh5XCIgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGBmbmAgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGl0c1xuICogYXJndW1lbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHRyYW5zZm9ybWVyLiBJZiBub25lIG9mIHRoZSBwcmVkaWNhdGVzXG4gKiBtYXRjaGVzLCBgZm5gIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIFtbKCouLi4gLT4gQm9vbGVhbiksKCouLi4gLT4gKildXSAtPiAoKi4uLiAtPiAqKVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMgQSBsaXN0IG9mIFtwcmVkaWNhdGUsIHRyYW5zZm9ybWVyXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGZuID0gUi5jb25kKFtcbiAqICAgICAgICBbUi5lcXVhbHMoMCksICAgUi5hbHdheXMoJ3dhdGVyIGZyZWV6ZXMgYXQgMMKwQycpXSxcbiAqICAgICAgICBbUi5lcXVhbHMoMTAwKSwgUi5hbHdheXMoJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQycpXSxcbiAqICAgICAgICBbUi5ULCAgICAgICAgICAgdGVtcCA9PiAnbm90aGluZyBzcGVjaWFsIGhhcHBlbnMgYXQgJyArIHRlbXAgKyAnwrBDJ11cbiAqICAgICAgXSk7XG4gKiAgICAgIGZuKDApOyAvLz0+ICd3YXRlciBmcmVlemVzIGF0IDDCsEMnXG4gKiAgICAgIGZuKDUwKTsgLy89PiAnbm90aGluZyBzcGVjaWFsIGhhcHBlbnMgYXQgNTDCsEMnXG4gKiAgICAgIGZuKDEwMCk7IC8vPT4gJ3dhdGVyIGJvaWxzIGF0IDEwMMKwQydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgdmFyIGFyaXR5ID0gcmVkdWNlKG1heCxcbiAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICBtYXAoZnVuY3Rpb24ocGFpcikgeyByZXR1cm4gcGFpclswXS5sZW5ndGg7IH0sIHBhaXJzKSk7XG4gIHJldHVybiBfYXJpdHkoYXJpdHksIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBwYWlycy5sZW5ndGgpIHtcbiAgICAgIGlmIChwYWlyc1tpZHhdWzBdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHBhaXJzW2lkeF1bMV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2NvbmQuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGNvbnN0cnVjdE4gPSByZXF1aXJlKCcuL2NvbnN0cnVjdE4nKTtcblxuXG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBzYW1lIHR5cGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCogLT4geyp9KSAtPiAoKiAtPiB7Kn0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAqICAgICAgZnVuY3Rpb24gQW5pbWFsKGtpbmQpIHtcbiAqICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICogICAgICB9O1xuICogICAgICBBbmltYWwucHJvdG90eXBlLnNpZ2h0aW5nID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgcmV0dXJuIFwiSXQncyBhIFwiICsgdGhpcy5raW5kICsgXCIhXCI7XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIHZhciBBbmltYWxDb25zdHJ1Y3RvciA9IFIuY29uc3RydWN0KEFuaW1hbClcbiAqXG4gKiAgICAgIC8vIE5vdGljZSB3ZSBubyBsb25nZXIgbmVlZCB0aGUgJ25ldycga2V5d29yZDpcbiAqICAgICAgQW5pbWFsQ29uc3RydWN0b3IoJ1BpZycpOyAvLz0+IHtcImtpbmRcIjogXCJQaWdcIiwgXCJzaWdodGluZ1wiOiBmdW5jdGlvbiAoKXsuLi59fTtcbiAqXG4gKiAgICAgIHZhciBhbmltYWxUeXBlcyA9IFtcIkxpb25cIiwgXCJUaWdlclwiLCBcIkJlYXJcIl07XG4gKiAgICAgIHZhciBhbmltYWxTaWdodGluZyA9IFIuaW52b2tlcigwLCAnc2lnaHRpbmcnKTtcbiAqICAgICAgdmFyIHNpZ2h0TmV3QW5pbWFsID0gUi5jb21wb3NlKGFuaW1hbFNpZ2h0aW5nLCBBbmltYWxDb25zdHJ1Y3Rvcik7XG4gKiAgICAgIFIubWFwKHNpZ2h0TmV3QW5pbWFsLCBhbmltYWxUeXBlcyk7IC8vPT4gW1wiSXQncyBhIExpb24hXCIsIFwiSXQncyBhIFRpZ2VyIVwiLCBcIkl0J3MgYSBCZWFyIVwiXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gY29uc3RydWN0KEZuKSB7XG4gIHJldHVybiBjb25zdHJ1Y3ROKEZuLmxlbmd0aCwgRm4pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jb25zdHJ1Y3QuanMiLCJ2YXIgX2NvbnRhaW5zID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29udGFpbnMnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGVxdWFsLCBpbiBgUi5lcXVhbHNgIHRlcm1zLCB0byBhdFxuICogbGVhc3Qgb25lIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIGl0ZW0gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYW4gZXF1aXZhbGVudCBpdGVtIGlzIGluIHRoZSBsaXN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNvbnRhaW5zKDMsIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmNvbnRhaW5zKDQsIFsxLCAyLCAzXSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5jb250YWlucyh7IG5hbWU6ICdGcmVkJyB9LCBbeyBuYW1lOiAnRnJlZCcgfV0pOyAvLz0+IHRydWVcbiAqICAgICAgUi5jb250YWlucyhbNDJdLCBbWzQyXV0pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9jb250YWlucyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9jb250YWlucy5qcyIsInZhciByZWR1Y2VCeSA9IHJlcXVpcmUoJy4vcmVkdWNlQnknKTtcblxuXG4vKipcbiAqIENvdW50cyB0aGUgZWxlbWVudHMgb2YgYSBsaXN0IGFjY29yZGluZyB0byBob3cgbWFueSBtYXRjaCBlYWNoIHZhbHVlIG9mIGFcbiAqIGtleSBnZW5lcmF0ZWQgYnkgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLiBSZXR1cm5zIGFuIG9iamVjdCBtYXBwaW5nIHRoZSBrZXlzXG4gKiBwcm9kdWNlZCBieSBgZm5gIHRvIHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW4gdGhlIGxpc3QuIE5vdGUgdGhhdCBhbGxcbiAqIGtleXMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBiZWNhdXNlIG9mIGhvdyBKYXZhU2NyaXB0IG9iamVjdHMgd29yay5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKGEgLT4gU3RyaW5nKSAtPiBbYV0gLT4geyp9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBtYXAgdmFsdWVzIHRvIGtleXMuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGNvdW50IGVsZW1lbnRzIGZyb20uXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gbnVtYmVyIG9mIG9jY3VycmVuY2VzIGluIHRoZSBsaXN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1iZXJzID0gWzEuMCwgMS4xLCAxLjIsIDIuMCwgMy4wLCAyLjJdO1xuICogICAgICBSLmNvdW50QnkoTWF0aC5mbG9vcikobnVtYmVycyk7ICAgIC8vPT4geycxJzogMywgJzInOiAyLCAnMyc6IDF9XG4gKlxuICogICAgICB2YXIgbGV0dGVycyA9IFsnYScsICdiJywgJ0EnLCAnYScsICdCJywgJ2MnXTtcbiAqICAgICAgUi5jb3VudEJ5KFIudG9Mb3dlcikobGV0dGVycyk7ICAgLy89PiB7J2EnOiAzLCAnYic6IDIsICdjJzogMX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2VCeShmdW5jdGlvbihhY2MsIGVsZW0pIHsgcmV0dXJuIGFjYyArIDE7IH0sIDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvY291bnRCeS5qcyIsInZhciBhZGQgPSByZXF1aXJlKCcuL2FkZCcpO1xuXG5cbi8qKlxuICogRGVjcmVtZW50cyBpdHMgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TnVtYmVyfSBuIC0gMVxuICogQHNlZSBSLmluY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGVjKDQyKTsgLy89PiA0MVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFkZCgtMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9kZWMuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogTWFrZXMgYSBkZXNjZW5kaW5nIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdmFsdWVcbiAqIHRoYXQgY2FuIGJlIGNvbXBhcmVkIHdpdGggYDxgIGFuZCBgPmAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gb2YgYXJpdHkgb25lIHRoYXQgcmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7TnVtYmVyfSBgLTFgIGlmIGZuKGEpID4gZm4oYiksIGAxYCBpZiBmbihiKSA+IGZuKGEpLCBvdGhlcndpc2UgYDBgXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ5QWdlID0gUi5kZXNjZW5kKFIucHJvcCgnYWdlJykpO1xuICogICAgICB2YXIgcGVvcGxlID0gW1xuICogICAgICAgIC8vIC4uLlxuICogICAgICBdO1xuICogICAgICB2YXIgcGVvcGxlQnlPbGRlc3RGaXJzdCA9IFIuc29ydChieUFnZSwgcGVvcGxlKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGRlc2NlbmQoZm4sIGEsIGIpIHtcbiAgdmFyIGFhID0gZm4oYSk7XG4gIHZhciBiYiA9IGZuKGIpO1xuICByZXR1cm4gYWEgPiBiYiA/IC0xIDogYWEgPCBiYiA/IDEgOiAwO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9kZXNjZW5kLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBhc3NvYyA9IHJlcXVpcmUoJy4vYXNzb2MnKTtcbnZhciBkaXNzb2MgPSByZXF1aXJlKCcuL2Rpc3NvYycpO1xuXG5cbi8qKlxuICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgb21pdHRpbmcgdGhlIHByb3BlcnR5IGF0IHRoZSBnaXZlbiBwYXRoLlxuICogTm90ZSB0aGF0IHRoaXMgY29waWVzIGFuZCBmbGF0dGVucyBwcm90b3R5cGUgcHJvcGVydGllcyBvbnRvIHRoZSBuZXcgb2JqZWN0XG4gKiBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjExLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW1N0cmluZ10gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB0aGUgdmFsdWUgdG8gb21pdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRob3V0IHRoZSBwcm9wZXJ0eSBhdCBwYXRoXG4gKiBAc2VlIFIuYXNzb2NQYXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaXNzb2NQYXRoKFsnYScsICdiJywgJ2MnXSwge2E6IHtiOiB7YzogNDJ9fX0pOyAvLz0+IHthOiB7Yjoge319fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZGlzc29jUGF0aChwYXRoLCBvYmopIHtcbiAgc3dpdGNoIChwYXRoLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBvYmo7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGRpc3NvYyhwYXRoWzBdLCBvYmopO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgaGVhZCA9IHBhdGhbMF07XG4gICAgICB2YXIgdGFpbCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhdGgsIDEpO1xuICAgICAgcmV0dXJuIG9ialtoZWFkXSA9PSBudWxsID8gb2JqIDogYXNzb2MoaGVhZCwgZGlzc29jUGF0aCh0YWlsLCBvYmpbaGVhZF0pLCBvYmopO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2Rpc3NvY1BhdGguanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogRGl2aWRlcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAvIGJgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLyBiYC5cbiAqIEBzZWUgUi5tdWx0aXBseVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGl2aWRlKDcxLCAxMDApOyAvLz0+IDAuNzFcbiAqXG4gKiAgICAgIHZhciBoYWxmID0gUi5kaXZpZGUoUi5fXywgMik7XG4gKiAgICAgIGhhbGYoNDIpOyAvLz0+IDIxXG4gKlxuICogICAgICB2YXIgcmVjaXByb2NhbCA9IFIuZGl2aWRlKDEpO1xuICogICAgICByZWNpcHJvY2FsKDQpOyAgIC8vPT4gMC4yNVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZGl2aWRlKGEsIGIpIHsgcmV0dXJuIGEgLyBiOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2RpdmlkZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF9kcm9wTGFzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Ryb3BMYXN0Jyk7XG52YXIgX3hkcm9wTGFzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hkcm9wTGFzdCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyBhbGwgYnV0IHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYGxpc3RgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIGBsaXN0YCB0byBza2lwLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCBvZiBlbGVtZW50cyB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgdGhlIGxpc3Qgd2l0aCBvbmx5IHRoZSBmaXJzdCBgbGlzdC5sZW5ndGggLSBuYCBlbGVtZW50c1xuICogQHNlZSBSLnRha2VMYXN0LCBSLmRyb3AsIFIuZHJvcFdoaWxlLCBSLmRyb3BMYXN0V2hpbGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRyb3BMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAqICAgICAgUi5kcm9wTGFzdCgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJ11cbiAqICAgICAgUi5kcm9wTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcExhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3BMYXN0KDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbXSwgX3hkcm9wTGFzdCwgX2Ryb3BMYXN0KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9kcm9wTGFzdC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF9kcm9wTGFzdFdoaWxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZHJvcExhc3RXaGlsZScpO1xudmFyIF94ZHJvcExhc3RXaGlsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hkcm9wTGFzdFdoaWxlJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgZXhjbHVkaW5nIGFsbCB0aGUgdGFpbGluZyBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3Qgd2hpY2hcbiAqIHNhdGlzZnkgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gSXQgcGFzc2VzIGVhY2ggdmFsdWUgZnJvbSB0aGUgcmlnaHRcbiAqIHRvIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24sIHNraXBwaW5nIGVsZW1lbnRzIHVudGlsIHRoZSBwcmVkaWNhdGVcbiAqIGZ1bmN0aW9uIHJldHVybnMgYSBgZmFsc3lgIHZhbHVlLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gb25lIGFyZ3VtZW50OlxuICogKih2YWx1ZSkqLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggZWxlbWVudFxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkgd2l0aG91dCBhbnkgdHJhaWxpbmcgZWxlbWVudHMgdGhhdCByZXR1cm4gYGZhbHN5YCB2YWx1ZXMgZnJvbSB0aGUgYHByZWRpY2F0ZWAuXG4gKiBAc2VlIFIudGFrZUxhc3RXaGlsZSwgUi5hZGRJbmRleCwgUi5kcm9wLCBSLmRyb3BXaGlsZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsdGVUaHJlZSA9IHggPT4geCA8PSAzO1xuICpcbiAqICAgICAgUi5kcm9wTGFzdFdoaWxlKGx0ZVRocmVlLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzLCA0XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbXSwgX3hkcm9wTGFzdFdoaWxlLCBfZHJvcExhc3RXaGlsZSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZHJvcExhc3RXaGlsZS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZHJvcFJlcGVhdHNXaXRoID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGRyb3BSZXBlYXRzV2l0aCcpO1xudmFyIGRyb3BSZXBlYXRzV2l0aCA9IHJlcXVpcmUoJy4vZHJvcFJlcGVhdHNXaXRoJyk7XG52YXIgZXF1YWxzID0gcmVxdWlyZSgnLi9lcXVhbHMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRob3V0IGFueSBjb25zZWN1dGl2ZWx5IHJlcGVhdGluZyBlbGVtZW50cy4gYFIuZXF1YWxzYFxuICogaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IGBsaXN0YCB3aXRob3V0IHJlcGVhdGluZyBlbGVtZW50cy5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIFIuZHJvcFJlcGVhdHMoWzEsIDEsIDEsIDIsIDMsIDQsIDQsIDIsIDJdKTsgLy89PiBbMSwgMiwgMywgNCwgMl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKF9kaXNwYXRjaGFibGUoW10sIF94ZHJvcFJlcGVhdHNXaXRoKGVxdWFscyksIGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9kcm9wUmVwZWF0cy5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZHJvcFdoaWxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGRyb3BXaGlsZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGV4Y2x1ZGluZyB0aGUgbGVhZGluZyBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3Qgd2hpY2hcbiAqIHNhdGlzZnkgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gSXQgcGFzc2VzIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24sIHNraXBwaW5nIGVsZW1lbnRzIHdoaWxlIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJuc1xuICogYHRydWVgLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGRyb3BXaGlsZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIudGFrZVdoaWxlLCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBsdGVUd28gPSB4ID0+IHggPD0gMjtcbiAqXG4gKiAgICAgIFIuZHJvcFdoaWxlKGx0ZVR3bywgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMywgNCwgMywgMiwgMV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydkcm9wV2hpbGUnXSwgX3hkcm9wV2hpbGUsIGZ1bmN0aW9uIGRyb3BXaGlsZShwcmVkLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4gJiYgcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGlkeCk7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9kcm9wV2hpbGUuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNGdW5jdGlvbicpO1xudmFyIGxpZnQgPSByZXF1aXJlKCcuL2xpZnQnKTtcbnZhciBvciA9IHJlcXVpcmUoJy4vb3InKTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gd3JhcHBpbmcgY2FsbHMgdG8gdGhlIHR3byBmdW5jdGlvbnMgaW4gYW4gYHx8YCBvcGVyYXRpb24sXG4gKiByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgZnVuY3Rpb24gaWYgaXQgaXMgdHJ1dGgteSBhbmQgdGhlIHJlc3VsdFxuICogb2YgdGhlIHNlY29uZCBmdW5jdGlvbiBvdGhlcndpc2UuIE5vdGUgdGhhdCB0aGlzIGlzIHNob3J0LWNpcmN1aXRlZCxcbiAqIG1lYW5pbmcgdGhhdCB0aGUgc2Vjb25kIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgdGhlIGZpcnN0IHJldHVybnMgYVxuICogdHJ1dGgteSB2YWx1ZS5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBmdW5jdGlvbnMsIGBSLmVpdGhlcmAgYWxzbyBhY2NlcHRzIGFueSBmYW50YXN5LWxhbmQgY29tcGF0aWJsZVxuICogYXBwbGljYXRpdmUgZnVuY3Rvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgYSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGcgYW5vdGhlciBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBpdHMgYXJndW1lbnRzIHRvIGBmYCBhbmQgYGdgIGFuZCBgfHxgcyB0aGVpciBvdXRwdXRzIHRvZ2V0aGVyLlxuICogQHNlZSBSLm9yXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGd0MTAgPSB4ID0+IHggPiAxMDtcbiAqICAgICAgdmFyIGV2ZW4gPSB4ID0+IHggJSAyID09PSAwO1xuICogICAgICB2YXIgZiA9IFIuZWl0aGVyKGd0MTAsIGV2ZW4pO1xuICogICAgICBmKDEwMSk7IC8vPT4gdHJ1ZVxuICogICAgICBmKDgpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGVpdGhlcihmLCBnKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbihmKSA/XG4gICAgZnVuY3Rpb24gX2VpdGhlcigpIHtcbiAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gOlxuICAgIGxpZnQob3IpKGYsIGcpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9laXRoZXIuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzIGluIGl0cyBkb21haW4gYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZVxuICogdmFsdWVzIG1hcCB0byB0aGUgc2FtZSB2YWx1ZSBpbiB0aGUgY29kb21haW47IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0geyp9IHlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5lcUJ5KE1hdGguYWJzLCA1LCAtNSk7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gZXFCeShmLCB4LCB5KSB7XG4gIHJldHVybiBlcXVhbHMoZih4KSwgZih5KSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2VxQnkuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG5cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgdHdvIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaW4gYFIuZXF1YWxzYCB0ZXJtcywgZm9yXG4gKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBVc2VmdWwgYXMgYSBjdXJyaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgayAtPiB7azogdn0gLT4ge2s6IHZ9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBvMSA9IHsgYTogMSwgYjogMiwgYzogMywgZDogNCB9O1xuICogICAgICB2YXIgbzIgPSB7IGE6IDEwLCBiOiAyMCwgYzogMywgZDogNDAgfTtcbiAqICAgICAgUi5lcVByb3BzKCdhJywgbzEsIG8yKTsgLy89PiBmYWxzZVxuICogICAgICBSLmVxUHJvcHMoJ2MnLCBvMSwgbzIpOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGVxUHJvcHMocHJvcCwgb2JqMSwgb2JqMikge1xuICByZXR1cm4gZXF1YWxzKG9iajFbcHJvcF0sIG9iajJbcHJvcF0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9lcVByb3BzLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGJ5IHJlY3Vyc2l2ZWx5IGV2b2x2aW5nIGEgc2hhbGxvdyBjb3B5IG9mIGBvYmplY3RgLFxuICogYWNjb3JkaW5nIHRvIHRoZSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9ucy4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllc1xuICogYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQSBgdHJhbnNmb3JtYXRpb25gIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGludm9rZWQgaWYgaXRzIGNvcnJlc3BvbmRpbmcga2V5XG4gKiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZXZvbHZlZCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiAodiAtPiB2KX0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybWF0aW9ucyBUaGUgb2JqZWN0IHNwZWNpZnlpbmcgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGFwcGx5XG4gKiAgICAgICAgdG8gdGhlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSB0cmFuc2Zvcm1lZC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRyYW5zZm9ybWVkIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdG9tYXRvICA9IHtmaXJzdE5hbWU6ICcgIFRvbWF0byAnLCBkYXRhOiB7ZWxhcHNlZDogMTAwLCByZW1haW5pbmc6IDE0MDB9LCBpZDoxMjN9O1xuICogICAgICB2YXIgdHJhbnNmb3JtYXRpb25zID0ge1xuICogICAgICAgIGZpcnN0TmFtZTogUi50cmltLFxuICogICAgICAgIGxhc3ROYW1lOiBSLnRyaW0sIC8vIFdpbGwgbm90IGdldCBpbnZva2VkLlxuICogICAgICAgIGRhdGE6IHtlbGFwc2VkOiBSLmFkZCgxKSwgcmVtYWluaW5nOiBSLmFkZCgtMSl9XG4gKiAgICAgIH07XG4gKiAgICAgIFIuZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgdG9tYXRvKTsgLy89PiB7Zmlyc3ROYW1lOiAnVG9tYXRvJywgZGF0YToge2VsYXBzZWQ6IDEwMSwgcmVtYWluaW5nOiAxMzk5fSwgaWQ6MTIzfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZXZvbHZlKHRyYW5zZm9ybWF0aW9ucywgb2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHRyYW5zZm9ybWF0aW9uLCBrZXksIHR5cGU7XG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb25zW2tleV07XG4gICAgdHlwZSA9IHR5cGVvZiB0cmFuc2Zvcm1hdGlvbjtcbiAgICByZXN1bHRba2V5XSA9IHR5cGUgPT09ICdmdW5jdGlvbicgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtYXRpb24ob2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgOiB0cmFuc2Zvcm1hdGlvbiAmJiB0eXBlID09PSAnb2JqZWN0JyA/IGV2b2x2ZSh0cmFuc2Zvcm1hdGlvbiwgb2JqZWN0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9iamVjdFtrZXldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2V2b2x2ZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF94ZmluZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hmaW5kJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlIHByZWRpY2F0ZSwgb3JcbiAqIGB1bmRlZmluZWRgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZmluZGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IGEgfCB1bmRlZmluZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiAgICAgICAgZGVzaXJlZCBvbmUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGVsZW1lbnQgZm91bmQsIG9yIGB1bmRlZmluZWRgLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4cyA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAqICAgICAgUi5maW5kKFIucHJvcEVxKCdhJywgMikpKHhzKTsgLy89PiB7YTogMn1cbiAqICAgICAgUi5maW5kKFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiB1bmRlZmluZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoWydmaW5kJ10sIF94ZmluZCwgZnVuY3Rpb24gZmluZChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9maW5kLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hmaW5kSW5kZXggPSByZXF1aXJlKCcuL2ludGVybmFsL194ZmluZEluZGV4Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZVxuICogcHJlZGljYXRlLCBvciBgLTFgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICogZGVzaXJlZCBvbmUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGZvdW5kLCBvciBgLTFgLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4cyA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IDFcbiAqICAgICAgUi5maW5kSW5kZXgoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IC0xXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKFtdLCBfeGZpbmRJbmRleCwgZnVuY3Rpb24gZmluZEluZGV4KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZmluZEluZGV4LmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX3hmaW5kTGFzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hmaW5kTGFzdCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlIHByZWRpY2F0ZSwgb3JcbiAqIGB1bmRlZmluZWRgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gYSB8IHVuZGVmaW5lZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqIGRlc2lyZWQgb25lLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBlbGVtZW50IGZvdW5kLCBvciBgdW5kZWZpbmVkYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeHMgPSBbe2E6IDEsIGI6IDB9LCB7YToxLCBiOiAxfV07XG4gKiAgICAgIFIuZmluZExhc3QoUi5wcm9wRXEoJ2EnLCAxKSkoeHMpOyAvLz0+IHthOiAxLCBiOiAxfVxuICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiB1bmRlZmluZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoW10sIF94ZmluZExhc3QsIGZ1bmN0aW9uIGZpbmRMYXN0KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gbGlzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZmluZExhc3QuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGZpbmRMYXN0SW5kZXggPSByZXF1aXJlKCcuL2ludGVybmFsL194ZmluZExhc3RJbmRleCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZVxuICogcHJlZGljYXRlLCBvciBgLTFgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICogZGVzaXJlZCBvbmUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGZvdW5kLCBvciBgLTFgLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciB4cyA9IFt7YTogMSwgYjogMH0sIHthOjEsIGI6IDF9XTtcbiAqICAgICAgUi5maW5kTGFzdEluZGV4KFIucHJvcEVxKCdhJywgMSkpKHhzKTsgLy89PiAxXG4gKiAgICAgIFIuZmluZExhc3RJbmRleChSLnByb3BFcSgnYScsIDQpKSh4cyk7IC8vPT4gLTFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9kaXNwYXRjaGFibGUoW10sIF94ZmluZExhc3RJbmRleCwgZnVuY3Rpb24gZmluZExhc3RJbmRleChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgaWR4IC09IDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZmluZExhc3RJbmRleC5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX21ha2VGbGF0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fbWFrZUZsYXQnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBieSBwdWxsaW5nIGV2ZXJ5IGl0ZW0gb3V0IG9mIGl0IChhbmQgYWxsIGl0cyBzdWItYXJyYXlzKVxuICogYW5kIHB1dHRpbmcgdGhlbSBpbiBhIG5ldyBhcnJheSwgZGVwdGgtZmlyc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmxhdHRlbmVkIGxpc3QuXG4gKiBAc2VlIFIudW5uZXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5mbGF0dGVuKFsxLCAyLCBbMywgNF0sIDUsIFs2LCBbNywgOCwgWzksIFsxMCwgMTFdLCAxMl1dXV0pO1xuICogICAgICAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoX21ha2VGbGF0KHRydWUpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ZsYXR0ZW4uanMiLCJ2YXIgX2NoZWNrRm9yTWV0aG9kID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gaW5wdXQgYGxpc3RgLCBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gYGZuYCBmb3IgZWFjaFxuICogZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAqXG4gKiBgZm5gIHJlY2VpdmVzIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICpcbiAqIE5vdGU6IGBSLmZvckVhY2hgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QuIEZvciBtb3JlXG4gKiBkZXRhaWxzIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2gjRGVzY3JpcHRpb25cbiAqXG4gKiBBbHNvIG5vdGUgdGhhdCwgdW5saWtlIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAsIFJhbWRhJ3MgYGZvckVhY2hgIHJldHVybnNcbiAqIHRoZSBvcmlnaW5hbCBhcnJheS4gSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgZWFjaGAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZvckVhY2hgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gKikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgdmFsdWVgLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9yaWdpbmFsIGxpc3QuXG4gKiBAc2VlIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgcHJpbnRYUGx1c0ZpdmUgPSB4ID0+IGNvbnNvbGUubG9nKHggKyA1KTtcbiAqICAgICAgUi5mb3JFYWNoKHByaW50WFBsdXNGaXZlLCBbMSwgMiwgM10pOyAvLz0+IFsxLCAyLCAzXVxuICogICAgICAvLyBsb2dzIDZcbiAqICAgICAgLy8gbG9ncyA3XG4gKiAgICAgIC8vIGxvZ3MgOFxuICogQHN5bWIgUi5mb3JFYWNoKGYsIFthLCBiLCBjXSkgPSBbYSwgYiwgY11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9jaGVja0Zvck1ldGhvZCgnZm9yRWFjaCcsIGZ1bmN0aW9uIGZvckVhY2goZm4sIGxpc3QpIHtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGZuKGxpc3RbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9mb3JFYWNoLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gaW5wdXQgYG9iamVjdGAsIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBgZm5gIGZvciBlYWNoXG4gKiBrZXkgYW5kIHZhbHVlIGluIHRoZSBvYmplY3QuXG4gKlxuICogYGZuYCByZWNlaXZlcyB0aHJlZSBhcmd1bWVudDogKih2YWx1ZSwga2V5LCBvYmopKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoYSwgU3RyaW5nLCBTdHJNYXAgYSkgLT4gQW55KSAtPiBTdHJNYXAgYSAtPiBTdHJNYXAgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUmVjZWl2ZXMgdGhyZWUgYXJndW1lbnQsIGB2YWx1ZWAsIGBrZXlgLCBgb2JqYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvcmlnaW5hbCBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHByaW50S2V5Q29uY2F0VmFsdWUgPSAodmFsdWUsIGtleSkgPT4gY29uc29sZS5sb2coa2V5ICsgJzonICsgdmFsdWUpO1xuICogICAgICBSLmZvckVhY2hPYmpJbmRleGVkKHByaW50S2V5Q29uY2F0VmFsdWUsIHt4OiAxLCB5OiAyfSk7IC8vPT4ge3g6IDEsIHk6IDJ9XG4gKiAgICAgIC8vIGxvZ3MgeDoxXG4gKiAgICAgIC8vIGxvZ3MgeToyXG4gKiBAc3ltYiBSLmZvckVhY2hPYmpJbmRleGVkKGYsIHt4OiBhLCB5OiBifSkgPSB7eDogYSwgeTogYn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGZvckVhY2hPYmpJbmRleGVkKGZuLCBvYmopIHtcbiAgdmFyIGtleUxpc3QgPSBrZXlzKG9iaik7XG4gIHZhciBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwga2V5TGlzdC5sZW5ndGgpIHtcbiAgICB2YXIga2V5ID0ga2V5TGlzdFtpZHhdO1xuICAgIGZuKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZm9yRWFjaE9iakluZGV4ZWQuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgZnJvbSBhIGxpc3Qga2V5LXZhbHVlIHBhaXJzLiBJZiBhIGtleSBhcHBlYXJzIGluXG4gKiBtdWx0aXBsZSBwYWlycywgdGhlIHJpZ2h0bW9zdCBwYWlyIGlzIGluY2x1ZGVkIGluIHRoZSBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbW2ssdl1dIC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMgQW4gYXJyYXkgb2YgdHdvLWVsZW1lbnQgYXJyYXlzIHRoYXQgd2lsbCBiZSB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBvdXRwdXQgb2JqZWN0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IG1hZGUgYnkgcGFpcmluZyB1cCBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICogQHNlZSBSLnRvUGFpcnMsIFIucGFpclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSk7IC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IHBhaXJzLmxlbmd0aCkge1xuICAgIHJlc3VsdFtwYWlyc1tpZHhdWzBdXSA9IHBhaXJzW2lkeF1bMV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZnJvbVBhaXJzLmpzIiwidmFyIF9jaGVja0Zvck1ldGhvZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIHJlZHVjZUJ5ID0gcmVxdWlyZSgnLi9yZWR1Y2VCeScpO1xuXG4vKipcbiAqIFNwbGl0cyBhIGxpc3QgaW50byBzdWItbGlzdHMgc3RvcmVkIGluIGFuIG9iamVjdCwgYmFzZWQgb24gdGhlIHJlc3VsdCBvZlxuICogY2FsbGluZyBhIFN0cmluZy1yZXR1cm5pbmcgZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50LCBhbmQgZ3JvdXBpbmcgdGhlXG4gKiByZXN1bHRzIGFjY29yZGluZyB0byB2YWx1ZXMgcmV0dXJuZWQuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGdyb3VwQnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW2FdIC0+IHtTdHJpbmc6IFthXX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIDo6IGEgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBncm91cFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgb3V0cHV0IG9mIGBmbmAgZm9yIGtleXMsIG1hcHBlZCB0byBhcnJheXMgb2YgZWxlbWVudHNcbiAqICAgICAgICAgdGhhdCBwcm9kdWNlZCB0aGF0IGtleSB3aGVuIHBhc3NlZCB0byBgZm5gLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBieUdyYWRlID0gUi5ncm91cEJ5KGZ1bmN0aW9uKHN0dWRlbnQpIHtcbiAqICAgICAgICB2YXIgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICogICAgICB9KTtcbiAqICAgICAgdmFyIHN0dWRlbnRzID0gW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0VkZHknLCBzY29yZTogNTh9LFxuICogICAgICAgICAgICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ0phY2snLCBzY29yZTogNjl9XTtcbiAqICAgICAgYnlHcmFkZShzdHVkZW50cyk7XG4gKiAgICAgIC8vIHtcbiAqICAgICAgLy8gICAnQSc6IFt7bmFtZTogJ0RpYW5uZScsIHNjb3JlOiA5OX1dLFxuICogICAgICAvLyAgICdCJzogW3tuYW1lOiAnQWJieScsIHNjb3JlOiA4NH1dXG4gKiAgICAgIC8vICAgLy8gLi4uLFxuICogICAgICAvLyAgICdGJzogW3tuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH1dXG4gKiAgICAgIC8vIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9jaGVja0Zvck1ldGhvZCgnZ3JvdXBCeScsIHJlZHVjZUJ5KGZ1bmN0aW9uKGFjYywgaXRlbSkge1xuICBpZiAoYWNjID09IG51bGwpIHtcbiAgICBhY2MgPSBbXTtcbiAgfVxuICBhY2MucHVzaChpdGVtKTtcbiAgcmV0dXJuIGFjYztcbn0sIG51bGwpKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9ncm91cEJ5LmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuLyoqXG4gKiBUYWtlcyBhIGxpc3QgYW5kIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzIHdoZXJlIGVhY2ggc3VibGlzdCdzIGVsZW1lbnRzIGFyZVxuICogYWxsIFwiZXF1YWxcIiBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGVxdWFsaXR5IGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIxLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYSkg4oaSIEJvb2xlYW4pIOKGkiBbYV0g4oaSIFtbYV1dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZ2l2ZW4gKGFkamFjZW50KVxuICogICAgICAgIGVsZW1lbnRzIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBncm91cFxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gZ3JvdXAuIEFsc28gYWNjZXB0cyBhIHN0cmluZywgd2hpY2ggd2lsbCBiZVxuICogICAgICAgIHRyZWF0ZWQgYXMgYSBsaXN0IG9mIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIHtMaXN0fSBBIGxpc3QgdGhhdCBjb250YWlucyBzdWJsaXN0cyBvZiBlcXVhbCBlbGVtZW50cyxcbiAqICAgICAgICAgd2hvc2UgY29uY2F0ZW5hdGlvbnMgYXJlIGVxdWFsIHRvIHRoZSBvcmlnaW5hbCBsaXN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBSLmdyb3VwV2l0aChSLmVxdWFscywgWzAsIDEsIDEsIDIsIDMsIDUsIDgsIDEzLCAyMV0pXG4gKiAvLz0+IFtbMF0sIFsxLCAxXSwgWzJdLCBbM10sIFs1XSwgWzhdLCBbMTNdLCBbMjFdXVxuICpcbiAqIFIuZ3JvdXBXaXRoKChhLCBiKSA9PiBhICUgMiA9PT0gYiAlIDIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzBdLCBbMSwgMV0sIFsyXSwgWzMsIDVdLCBbOF0sIFsxMywgMjFdXVxuICpcbiAqIFIuZ3JvdXBXaXRoKFIuZXFCeShpc1Zvd2VsKSwgJ2Flc3Rpb3UnKVxuICogLy89PiBbJ2FlJywgJ3N0JywgJ2lvdSddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbihmbiwgbGlzdCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB2YXIgbmV4dGlkeCA9IGlkeCArIDE7XG4gICAgd2hpbGUgKG5leHRpZHggPCBsZW4gJiYgZm4obGlzdFtpZHhdLCBsaXN0W25leHRpZHhdKSkge1xuICAgICAgbmV4dGlkeCArPSAxO1xuICAgIH1cbiAgICByZXMucHVzaChsaXN0LnNsaWNlKGlkeCwgbmV4dGlkeCkpO1xuICAgIGlkeCA9IG5leHRpZHg7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZ3JvdXBXaXRoLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5sdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZ3QoMiwgMSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0KDIsIDIpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZ3QoMiwgMyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndCgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndCgneicsICdhJyk7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZ3QoYSwgYikgeyByZXR1cm4gYSA+IGI7IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvZ3QuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5sdGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmd0ZSgyLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZ3RlKDIsIDIpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ndGUoMiwgMyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndGUoJ2EnLCAneicpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuZ3RlKCd6JywgJ2EnKTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBndGUoYSwgYikgeyByZXR1cm4gYSA+PSBiOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2d0ZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZVxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBzIC0+IHtzOiB4fSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2sgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBoYXNOYW1lID0gUi5oYXMoJ25hbWUnKTtcbiAqICAgICAgaGFzTmFtZSh7bmFtZTogJ2FsaWNlJ30pOyAgIC8vPT4gdHJ1ZVxuICogICAgICBoYXNOYW1lKHtuYW1lOiAnYm9iJ30pOyAgICAgLy89PiB0cnVlXG4gKiAgICAgIGhhc05hbWUoe30pOyAgICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKlxuICogICAgICB2YXIgcG9pbnQgPSB7eDogMCwgeTogMH07XG4gKiAgICAgIHZhciBwb2ludEhhcyA9IFIuaGFzKFIuX18sIHBvaW50KTtcbiAqICAgICAgcG9pbnRIYXMoJ3gnKTsgIC8vPT4gdHJ1ZVxuICogICAgICBwb2ludEhhcygneScpOyAgLy89PiB0cnVlXG4gKiAgICAgIHBvaW50SGFzKCd6Jyk7ICAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfaGFzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2hhcy5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhcyBhIHByb3BlcnR5IHdpdGhcbiAqIHRoZSBzcGVjaWZpZWQgbmFtZVxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBzIC0+IHtzOiB4fSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2sgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSh3aWR0aCwgaGVpZ2h0KSB7XG4gKiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICogICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICogICAgICB9XG4gKiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gKiAgICAgIH07XG4gKlxuICogICAgICB2YXIgc3F1YXJlID0gbmV3IFJlY3RhbmdsZSgyLCAyKTtcbiAqICAgICAgUi5oYXNJbignd2lkdGgnLCBzcXVhcmUpOyAgLy89PiB0cnVlXG4gKiAgICAgIFIuaGFzSW4oJ2FyZWEnLCBzcXVhcmUpOyAgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBoYXNJbihwcm9wLCBvYmopIHtcbiAgcmV0dXJuIHByb3AgaW4gb2JqO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9oYXNJbi5qcyIsInZhciBudGggPSByZXF1aXJlKCcuL250aCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIEluIHNvbWUgbGlicmFyaWVzXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBmaXJzdGAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi50YWlsLCBSLmluaXQsIFIubGFzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaGVhZChbJ2ZpJywgJ2ZvJywgJ2Z1bSddKTsgLy89PiAnZmknXG4gKiAgICAgIFIuaGVhZChbXSk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLmhlYWQoJ2FiYycpOyAvLz0+ICdhJ1xuICogICAgICBSLmhlYWQoJycpOyAvLz0+ICcnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gbnRoKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaGVhZC5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAqIGZ1bmN0aW9uIGRlcGVuZGluZyB1cG9uIHRoZSByZXN1bHQgb2YgdGhlIGBjb25kaXRpb25gIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoKi4uLiAtPiBCb29sZWFuKSAtPiAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiAqKSAtPiAoKi4uLiAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZGl0aW9uIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblRydWUgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25GYWxzZSBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgY29uZGl0aW9uYCBldmFsdWF0ZXMgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyB1bmFyeSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvY2VzcyBlaXRoZXIgdGhlIGBvblRydWVgIG9yIHRoZSBgb25GYWxzZWBcbiAqICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZXBlbmRpbmcgdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gKiBAc2VlIFIudW5sZXNzLCBSLndoZW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaW5jQ291bnQgPSBSLmlmRWxzZShcbiAqICAgICAgICBSLmhhcygnY291bnQnKSxcbiAqICAgICAgICBSLm92ZXIoUi5sZW5zUHJvcCgnY291bnQnKSwgUi5pbmMpLFxuICogICAgICAgIFIuYXNzb2MoJ2NvdW50JywgMSlcbiAqICAgICAgKTtcbiAqICAgICAgaW5jQ291bnQoe30pOyAgICAgICAgICAgLy89PiB7IGNvdW50OiAxIH1cbiAqICAgICAgaW5jQ291bnQoeyBjb3VudDogMSB9KTsgLy89PiB7IGNvdW50OiAyIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICByZXR1cm4gY3VycnlOKE1hdGgubWF4KGNvbmRpdGlvbi5sZW5ndGgsIG9uVHJ1ZS5sZW5ndGgsIG9uRmFsc2UubGVuZ3RoKSxcbiAgICBmdW5jdGlvbiBfaWZFbHNlKCkge1xuICAgICAgcmV0dXJuIGNvbmRpdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gb25UcnVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvbkZhbHNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICApO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pZkVsc2UuanMiLCJ2YXIgYWRkID0gcmVxdWlyZSgnLi9hZGQnKTtcblxuXG4vKipcbiAqIEluY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn0gbiArIDFcbiAqIEBzZWUgUi5kZWNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluYyg0Mik7IC8vPT4gNDNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhZGQoMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbmMuanMiLCJ2YXIgcmVkdWNlQnkgPSByZXF1aXJlKCcuL3JlZHVjZUJ5Jyk7XG5cblxuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEga2V5LCB0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBpbnRvIGFuXG4gKiBvYmplY3QgaW5kZXhpbmcgdGhlIG9iamVjdHMgYnkgdGhlIGdpdmVuIGtleS4gTm90ZSB0aGF0IGlmIG11bHRpcGxlXG4gKiBvYmplY3RzIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgaW5kZXhpbmcga2V5IG9ubHkgdGhlIGxhc3QgdmFsdWVcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBvYmplY3QuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW3trOiB2fV0gLT4ge2s6IHtrOiB2fX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIDo6IGEgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2Ygb2JqZWN0cyB0byBpbmRleFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgaW5kZXhpbmcgZWFjaCBhcnJheSBlbGVtZW50IGJ5IHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGlzdCA9IFt7aWQ6ICd4eXonLCB0aXRsZTogJ0EnfSwge2lkOiAnYWJjJywgdGl0bGU6ICdCJ31dO1xuICogICAgICBSLmluZGV4QnkoUi5wcm9wKCdpZCcpLCBsaXN0KTtcbiAqICAgICAgLy89PiB7YWJjOiB7aWQ6ICdhYmMnLCB0aXRsZTogJ0InfSwgeHl6OiB7aWQ6ICd4eXonLCB0aXRsZTogJ0EnfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWR1Y2VCeShmdW5jdGlvbihhY2MsIGVsZW0pIHsgcmV0dXJuIGVsZW07IH0sIG51bGwpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW5kZXhCeS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2luZGV4T2YgPSByZXF1aXJlKCcuL2ludGVybmFsL19pbmRleE9mJyk7XG52YXIgX2lzQXJyYXkgPSByZXF1aXJlKCcuL2ludGVybmFsL19pc0FycmF5Jyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMVxuICogaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZVxuICogZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCwgb3IgLTEgaWYgdGhlIHRhcmdldCBpcyBub3QgZm91bmQuXG4gKiBAc2VlIFIubGFzdEluZGV4T2ZcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluZGV4T2YoMywgWzEsMiwzLDRdKTsgLy89PiAyXG4gKiAgICAgIFIuaW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gaW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gIHJldHVybiB0eXBlb2YgeHMuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpID9cbiAgICB4cy5pbmRleE9mKHRhcmdldCkgOlxuICAgIF9pbmRleE9mKHhzLCB0YXJnZXQsIDApO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbmRleE9mLmpzIiwidmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubGFzdCwgUi5oZWFkLCBSLnRhaWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluaXQoWzEsIDIsIDNdKTsgIC8vPT4gWzEsIDJdXG4gKiAgICAgIFIuaW5pdChbMSwgMl0pOyAgICAgLy89PiBbMV1cbiAqICAgICAgUi5pbml0KFsxXSk7ICAgICAgICAvLz0+IFtdXG4gKiAgICAgIFIuaW5pdChbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi5pbml0KCdhYmMnKTsgIC8vPT4gJ2FiJ1xuICogICAgICBSLmluaXQoJ2FiJyk7ICAgLy89PiAnYSdcbiAqICAgICAgUi5pbml0KCdhJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi5pbml0KCcnKTsgICAgIC8vPT4gJydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBzbGljZSgwLCAtMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbml0LmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIEluc2VydHMgdGhlIHN1cHBsaWVkIGVsZW1lbnQgaW50byB0aGUgbGlzdCwgYXQgaW5kZXggYGluZGV4YC4gX05vdGUgdGhhdFxuICogdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjJcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0geyp9IGVsdCBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IGludG9cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBBcnJheSB3aXRoIGBlbHRgIGluc2VydGVkIGF0IGBpbmRleGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbnNlcnQoMiwgJ3gnLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLDMsNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGluc2VydChpZHgsIGVsdCwgbGlzdCkge1xuICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCk7XG4gIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBlbHQpO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnNlcnQuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogSW5zZXJ0cyB0aGUgc3ViLWxpc3QgaW50byB0aGUgbGlzdCwgYXQgaW5kZXggYGluZGV4YC4gX05vdGUgdGhhdCB0aGlzIGlzIG5vdFxuICogZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHN1Yi1saXN0XG4gKiBAcGFyYW0ge0FycmF5fSBlbHRzIFRoZSBzdWItbGlzdCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IHRoZSBzdWItbGlzdCBpbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0c2AgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgYGluZGV4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluc2VydEFsbCgyLCBbJ3gnLCd5JywneiddLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLCd5JywneicsMyw0XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gaW5zZXJ0QWxsKGlkeCwgZWx0cywgbGlzdCkge1xuICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICByZXR1cm4gW10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDAsIGlkeCksXG4gICAgICAgICAgICAgICAgICAgZWx0cyxcbiAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW5zZXJ0QWxsLmpzIiwidmFyIF9jb250YWlucyA9IHJlcXVpcmUoJy4vX2NvbnRhaW5zJyk7XG5cblxuLy8gQSBzaW1wbGUgU2V0IHR5cGUgdGhhdCBob25vdXJzIFIuZXF1YWxzIHNlbWFudGljc1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIF9TZXQoKSB7XG4gICAgLyogZ2xvYmFscyBTZXQgKi9cbiAgICB0aGlzLl9uYXRpdmVTZXQgPSB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nID8gbmV3IFNldCgpIDogbnVsbDtcbiAgICB0aGlzLl9pdGVtcyA9IHt9O1xuICB9XG5cbiAgLy8gdW50aWwgd2UgZmlndXJlIG91dCB3aHkganNkb2MgY2hva2VzIG9uIHRoaXNcbiAgLy8gQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBTZXRcbiAgLy8gQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gZGlkIG5vdCBleGlzdCBwcmlvciwgb3RoZXJ3aXNlIGZhbHNlXG4gIC8vXG4gIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gIWhhc09yQWRkKGl0ZW0sIHRydWUsIHRoaXMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGNoZWNrIGZvciBleGlzdGVuY2UgaW4gdGhlIFNldFxuICAvLyBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaXRlbSBleGlzdHMgaW4gdGhlIFNldCwgb3RoZXJ3aXNlIGZhbHNlXG4gIC8vXG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaGFzT3JBZGQoaXRlbSwgZmFsc2UsIHRoaXMpO1xuICB9O1xuXG4gIC8vXG4gIC8vIENvbWJpbmVzIHRoZSBsb2dpYyBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBpdGVtIGlzIGEgbWVtYmVyIG9mIHRoZSBzZXQgYW5kXG4gIC8vIGZvciBhZGRpbmcgYSBuZXcgaXRlbSB0byB0aGUgc2V0LlxuICAvL1xuICAvLyBAcGFyYW0gaXRlbSAgICAgICBUaGUgaXRlbSB0byBjaGVjayBvciBhZGQgdG8gdGhlIFNldCBpbnN0YW5jZS5cbiAgLy8gQHBhcmFtIHNob3VsZEFkZCAgSWYgdHJ1ZSwgdGhlIGl0ZW0gd2lsbCBiZSBhZGRlZCB0byB0aGUgc2V0IGlmIGl0IGRvZXNuJ3RcbiAgLy8gICAgICAgICAgICAgICAgICAgYWxyZWFkeSBleGlzdC5cbiAgLy8gQHBhcmFtIHNldCAgICAgICAgVGhlIHNldCBpbnN0YW5jZSB0byBjaGVjayBvciBhZGQgdG8uXG4gIC8vIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gYWxyZWFkeSBleGlzdGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gIC8vXG4gIGZ1bmN0aW9uIGhhc09yQWRkKGl0ZW0sIHNob3VsZEFkZCwgc2V0KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICB2YXIgcHJldlNpemUsIG5ld1NpemU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgICAgaWYgKGl0ZW0gPT09IDAgJiYgMSAvIGl0ZW0gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIGlmIChzZXQuX2l0ZW1zWyctMCddKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNob3VsZEFkZCkge1xuICAgICAgICAgICAgICBzZXQuX2l0ZW1zWyctMCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgdHlwZXMgY2FuIGFsbCB1dGlsaXNlIHRoZSBuYXRpdmUgU2V0XG4gICAgICAgIGlmIChzZXQuX25hdGl2ZVNldCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NpemUgPT09IHByZXZTaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0Ll9uYXRpdmVTZXQuaGFzKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXVtpdGVtXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluIHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1baXRlbV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgLy8gc2V0Ll9pdGVtc1snYm9vbGVhbiddIGhvbGRzIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICAgICAgLy8gcmVwcmVzZW50aW5nIFsgZmFsc2VFeGlzdHMsIHRydWVFeGlzdHMgXVxuICAgICAgICBpZiAodHlwZSBpbiBzZXQuX2l0ZW1zKSB7XG4gICAgICAgICAgdmFyIGJJZHggPSBpdGVtID8gMSA6IDA7XG4gICAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV1bYklkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1bYklkeF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gaXRlbSA/IFtmYWxzZSwgdHJ1ZV0gOiBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAvLyBjb21wYXJlIGZ1bmN0aW9ucyBmb3IgcmVmZXJlbmNlIGVxdWFsaXR5XG4gICAgICAgIGlmIChzZXQuX25hdGl2ZVNldCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHByZXZTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICAgIHNldC5fbmF0aXZlU2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIG5ld1NpemUgPSBzZXQuX25hdGl2ZVNldC5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NpemUgPT09IHByZXZTaXplO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0Ll9uYXRpdmVTZXQuaGFzKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBbaXRlbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2NvbnRhaW5zKGl0ZW0sIHNldC5faXRlbXNbdHlwZV0pKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFzZXQuX2l0ZW1zWydudWxsJ10pIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgICAgc2V0Ll9pdGVtc1snbnVsbCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAgICAgLy8gZm9yIGVhY2ggdHlwZS5cbiAgICAgICAgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2FuIHRocm91Z2ggYWxsIHByZXZpb3VzbHkgYXBwbGllZCBpdGVtc1xuICAgICAgICBpZiAoIV9jb250YWlucyhpdGVtLCBzZXQuX2l0ZW1zW3R5cGVdKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0ucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX1NldDtcbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fU2V0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfYXBlcnR1cmUobiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxpbWl0ID0gbGlzdC5sZW5ndGggLSAobiAtIDEpO1xuICB2YXIgYWNjID0gbmV3IEFycmF5KGxpbWl0ID49IDAgPyBsaW1pdCA6IDApO1xuICB3aGlsZSAoaWR4IDwgbGltaXQpIHtcbiAgICBhY2NbaWR4XSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGlkeCwgaWR4ICsgbik7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fYXBlcnR1cmUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9hcnJheUZyb21JdGVyYXRvcihpdGVyKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIHZhciBuZXh0O1xuICB3aGlsZSAoIShuZXh0ID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICBsaXN0LnB1c2gobmV4dC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2FycmF5RnJvbUl0ZXJhdG9yLmpzIiwidmFyIHRha2UgPSByZXF1aXJlKCcuLi90YWtlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJvcExhc3QobiwgeHMpIHtcbiAgcmV0dXJuIHRha2UobiA8IHhzLmxlbmd0aCA/IHhzLmxlbmd0aCAtIG4gOiAwLCB4cyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Ryb3BMYXN0LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcm9wTGFzdFdoaWxlKHByZWQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwICYmIHByZWQobGlzdFtpZHhdKSkge1xuICAgIGlkeCAtPSAxO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwLCBpZHggKyAxKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZHJvcExhc3RXaGlsZS5qcyIsInZhciBfYXJyYXlGcm9tSXRlcmF0b3IgPSByZXF1aXJlKCcuL19hcnJheUZyb21JdGVyYXRvcicpO1xudmFyIF9mdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuL19mdW5jdGlvbk5hbWUnKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgaWRlbnRpY2FsID0gcmVxdWlyZSgnLi4vaWRlbnRpY2FsJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4uL2tleXMnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2VxdWFscyhhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICBpZiAoaWRlbnRpY2FsKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZShhKSAhPT0gdHlwZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZW9mIGEuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmIGEuZXF1YWxzKGIpICYmXG4gICAgICAgICAgIHR5cGVvZiBiLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJiBiLmVxdWFscyhhKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZShhKSkge1xuICAgIGNhc2UgJ0FyZ3VtZW50cyc6XG4gICAgY2FzZSAnQXJyYXknOlxuICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICBpZiAodHlwZW9mIGEuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBfZnVuY3Rpb25OYW1lKGEuY29uc3RydWN0b3IpID09PSAnUHJvbWlzZScpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICBpZiAoISh0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgaWRlbnRpY2FsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgaWYgKCFpZGVudGljYWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdFcnJvcic6XG4gICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIGlmICghKGEuc291cmNlID09PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmXG4gICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZSAmJlxuICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICBhLnN0aWNreSA9PT0gYi5zdGlja3kgJiZcbiAgICAgICAgICAgIGEudW5pY29kZSA9PT0gYi51bmljb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICBpZiAoIV9lcXVhbHMoX2FycmF5RnJvbUl0ZXJhdG9yKGEuZW50cmllcygpKSwgX2FycmF5RnJvbUl0ZXJhdG9yKGIuZW50cmllcygpKSwgc3RhY2tBLCBzdGFja0IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFZhbHVlcyBvZiBvdGhlciB0eXBlcyBhcmUgb25seSBlcXVhbCBpZiBpZGVudGljYWwuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBrZXlzKGEpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpZHggPSBzdGFja0EubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgaWYgKHN0YWNrQVtpZHhdID09PSBhKSB7XG4gICAgICByZXR1cm4gc3RhY2tCW2lkeF0gPT09IGI7XG4gICAgfVxuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgc3RhY2tBLnB1c2goYSk7XG4gIHN0YWNrQi5wdXNoKGIpO1xuICBpZHggPSBrZXlzQS5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcbiAgICBpZiAoIShfaGFzKGtleSwgYikgJiYgX2VxdWFscyhiW2tleV0sIGFba2V5XSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuICBzdGFja0EucG9wKCk7XG4gIHN0YWNrQi5wb3AoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2VxdWFscy5qcyIsInZhciBfZm9yY2VSZWR1Y2VkID0gcmVxdWlyZSgnLi9fZm9yY2VSZWR1Y2VkJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vX3JlZHVjZScpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcbnZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2lzQXJyYXlMaWtlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgcHJlc2VydmluZ1JlZHVjZWQgPSBmdW5jdGlvbih4Zikge1xuICAgIHJldHVybiB7XG4gICAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBfeGZCYXNlLmluaXQsXG4gICAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICAgICAgfSxcbiAgICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHJldCA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gcmV0WydAQHRyYW5zZHVjZXIvcmVkdWNlZCddID8gX2ZvcmNlUmVkdWNlZChyZXQpIDogcmV0O1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF94Y2F0KHhmKSB7XG4gICAgdmFyIHJ4ZiA9IHByZXNlcnZpbmdSZWR1Y2VkKHhmKTtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BAdHJhbnNkdWNlci9pbml0JzogX3hmQmFzZS5pbml0LFxuICAgICAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJ4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgICB9LFxuICAgICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gIWlzQXJyYXlMaWtlKGlucHV0KSA/IF9yZWR1Y2UocnhmLCByZXN1bHQsIFtpbnB1dF0pIDogX3JlZHVjZShyeGYsIHJlc3VsdCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2ZsYXRDYXQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9mb3JjZVJlZHVjZWQoeCkge1xuICByZXR1cm4ge1xuICAgICdAQHRyYW5zZHVjZXIvdmFsdWUnOiB4LFxuICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fZm9yY2VSZWR1Y2VkLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfZnVuY3Rpb25OYW1lKGYpIHtcbiAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gIHZhciBtYXRjaCA9IFN0cmluZyhmKS5tYXRjaCgvXmZ1bmN0aW9uIChcXHcqKS8pO1xuICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/ICcnIDogbWF0Y2hbMV07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2Z1bmN0aW9uTmFtZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzUmVnRXhwKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzUmVnRXhwLmpzIiwidmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfb2JqZWN0QXNzaWduKHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgfVxuXG4gIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGlkeCA9IDE7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpZHhdO1xuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKF9oYXMobmV4dEtleSwgc291cmNlKSkge1xuICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19vYmplY3RBc3NpZ24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9vZih4KSB7IHJldHVybiBbeF07IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fb2YuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9waXBlKGYsIGcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnLmNhbGwodGhpcywgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcGlwZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX3BpcGVQKGYsIGcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHJldHVybiBmLmFwcGx5KGN0eCwgYXJndW1lbnRzKS50aGVuKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBnLmNhbGwoY3R4LCB4KTtcbiAgICB9KTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcGlwZVAuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9xdW90ZShzKSB7XG4gIHZhciBlc2NhcGVkID0gc1xuICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgLnJlcGxhY2UoL1tcXGJdL2csICdcXFxcYicpICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJylcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JylcbiAgICAucmVwbGFjZSgvXFx2L2csICdcXFxcdicpXG4gICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcblxuICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fcXVvdGUuanMiLCJ2YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJy4vX2Fzc2lnbicpO1xudmFyIF9pZGVudGl0eSA9IHJlcXVpcmUoJy4vX2lkZW50aXR5Jyk7XG52YXIgX2lzVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL19pc1RyYW5zZm9ybWVyJyk7XG52YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pc0FycmF5TGlrZScpO1xudmFyIG9iak9mID0gcmVxdWlyZSgnLi4vb2JqT2YnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIF9zdGVwQ2F0QXJyYXkgPSB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogQXJyYXksXG4gICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24oeHMsIHgpIHtcbiAgICAgIHhzLnB1c2goeCk7XG4gICAgICByZXR1cm4geHM7XG4gICAgfSxcbiAgICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IF9pZGVudGl0eVxuICB9O1xuICB2YXIgX3N0ZXBDYXRTdHJpbmcgPSB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogU3RyaW5nLFxuICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG4gIH07XG4gIHZhciBfc3RlcENhdE9iamVjdCA9IHtcbiAgICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBPYmplY3QsXG4gICAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgICAgcmV0dXJuIF9hc3NpZ24oXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgaXNBcnJheUxpa2UoaW5wdXQpID8gb2JqT2YoaW5wdXRbMF0sIGlucHV0WzFdKSA6IGlucHV0XG4gICAgICApO1xuICAgIH0sXG4gICAgJ0BAdHJhbnNkdWNlci9yZXN1bHQnOiBfaWRlbnRpdHlcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gX3N0ZXBDYXQob2JqKSB7XG4gICAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICByZXR1cm4gX3N0ZXBDYXRBcnJheTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gX3N0ZXBDYXRTdHJpbmc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIF9zdGVwQ2F0T2JqZWN0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgdHJhbnNmb3JtZXIgZm9yICcgKyBvYmopO1xuICB9O1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL19zdGVwQ2F0LmpzIiwiLyoqXG4gKiBQb2x5ZmlsbCBmcm9tIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nPi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwYWQgPSBmdW5jdGlvbiBwYWQobikgeyByZXR1cm4gKG4gPCAxMCA/ICcwJyA6ICcnKSArIG47IH07XG5cbiAgcmV0dXJuIHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgICAgIHJldHVybiBkLnRvSVNPU3RyaW5nKCk7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24gX3RvSVNPU3RyaW5nKGQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGQuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0RhdGUoKSkgKyAnVCcgK1xuICAgICAgICBwYWQoZC5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICtcbiAgICAgICAgKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxMDAwKS50b0ZpeGVkKDMpLnNsaWNlKDIsIDUpICsgJ1onXG4gICAgICApO1xuICAgIH07XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3RvSVNPU3RyaW5nLmpzIiwidmFyIF9jb250YWlucyA9IHJlcXVpcmUoJy4vX2NvbnRhaW5zJyk7XG52YXIgX21hcCA9IHJlcXVpcmUoJy4vX21hcCcpO1xudmFyIF9xdW90ZSA9IHJlcXVpcmUoJy4vX3F1b3RlJyk7XG52YXIgX3RvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fdG9JU09TdHJpbmcnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi4va2V5cycpO1xudmFyIHJlamVjdCA9IHJlcXVpcmUoJy4uL3JlamVjdCcpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX3RvU3RyaW5nKHgsIHNlZW4pIHtcbiAgdmFyIHJlY3VyID0gZnVuY3Rpb24gcmVjdXIoeSkge1xuICAgIHZhciB4cyA9IHNlZW4uY29uY2F0KFt4XSk7XG4gICAgcmV0dXJuIF9jb250YWlucyh5LCB4cykgPyAnPENpcmN1bGFyPicgOiBfdG9TdHJpbmcoeSwgeHMpO1xuICB9O1xuXG4gIC8vICBtYXBQYWlycyA6OiAoT2JqZWN0LCBbU3RyaW5nXSkgLT4gW1N0cmluZ11cbiAgdmFyIG1hcFBhaXJzID0gZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgcmV0dXJuIF9tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gX3F1b3RlKGspICsgJzogJyArIHJlY3VyKG9ialtrXSk7IH0sIGtleXMuc2xpY2UoKS5zb3J0KCkpO1xuICB9O1xuXG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpKSB7XG4gICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzpcbiAgICAgIHJldHVybiAnKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCcgKyBfbWFwKHJlY3VyLCB4KS5qb2luKCcsICcpICsgJykpJztcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICByZXR1cm4gJ1snICsgX21hcChyZWN1ciwgeCkuY29uY2F0KG1hcFBhaXJzKHgsIHJlamVjdChmdW5jdGlvbihrKSB7IHJldHVybiAvXlxcZCskLy50ZXN0KGspOyB9LCBrZXlzKHgpKSkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBCb29sZWFuKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiB4LnRvU3RyaW5nKCk7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICByZXR1cm4gJ25ldyBEYXRlKCcgKyAoaXNOYU4oeC52YWx1ZU9mKCkpID8gcmVjdXIoTmFOKSA6IF9xdW90ZShfdG9JU09TdHJpbmcoeCkpKSArICcpJztcbiAgICBjYXNlICdbb2JqZWN0IE51bGxdJzpcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IE51bWJlcignICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogMSAvIHggPT09IC1JbmZpbml0eSA/ICctMCcgOiB4LnRvU3RyaW5nKDEwKTtcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgU3RyaW5nKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiBfcXVvdGUoeCk7XG4gICAgY2FzZSAnW29iamVjdCBVbmRlZmluZWRdJzpcbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiB4LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciByZXByID0geC50b1N0cmluZygpO1xuICAgICAgICBpZiAocmVwciAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICByZXR1cm4gcmVwcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIG1hcFBhaXJzKHgsIGtleXMoeCkpLmpvaW4oJywgJykgKyAnfSc7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9fdG9TdHJpbmcuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2VkID0gcmVxdWlyZSgnLi9fcmVkdWNlZCcpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWEFsbChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuYWxsID0gdHJ1ZTtcbiAgfVxuICBYQWxsLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEFsbC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICh0aGlzLmFsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICghdGhpcy5mKGlucHV0KSkge1xuICAgICAgdGhpcy5hbGwgPSBmYWxzZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBmYWxzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94YWxsKGYsIHhmKSB7IHJldHVybiBuZXcgWEFsbChmLCB4Zik7IH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194YWxsLmpzIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL19jb25jYXQnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYQXBlcnR1cmUobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuYWNjID0gbmV3IEFycmF5KG4pO1xuICB9XG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHRoaXMuYWNjID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5zdG9yZShpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbCA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmdldENvcHkoKSkgOiByZXN1bHQ7XG4gIH07XG4gIFhBcGVydHVyZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHRoaXMuYWNjW3RoaXMucG9zXSA9IGlucHV0O1xuICAgIHRoaXMucG9zICs9IDE7XG4gICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMuZnVsbCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBYQXBlcnR1cmUucHJvdG90eXBlLmdldENvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX2NvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFjYywgdGhpcy5wb3MpLFxuICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuYWNjLCAwLCB0aGlzLnBvcykpO1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94YXBlcnR1cmUobiwgeGYpIHsgcmV0dXJuIG5ldyBYQXBlcnR1cmUobiwgeGYpOyB9KTtcbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGFwZXJ0dXJlLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfZmxhdENhdCA9IHJlcXVpcmUoJy4vX2ZsYXRDYXQnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuLi9tYXAnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gX3hjaGFpbihmLCB4Zikge1xuICByZXR1cm4gbWFwKGYsIF9mbGF0Q2F0KHhmKSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194Y2hhaW4uanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWERyb3AobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5uID0gbjtcbiAgfVxuICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5uID4gMCkge1xuICAgICAgdGhpcy5uIC09IDE7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3AobiwgeGYpIHsgcmV0dXJuIG5ldyBYRHJvcChuLCB4Zik7IH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRHJvcExhc3QobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuYWNjID0gbmV3IEFycmF5KG4pO1xuICB9XG4gIFhEcm9wTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9ICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB0aGlzLmFjYyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmZ1bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmFjY1t0aGlzLnBvc10pO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBYRHJvcExhc3QucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB0aGlzLmFjY1t0aGlzLnBvc10gPSBpbnB1dDtcbiAgICB0aGlzLnBvcyArPSAxO1xuICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5hY2MubGVuZ3RoKSB7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmZ1bGwgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGRyb3BMYXN0KG4sIHhmKSB7IHJldHVybiBuZXcgWERyb3BMYXN0KG4sIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hkcm9wTGFzdC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vX3JlZHVjZScpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhEcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICAgIHRoaXMuZiA9IGZuO1xuICAgIHRoaXMucmV0YWluZWQgPSBbXTtcbiAgICB0aGlzLnhmID0geGY7XG4gIH1cbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHRoaXMucmV0YWluZWQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy5yZXRhaW4ocmVzdWx0LCBpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZmx1c2gocmVzdWx0LCBpbnB1dCk7XG4gIH07XG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXN1bHQgPSBfcmVkdWNlKFxuICAgICAgdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRoaXMucmV0YWluZWRcbiAgICApO1xuICAgIHRoaXMucmV0YWluZWQgPSBbXTtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLnJldGFpbmVkLnB1c2goaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdFdoaWxlKGZuLCB4ZikgeyByZXR1cm4gbmV3IFhEcm9wTGFzdFdoaWxlKGZuLCB4Zik7IH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcExhc3RXaGlsZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRHJvcFdoaWxlKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZikge1xuICAgICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFdoaWxlKGYsIHhmKSB7IHJldHVybiBuZXcgWERyb3BXaGlsZShmLCB4Zik7IH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194ZHJvcFdoaWxlLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhGaWx0ZXIoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaWx0ZXIoZiwgeGYpIHsgcmV0dXJuIG5ldyBYRmlsdGVyKGYsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmaWx0ZXIuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2VkID0gcmVxdWlyZSgnLi9fcmVkdWNlZCcpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWEZpbmQoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gIH1cbiAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHZvaWQgMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmluZChmLCB4ZikgeyByZXR1cm4gbmV3IFhGaW5kKGYsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmaW5kLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfcmVkdWNlZCA9IHJlcXVpcmUoJy4vX3JlZHVjZWQnKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhGaW5kSW5kZXgoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmlkeCA9IC0xO1xuICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgfVxuICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEZpbmRJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmlkeCArPSAxO1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlkeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIF94ZmluZEluZGV4KGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbmRJbmRleChmLCB4Zik7IH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194ZmluZEluZGV4LmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhGaW5kTGFzdChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdCkpO1xuICB9O1xuICBYRmluZExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmRMYXN0KGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbmRMYXN0KGYsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmaW5kTGFzdC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRmluZExhc3RJbmRleChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuaWR4ID0gLTE7XG4gICAgdGhpcy5sYXN0SWR4ID0gLTE7XG4gIH1cbiAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdElkeCkpO1xuICB9O1xuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5pZHggKz0gMTtcbiAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgdGhpcy5sYXN0SWR4ID0gdGhpcy5pZHg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kTGFzdEluZGV4KGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbmRMYXN0SW5kZXgoZiwgeGYpOyB9KTtcbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feGZpbmRMYXN0SW5kZXguanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWE1hcChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5mKGlucHV0KSk7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3htYXAoZiwgeGYpIHsgcmV0dXJuIG5ldyBYTWFwKGYsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3htYXAuanMiLCJ2YXIgX2N1cnJ5TiA9IHJlcXVpcmUoJy4vX2N1cnJ5TicpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhSZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gICAgdGhpcy52YWx1ZUZuID0gdmFsdWVGbjtcbiAgICB0aGlzLnZhbHVlQWNjID0gdmFsdWVBY2M7XG4gICAgdGhpcy5rZXlGbiA9IGtleUZuO1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmlucHV0cyA9IHt9O1xuICB9XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5pbnB1dHMpIHtcbiAgICAgIGlmIChfaGFzKGtleSwgdGhpcy5pbnB1dHMpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlucHV0c1trZXldKTtcbiAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnB1dHMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcbiAgWFJlZHVjZUJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXlGbihpbnB1dCk7XG4gICAgdGhpcy5pbnB1dHNba2V5XSA9IHRoaXMuaW5wdXRzW2tleV0gfHwgW2tleSwgdGhpcy52YWx1ZUFjY107XG4gICAgdGhpcy5pbnB1dHNba2V5XVsxXSA9IHRoaXMudmFsdWVGbih0aGlzLmlucHV0c1trZXldWzFdLCBpbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX2N1cnJ5Tig0LCBbXSxcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX3hyZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYUmVkdWNlQnkodmFsdWVGbiwgdmFsdWVBY2MsIGtleUZuLCB4Zik7XG4gICAgICAgICAgICAgICAgIH0pO1xufSgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludGVybmFsL194cmVkdWNlQnkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2VkID0gcmVxdWlyZSgnLi9fcmVkdWNlZCcpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhUYWtlKG4sIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMubiA9IG47XG4gICAgdGhpcy5pID0gMDtcbiAgfVxuICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmkgKz0gMTtcbiAgICB2YXIgcmV0ID0gdGhpcy5uID09PSAwID8gcmVzdWx0IDogdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5pID49IHRoaXMubiA/IF9yZWR1Y2VkKHJldCkgOiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3h0YWtlKG4sIHhmKSB7IHJldHVybiBuZXcgWFRha2UobiwgeGYpOyB9KTtcbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcm5hbC9feHRha2UuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF9yZWR1Y2VkID0gcmVxdWlyZSgnLi9fcmVkdWNlZCcpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWFRha2VXaGlsZShmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSA6IF9yZWR1Y2VkKHJlc3VsdCk7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3h0YWtlV2hpbGUoZiwgeGYpIHsgcmV0dXJuIG5ldyBYVGFrZVdoaWxlKGYsIHhmKTsgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJuYWwvX3h0YWtlV2hpbGUuanMiLCJ2YXIgX2NvbnRhaW5zID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29udGFpbnMnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2ZpbHRlcicpO1xudmFyIGZsaXAgPSByZXF1aXJlKCcuL2ZsaXAnKTtcbnZhciB1bmlxID0gcmVxdWlyZSgnLi91bmlxJyk7XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aG9zZVxuICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGVsZW1lbnRzIGZvdW5kIGluIGJvdGggYGxpc3QxYCBhbmQgYGxpc3QyYC5cbiAqIEBzZWUgUi5pbnRlcnNlY3Rpb25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbnRlcnNlY3Rpb24oWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzQsIDNdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBpbnRlcnNlY3Rpb24obGlzdDEsIGxpc3QyKSB7XG4gIHZhciBsb29rdXBMaXN0LCBmaWx0ZXJlZExpc3Q7XG4gIGlmIChsaXN0MS5sZW5ndGggPiBsaXN0Mi5sZW5ndGgpIHtcbiAgICBsb29rdXBMaXN0ID0gbGlzdDE7XG4gICAgZmlsdGVyZWRMaXN0ID0gbGlzdDI7XG4gIH0gZWxzZSB7XG4gICAgbG9va3VwTGlzdCA9IGxpc3QyO1xuICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QxO1xuICB9XG4gIHJldHVybiB1bmlxKF9maWx0ZXIoZmxpcChfY29udGFpbnMpKGxvb2t1cExpc3QpLCBmaWx0ZXJlZExpc3QpKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJzZWN0aW9uLmpzIiwidmFyIF9jb250YWluc1dpdGggPSByZXF1aXJlKCcuL2ludGVybmFsL19jb250YWluc1dpdGgnKTtcbnZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgdW5pcVdpdGggPSByZXF1aXJlKCcuL3VuaXFXaXRoJyk7XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aG9zZVxuICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuIER1cGxpY2F0aW9uIGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvIHRoZVxuICogdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byB0d28gbGlzdCBlbGVtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoKGEsIGEpIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gKiAgICAgICAgdGhlIHR3byBzdXBwbGllZCBlbGVtZW50cyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBPbmUgbGlzdCBvZiBpdGVtcyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBBIHNlY29uZCBsaXN0IG9mIGl0ZW1zIHRvIGNvbXBhcmVcbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhvc2UgZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gKiBAc2VlIFIuaW50ZXJzZWN0aW9uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGJ1ZmZhbG9TcHJpbmdmaWVsZCA9IFtcbiAqICAgICAgICB7aWQ6IDgyNCwgbmFtZTogJ1JpY2hpZSBGdXJheSd9LFxuICogICAgICAgIHtpZDogOTU2LCBuYW1lOiAnRGV3ZXkgTWFydGluJ30sXG4gKiAgICAgICAge2lkOiAzMTMsIG5hbWU6ICdCcnVjZSBQYWxtZXInfSxcbiAqICAgICAgICB7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sXG4gKiAgICAgICAge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31cbiAqICAgICAgXTtcbiAqICAgICAgdmFyIGNzbnkgPSBbXG4gKiAgICAgICAge2lkOiAyMDQsIG5hbWU6ICdEYXZpZCBDcm9zYnknfSxcbiAqICAgICAgICB7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sXG4gKiAgICAgICAge2lkOiA1MzksIG5hbWU6ICdHcmFoYW0gTmFzaCd9LFxuICogICAgICAgIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XG4gKiAgICAgIF07XG4gKlxuICogICAgICBSLmludGVyc2VjdGlvbldpdGgoUi5lcUJ5KFIucHJvcCgnaWQnKSksIGJ1ZmZhbG9TcHJpbmdmaWVsZCwgY3NueSk7XG4gKiAgICAgIC8vPT4gW3tpZDogNDU2LCBuYW1lOiAnU3RlcGhlbiBTdGlsbHMnfSwge2lkOiAxNzcsIG5hbWU6ICdOZWlsIFlvdW5nJ31dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBpbnRlcnNlY3Rpb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICB2YXIgbG9va3VwTGlzdCwgZmlsdGVyZWRMaXN0O1xuICBpZiAobGlzdDEubGVuZ3RoID4gbGlzdDIubGVuZ3RoKSB7XG4gICAgbG9va3VwTGlzdCA9IGxpc3QxO1xuICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QyO1xuICB9IGVsc2Uge1xuICAgIGxvb2t1cExpc3QgPSBsaXN0MjtcbiAgICBmaWx0ZXJlZExpc3QgPSBsaXN0MTtcbiAgfVxuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGZpbHRlcmVkTGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoX2NvbnRhaW5zV2l0aChwcmVkLCBmaWx0ZXJlZExpc3RbaWR4XSwgbG9va3VwTGlzdCkpIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gZmlsdGVyZWRMaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiB1bmlxV2l0aChwcmVkLCByZXN1bHRzKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50ZXJzZWN0aW9uV2l0aC5qcyIsInZhciBfY2hlY2tGb3JNZXRob2QgPSByZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCB3aXRoIHRoZSBzZXBhcmF0b3IgaW50ZXJwb3NlZCBiZXR3ZWVuIGVsZW1lbnRzLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBpbnRlcnNwZXJzZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0geyp9IHNlcGFyYXRvciBUaGUgZWxlbWVudCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGludGVycG9zZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW50ZXJzcGVyc2UoJ24nLCBbJ2JhJywgJ2EnLCAnYSddKTsgLy89PiBbJ2JhJywgJ24nLCAnYScsICduJywgJ2EnXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2NoZWNrRm9yTWV0aG9kKCdpbnRlcnNwZXJzZScsIGZ1bmN0aW9uIGludGVyc3BlcnNlKHNlcGFyYXRvciwgbGlzdCkge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW5ndGgpIHtcbiAgICBpZiAoaWR4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICBvdXQucHVzaChsaXN0W2lkeF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQucHVzaChsaXN0W2lkeF0sIHNlcGFyYXRvcik7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pbnRlcnNwZXJzZS5qcyIsInZhciBfY2xvbmUgPSByZXF1aXJlKCcuL2ludGVybmFsL19jbG9uZScpO1xudmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBfaXNUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzVHJhbnNmb3JtZXInKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgX3N0ZXBDYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19zdGVwQ2F0Jyk7XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBpdGVtcyBvZiB0aGUgbGlzdCB3aXRoIHRoZSB0cmFuc2R1Y2VyIGFuZCBhcHBlbmRzIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgdG8gdGhlIGFjY3VtdWxhdG9yIHVzaW5nIGFuIGFwcHJvcHJpYXRlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKiBiYXNlZCBvbiB0aGUgYWNjdW11bGF0b3IgdHlwZS5cbiAqXG4gKiBUaGUgYWNjdW11bGF0b3IgY2FuIGJlIGFuIGFycmF5LCBzdHJpbmcsIG9iamVjdCBvciBhIHRyYW5zZm9ybWVyLiBJdGVyYXRlZFxuICogaXRlbXMgd2lsbCBiZSBhcHBlbmRlZCB0byBhcnJheXMgYW5kIGNvbmNhdGVuYXRlZCB0byBzdHJpbmdzLiBPYmplY3RzIHdpbGxcbiAqIGJlIG1lcmdlZCBkaXJlY3RseSBvciAyLWl0ZW0gYXJyYXlzIHdpbGwgYmUgbWVyZ2VkIGFzIGtleSwgdmFsdWUgcGFpcnMuXG4gKlxuICogVGhlIGFjY3VtdWxhdG9yIGNhbiBhbHNvIGJlIGEgdHJhbnNmb3JtZXIgb2JqZWN0IHRoYXQgcHJvdmlkZXMgYSAyLWFyaXR5XG4gKiByZWR1Y2luZyBpdGVyYXRvciBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmRcbiAqIDEtYXJpdHkgcmVzdWx0IGV4dHJhY3Rpb24gZnVuY3Rpb24gcmVzdWx0LiBUaGUgc3RlcCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZVxuICogaXRlcmF0b3IgZnVuY3Rpb24gaW4gcmVkdWNlLiBUaGUgcmVzdWx0IGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCB0aGVcbiAqIGZpbmFsIGFjY3VtdWxhdG9yIGludG8gdGhlIHJldHVybiB0eXBlIGFuZCBpbiBtb3N0IGNhc2VzIGlzIFIuaWRlbnRpdHkuIFRoZVxuICogaW5pdCBmdW5jdGlvbiBpcyB1c2VkIHRvIHByb3ZpZGUgdGhlIGluaXRpYWwgYWNjdW11bGF0b3IuXG4gKlxuICogVGhlIGl0ZXJhdGlvbiBpcyBwZXJmb3JtZWQgd2l0aCBSLnJlZHVjZSBhZnRlciBpbml0aWFsaXppbmcgdGhlIHRyYW5zZHVjZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiAoYiAtPiBiKSAtPiBbY10gLT4gYVxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiBUaGUgdHJhbnNkdWNlciBmdW5jdGlvbi4gUmVjZWl2ZXMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhIHRyYW5zZm9ybWVyLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBudW1iZXJzID0gWzEsIDIsIDMsIDRdO1xuICogICAgICB2YXIgdHJhbnNkdWNlciA9IFIuY29tcG9zZShSLm1hcChSLmFkZCgxKSksIFIudGFrZSgyKSk7XG4gKlxuICogICAgICBSLmludG8oW10sIHRyYW5zZHVjZXIsIG51bWJlcnMpOyAvLz0+IFsyLCAzXVxuICpcbiAqICAgICAgdmFyIGludG9BcnJheSA9IFIuaW50byhbXSk7XG4gKiAgICAgIGludG9BcnJheSh0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIGludG8oYWNjLCB4ZiwgbGlzdCkge1xuICByZXR1cm4gX2lzVHJhbnNmb3JtZXIoYWNjKSA/XG4gICAgX3JlZHVjZSh4ZihhY2MpLCBhY2NbJ0BAdHJhbnNkdWNlci9pbml0J10oKSwgbGlzdCkgOlxuICAgIF9yZWR1Y2UoeGYoX3N0ZXBDYXQoYWNjKSksIF9jbG9uZShhY2MsIFtdLCBbXSwgZmFsc2UpLCBsaXN0KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW50by5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG4vKipcbiAqIFNhbWUgYXMgUi5pbnZlcnRPYmosIGhvd2V2ZXIgdGhpcyBhY2NvdW50cyBmb3Igb2JqZWN0cyB3aXRoIGR1cGxpY2F0ZSB2YWx1ZXNcbiAqIGJ5IHB1dHRpbmcgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7czogeH0gLT4ge3g6IFsgcywgLi4uIF19XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHtPYmplY3R9IG91dCBBIG5ldyBvYmplY3Qgd2l0aCBrZXlzXG4gKiBpbiBhbiBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgcmFjZVJlc3VsdHNCeUZpcnN0TmFtZSA9IHtcbiAqICAgICAgICBmaXJzdDogJ2FsaWNlJyxcbiAqICAgICAgICBzZWNvbmQ6ICdqYWtlJyxcbiAqICAgICAgICB0aGlyZDogJ2FsaWNlJyxcbiAqICAgICAgfTtcbiAqICAgICAgUi5pbnZlcnQocmFjZVJlc3VsdHNCeUZpcnN0TmFtZSk7XG4gKiAgICAgIC8vPT4geyAnYWxpY2UnOiBbJ2ZpcnN0JywgJ3RoaXJkJ10sICdqYWtlJzpbJ3NlY29uZCddIH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGludmVydChvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIG91dCA9IHt9O1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaWR4XTtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgdmFyIGxpc3QgPSBfaGFzKHZhbCwgb3V0KSA/IG91dFt2YWxdIDogKG91dFt2YWxdID0gW10pO1xuICAgIGxpc3RbbGlzdC5sZW5ndGhdID0ga2V5O1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2ludmVydC5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUga2V5cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IGFzIHZhbHVlcywgYW5kIHRoZVxuICogdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsIHdoaWNoIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MsIGFzIGtleXMuIE5vdGVcbiAqIHRoYXQgdGhlIGxhc3Qga2V5IGZvdW5kIGlzIHByZWZlcnJlZCB3aGVuIGhhbmRsaW5nIHRoZSBzYW1lIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7czogeH0gLT4ge3g6IHN9XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHtPYmplY3R9IG91dCBBIG5ldyBvYmplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgcmFjZVJlc3VsdHMgPSB7XG4gKiAgICAgICAgZmlyc3Q6ICdhbGljZScsXG4gKiAgICAgICAgc2Vjb25kOiAnamFrZSdcbiAqICAgICAgfTtcbiAqICAgICAgUi5pbnZlcnRPYmoocmFjZVJlc3VsdHMpO1xuICogICAgICAvLz0+IHsgJ2FsaWNlJzogJ2ZpcnN0JywgJ2pha2UnOidzZWNvbmQnIH1cbiAqXG4gKiAgICAgIC8vIEFsdGVybmF0aXZlbHk6XG4gKiAgICAgIHZhciByYWNlUmVzdWx0cyA9IFsnYWxpY2UnLCAnamFrZSddO1xuICogICAgICBSLmludmVydE9iaihyYWNlUmVzdWx0cyk7XG4gKiAgICAgIC8vPT4geyAnYWxpY2UnOiAnMCcsICdqYWtlJzonMScgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gaW52ZXJ0T2JqKG9iaikge1xuICB2YXIgcHJvcHMgPSBrZXlzKG9iaik7XG4gIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgb3V0ID0ge307XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpZHhdO1xuICAgIG91dFtvYmpba2V5XV0gPSBrZXk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvaW52ZXJ0T2JqLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBlbXB0eSA9IHJlcXVpcmUoJy4vZW1wdHknKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGl0cyB0eXBlJ3MgZW1wdHkgdmFsdWU7IGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5lbXB0eVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNFbXB0eShbMSwgMiwgM10pOyAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0VtcHR5KFtdKTsgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNFbXB0eSgnJyk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmlzRW1wdHkobnVsbCk7ICAgICAgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNFbXB0eSh7fSk7ICAgICAgICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmlzRW1wdHkoe2xlbmd0aDogMH0pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBpc0VtcHR5KHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiBlcXVhbHMoeCwgZW1wdHkoeCkpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pc0VtcHR5LmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pc05pbChudWxsKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNOaWwodW5kZWZpbmVkKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNOaWwoMCk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc05pbChbXSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGlzTmlsKHgpIHsgcmV0dXJuIHggPT0gbnVsbDsgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9pc05pbC5qcyIsInZhciBpbnZva2VyID0gcmVxdWlyZSgnLi9pbnZva2VyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIG1hZGUgYnkgaW5zZXJ0aW5nIHRoZSBgc2VwYXJhdG9yYCBiZXR3ZWVuIGVhY2ggZWxlbWVudCBhbmRcbiAqIGNvbmNhdGVuYXRpbmcgYWxsIHRoZSBlbGVtZW50cyBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFN0cmluZyAtPiBbYV0gLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNlcGFyYXRvciBUaGUgc3RyaW5nIHVzZWQgdG8gc2VwYXJhdGUgdGhlIGVsZW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGVsZW1lbnRzIHRvIGpvaW4gaW50byBhIHN0cmluZy5cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgbWFkZSBieSBjb25jYXRlbmF0aW5nIGB4c2Agd2l0aCBgc2VwYXJhdG9yYC5cbiAqIEBzZWUgUi5zcGxpdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzcGFjZXIgPSBSLmpvaW4oJyAnKTtcbiAqICAgICAgc3BhY2VyKFsnYScsIDIsIDMuNF0pOyAgIC8vPT4gJ2EgMiAzLjQnXG4gKiAgICAgIFIuam9pbignfCcsIFsxLCAyLCAzXSk7ICAgIC8vPT4gJzF8MnwzJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGludm9rZXIoMSwgJ2pvaW4nKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2pvaW4uanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBwbGllZFxuICogb2JqZWN0LCBpbmNsdWRpbmcgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBba11cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBvYmplY3QncyBvd24gYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLmtleXNJbihmKTsgLy89PiBbJ3gnLCAneSddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBrZXlzSW4ob2JqKSB7XG4gIHZhciBwcm9wO1xuICB2YXIga3MgPSBbXTtcbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICB9XG4gIHJldHVybiBrcztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMva2V5c0luLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJyYXknKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZlxuICogdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gYFIuZXF1YWxzYCBpcyB1c2VkIHRvIGRldGVybWluZVxuICogZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCwgb3IgLTEgaWYgdGhlIHRhcmdldCBpcyBub3QgZm91bmQuXG4gKiBAc2VlIFIuaW5kZXhPZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubGFzdEluZGV4T2YoMywgWy0xLDMsMywwLDEsMiwzLDRdKTsgLy89PiA2XG4gKiAgICAgIFIubGFzdEluZGV4T2YoMTAsIFsxLDIsMyw0XSk7IC8vPT4gLTFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGxhc3RJbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgaWYgKHR5cGVvZiB4cy5sYXN0SW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpKSB7XG4gICAgcmV0dXJuIHhzLmxhc3RJbmRleE9mKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkeCA9IHhzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgICBpZiAoZXF1YWxzKHhzW2lkeF0sIHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIGlkeCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbGFzdEluZGV4T2YuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGxlbnMgPSByZXF1aXJlKCcuL2xlbnMnKTtcbnZhciBudGggPSByZXF1aXJlKCcuL250aCcpO1xudmFyIHVwZGF0ZSA9IHJlcXVpcmUoJy4vdXBkYXRlJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIE51bWJlciAtPiBMZW5zIHMgYVxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBoZWFkTGVucyA9IFIubGVuc0luZGV4KDApO1xuICpcbiAqICAgICAgUi52aWV3KGhlYWRMZW5zLCBbJ2EnLCAnYicsICdjJ10pOyAgICAgICAgICAgIC8vPT4gJ2EnXG4gKiAgICAgIFIuc2V0KGhlYWRMZW5zLCAneCcsIFsnYScsICdiJywgJ2MnXSk7ICAgICAgICAvLz0+IFsneCcsICdiJywgJ2MnXVxuICogICAgICBSLm92ZXIoaGVhZExlbnMsIFIudG9VcHBlciwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbJ0EnLCAnYicsICdjJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGxlbnNJbmRleChuKSB7XG4gIHJldHVybiBsZW5zKG50aChuKSwgdXBkYXRlKG4pKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbGVuc0luZGV4LmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBhc3NvY1BhdGggPSByZXF1aXJlKCcuL2Fzc29jUGF0aCcpO1xudmFyIGxlbnMgPSByZXF1aXJlKCcuL2xlbnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyB3aG9zZSBmb2N1cyBpcyB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgW0lkeF0gLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gdXNlLlxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhIZWFkWUxlbnMgPSBSLmxlbnNQYXRoKFsneCcsIDAsICd5J10pO1xuICpcbiAqICAgICAgUi52aWV3KHhIZWFkWUxlbnMsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4gMlxuICogICAgICBSLnNldCh4SGVhZFlMZW5zLCAxLCB7eDogW3t5OiAyLCB6OiAzfSwge3k6IDQsIHo6IDV9XX0pO1xuICogICAgICAvLz0+IHt4OiBbe3k6IDEsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICogICAgICBSLm92ZXIoeEhlYWRZTGVucywgUi5uZWdhdGUsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4ge3g6IFt7eTogLTIsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbGVuc1BhdGgocCkge1xuICByZXR1cm4gbGVucyhwYXRoKHApLCBhc3NvY1BhdGgocCkpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9sZW5zUGF0aC5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgYXNzb2MgPSByZXF1aXJlKCcuL2Fzc29jJyk7XG52YXIgbGVucyA9IHJlcXVpcmUoJy4vbGVucycpO1xudmFyIHByb3AgPSByZXF1aXJlKCcuL3Byb3AnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsZW5zIHdob3NlIGZvY3VzIGlzIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgU3RyaW5nIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge1N0cmluZ30ga1xuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICpcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgLy89PiB7eDogNCwgeTogMn1cbiAqICAgICAgUi5vdmVyKHhMZW5zLCBSLm5lZ2F0ZSwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IC0xLCB5OiAyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbGVuc1Byb3Aoaykge1xuICByZXR1cm4gbGVucyhwcm9wKGspLCBhc3NvYyhrKSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2xlbnNQcm9wLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5ndFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubHQoMiwgMSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdCgyLCAyKTsgLy89PiBmYWxzZVxuICogICAgICBSLmx0KDIsIDMpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdCgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0KCd6JywgJ2EnKTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbHQoYSwgYikgeyByZXR1cm4gYSA8IGI7IH0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbHQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5ndGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmx0ZSgyLCAxKTsgLy89PiBmYWxzZVxuICogICAgICBSLmx0ZSgyLCAyKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHRlKDIsIDMpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoJ2EnLCAneicpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoJ3onLCAnYScpOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBsdGUoYSwgYikgeyByZXR1cm4gYSA8PSBiOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL2x0ZS5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUaGUgbWFwQWNjdW0gZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gKiBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIGEgbGlzdCwgcGFzc2luZyBhbiBhY2N1bXVsYXRpbmdcbiAqIHBhcmFtZXRlciBmcm9tIGxlZnQgdG8gcmlnaHQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKmFjYyogYW5kICp2YWx1ZSosIGFuZCBzaG91bGRcbiAqIHJldHVybiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhY2MgLT4geCAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5hZGRJbmRleCwgUi5tYXBBY2N1bVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICogICAgICB2YXIgYXBwZW5kZXIgPSAoYSwgYikgPT4gW2EgKyBiLCBhICsgYl07XG4gKlxuICogICAgICBSLm1hcEFjY3VtKGFwcGVuZGVyLCAwLCBkaWdpdHMpOyAvLz0+IFsnMDEyMzQnLCBbJzAxJywgJzAxMicsICcwMTIzJywgJzAxMjM0J11dXG4gKiBAc3ltYiBSLm1hcEFjY3VtKGYsIGEsIFtiLCBjLCBkXSkgPSBbXG4gKiAgIGYoZihmKGEsIGIpWzBdLCBjKVswXSwgZClbMF0sXG4gKiAgIFtcbiAqICAgICBmKGEsIGIpWzFdLFxuICogICAgIGYoZihhLCBiKVswXSwgYylbMV0sXG4gKiAgICAgZihmKGYoYSwgYilbMF0sIGMpWzBdLCBkKVsxXVxuICogICBdXG4gKiBdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBtYXBBY2N1bShmbiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHR1cGxlID0gW2FjY107XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgIHJlc3VsdFtpZHhdID0gdHVwbGVbMV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIFt0dXBsZVswXSwgcmVzdWx0XTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbWFwQWNjdW0uanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogVGhlIG1hcEFjY3VtUmlnaHQgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gKiBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIGEgbGlzdCwgcGFzc2luZyBhbiBhY2N1bXVsYXRpbmdcbiAqIHBhcmFtZXRlciBmcm9tIHJpZ2h0IHRvIGxlZnQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAqXG4gKiBTaW1pbGFyIHRvIGBtYXBBY2N1bWAsIGV4Y2VwdCBtb3ZlcyB0aHJvdWdoIHRoZSBpbnB1dCBsaXN0IGZyb20gdGhlIHJpZ2h0IHRvXG4gKiB0aGUgbGVmdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKnZhbHVlKiBhbmQgKmFjYyosIGFuZCBzaG91bGRcbiAqIHJldHVybiBhIHR1cGxlICpbdmFsdWUsIGFjY10qLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICh4LT4gYWNjIC0+ICh5LCBhY2MpKSAtPiBhY2MgLT4gW3hdIC0+IChbeV0sIGFjYylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlcnkgZWxlbWVudCBvZiB0aGUgaW5wdXQgYGxpc3RgLlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLmFkZEluZGV4LCBSLm1hcEFjY3VtXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICogICAgICB2YXIgYXBwZW5kID0gKGEsIGIpID0+IFthICsgYiwgYSArIGJdO1xuICpcbiAqICAgICAgUi5tYXBBY2N1bVJpZ2h0KGFwcGVuZCwgNSwgZGlnaXRzKTsgLy89PiBbWycxMjM0NScsICcyMzQ1JywgJzM0NScsICc0NSddLCAnMTIzNDUnXVxuICogQHN5bWIgUi5tYXBBY2N1bVJpZ2h0KGYsIGEsIFtiLCBjLCBkXSkgPSBbXG4gKiAgIFtcbiAqICAgICBmKGIsIGYoYywgZihkLCBhKVswXSlbMF0pWzFdLFxuICogICAgIGYoYywgZihkLCBhKVswXSlbMV0sXG4gKiAgICAgZihkLCBhKVsxXSxcbiAqICAgXVxuICogICBmKGIsIGYoYywgZihkLCBhKVswXSlbMF0pWzBdLFxuICogXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW1SaWdodChmbiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHR1cGxlID0gW2FjY107XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIHR1cGxlID0gZm4obGlzdFtpZHhdLCB0dXBsZVswXSk7XG4gICAgcmVzdWx0W2lkeF0gPSB0dXBsZVsxXTtcbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gW3Jlc3VsdCwgdHVwbGVbMF1dO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9tYXBBY2N1bVJpZ2h0LmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbi8qKlxuICogQW4gT2JqZWN0LXNwZWNpZmljIHZlcnNpb24gb2YgYG1hcGAuIFRoZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRocmVlXG4gKiBhcmd1bWVudHM6ICoodmFsdWUsIGtleSwgb2JqKSouIElmIG9ubHkgdGhlIHZhbHVlIGlzIHNpZ25pZmljYW50LCB1c2VcbiAqIGBtYXBgIGluc3RlYWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoKiwgU3RyaW5nLCBPYmplY3QpIC0+ICopIC0+IE9iamVjdCAtPiBPYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWFwXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHZhbHVlcyA9IHsgeDogMSwgeTogMiwgejogMyB9O1xuICogICAgICB2YXIgcHJlcGVuZEtleUFuZERvdWJsZSA9IChudW0sIGtleSwgb2JqKSA9PiBrZXkgKyAobnVtICogMik7XG4gKlxuICogICAgICBSLm1hcE9iakluZGV4ZWQocHJlcGVuZEtleUFuZERvdWJsZSwgdmFsdWVzKTsgLy89PiB7IHg6ICd4MicsIHk6ICd5NCcsIHo6ICd6NicgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbWFwT2JqSW5kZXhlZChmbiwgb2JqKSB7XG4gIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgYWNjW2tleV0gPSBmbihvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9LCBrZXlzKG9iaikpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9tYXBPYmpJbmRleGVkLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFRlc3RzIGEgcmVndWxhciBleHByZXNzaW9uIGFnYWluc3QgYSBTdHJpbmcuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnMgZnJvbVxuICogW2BTdHJpbmcucHJvdG90eXBlLm1hdGNoYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL21hdGNoKVxuICogd2hpY2ggcmV0dXJucyBgbnVsbGAgd2hlbiB0aGVyZSBhcmUgbm8gbWF0Y2hlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBbU3RyaW5nIHwgVW5kZWZpbmVkXVxuICogQHBhcmFtIHtSZWdFeHB9IHJ4IEEgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBtYXRjaGVzIG9yIGVtcHR5IGFycmF5LlxuICogQHNlZSBSLnRlc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICogICAgICBSLm1hdGNoKC9hLywgJ2InKTsgLy89PiBbXVxuICogICAgICBSLm1hdGNoKC9hLywgbnVsbCk7IC8vPT4gVHlwZUVycm9yOiBudWxsIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCJtYXRjaFwiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBtYXRjaChyeCwgc3RyKSB7XG4gIHJldHVybiBzdHIubWF0Y2gocngpIHx8IFtdO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9tYXRjaC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzSW50ZWdlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzSW50ZWdlcicpO1xuXG5cbi8qKlxuICogbWF0aE1vZCBiZWhhdmVzIGxpa2UgdGhlIG1vZHVsbyBvcGVyYXRvciBzaG91bGQgbWF0aGVtYXRpY2FsbHksIHVubGlrZSB0aGVcbiAqIGAlYCBvcGVyYXRvciAoYW5kIGJ5IGV4dGVuc2lvbiwgUi5tb2R1bG8pLiBTbyB3aGlsZSBcIi0xNyAlIDVcIiBpcyAtMixcbiAqIG1hdGhNb2QoLTE3LCA1KSBpcyAzLiBtYXRoTW9kIHJlcXVpcmVzIEludGVnZXIgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBOYU5cbiAqIHdoZW4gdGhlIG1vZHVsdXMgaXMgemVybyBvciBuZWdhdGl2ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gbSBUaGUgZGl2aWRlbmQuXG4gKiBAcGFyYW0ge051bWJlcn0gcCB0aGUgbW9kdWx1cy5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYiBtb2QgYWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tYXRoTW9kKC0xNywgNSk7ICAvLz0+IDNcbiAqICAgICAgUi5tYXRoTW9kKDE3LCA1KTsgICAvLz0+IDJcbiAqICAgICAgUi5tYXRoTW9kKDE3LCAtNSk7ICAvLz0+IE5hTlxuICogICAgICBSLm1hdGhNb2QoMTcsIDApOyAgIC8vPT4gTmFOXG4gKiAgICAgIFIubWF0aE1vZCgxNy4yLCA1KTsgLy89PiBOYU5cbiAqICAgICAgUi5tYXRoTW9kKDE3LCA1LjMpOyAvLz0+IE5hTlxuICpcbiAqICAgICAgdmFyIGNsb2NrID0gUi5tYXRoTW9kKFIuX18sIDEyKTtcbiAqICAgICAgY2xvY2soMTUpOyAvLz0+IDNcbiAqICAgICAgY2xvY2soMjQpOyAvLz0+IDBcbiAqXG4gKiAgICAgIHZhciBzZXZlbnRlZW5Nb2QgPSBSLm1hdGhNb2QoMTcpO1xuICogICAgICBzZXZlbnRlZW5Nb2QoMyk7ICAvLz0+IDJcbiAqICAgICAgc2V2ZW50ZWVuTW9kKDQpOyAgLy89PiAxXG4gKiAgICAgIHNldmVudGVlbk1vZCgxMCk7IC8vPT4gN1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbWF0aE1vZChtLCBwKSB7XG4gIGlmICghX2lzSW50ZWdlcihtKSkgeyByZXR1cm4gTmFOOyB9XG4gIGlmICghX2lzSW50ZWdlcihwKSB8fCBwIDwgMSkgeyByZXR1cm4gTmFOOyB9XG4gIHJldHVybiAoKG0gJSBwKSArIHApICUgcDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbWF0aE1vZC5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzLCBhbmQgcmV0dXJucyB3aGljaGV2ZXIgdmFsdWUgcHJvZHVjZXMgdGhlXG4gKiBsYXJnZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWF4LCBSLm1pbkJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gKiAgICAgIHZhciBzcXVhcmUgPSBuID0+IG4gKiBuO1xuICpcbiAqICAgICAgUi5tYXhCeShzcXVhcmUsIC0zLCAyKTsgLy89PiAtM1xuICpcbiAqICAgICAgUi5yZWR1Y2UoUi5tYXhCeShzcXVhcmUpLCAwLCBbMywgLTUsIDQsIDEsIC0yXSk7IC8vPT4gLTVcbiAqICAgICAgUi5yZWR1Y2UoUi5tYXhCeShzcXVhcmUpLCAwLCBbXSk7IC8vPT4gMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gbWF4QnkoZiwgYSwgYikge1xuICByZXR1cm4gZihiKSA+IGYoYSkgPyBiIDogYTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvbWF4QnkuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIG1lYW4gPSByZXF1aXJlKCcuL21lYW4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1lZGlhbiBvZiB0aGUgZ2l2ZW4gbGlzdCBvZiBudW1iZXJzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVkaWFuKFsyLCA5LCA3XSk7IC8vPT4gN1xuICogICAgICBSLm1lZGlhbihbNywgMiwgMTAsIDldKTsgLy89PiA4XG4gKiAgICAgIFIubWVkaWFuKFtdKTsgLy89PiBOYU5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIG1lZGlhbihsaXN0KSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIHdpZHRoID0gMiAtIGxlbiAlIDI7XG4gIHZhciBpZHggPSAobGVuIC0gd2lkdGgpIC8gMjtcbiAgcmV0dXJuIG1lYW4oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICB9KS5zbGljZShpZHgsIGlkeCArIHdpZHRoKSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21lZGlhbi5qcyIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfaGFzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faGFzJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgY2FjaGVzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZm5gXG4gKiBmb3IgYSBnaXZlbiBhcmd1bWVudCBzZXQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGVcbiAqIG1lbW9pemVkIGBmbmAgd2l0aCB0aGUgc2FtZSBhcmd1bWVudCBzZXQgd2lsbCBub3QgcmVzdWx0IGluIGFuIGFkZGl0aW9uYWxcbiAqIGNhbGwgdG8gYGZuYDsgaW5zdGVhZCwgdGhlIGNhY2hlZCByZXN1bHQgZm9yIHRoYXQgc2V0IG9mIGFyZ3VtZW50cyB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKi4uLiAtPiBhKSAtPiAoKi4uLiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gTWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBjb3VudCA9IDA7XG4gKiAgICAgIHZhciBmYWN0b3JpYWwgPSBSLm1lbW9pemUobiA9PiB7XG4gKiAgICAgICAgY291bnQgKz0gMTtcbiAqICAgICAgICByZXR1cm4gUi5wcm9kdWN0KFIucmFuZ2UoMSwgbiArIDEpKTtcbiAqICAgICAgfSk7XG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGNvdW50OyAvLz0+IDFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5ID0gdG9TdHJpbmcoYXJndW1lbnRzKTtcbiAgICBpZiAoIV9oYXMoa2V5LCBjYWNoZSkpIHtcbiAgICAgIGNhY2hlW2tleV0gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21lbW9pemUuanMiLCJ2YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Fzc2lnbicpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCBtZXJnZWQgd2l0aFxuICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLFxuICogdGhlIHZhbHVlIGZyb20gdGhlIHNlY29uZCBvYmplY3Qgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VXaXRoLCBSLm1lcmdlV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2UoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDEwIH0sIHsgJ2FnZSc6IDQwIH0pO1xuICogICAgICAvLz0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gKlxuICogICAgICB2YXIgcmVzZXRUb0RlZmF1bHQgPSBSLm1lcmdlKFIuX18sIHt4OiAwfSk7XG4gKiAgICAgIHJlc2V0VG9EZWZhdWx0KHt4OiA1LCB5OiAyfSk7IC8vPT4ge3g6IDAsIHk6IDJ9XG4gKiBAc3ltYiBSLm1lcmdlKHsgeDogMSwgeTogMiB9LCB7IHk6IDUsIHo6IDMgfSkgPSB7IHg6IDEsIHk6IDUsIHo6IDMgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbWVyZ2UobCwgcikge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgbCwgcik7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21lcmdlLmpzIiwidmFyIF9hc3NpZ24gPSByZXF1aXJlKCcuL2ludGVybmFsL19hc3NpZ24nKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBNZXJnZXMgYSBsaXN0IG9mIG9iamVjdHMgdG9nZXRoZXIgaW50byBvbmUgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFt7azogdn1dIC0+IHtrOiB2fVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBvYmplY3RzXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbWVyZ2VkIG9iamVjdC5cbiAqIEBzZWUgUi5yZWR1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlQWxsKFt7Zm9vOjF9LHtiYXI6Mn0se2JhejozfV0pOyAvLz0+IHtmb286MSxiYXI6MixiYXo6M31cbiAqICAgICAgUi5tZXJnZUFsbChbe2ZvbzoxfSx7Zm9vOjJ9LHtiYXI6Mn1dKTsgLy89PiB7Zm9vOjIsYmFyOjJ9XG4gKiBAc3ltYiBSLm1lcmdlQWxsKFt7IHg6IDEgfSwgeyB5OiAyIH0sIHsgejogMyB9XSkgPSB7IHg6IDEsIHk6IDIsIHo6IDMgfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbWVyZ2VBbGwobGlzdCkge1xuICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBbe31dLmNvbmNhdChsaXN0KSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21lcmdlQWxsLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBtZXJnZVdpdGhLZXkgPSByZXF1aXJlKCcuL21lcmdlV2l0aEtleScpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHR3byBwcm92aWRlZCBvYmplY3RzLiBJZlxuICogYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0cywgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlc1xuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gZWFjaCBvYmplY3QsIHdpdGggdGhlIHJlc3VsdCBiZWluZyB1c2VkIGFzIHRoZVxuICogdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkgaW4gdGhlIHJldHVybmVkIG9iamVjdC4gVGhlIGtleSB3aWxsIGJlXG4gKiBleGNsdWRlZCBmcm9tIHRoZSByZXR1cm5lZCBvYmplY3QgaWYgdGhlIHJlc3VsdGluZyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIChhIC0+IGEgLT4gYSkgLT4ge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZSwgUi5tZXJnZVdpdGhLZXlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlV2l0aChSLmNvbmNhdCxcbiAqICAgICAgICAgICAgICAgICAgeyBhOiB0cnVlLCB2YWx1ZXM6IFsxMCwgMjBdIH0sXG4gKiAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgdmFsdWVzOiBbMTUsIDM1XSB9KTtcbiAqICAgICAgLy89PiB7IGE6IHRydWUsIGI6IHRydWUsIHZhbHVlczogWzEwLCAyMCwgMTUsIDM1XSB9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBtZXJnZVdpdGgoZm4sIGwsIHIpIHtcbiAgcmV0dXJuIG1lcmdlV2l0aEtleShmdW5jdGlvbihfLCBfbCwgX3IpIHtcbiAgICByZXR1cm4gZm4oX2wsIF9yKTtcbiAgfSwgbCwgcik7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21lcmdlV2l0aC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzbWFsbGVyIG9mIGl0cyB0d28gYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5taW5CeSwgUi5tYXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1pbig3ODksIDEyMyk7IC8vPT4gMTIzXG4gKiAgICAgIFIubWluKCdhJywgJ2InKTsgLy89PiAnYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG1pbihhLCBiKSB7IHJldHVybiBiIDwgYSA/IGIgOiBhOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL21pbi5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzLCBhbmQgcmV0dXJucyB3aGljaGV2ZXIgdmFsdWUgcHJvZHVjZXMgdGhlXG4gKiBzbWFsbGVyIHJlc3VsdCB3aGVuIHBhc3NlZCB0byB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGIgPT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLm1pbiwgUi5tYXhCeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vICBzcXVhcmUgOjogTnVtYmVyIC0+IE51bWJlclxuICogICAgICB2YXIgc3F1YXJlID0gbiA9PiBuICogbjtcbiAqXG4gKiAgICAgIFIubWluQnkoc3F1YXJlLCAtMywgMik7IC8vPT4gMlxuICpcbiAqICAgICAgUi5yZWR1Y2UoUi5taW5CeShzcXVhcmUpLCBJbmZpbml0eSwgWzMsIC01LCA0LCAxLCAtMl0pOyAvLz0+IDFcbiAqICAgICAgUi5yZWR1Y2UoUi5taW5CeShzcXVhcmUpLCBJbmZpbml0eSwgW10pOyAvLz0+IEluZmluaXR5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBtaW5CeShmLCBhLCBiKSB7XG4gIHJldHVybiBmKGIpIDwgZihhKSA/IGIgOiBhO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9taW5CeS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBEaXZpZGVzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYnkgdGhlIHNlY29uZCBhbmQgcmV0dXJucyB0aGUgcmVtYWluZGVyLiBOb3RlXG4gKiB0aGF0IHRoaXMgZnVuY3Rpb24gcHJlc2VydmVzIHRoZSBKYXZhU2NyaXB0LXN0eWxlIGJlaGF2aW9yIGZvciBtb2R1bG8uIEZvclxuICogbWF0aGVtYXRpY2FsIG1vZHVsbyBzZWUgYG1hdGhNb2RgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSB2YWx1ZSB0byB0aGUgZGl2aWRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHBzZXVkby1tb2R1bHVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgJSBhYC5cbiAqIEBzZWUgUi5tYXRoTW9kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tb2R1bG8oMTcsIDMpOyAvLz0+IDJcbiAqICAgICAgLy8gSlMgYmVoYXZpb3I6XG4gKiAgICAgIFIubW9kdWxvKC0xNywgMyk7IC8vPT4gLTJcbiAqICAgICAgUi5tb2R1bG8oMTcsIC0zKTsgLy89PiAyXG4gKlxuICogICAgICB2YXIgaXNPZGQgPSBSLm1vZHVsbyhSLl9fLCAyKTtcbiAqICAgICAgaXNPZGQoNDIpOyAvLz0+IDBcbiAqICAgICAgaXNPZGQoMjEpOyAvLz0+IDFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG1vZHVsbyhhLCBiKSB7IHJldHVybiBhICUgYjsgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9tb2R1bG8uanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogTmVnYXRlcyBpdHMgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubmVnYXRlKDQyKTsgLy89PiAtNDJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIG5lZ2F0ZShuKSB7IHJldHVybiAtbjsgfSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9uZWdhdGUuanMiLCJ2YXIgX2NvbXBsZW1lbnQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb21wbGVtZW50Jyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGFueSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3hhbnknKTtcbnZhciBhbnkgPSByZXF1aXJlKCcuL2FueScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgbm8gZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbnlgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkIGJ5IGV2ZXJ5IGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHNlZSBSLmFsbCwgUi5hbnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNFdmVuID0gbiA9PiBuICUgMiA9PT0gMDtcbiAqXG4gKiAgICAgIFIubm9uZShpc0V2ZW4sIFsxLCAzLCA1LCA3LCA5LCAxMV0pOyAvLz0+IHRydWVcbiAqICAgICAgUi5ub25lKGlzRXZlbiwgWzEsIDMsIDUsIDcsIDgsIDExXSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKF9jb21wbGVtZW50KF9kaXNwYXRjaGFibGUoWydhbnknXSwgX3hhbnksIGFueSkpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL25vbmUuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG52YXIgbnRoID0gcmVxdWlyZSgnLi9udGgnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGl0cyBudGggYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICouLi4gLT4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubnRoQXJnKDEpKCdhJywgJ2InLCAnYycpOyAvLz0+ICdiJ1xuICogICAgICBSLm50aEFyZygtMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2MnXG4gKiBAc3ltYiBSLm50aEFyZygtMSkoYSwgYiwgYykgPSBjXG4gKiBAc3ltYiBSLm50aEFyZygwKShhLCBiLCBjKSA9IGFcbiAqIEBzeW1iIFIubnRoQXJnKDEpKGEsIGIsIGMpID0gYlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgdmFyIGFyaXR5ID0gbiA8IDAgPyAxIDogbiArIDE7XG4gIHJldHVybiBjdXJyeU4oYXJpdHksIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBudGgobiwgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL250aEFyZy5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX29mID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fb2YnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGV0b24gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUgcHJvdmlkZWQuXG4gKlxuICogTm90ZSB0aGlzIGBvZmAgaXMgZGlmZmVyZW50IGZyb20gdGhlIEVTNiBgb2ZgOyBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29mXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0geCBhbnkgdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSB3cmFwcGluZyBgeGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5vZihudWxsKTsgLy89PiBbbnVsbF1cbiAqICAgICAgUi5vZihbNDJdKTsgLy89PiBbWzQyXV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKF9vZik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9vZi5qcyIsInZhciBfY29udGFpbnMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb250YWlucycpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IG9taXR0aW5nIHRoZSBrZXlzIHNwZWNpZmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW1N0cmluZ10gLT4ge1N0cmluZzogKn0gLT4ge1N0cmluZzogKn1cbiAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBvbWl0IGZyb20gdGhlIG5ldyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agbm90IG9uIGl0LlxuICogQHNlZSBSLnBpY2tcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm9taXQoWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YjogMiwgYzogM31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIG9taXQobmFtZXMsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKCFfY29udGFpbnMocHJvcCwgbmFtZXMpKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL29taXQuanMiLCJ2YXIgX2FyaXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fYXJpdHknKTtcbnZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ3VhcmRzIGludm9jYXRpb24gb2ZcbiAqIGBmbmAgc3VjaCB0aGF0IGBmbmAgY2FuIG9ubHkgZXZlciBiZSBjYWxsZWQgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHRpbWVzXG4gKiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgaW52b2tlZC4gVGhlIGZpcnN0IHZhbHVlIGNhbGN1bGF0ZWQgaXMgcmV0dXJuZWQgaW5cbiAqIHN1YnNlcXVlbnQgaW52b2NhdGlvbnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGEuLi4gLT4gYikgLT4gKGEuLi4gLT4gYilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwIGluIGEgY2FsbC1vbmx5LW9uY2Ugd3JhcHBlci5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWRkT25lT25jZSA9IFIub25jZSh4ID0+IHggKyAxKTtcbiAqICAgICAgYWRkT25lT25jZSgxMCk7IC8vPT4gMTFcbiAqICAgICAgYWRkT25lT25jZShhZGRPbmVPbmNlKDUwKSk7IC8vPT4gMTFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgcmVzdWx0O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9vbmNlLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFRha2VzIHR3byBhcmd1bWVudHMsIGBmc3RgIGFuZCBgc25kYCwgYW5kIHJldHVybnMgYFtmc3QsIHNuZF1gLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gYiAtPiAoYSxiKVxuICogQHBhcmFtIHsqfSBmc3RcbiAqIEBwYXJhbSB7Kn0gc25kXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5vYmpPZiwgUi5vZlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGFpcignZm9vJywgJ2JhcicpOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBwYWlyKGZzdCwgc25kKSB7IHJldHVybiBbZnN0LCBzbmRdOyB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3BhaXIuanMiLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jcmVhdGVQYXJ0aWFsQXBwbGljYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIGluaXRpYWxseSBmb2xsb3dlZCBieSB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIGBnYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4sIG4pIC0+IHgpIC0+IFthLCBiLCBjLCAuLi5dIC0+ICgoZCwgZSwgZiwgLi4uLCBuKSAtPiB4KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGFydGlhbFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG11bHRpcGx5MiA9IChhLCBiKSA9PiBhICogYjtcbiAqICAgICAgdmFyIGRvdWJsZSA9IFIucGFydGlhbChtdWx0aXBseTIsIFsyXSk7XG4gKiAgICAgIGRvdWJsZSgyKTsgLy89PiA0XG4gKlxuICogICAgICB2YXIgZ3JlZXQgPSAoc2FsdXRhdGlvbiwgdGl0bGUsIGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+XG4gKiAgICAgICAgc2FsdXRhdGlvbiArICcsICcgKyB0aXRsZSArICcgJyArIGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lICsgJyEnO1xuICpcbiAqICAgICAgdmFyIHNheUhlbGxvID0gUi5wYXJ0aWFsKGdyZWV0LCBbJ0hlbGxvJ10pO1xuICogICAgICB2YXIgc2F5SGVsbG9Ub01zID0gUi5wYXJ0aWFsKHNheUhlbGxvLCBbJ01zLiddKTtcbiAqICAgICAgc2F5SGVsbG9Ub01zKCdKYW5lJywgJ0pvbmVzJyk7IC8vPT4gJ0hlbGxvLCBNcy4gSmFuZSBKb25lcyEnXG4gKiBAc3ltYiBSLnBhcnRpYWwoZiwgW2EsIGJdKShjLCBkKSA9IGYoYSwgYiwgYywgZClcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoX2NvbmNhdCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wYXJ0aWFsLmpzIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb25jYXQnKTtcbnZhciBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL19jcmVhdGVQYXJ0aWFsQXBwbGljYXRvcicpO1xudmFyIGZsaXAgPSByZXF1aXJlKCcuL2ZsaXAnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAqIFdoZW4gYXBwbGllZCwgYGdgIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGFyZ3VtZW50c1xuICogcHJvdmlkZWQgdG8gYGdgIGZvbGxvd2VkIGJ5IHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgaW5pdGlhbGx5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEsIGIsIGMsIC4uLiwgbikgLT4geCkgLT4gW2QsIGUsIGYsIC4uLiwgbl0gLT4gKChhLCBiLCBjLCAuLi4pIC0+IHgpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5wYXJ0aWFsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGdyZWV0ID0gKHNhbHV0YXRpb24sIHRpdGxlLCBmaXJzdE5hbWUsIGxhc3ROYW1lKSA9PlxuICogICAgICAgIHNhbHV0YXRpb24gKyAnLCAnICsgdGl0bGUgKyAnICcgKyBmaXJzdE5hbWUgKyAnICcgKyBsYXN0TmFtZSArICchJztcbiAqXG4gKiAgICAgIHZhciBncmVldE1zSmFuZUpvbmVzID0gUi5wYXJ0aWFsUmlnaHQoZ3JlZXQsIFsnTXMuJywgJ0phbmUnLCAnSm9uZXMnXSk7XG4gKlxuICogICAgICBncmVldE1zSmFuZUpvbmVzKCdIZWxsbycpOyAvLz0+ICdIZWxsbywgTXMuIEphbmUgSm9uZXMhJ1xuICogQHN5bWIgUi5wYXJ0aWFsUmlnaHQoZiwgW2EsIGJdKShjLCBkKSA9IGYoYywgZCwgYSwgYilcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoZmxpcChfY29uY2F0KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wYXJ0aWFsUmlnaHQuanMiLCJ2YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBqdXh0ID0gcmVxdWlyZSgnLi9qdXh0Jyk7XG52YXIgcmVqZWN0ID0gcmVxdWlyZSgnLi9yZWplY3QnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIGxpc3Qgb3Igb3RoZXIgXCJmaWx0ZXJhYmxlXCIgb2JqZWN0IGFuZCByZXR1cm5zIHRoZVxuICogcGFpciBvZiBmaWx0ZXJhYmxlIG9iamVjdHMgb2YgdGhlIHNhbWUgdHlwZSBvZiBlbGVtZW50cyB3aGljaCBkbyBhbmQgZG8gbm90XG4gKiBzYXRpc2Z5LCB0aGUgcHJlZGljYXRlLCByZXNwZWN0aXZlbHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS40XG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IFtmIGEsIGYgYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpZGUgdGhlIGVsZW1lbnQgYmVsb25ncyB0by5cbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGUgdGhlIGxpc3QgKG9yIG90aGVyIGZpbHRlcmFibGUpIHRvIHBhcnRpdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSwgY29udGFpbmluZyBmaXJzdCB0aGUgc3Vic2V0IG9mIGVsZW1lbnRzIHRoYXQgc2F0aXNmeSB0aGVcbiAqICAgICAgICAgcHJlZGljYXRlLCBhbmQgc2Vjb25kIHRoZSBzdWJzZXQgb2YgZWxlbWVudHMgdGhhdCBkbyBub3Qgc2F0aXNmeS5cbiAqIEBzZWUgUi5maWx0ZXIsIFIucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYXJ0aXRpb24oUi5jb250YWlucygncycpLCBbJ3NzcycsICd0dHQnLCAnZm9vJywgJ2JhcnMnXSk7XG4gKiAgICAgIC8vID0+IFsgWyAnc3NzJywgJ2JhcnMnIF0sICBbICd0dHQnLCAnZm9vJyBdIF1cbiAqXG4gKiAgICAgIFIucGFydGl0aW9uKFIuY29udGFpbnMoJ3MnKSwgeyBhOiAnc3NzJywgYjogJ3R0dCcsIGZvbzogJ2JhcnMnIH0pO1xuICogICAgICAvLyA9PiBbIHsgYTogJ3NzcycsIGZvbzogJ2JhcnMnIH0sIHsgYjogJ3R0dCcgfSAgXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGp1eHQoW2ZpbHRlciwgcmVqZWN0XSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wYXJ0aXRpb24uanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgbmVzdGVkIHBhdGggb24gYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmljIHZhbHVlLCBpblxuICogYFIuZXF1YWxzYCB0ZXJtcy4gTW9zdCBsaWtlbHkgdXNlZCB0byBmaWx0ZXIgYSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IGEgLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIG5lc3RlZCBwcm9wZXJ0eSB0byB1c2VcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRoZSBuZXN0ZWQgcHJvcGVydHkgd2l0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIHRoZSBuZXN0ZWQgcHJvcGVydHkgaW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgZXF1YWxzIHRoZSBuZXN0ZWQgb2JqZWN0IHByb3BlcnR5LFxuICogICAgICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgdXNlcjEgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogOTAyMTAgfSB9O1xuICogICAgICB2YXIgdXNlcjIgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogNTU1NTUgfSB9O1xuICogICAgICB2YXIgdXNlcjMgPSB7IG5hbWU6ICdCb2InIH07XG4gKiAgICAgIHZhciB1c2VycyA9IFsgdXNlcjEsIHVzZXIyLCB1c2VyMyBdO1xuICogICAgICB2YXIgaXNGYW1vdXMgPSBSLnBhdGhFcShbJ2FkZHJlc3MnLCAnemlwQ29kZSddLCA5MDIxMCk7XG4gKiAgICAgIFIuZmlsdGVyKGlzRmFtb3VzLCB1c2Vycyk7IC8vPT4gWyB1c2VyMSBdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBwYXRoRXEoX3BhdGgsIHZhbCwgb2JqKSB7XG4gIHJldHVybiBlcXVhbHMocGF0aChfcGF0aCwgb2JqKSwgdmFsKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcGF0aEVxLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBkZWZhdWx0VG8gPSByZXF1aXJlKCcuL2RlZmF1bHRUbycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuXG4vKipcbiAqIElmIHRoZSBnaXZlbiwgbm9uLW51bGwgb2JqZWN0IGhhcyBhIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoLCByZXR1cm5zIHRoZVxuICogdmFsdWUgYXQgdGhhdCBwYXRoLiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIGEgLT4gW0lkeF0gLT4ge2F9IC0+IGFcbiAqIEBwYXJhbSB7Kn0gZCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IHAgVGhlIHBhdGggdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYCBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGF0aE9yKCdOL0EnLCBbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICogICAgICBSLnBhdGhPcignTi9BJywgWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IFwiTi9BXCJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhPcihkLCBwLCBvYmopIHtcbiAgcmV0dXJuIGRlZmF1bHRUbyhkLCBwYXRoKHAsIG9iaikpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wYXRoT3IuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGF0IGdpdmVuIHBhdGggc2F0aXNmaWVzIHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW0lkeF0gLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BQYXRoXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wU2F0aXNmaWVzLCBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhTYXRpc2ZpZXMoeSA9PiB5ID4gMCwgWyd4JywgJ3knXSwge3g6IHt5OiAyfX0pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhTYXRpc2ZpZXMocHJlZCwgcHJvcFBhdGgsIG9iaikge1xuICByZXR1cm4gcHJvcFBhdGgubGVuZ3RoID4gMCAmJiBwcmVkKHBhdGgocHJvcFBhdGgsIG9iaikpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wYXRoU2F0aXNmaWVzLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyBzcGVjaWZpZWQuIElmXG4gKiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGUgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agb24gaXQuXG4gKiBAc2VlIFIub21pdCwgUi5wcm9wc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGljayhbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICogICAgICBSLnBpY2soWydhJywgJ2UnLCAnZiddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcGljayhuYW1lcywgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICBpZiAobmFtZXNbaWR4XSBpbiBvYmopIHtcbiAgICAgIHJlc3VsdFtuYW1lc1tpZHhdXSA9IG9ialtuYW1lc1tpZHhdXTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcGljay5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGFydGlhbCBjb3B5IG9mIGFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhlIGtleXMgdGhhdCBzYXRpc2Z5XG4gKiB0aGUgc3VwcGxpZWQgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAodiwgayAtPiBCb29sZWFuKSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGtleVxuICogICAgICAgIHNob3VsZCBiZSBpbmNsdWRlZCBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGggb25seSBwcm9wZXJ0aWVzIHRoYXQgc2F0aXNmeSBgcHJlZGBcbiAqICAgICAgICAgb24gaXQuXG4gKiBAc2VlIFIucGljaywgUi5maWx0ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNVcHBlckNhc2UgPSAodmFsLCBrZXkpID0+IGtleS50b1VwcGVyQ2FzZSgpID09PSBrZXk7XG4gKiAgICAgIFIucGlja0J5KGlzVXBwZXJDYXNlLCB7YTogMSwgYjogMiwgQTogMywgQjogNH0pOyAvLz0+IHtBOiAzLCBCOiA0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcGlja0J5KHRlc3QsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKHRlc3Qob2JqW3Byb3BdLCBwcm9wLCBvYmopKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3BpY2tCeS5qcyIsInZhciBjb21wb3NlSyA9IHJlcXVpcmUoJy4vY29tcG9zZUsnKTtcbnZhciByZXZlcnNlID0gcmVxdWlyZSgnLi9yZXZlcnNlJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGVmdC10by1yaWdodCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAqXG4gKiBgUi5waXBlSyhmLCBnLCBoKWAgaXMgZXF1aXZhbGVudCB0byBgUi5waXBlKFIuY2hhaW4oZiksIFIuY2hhaW4oZyksIFIuY2hhaW4oaCkpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgQ2hhaW4gbSA9PiAoKGEgLT4gbSBiKSwgKGIgLT4gbSBjKSwgLi4uLCAoeSAtPiBtIHopKSAtPiAoYSAtPiBtIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZUtcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyAgcGFyc2VKc29uIDo6IFN0cmluZyAtPiBNYXliZSAqXG4gKiAgICAgIC8vICBnZXQgOjogU3RyaW5nIC0+IE9iamVjdCAtPiBNYXliZSAqXG4gKlxuICogICAgICAvLyAgZ2V0U3RhdGVDb2RlIDo6IE1heWJlIFN0cmluZyAtPiBNYXliZSBTdHJpbmdcbiAqICAgICAgdmFyIGdldFN0YXRlQ29kZSA9IFIucGlwZUsoXG4gKiAgICAgICAgcGFyc2VKc29uLFxuICogICAgICAgIGdldCgndXNlcicpLFxuICogICAgICAgIGdldCgnYWRkcmVzcycpLFxuICogICAgICAgIGdldCgnc3RhdGUnKSxcbiAqICAgICAgICBSLmNvbXBvc2UoTWF5YmUub2YsIFIudG9VcHBlcilcbiAqICAgICAgKTtcbiAqXG4gKiAgICAgIGdldFN0YXRlQ29kZSgne1widXNlclwiOntcImFkZHJlc3NcIjp7XCJzdGF0ZVwiOlwibnlcIn19fScpO1xuICogICAgICAvLz0+IEp1c3QoJ05ZJylcbiAqICAgICAgZ2V0U3RhdGVDb2RlKCdbSW52YWxpZCBKU09OXScpO1xuICogICAgICAvLz0+IE5vdGhpbmcoKVxuICogQHN5bWIgUi5waXBlSyhmLCBnLCBoKShhKSA9IFIuY2hhaW4oaCwgUi5jaGFpbihnLCBmKGEpKSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlSygpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVLIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiBjb21wb3NlSy5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3BpcGVLLmpzIiwidmFyIG11bHRpcGx5ID0gcmVxdWlyZSgnLi9tdWx0aXBseScpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJy4vcmVkdWNlJyk7XG5cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHRvZ2V0aGVyIGFsbCB0aGUgZWxlbWVudHMgb2YgYSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IEFuIGFycmF5IG9mIG51bWJlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHByb2R1Y3Qgb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvZHVjdChbMiw0LDYsOCwxMDAsMV0pOyAvLz0+IDM4NDAwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlKG11bHRpcGx5LCAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3Byb2R1Y3QuanMiLCJ2YXIgX21hcCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xudmFyIHBpY2tBbGwgPSByZXF1aXJlKCcuL3BpY2tBbGwnKTtcbnZhciB1c2VXaXRoID0gcmVxdWlyZSgnLi91c2VXaXRoJyk7XG5cblxuLyoqXG4gKiBSZWFzb25hYmxlIGFuYWxvZyB0byBTUUwgYHNlbGVjdGAgc3RhdGVtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFtrXSAtPiBbe2s6IHZ9XSAtPiBbe2s6IHZ9XVxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHByb2plY3RcbiAqIEBwYXJhbSB7QXJyYXl9IG9ianMgVGhlIG9iamVjdHMgdG8gcXVlcnlcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBvYmplY3RzIHdpdGgganVzdCB0aGUgYHByb3BzYCBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhYmJ5ID0ge25hbWU6ICdBYmJ5JywgYWdlOiA3LCBoYWlyOiAnYmxvbmQnLCBncmFkZTogMn07XG4gKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJywgZ3JhZGU6IDd9O1xuICogICAgICB2YXIga2lkcyA9IFthYmJ5LCBmcmVkXTtcbiAqICAgICAgUi5wcm9qZWN0KFsnbmFtZScsICdncmFkZSddLCBraWRzKTsgLy89PiBbe25hbWU6ICdBYmJ5JywgZ3JhZGU6IDJ9LCB7bmFtZTogJ0ZyZWQnLCBncmFkZTogN31dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gdXNlV2l0aChfbWFwLCBbcGlja0FsbCwgaWRlbnRpdHldKTsgLy8gcGFzc2luZyBgaWRlbnRpdHlgIGdpdmVzIGNvcnJlY3QgYXJpdHlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3Byb2plY3QuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGVxdWFscyA9IHJlcXVpcmUoJy4vZXF1YWxzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBpcyBlcXVhbCwgaW4gYFIuZXF1YWxzYFxuICogdGVybXMsIHRvIHRoZSBnaXZlbiB2YWx1ZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgU3RyaW5nIC0+IGEgLT4gT2JqZWN0IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZXF1YWxzLCBSLnByb3BTYXRpc2ZpZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWJieSA9IHtuYW1lOiAnQWJieScsIGFnZTogNywgaGFpcjogJ2Jsb25kJ307XG4gKiAgICAgIHZhciBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJ307XG4gKiAgICAgIHZhciBydXN0eSA9IHtuYW1lOiAnUnVzdHknLCBhZ2U6IDEwLCBoYWlyOiAnYnJvd24nfTtcbiAqICAgICAgdmFyIGFsb2lzID0ge25hbWU6ICdBbG9pcycsIGFnZTogMTUsIGRpc3Bvc2l0aW9uOiAnc3VybHknfTtcbiAqICAgICAgdmFyIGtpZHMgPSBbYWJieSwgZnJlZCwgcnVzdHksIGFsb2lzXTtcbiAqICAgICAgdmFyIGhhc0Jyb3duSGFpciA9IFIucHJvcEVxKCdoYWlyJywgJ2Jyb3duJyk7XG4gKiAgICAgIFIuZmlsdGVyKGhhc0Jyb3duSGFpciwga2lkcyk7IC8vPT4gW2ZyZWQsIHJ1c3R5XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gcHJvcEVxKG5hbWUsIHZhbCwgb2JqKSB7XG4gIHJldHVybiBlcXVhbHModmFsLCBvYmpbbmFtZV0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wcm9wRXEuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgb2YgdGhlIGdpdmVuIHR5cGU7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyBUeXBlIC0+IFN0cmluZyAtPiBPYmplY3QgLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmlzLCBSLnByb3BTYXRpc2ZpZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gdHJ1ZVxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6ICdmb28nfSk7ICAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt9KTsgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBwcm9wSXModHlwZSwgbmFtZSwgb2JqKSB7XG4gIHJldHVybiBpcyh0eXBlLCBvYmpbbmFtZV0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wcm9wSXMuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcblxuXG4vKipcbiAqIElmIHRoZSBnaXZlbiwgbm9uLW51bGwgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUsXG4gKiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGF0IHByb3BlcnR5LiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdFxuICogdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIGEgLT4gU3RyaW5nIC0+IE9iamVjdCAtPiBhXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXR1cm4uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkgb2YgdGhlIHN1cHBsaWVkIG9iamVjdCBvciB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWxpY2UgPSB7XG4gKiAgICAgICAgbmFtZTogJ0FMSUNFJyxcbiAqICAgICAgICBhZ2U6IDEwMVxuICogICAgICB9O1xuICogICAgICB2YXIgZmF2b3JpdGUgPSBSLnByb3AoJ2Zhdm9yaXRlTGlicmFyeScpO1xuICogICAgICB2YXIgZmF2b3JpdGVXaXRoRGVmYXVsdCA9IFIucHJvcE9yKCdSYW1kYScsICdmYXZvcml0ZUxpYnJhcnknKTtcbiAqXG4gKiAgICAgIGZhdm9yaXRlKGFsaWNlKTsgIC8vPT4gdW5kZWZpbmVkXG4gKiAgICAgIGZhdm9yaXRlV2l0aERlZmF1bHQoYWxpY2UpOyAgLy89PiAnUmFtZGEnXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBwcm9wT3IodmFsLCBwLCBvYmopIHtcbiAgcmV0dXJuIChvYmogIT0gbnVsbCAmJiBfaGFzKHAsIG9iaikpID8gb2JqW3BdIDogdmFsO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wcm9wT3IuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgc2F0aXNmaWVzIHRoZSBnaXZlblxuICogcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IHtTdHJpbmc6IGF9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wRXEsIFIucHJvcElzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9wU2F0aXNmaWVzKHggPT4geCA+IDAsICd4Jywge3g6IDEsIHk6IDJ9KTsgLy89PiB0cnVlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiBwcm9wU2F0aXNmaWVzKHByZWQsIG5hbWUsIG9iaikge1xuICByZXR1cm4gcHJlZChvYmpbbmFtZV0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wcm9wU2F0aXNmaWVzLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIEFjdHMgYXMgbXVsdGlwbGUgYHByb3BgOiBhcnJheSBvZiBrZXlzIGluLCBhcnJheSBvZiB2YWx1ZXMgb3V0LiBQcmVzZXJ2ZXNcbiAqIG9yZGVyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBba10gLT4ge2s6IHZ9IC0+IFt2XVxuICogQHBhcmFtIHtBcnJheX0gcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZldGNoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgb3IgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9wcyhbJ3gnLCAneSddLCB7eDogMSwgeTogMn0pOyAvLz0+IFsxLCAyXVxuICogICAgICBSLnByb3BzKFsnYycsICdhJywgJ2InXSwge2I6IDIsIGE6IDF9KTsgLy89PiBbdW5kZWZpbmVkLCAxLCAyXVxuICpcbiAqICAgICAgdmFyIGZ1bGxOYW1lID0gUi5jb21wb3NlKFIuam9pbignICcpLCBSLnByb3BzKFsnZmlyc3QnLCAnbGFzdCddKSk7XG4gKiAgICAgIGZ1bGxOYW1lKHtsYXN0OiAnQnVsbGV0LVRvb3RoJywgYWdlOiAzMywgZmlyc3Q6ICdUb255J30pOyAvLz0+ICdUb255IEJ1bGxldC1Ub290aCdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHByb3BzKHBzLCBvYmopIHtcbiAgdmFyIGxlbiA9IHBzLmxlbmd0aDtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgb3V0W2lkeF0gPSBvYmpbcHNbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9wcm9wcy5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2lzTnVtYmVyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNOdW1iZXInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG51bWJlcnMgZnJvbSBgZnJvbWAgKGluY2x1c2l2ZSkgdG8gYHRvYCAoZXhjbHVzaXZlKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gW051bWJlcl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIFRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gKiBAcGFyYW0ge051bWJlcn0gdG8gT25lIG1vcmUgdGhhbiB0aGUgbGFzdCBudW1iZXIgaW4gdGhlIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgbnVtYmVycyBpbiB0dGhlIHNldCBgW2EsIGIpYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJhbmdlKDEsIDUpOyAgICAvLz0+IFsxLCAyLCAzLCA0XVxuICogICAgICBSLnJhbmdlKDUwLCA1Myk7ICAvLz0+IFs1MCwgNTEsIDUyXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcmFuZ2UoZnJvbSwgdG8pIHtcbiAgaWYgKCEoX2lzTnVtYmVyKGZyb20pICYmIF9pc051bWJlcih0bykpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm90aCBhcmd1bWVudHMgdG8gcmFuZ2UgbXVzdCBiZSBudW1iZXJzJyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbiA9IGZyb207XG4gIHdoaWxlIChuIDwgdG8pIHtcbiAgICByZXN1bHQucHVzaChuKTtcbiAgICBuICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcmFuZ2UuanMiLCJ2YXIgX2N1cnJ5TiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5TicpO1xudmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfcmVkdWNlZCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZWQnKTtcblxuXG4vKipcbiAqIExpa2UgYHJlZHVjZWAsIGByZWR1Y2VXaGlsZWAgcmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoXG4gKiB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmcgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBgcmVkdWNlV2hpbGVgIGFsc29cbiAqIHRha2VzIGEgcHJlZGljYXRlIHRoYXQgaXMgZXZhbHVhdGVkIGJlZm9yZSBlYWNoIHN0ZXAuIElmIHRoZSBwcmVkaWNhdGUgcmV0dXJuc1xuICogYGZhbHNlYCwgaXQgXCJzaG9ydC1jaXJjdWl0c1wiIHRoZSBpdGVyYXRpb24gYW5kIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWVcbiAqIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IEJvb2xlYW4pIC0+ICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBUaGUgcHJlZGljYXRlLiBJdCBpcyBwYXNzZWQgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZVxuICogICAgICAgIGFjY3VtdWxhdG9yIGFuZCB0aGUgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBhIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc09kZCA9IChhY2MsIHgpID0+IHggJSAyID09PSAxO1xuICogICAgICB2YXIgeHMgPSBbMSwgMywgNSwgNjAsIDc3NywgODAwXTtcbiAqICAgICAgUi5yZWR1Y2VXaGlsZShpc09kZCwgUi5hZGQsIDAsIHhzKTsgLy89PiA5XG4gKlxuICogICAgICB2YXIgeXMgPSBbMiwgNCwgNl1cbiAqICAgICAgUi5yZWR1Y2VXaGlsZShpc09kZCwgUi5hZGQsIDExMSwgeXMpOyAvLz0+IDExMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeU4oNCwgW10sIGZ1bmN0aW9uIF9yZWR1Y2VXaGlsZShwcmVkLCBmbiwgYSwgbGlzdCkge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbihhY2MsIHgpIHtcbiAgICByZXR1cm4gcHJlZChhY2MsIHgpID8gZm4oYWNjLCB4KSA6IF9yZWR1Y2VkKGFjYyk7XG4gIH0sIGEsIGxpc3QpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9yZWR1Y2VXaGlsZS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2VkJyk7XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIHdyYXBwZWQgdG8gaW5kaWNhdGUgdGhhdCBpdCBpcyB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIHJlZHVjZVxuICogYW5kIHRyYW5zZHVjZSBmdW5jdGlvbnMuIFRoZSByZXR1cm5lZCB2YWx1ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGJsYWNrXG4gKiBib3g6IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc3RhYmxlLlxuICpcbiAqIE5vdGU6IHRoaXMgb3B0aW1pemF0aW9uIGlzIHVuYXZhaWxhYmxlIHRvIGZ1bmN0aW9ucyBub3QgZXhwbGljaXRseSBsaXN0ZWRcbiAqIGFib3ZlLiBGb3IgaW5zdGFuY2UsIGl0IGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHJlZHVjZVJpZ2h0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gKlxuICogQHBhcmFtIHsqfSB4IFRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgcmVkdWNlLlxuICogQHJldHVybiB7Kn0gVGhlIHdyYXBwZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlKFxuICogICAgICAgIFIucGlwZShSLmFkZCwgUi53aGVuKFIuZ3RlKFIuX18sIDEwKSwgUi5yZWR1Y2VkKSksXG4gKiAgICAgICAgMCxcbiAqICAgICAgICBbMSwgMiwgMywgNCwgNV0pIC8vIDEwXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKF9yZWR1Y2VkKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3JlZHVjZWQuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc3ViLWxpc3Qgb2YgYGxpc3RgIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydGAgYW5kIGNvbnRhaW5pbmdcbiAqIGBjb3VudGAgZWxlbWVudHMuIF9Ob3RlIHRoYXQgdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZlxuICogdGhlIGxpc3Qgd2l0aCB0aGUgY2hhbmdlcy5cbiAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4yXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgcG9zaXRpb24gdG8gc3RhcnQgcmVtb3ZpbmcgZWxlbWVudHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byByZW1vdmUgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGNvdW50YCBlbGVtZW50cyBmcm9tIGBzdGFydGAgcmVtb3ZlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlbW92ZSgyLCAzLCBbMSwyLDMsNCw1LDYsNyw4XSk7IC8vPT4gWzEsMiw2LDcsOF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHJlbW92ZShzdGFydCwgY291bnQsIGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApO1xuICByZXN1bHQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3JlbW92ZS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgYWx3YXlzID0gcmVxdWlyZSgnLi9hbHdheXMnKTtcbnZhciB0aW1lcyA9IHJlcXVpcmUoJy4vdGltZXMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmaXhlZCBsaXN0IG9mIHNpemUgYG5gIGNvbnRhaW5pbmcgYSBzcGVjaWZpZWQgaWRlbnRpY2FsIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBuIC0+IFthXVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVwZWF0LlxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkgY29udGFpbmluZyBgbmAgYHZhbHVlYHMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZXBlYXQoJ2hpJywgNSk7IC8vPT4gWydoaScsICdoaScsICdoaScsICdoaScsICdoaSddXG4gKlxuICogICAgICB2YXIgb2JqID0ge307XG4gKiAgICAgIHZhciByZXBlYXRlZE9ianMgPSBSLnJlcGVhdChvYmosIDUpOyAvLz0+IFt7fSwge30sIHt9LCB7fSwge31dXG4gKiAgICAgIHJlcGVhdGVkT2Jqc1swXSA9PT0gcmVwZWF0ZWRPYmpzWzFdOyAvLz0+IHRydWVcbiAqIEBzeW1iIFIucmVwZWF0KGEsIDApID0gW11cbiAqIEBzeW1iIFIucmVwZWF0KGEsIDEpID0gW2FdXG4gKiBAc3ltYiBSLnJlcGVhdChhLCAyKSA9IFthLCBhXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcmVwZWF0KHZhbHVlLCBuKSB7XG4gIHJldHVybiB0aW1lcyhhbHdheXModmFsdWUpLCBuKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvcmVwZWF0LmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFJlcGxhY2UgYSBzdWJzdHJpbmcgb3IgcmVnZXggbWF0Y2ggaW4gYSBzdHJpbmcgd2l0aCBhIHJlcGxhY2VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyBSZWdFeHB8U3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHBhdHRlcm4gQSByZWd1bGFyIGV4cHJlc3Npb24gb3IgYSBzdWJzdHJpbmcgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVwbGFjZW1lbnQgVGhlIHN0cmluZyB0byByZXBsYWNlIHRoZSBtYXRjaGVzIHdpdGguXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gZG8gdGhlIHNlYXJjaCBhbmQgcmVwbGFjZW1lbnQgaW4uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZXN1bHQuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZXBsYWNlKCdmb28nLCAnYmFyJywgJ2ZvbyBmb28gZm9vJyk7IC8vPT4gJ2JhciBmb28gZm9vJ1xuICogICAgICBSLnJlcGxhY2UoL2Zvby8sICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGZvbyBmb28nXG4gKlxuICogICAgICAvLyBVc2UgdGhlIFwiZ1wiIChnbG9iYWwpIGZsYWcgdG8gcmVwbGFjZSBhbGwgb2NjdXJyZW5jZXM6XG4gKiAgICAgIFIucmVwbGFjZSgvZm9vL2csICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGJhciBiYXInXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCByZXBsYWNlbWVudCwgc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgcmVwbGFjZW1lbnQpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9yZXBsYWNlLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFNjYW4gaXMgc2ltaWxhciB0byByZWR1Y2UsIGJ1dCByZXR1cm5zIGEgbGlzdCBvZiBzdWNjZXNzaXZlbHkgcmVkdWNlZCB2YWx1ZXNcbiAqIGZyb20gdGhlIGxlZnRcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSxiIC0+IGEpIC0+IGEgLT4gW2JdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICogICAgICAgIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIGFsbCBpbnRlcm1lZGlhdGVseSByZWR1Y2VkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbnVtYmVycyA9IFsxLCAyLCAzLCA0XTtcbiAqICAgICAgdmFyIGZhY3RvcmlhbHMgPSBSLnNjYW4oUi5tdWx0aXBseSwgMSwgbnVtYmVycyk7IC8vPT4gWzEsIDEsIDIsIDYsIDI0XVxuICogQHN5bWIgUi5zY2FuKGYsIGEsIFtiLCBjXSkgPSBbYSwgZihhLCBiKSwgZihmKGEsIGIpLCBjKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHNjYW4oZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW2FjY107XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBhY2MgPSBmbihhY2MsIGxpc3RbaWR4XSk7XG4gICAgcmVzdWx0W2lkeCArIDFdID0gYWNjO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3NjYW4uanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGFsd2F5cyA9IHJlcXVpcmUoJy4vYWx3YXlzJyk7XG52YXIgb3ZlciA9IHJlcXVpcmUoJy4vb3ZlcicpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIFwic2V0dGluZ1wiIHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHN0cnVjdHVyZVxuICogZm9jdXNlZCBieSB0aGUgZ2l2ZW4gbGVucyB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgTGVucyBzIGEgLT4gYSAtPiBzIC0+IHNcbiAqIEBwYXJhbSB7TGVuc30gbGVuc1xuICogQHBhcmFtIHsqfSB2XG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gKlxuICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIuc2V0KHhMZW5zLCA4LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogOCwgeTogMn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHNldChsZW5zLCB2LCB4KSB7XG4gIHJldHVybiBvdmVyKGxlbnMsIGFsd2F5cyh2KSwgeCk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3NldC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCwgc29ydGVkIGFjY29yZGluZyB0byB0aGUgY29tcGFyYXRvciBmdW5jdGlvbixcbiAqIHdoaWNoIHNob3VsZCBhY2NlcHQgdHdvIHZhbHVlcyBhdCBhIHRpbWUgYW5kIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciBpZiB0aGVcbiAqIGZpcnN0IHZhbHVlIGlzIHNtYWxsZXIsIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGl0J3MgbGFyZ2VyLCBhbmQgemVybyBpZiB0aGV5XG4gKiBhcmUgZXF1YWwuIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBpcyBhICoqY29weSoqIG9mIHRoZSBsaXN0LiBJdCBkb2VzIG5vdFxuICogbW9kaWZ5IHRoZSBvcmlnaW5hbC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhLGEgLT4gTnVtYmVyKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIEEgc29ydGluZyBmdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHNvcnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSB3aXRoIGl0cyBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGRpZmYgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcbiAqICAgICAgUi5zb3J0KGRpZmYsIFs0LDIsNyw1XSk7IC8vPT4gWzIsIDQsIDUsIDddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBzb3J0KGNvbXBhcmF0b3IsIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnNvcnQoY29tcGFyYXRvcik7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3NvcnQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogU29ydHMgdGhlIGxpc3QgYWNjb3JkaW5nIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGJ5IHRoZSBrZXlzIGdlbmVyYXRlZCBieSBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzb3J0QnlGaXJzdEl0ZW0gPSBSLnNvcnRCeShSLnByb3AoMCkpO1xuICogICAgICB2YXIgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZSA9IFIuc29ydEJ5KFIuY29tcG9zZShSLnRvTG93ZXIsIFIucHJvcCgnbmFtZScpKSk7XG4gKiAgICAgIHZhciBwYWlycyA9IFtbLTEsIDFdLCBbLTIsIDJdLCBbLTMsIDNdXTtcbiAqICAgICAgc29ydEJ5Rmlyc3RJdGVtKHBhaXJzKTsgLy89PiBbWy0zLCAzXSwgWy0yLCAyXSwgWy0xLCAxXV1cbiAqICAgICAgdmFyIGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gKiAgICAgICAgYWdlOiAxMDFcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIGJvYiA9IHtcbiAqICAgICAgICBuYW1lOiAnQm9iJyxcbiAqICAgICAgICBhZ2U6IC0xMFxuICogICAgICB9O1xuICogICAgICB2YXIgY2xhcmEgPSB7XG4gKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAqICAgICAgICBhZ2U6IDMxNC4xNTlcbiAqICAgICAgfTtcbiAqICAgICAgdmFyIHBlb3BsZSA9IFtjbGFyYSwgYm9iLCBhbGljZV07XG4gKiAgICAgIHNvcnRCeU5hbWVDYXNlSW5zZW5zaXRpdmUocGVvcGxlKTsgLy89PiBbYWxpY2UsIGJvYiwgY2xhcmFdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBzb3J0QnkoZm4sIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBhYSA9IGZuKGEpO1xuICAgIHZhciBiYiA9IGZuKGIpO1xuICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9zb3J0QnkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogU29ydHMgYSBsaXN0IGFjY29yZGluZyB0byBhIGxpc3Qgb2YgY29tcGFyYXRvcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFthIC0+IGEgLT4gTnVtYmVyXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBmdW5jdGlvbnMgQSBsaXN0IG9mIGNvbXBhcmF0b3IgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGFjY29yZGluZyB0byB0aGUgY29tYXJhdG9yIGZ1bmN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWxpY2UgPSB7XG4gKiAgICAgICAgbmFtZTogJ2FsaWNlJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBib2IgPSB7XG4gKiAgICAgICAgbmFtZTogJ2JvYicsXG4gKiAgICAgICAgYWdlOiAzMFxuICogICAgICB9O1xuICogICAgICB2YXIgY2xhcmEgPSB7XG4gKiAgICAgICAgbmFtZTogJ2NsYXJhJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBwZW9wbGUgPSBbY2xhcmEsIGJvYiwgYWxpY2VdO1xuICogICAgICB2YXIgYWdlTmFtZVNvcnQgPSBSLnNvcnRXaXRoKFtcbiAqICAgICAgICBSLmRlc2NlbmQoUi5wcm9wKCdhZ2UnKSksXG4gKiAgICAgICAgUi5hc2NlbmQoUi5wcm9wKCduYW1lJykpXG4gKiAgICAgIF0pO1xuICogICAgICBhZ2VOYW1lU29ydChwZW9wbGUpOyAvLz0+IFthbGljZSwgY2xhcmEsIGJvYl1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnRXaXRoKGZucywgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChyZXN1bHQgPT09IDAgJiYgaSA8IGZucy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGZuc1tpXShhLCBiKTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3NvcnRXaXRoLmpzIiwidmFyIGludm9rZXIgPSByZXF1aXJlKCcuL2ludm9rZXInKTtcblxuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGdpdmVuXG4gKiBzZXBhcmF0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIChTdHJpbmcgfCBSZWdFeHApIC0+IFN0cmluZyAtPiBbU3RyaW5nXVxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBzZXAgVGhlIHBhdHRlcm4uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VwYXJhdGUgaW50byBhbiBhcnJheS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2Ygc3RyaW5ncyBmcm9tIGBzdHJgIHNlcGFyYXRlZCBieSBgc3RyYC5cbiAqIEBzZWUgUi5qb2luXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHBhdGhDb21wb25lbnRzID0gUi5zcGxpdCgnLycpO1xuICogICAgICBSLnRhaWwocGF0aENvbXBvbmVudHMoJy91c3IvbG9jYWwvYmluL25vZGUnKSk7IC8vPT4gWyd1c3InLCAnbG9jYWwnLCAnYmluJywgJ25vZGUnXVxuICpcbiAqICAgICAgUi5zcGxpdCgnLicsICdhLmIuYy54eXouZCcpOyAvLz0+IFsnYScsICdiJywgJ2MnLCAneHl6JywgJ2QnXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGludm9rZXIoMSwgJ3NwbGl0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy9zcGxpdC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgbGVuZ3RoID0gcmVxdWlyZSgnLi9sZW5ndGgnKTtcbnZhciBzbGljZSA9IHJlcXVpcmUoJy4vc2xpY2UnKTtcblxuXG4vKipcbiAqIFNwbGl0cyBhIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIGF0IGEgZ2l2ZW4gaW5kZXguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZywgU3RyaW5nXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgYXJyYXkvc3RyaW5nIGlzIHNwbGl0LlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFycmF5IFRoZSBhcnJheS9zdHJpbmcgdG8gYmUgc3BsaXQuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNwbGl0QXQoMSwgWzEsIDIsIDNdKTsgICAgICAgICAgLy89PiBbWzFdLCBbMiwgM11dXG4gKiAgICAgIFIuc3BsaXRBdCg1LCAnaGVsbG8gd29ybGQnKTsgICAgICAvLz0+IFsnaGVsbG8nLCAnIHdvcmxkJ11cbiAqICAgICAgUi5zcGxpdEF0KC0xLCAnZm9vYmFyJyk7ICAgICAgICAgIC8vPT4gWydmb29iYScsICdyJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHNwbGl0QXQoaW5kZXgsIGFycmF5KSB7XG4gIHJldHVybiBbc2xpY2UoMCwgaW5kZXgsIGFycmF5KSwgc2xpY2UoaW5kZXgsIGxlbmd0aChhcnJheSksIGFycmF5KV07XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3NwbGl0QXQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogU3BsaXRzIGEgY29sbGVjdGlvbiBpbnRvIHNsaWNlcyBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFtbYV1dXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNwbGl0RXZlcnkoMywgWzEsIDIsIDMsIDQsIDUsIDYsIDddKTsgLy89PiBbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3XV1cbiAqICAgICAgUi5zcGxpdEV2ZXJ5KDMsICdmb29iYXJiYXonKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHNwbGl0RXZlcnkobiwgbGlzdCkge1xuICBpZiAobiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBzcGxpdEV2ZXJ5IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goc2xpY2UoaWR4LCBpZHggKz0gbiwgbGlzdCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3NwbGl0RXZlcnkuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IGFuZCBhIHByZWRpY2F0ZSBhbmQgcmV0dXJucyBhIHBhaXIgb2YgbGlzdHMgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogIC0gdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoZSB0d28gb3V0cHV0IGxpc3RzIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IGxpc3Q7XG4gKiAgLSBub25lIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgb3V0cHV0IGxpc3Qgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IGFuZFxuICogIC0gaWYgdGhlIHNlY29uZCBvdXRwdXQgbGlzdCBpcyBub24tZW1wdHksIGl0cyBmaXJzdCBlbGVtZW50IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIFRoZSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzIHdoZXJlIHRoZSBhcnJheSBpcyBzcGxpdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGJlIHNwbGl0LlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zcGxpdFdoZW4oUi5lcXVhbHMoMiksIFsxLCAyLCAzLCAxLCAyLCAzXSk7ICAgLy89PiBbWzFdLCBbMiwgMywgMSwgMiwgM11dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBzcGxpdFdoZW4ocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcHJlZml4ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbiAmJiAhcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgcHJlZml4LnB1c2gobGlzdFtpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBbcHJlZml4LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpXTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvc3BsaXRXaGVuLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFN1YnRyYWN0cyBpdHMgc2Vjb25kIGFyZ3VtZW50IGZyb20gaXRzIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLSBiYC5cbiAqIEBzZWUgUi5hZGRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN1YnRyYWN0KDEwLCA4KTsgLy89PiAyXG4gKlxuICogICAgICB2YXIgbWludXM1ID0gUi5zdWJ0cmFjdChSLl9fLCA1KTtcbiAqICAgICAgbWludXM1KDE3KTsgLy89PiAxMlxuICpcbiAqICAgICAgdmFyIGNvbXBsZW1lbnRhcnlBbmdsZSA9IFIuc3VidHJhY3QoOTApO1xuICogICAgICBjb21wbGVtZW50YXJ5QW5nbGUoMzApOyAvLz0+IDYwXG4gKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSg3Mik7IC8vPT4gMThcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvc3VidHJhY3QuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGNvbmNhdCA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgZGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vZGlmZmVyZW5jZScpO1xuXG5cbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBmaXJzdCBvclxuICogc2Vjb25kIGxpc3QsIGJ1dCBub3QgYm90aC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIG9yIGBsaXN0MmAsIGJ1dCBub3QgYm90aC5cbiAqIEBzZWUgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aCwgUi5kaWZmZXJlbmNlLCBSLmRpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFsxLDIsNyw2LDVdXG4gKiAgICAgIFIuc3ltbWV0cmljRGlmZmVyZW5jZShbNyw2LDUsNCwzXSwgWzEsMiwzLDRdKTsgLy89PiBbNyw2LDUsMSwyXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gc3ltbWV0cmljRGlmZmVyZW5jZShsaXN0MSwgbGlzdDIpIHtcbiAgcmV0dXJuIGNvbmNhdChkaWZmZXJlbmNlKGxpc3QxLCBsaXN0MiksIGRpZmZlcmVuY2UobGlzdDIsIGxpc3QxKSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3N5bW1ldHJpY0RpZmZlcmVuY2UuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIGNvbmNhdCA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgZGlmZmVyZW5jZVdpdGggPSByZXF1aXJlKCcuL2RpZmZlcmVuY2VXaXRoJyk7XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIGZpcnN0IG9yXG4gKiBzZWNvbmQgbGlzdCwgYnV0IG5vdCBib3RoLiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGUgdmFsdWVcbiAqIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBlbGVtZW50cyBpbiBgbGlzdDFgIG9yIGBsaXN0MmAsIGJ1dCBub3QgYm90aC5cbiAqIEBzZWUgUi5zeW1tZXRyaWNEaWZmZXJlbmNlLCBSLmRpZmZlcmVuY2UsIFIuZGlmZmVyZW5jZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZXFBID0gUi5lcUJ5KFIucHJvcCgnYScpKTtcbiAqICAgICAgdmFyIGwxID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM30sIHthOiA0fV07XG4gKiAgICAgIHZhciBsMiA9IFt7YTogM30sIHthOiA0fSwge2E6IDV9LCB7YTogNn1dO1xuICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoKGVxQSwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn0sIHthOiA1fSwge2E6IDZ9XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gc3ltbWV0cmljRGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSB7XG4gIHJldHVybiBjb25jYXQoZGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZVdpdGgocHJlZCwgbGlzdDIsIGxpc3QxKSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3N5bW1ldHJpY0RpZmZlcmVuY2VXaXRoLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBkcm9wID0gcmVxdWlyZSgnLi9kcm9wJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgbGFzdCBgbmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gKiBJZiBgbiA+IGxpc3QubGVuZ3RoYCwgcmV0dXJucyBhIGxpc3Qgb2YgYGxpc3QubGVuZ3RoYCBlbGVtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLmRyb3BMYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50YWtlTGFzdCgxLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnYmF6J11cbiAqICAgICAgUi50YWtlTGFzdCgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlTGFzdCg0LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2VMYXN0KDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ21kYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHRha2VMYXN0KG4sIHhzKSB7XG4gIHJldHVybiBkcm9wKG4gPj0gMCA/IHhzLmxlbmd0aCAtIG4gOiAwLCB4cyk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3Rha2VMYXN0LmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBsYXN0IGBuYCBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3QsIHBhc3NpbmdcbiAqIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbiwgYW5kIHRlcm1pbmF0aW5nIHdoZW4gdGhlXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLiBFeGNsdWRlcyB0aGUgZWxlbWVudCB0aGF0IGNhdXNlZCB0aGVcbiAqIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBmYWlsLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6XG4gKiAqKHZhbHVlKSouXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIuZHJvcExhc3RXaGlsZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc05vdE9uZSA9IHggPT4geCAhPT0gMTtcbiAqXG4gKiAgICAgIFIudGFrZUxhc3RXaGlsZShpc05vdE9uZSwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgMywgNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHRha2VMYXN0V2hpbGUoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGlkeCA+PSAwICYmIGZuKGxpc3RbaWR4XSkpIHtcbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4ICsgMSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3Rha2VMYXN0V2hpbGUuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeHRha2VXaGlsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3h0YWtlV2hpbGUnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LFxuICogcGFzc2luZyBlYWNoIHZhbHVlIHRvIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24sIGFuZCB0ZXJtaW5hdGluZyB3aGVuXG4gKiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZmFpbC4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OlxuICogKih2YWx1ZSkqLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlV2hpbGVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLmRyb3BXaGlsZSwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgaXNOb3RGb3VyID0geCA9PiB4ICE9PSA0O1xuICpcbiAqICAgICAgUi50YWtlV2hpbGUoaXNOb3RGb3VyLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFsxLCAyLCAzXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZShbJ3Rha2VXaGlsZSddLCBfeHRha2VXaGlsZSwgZnVuY3Rpb24gdGFrZVdoaWxlKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4gJiYgZm4obGlzdFtpZHhdKSkge1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCAwLCBpZHgpO1xufSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdGFrZVdoaWxlLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGEgLT4gKikgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGB4YC4gVGhlIHJldHVybiB2YWx1ZSBvZiBgZm5gIHdpbGwgYmUgdGhyb3duIGF3YXkuXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9IGB4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgc2F5WCA9IHggPT4gY29uc29sZS5sb2coJ3ggaXMgJyArIHgpO1xuICogICAgICBSLnRhcChzYXlYLCAxMDApOyAvLz0+IDEwMFxuICogICAgICAvLyBsb2dzICd4IGlzIDEwMCdcbiAqIEBzeW1iIFIudGFwKGYsIGEpID0gYVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdGFwKGZuLCB4KSB7XG4gIGZuKHgpO1xuICByZXR1cm4geDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdGFwLmpzIiwidmFyIF9jbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Nsb25lUmVnRXhwJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc1JlZ0V4cCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzUmVnRXhwJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFJlZ0V4cCAtPiBTdHJpbmcgLT4gQm9vbGVhblxuICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIubWF0Y2hcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRlc3QoL154LywgJ3h5eicpOyAvLz0+IHRydWVcbiAqICAgICAgUi50ZXN0KC9eeS8sICd4eXonKTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdGVzdChwYXR0ZXJuLCBzdHIpIHtcbiAgaWYgKCFfaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCfigJh0ZXN04oCZIHJlcXVpcmVzIGEgdmFsdWUgb2YgdHlwZSBSZWdFeHAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50OyByZWNlaXZlZCAnICsgdG9TdHJpbmcocGF0dGVybikpO1xuICB9XG4gIHJldHVybiBfY2xvbmVSZWdFeHAocGF0dGVybikudGVzdChzdHIpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90ZXN0LmpzIiwidmFyIGludm9rZXIgPSByZXF1aXJlKCcuL2ludm9rZXInKTtcblxuXG4vKipcbiAqIFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIGBzdHJgLlxuICogQHNlZSBSLnRvVXBwZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvTG93ZXIoJ1hZWicpOyAvLz0+ICd4eXonXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gaW52b2tlcigwLCAndG9Mb3dlckNhc2UnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3RvTG93ZXIuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcblxuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzLiBPbmx5IHRoZSBvYmplY3Qnc1xuICogb3duIHByb3BlcnRpZXMgYXJlIHVzZWQuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICp9IC0+IFtbU3RyaW5nLCpdXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGtleSwgdmFsdWUgYXJyYXlzIGZyb20gdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICogQHNlZSBSLmZyb21QYWlyc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudG9QYWlycyh7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gdG9QYWlycyhvYmopIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgb2JqKSkge1xuICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtwcm9wLCBvYmpbcHJvcF1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnM7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3RvUGFpcnMuanMiLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuIFRoZSBvYmplY3QncyBvd25cbiAqIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZSB1c2VkLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZVxuICogb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGRpZmZlcmVudCBKU1xuICogcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd25cbiAqICAgICAgICAgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLnRvUGFpcnNJbihmKTsgLy89PiBbWyd4JywnWCddLCBbJ3knLCdZJ11dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0b1BhaXJzSW4ob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIHBhaXJzW3BhaXJzLmxlbmd0aF0gPSBbcHJvcCwgb2JqW3Byb3BdXTtcbiAgfVxuICByZXR1cm4gcGFpcnM7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3RvUGFpcnNJbi5qcyIsInZhciBpbnZva2VyID0gcmVxdWlyZSgnLi9pbnZva2VyJyk7XG5cblxuLyoqXG4gKiBUaGUgdXBwZXIgY2FzZSB2ZXJzaW9uIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVwcGVyIGNhc2UgdmVyc2lvbiBvZiBgc3RyYC5cbiAqIEBzZWUgUi50b0xvd2VyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1VwcGVyKCdhYmMnKTsgLy89PiAnQUJDJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGludm9rZXIoMCwgJ3RvVXBwZXJDYXNlJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90b1VwcGVyLmpzIiwidmFyIF9yZWR1Y2UgPSByZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcbnZhciBfeHdyYXAgPSByZXF1aXJlKCcuL2ludGVybmFsL194d3JhcCcpO1xudmFyIGN1cnJ5TiA9IHJlcXVpcmUoJy4vY3VycnlOJyk7XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIHRyYW5zZHVjZXIgdXNpbmcgc3VwcGxpZWQgaXRlcmF0b3IgZnVuY3Rpb24uIFJldHVybnMgYSBzaW5nbGVcbiAqIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nIHRoZSB0cmFuc2Zvcm1lZFxuICogaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHZhbHVlXG4gKiBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCB3aWxsIGJlXG4gKiB3cmFwcGVkIGFzIGEgdHJhbnNmb3JtZXIgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNkdWNlci4gQSB0cmFuc2Zvcm1lciBjYW4gYmVcbiAqIHBhc3NlZCBkaXJlY3RseSBpbiBwbGFjZSBvZiBhbiBpdGVyYXRvciBmdW5jdGlvbi4gSW4gYm90aCBjYXNlcywgaXRlcmF0aW9uXG4gKiBtYXkgYmUgc3RvcHBlZCBlYXJseSB3aXRoIHRoZSBgUi5yZWR1Y2VkYCBmdW5jdGlvbi5cbiAqXG4gKiBBIHRyYW5zZHVjZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhXG4gKiB0cmFuc2Zvcm1lciBhbmQgY2FuIGJlIGNvbXBvc2VkIGRpcmVjdGx5LlxuICpcbiAqIEEgdHJhbnNmb3JtZXIgaXMgYW4gYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYSAyLWFyaXR5IHJlZHVjaW5nIGl0ZXJhdG9yXG4gKiBmdW5jdGlvbiwgc3RlcCwgMC1hcml0eSBpbml0aWFsIHZhbHVlIGZ1bmN0aW9uLCBpbml0LCBhbmQgMS1hcml0eSByZXN1bHRcbiAqIGV4dHJhY3Rpb24gZnVuY3Rpb24sIHJlc3VsdC4gVGhlIHN0ZXAgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgaXRlcmF0b3JcbiAqIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlIGZpbmFsXG4gKiBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpcyBSLmlkZW50aXR5LiBUaGUgaW5pdFxuICogZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGFjY3VtdWxhdG9yLCBidXQgaXMgaWdub3JlZCBieVxuICogdHJhbnNkdWNlLlxuICpcbiAqIFRoZSBpdGVyYXRpb24gaXMgcGVyZm9ybWVkIHdpdGggUi5yZWR1Y2UgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSB0cmFuc2R1Y2VyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChjIC0+IGMpIC0+IChhLGIgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgVGhlIHRyYW5zZHVjZXIgZnVuY3Rpb24uIFJlY2VpdmVzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYSB0cmFuc2Zvcm1lci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuIFdyYXBwZWQgYXMgdHJhbnNmb3JtZXIsIGlmIG5lY2Vzc2FyeSwgYW5kIHVzZWQgdG9cbiAqICAgICAgICBpbml0aWFsaXplIHRoZSB0cmFuc2R1Y2VyXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZCwgUi5pbnRvXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gKiAgICAgIHZhciB0cmFuc2R1Y2VyID0gUi5jb21wb3NlKFIubWFwKFIuYWRkKDEpKSwgUi50YWtlKDIpKTtcbiAqXG4gKiAgICAgIFIudHJhbnNkdWNlKHRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjdXJyeU4oNCwgZnVuY3Rpb24gdHJhbnNkdWNlKHhmLCBmbiwgYWNjLCBsaXN0KSB7XG4gIHJldHVybiBfcmVkdWNlKHhmKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IF94d3JhcChmbikgOiBmbiksIGFjYywgbGlzdCk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3RyYW5zZHVjZS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIGEgMkQgbGlzdC5cbiAqIFdoZW4gcGFzc2VkIGEgbGlzdCBvZiBgbmAgbGlzdHMgb2YgbGVuZ3RoIGB4YCxcbiAqIHJldHVybnMgYSBsaXN0IG9mIGB4YCBsaXN0cyBvZiBsZW5ndGggYG5gLlxuICpcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbW2FdXSAtPiBbW2FdXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBIDJEIGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fSBBIDJEIGxpc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyYW5zcG9zZShbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV0pIC8vPT4gW1sxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddXVxuICogICAgICBSLnRyYW5zcG9zZShbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dKSAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICpcbiAqIElmIHNvbWUgb2YgdGhlIHJvd3MgYXJlIHNob3J0ZXIgdGhhbiB0aGUgZm9sbG93aW5nIHJvd3MsIHRoZWlyIGVsZW1lbnRzIGFyZSBza2lwcGVkOlxuICpcbiAqICAgICAgUi50cmFuc3Bvc2UoW1sxMCwgMTFdLCBbMjBdLCBbXSwgWzMwLCAzMSwgMzJdXSkgLy89PiBbWzEwLCAyMCwgMzBdLCBbMTEsIDMxXSwgWzMyXV1cbiAqIEBzeW1iIFIudHJhbnNwb3NlKFtbYV0sIFtiXSwgW2NdXSkgPSBbYSwgYiwgY11cbiAqIEBzeW1iIFIudHJhbnNwb3NlKFtbYSwgYl0sIFtjLCBkXV0pID0gW1thLCBjXSwgW2IsIGRdXVxuICogQHN5bWIgUi50cmFuc3Bvc2UoW1thLCBiXSwgW2NdXSkgPSBbW2EsIGNdLCBbYl1dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0ZXJsaXN0KSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAoaSA8IG91dGVybGlzdC5sZW5ndGgpIHtcbiAgICB2YXIgaW5uZXJsaXN0ID0gb3V0ZXJsaXN0W2ldO1xuICAgIHZhciBqID0gMDtcbiAgICB3aGlsZSAoaiA8IGlubmVybGlzdC5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2pdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXN1bHRbal0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtqXS5wdXNoKGlubmVybGlzdFtqXSk7XG4gICAgICBqICs9IDE7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90cmFuc3Bvc2UuanMiLCJ2YXIgX2N1cnJ5MyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MycpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgc2VxdWVuY2UgPSByZXF1aXJlKCcuL3NlcXVlbmNlJyk7XG5cblxuLyoqXG4gKiBNYXBzIGFuIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSktcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiBvdmVyIGEgW1RyYXZlcnNhYmxlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlKSxcbiAqIHRoZW4gdXNlcyBbYHNlcXVlbmNlYF0oI3NlcXVlbmNlKSB0byB0cmFuc2Zvcm0gdGhlIHJlc3VsdGluZyBUcmF2ZXJzYWJsZSBvZiBBcHBsaWNhdGl2ZVxuICogaW50byBhbiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2VxdWVuY2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChhIC0+IGYgYSkgLT4gKGEgLT4gZiBiKSAtPiB0IGEgLT4gZiAodCBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0gdHJhdmVyc2FibGVcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuc2VxdWVuY2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBSZXR1cm5zIGBOb3RoaW5nYCBpZiB0aGUgZ2l2ZW4gZGl2aXNvciBpcyBgMGBcbiAqICAgICAgc2FmZURpdiA9IG4gPT4gZCA9PiBkID09PSAwID8gTm90aGluZygpIDogSnVzdChuIC8gZClcbiAqXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgNCwgNV0pOyAvLz0+IEp1c3QoWzUsIDIuNSwgMl0pXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgMCwgNV0pOyAvLz0+IE5vdGhpbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHRyYXZlcnNlKG9mLCBmLCB0cmF2ZXJzYWJsZSkge1xuICByZXR1cm4gc2VxdWVuY2Uob2YsIG1hcChmLCB0cmF2ZXJzYWJsZSkpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90cmF2ZXJzZS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBSZW1vdmVzIChzdHJpcHMpIHdoaXRlc3BhY2UgZnJvbSBib3RoIGVuZHMgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRyaW1tZWQgdmVyc2lvbiBvZiBgc3RyYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyaW0oJyAgIHh5eiAgJyk7IC8vPT4gJ3h5eidcbiAqICAgICAgUi5tYXAoUi50cmltLCBSLnNwbGl0KCcsJywgJ3gsIHksIHonKSk7IC8vPT4gWyd4JywgJ3knLCAneiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgd3MgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgICAgICAgICAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArXG4gICAgICAgICAgICdcXHUyMDI5XFx1RkVGRic7XG4gIHZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG4gIHZhciBoYXNQcm90b1RyaW0gPSAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSA9PT0gJ2Z1bmN0aW9uJyk7XG4gIGlmICghaGFzUHJvdG9UcmltIHx8ICh3cy50cmltKCkgfHwgIXplcm9XaWR0aC50cmltKCkpKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgICAgIHZhciBiZWdpblJ4ID0gbmV3IFJlZ0V4cCgnXlsnICsgd3MgKyAnXVsnICsgd3MgKyAnXSonKTtcbiAgICAgIHZhciBlbmRSeCA9IG5ldyBSZWdFeHAoJ1snICsgd3MgKyAnXVsnICsgd3MgKyAnXSokJyk7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYmVnaW5SeCwgJycpLnJlcGxhY2UoZW5kUngsICcnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2N1cnJ5MShmdW5jdGlvbiB0cmltKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgfSk7XG4gIH1cbn0oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy90cmltLmpzIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIGB0cnlDYXRjaGAgdGFrZXMgdHdvIGZ1bmN0aW9ucywgYSBgdHJ5ZXJgIGFuZCBhIGBjYXRjaGVyYC4gVGhlIHJldHVybmVkXG4gKiBmdW5jdGlvbiBldmFsdWF0ZXMgdGhlIGB0cnllcmA7IGlmIGl0IGRvZXMgbm90IHRocm93LCBpdCBzaW1wbHkgcmV0dXJucyB0aGVcbiAqIHJlc3VsdC4gSWYgdGhlIGB0cnllcmAgKmRvZXMqIHRocm93LCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRoZVxuICogYGNhdGNoZXJgIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGl0cyByZXN1bHQuIE5vdGUgdGhhdCBmb3IgZWZmZWN0aXZlXG4gKiBjb21wb3NpdGlvbiB3aXRoIHRoaXMgZnVuY3Rpb24sIGJvdGggdGhlIGB0cnllcmAgYW5kIGBjYXRjaGVyYCBmdW5jdGlvbnNcbiAqIG11c3QgcmV0dXJuIHRoZSBzYW1lIHR5cGUgb2YgcmVzdWx0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKC4uLnggLT4gYSkgLT4gKChlLCAuLi54KSAtPiBhKSAtPiAoLi4ueCAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJ5ZXIgVGhlIGZ1bmN0aW9uIHRoYXQgbWF5IHRocm93LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2F0Y2hlciBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBpZiBgdHJ5ZXJgIHRocm93cy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgY2F0Y2ggZXhjZXB0aW9ucyBhbmQgc2VuZCB0aGVuIHRvIHRoZSBjYXRjaGVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudHJ5Q2F0Y2goUi5wcm9wKCd4JyksIFIuRikoe3g6IHRydWV9KTsgLy89PiB0cnVlXG4gKiAgICAgIFIudHJ5Q2F0Y2goUi5wcm9wKCd4JyksIFIuRikobnVsbCk7ICAgICAgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gX3RyeUNhdGNoKHRyeWVyLCBjYXRjaGVyKSB7XG4gIHJldHVybiBfYXJpdHkodHJ5ZXIubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRyeWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhdGNoZXIuYXBwbHkodGhpcywgX2NvbmNhdChbZV0sIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgfSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3RyeUNhdGNoLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZuYCwgd2hpY2ggdGFrZXMgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFcbiAqIGZ1bmN0aW9uIHdoaWNoOlxuICpcbiAqICAgLSB0YWtlcyBhbnkgbnVtYmVyIG9mIHBvc2l0aW9uYWwgYXJndW1lbnRzO1xuICogICAtIHBhc3NlcyB0aGVzZSBhcmd1bWVudHMgdG8gYGZuYCBhcyBhbiBhcnJheTsgYW5kXG4gKiAgIC0gcmV0dXJucyB0aGUgcmVzdWx0LlxuICpcbiAqIEluIG90aGVyIHdvcmRzLCBSLnVuYXBwbHkgZGVyaXZlcyBhIHZhcmlhZGljIGZ1bmN0aW9uIGZyb20gYSBmdW5jdGlvbiB3aGljaFxuICogdGFrZXMgYW4gYXJyYXkuIFIudW5hcHBseSBpcyB0aGUgaW52ZXJzZSBvZiBSLmFwcGx5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChbKi4uLl0gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5hcHBseVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5hcHBseShKU09OLnN0cmluZ2lmeSkoMSwgMiwgMyk7IC8vPT4gJ1sxLDIsM10nXG4gKiBAc3ltYiBSLnVuYXBwbHkoZikoYSwgYikgPSBmKFthLCBiXSlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHVuYXBwbHkoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmbihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgfTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdW5hcHBseS5qcyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgbkFyeSA9IHJlcXVpcmUoJy4vbkFyeScpO1xuXG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSAxIHBhcmFtZXRlci4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBiKSAtPiAoYSAtPiBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgYGZuYC4gVGhlIG5ldyBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIGJlIG9mXG4gKiAgICAgICAgIGFyaXR5IDEuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHRha2VzVHdvQXJncyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAqICAgICAgICByZXR1cm4gW2EsIGJdO1xuICogICAgICB9O1xuICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIpOyAvLz0+IFsxLCAyXVxuICpcbiAqICAgICAgdmFyIHRha2VzT25lQXJnID0gUi51bmFyeSh0YWtlc1R3b0FyZ3MpO1xuICogICAgICB0YWtlc09uZUFyZy5sZW5ndGg7IC8vPT4gMVxuICogICAgICAvLyBPbmx5IDEgYXJndW1lbnQgaXMgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uXG4gKiAgICAgIHRha2VzT25lQXJnKDEsIDIpOyAvLz0+IFsxLCB1bmRlZmluZWRdXG4gKiBAc3ltYiBSLnVuYXJ5KGYpKGEsIGIsIGMpID0gZihhKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTEoZnVuY3Rpb24gdW5hcnkoZm4pIHtcbiAgcmV0dXJuIG5BcnkoMSwgZm4pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91bmFyeS5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBvZiBhcml0eSBgbmAgZnJvbSBhIChtYW51YWxseSkgY3VycmllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+IChhIC0+IGIpIC0+IChhIC0+IGMpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHVuY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgYWRkRm91ciA9IGEgPT4gYiA9PiBjID0+IGQgPT4gYSArIGIgKyBjICsgZDtcbiAqXG4gKiAgICAgIHZhciB1bmN1cnJpZWRBZGRGb3VyID0gUi51bmN1cnJ5Tig0LCBhZGRGb3VyKTtcbiAqICAgICAgdW5jdXJyaWVkQWRkRm91cigxLCAyLCAzLCA0KTsgLy89PiAxMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdW5jdXJyeU4oZGVwdGgsIGZuKSB7XG4gIHJldHVybiBjdXJyeU4oZGVwdGgsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50RGVwdGggPSAxO1xuICAgIHZhciB2YWx1ZSA9IGZuO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBlbmRJZHg7XG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCA8PSBkZXB0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVuZElkeCA9IGN1cnJlbnREZXB0aCA9PT0gZGVwdGggPyBhcmd1bWVudHMubGVuZ3RoIDogaWR4ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIGlkeCwgZW5kSWR4KSk7XG4gICAgICBjdXJyZW50RGVwdGggKz0gMTtcbiAgICAgIGlkeCA9IGVuZElkeDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdW5jdXJyeU4uanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQnVpbGRzIGEgbGlzdCBmcm9tIGEgc2VlZCB2YWx1ZS4gQWNjZXB0cyBhbiBpdGVyYXRvciBmdW5jdGlvbiwgd2hpY2ggcmV0dXJuc1xuICogZWl0aGVyIGZhbHNlIHRvIHN0b3AgaXRlcmF0aW9uIG9yIGFuIGFycmF5IG9mIGxlbmd0aCAyIGNvbnRhaW5pbmcgdGhlIHZhbHVlXG4gKiB0byBhZGQgdG8gdGhlIHJlc3VsdGluZyBsaXN0IGFuZCB0aGUgc2VlZCB0byBiZSB1c2VkIGluIHRoZSBuZXh0IGNhbGwgdG8gdGhlXG4gKiBpdGVyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgb25lIGFyZ3VtZW50OiAqKHNlZWQpKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBbYl0pIC0+ICogLT4gW2JdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYHNlZWRgLCBhbmQgcmV0dXJuc1xuICogICAgICAgIGVpdGhlciBmYWxzZSB0byBxdWl0IGl0ZXJhdGlvbiBvciBhbiBhcnJheSBvZiBsZW5ndGggdHdvIHRvIHByb2NlZWQuIFRoZSBlbGVtZW50XG4gKiAgICAgICAgYXQgaW5kZXggMCBvZiB0aGlzIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJlc3VsdGluZyBhcnJheSwgYW5kIHRoZSBlbGVtZW50XG4gKiAgICAgICAgYXQgaW5kZXggMSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbmV4dCBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0geyp9IHNlZWQgVGhlIHNlZWQgdmFsdWUuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZpbmFsIGxpc3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGYgPSBuID0+IG4gPiA1MCA/IGZhbHNlIDogWy1uLCBuICsgMTBdO1xuICogICAgICBSLnVuZm9sZChmLCAxMCk7IC8vPT4gWy0xMCwgLTIwLCAtMzAsIC00MCwgLTUwXVxuICogQHN5bWIgUi51bmZvbGQoZiwgeCkgPSBbZih4KVswXSwgZihmKHgpWzFdKVswXSwgZihmKGYoeClbMV0pWzFdKVswXSwgLi4uXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gdW5mb2xkKGZuLCBzZWVkKSB7XG4gIHZhciBwYWlyID0gZm4oc2VlZCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKHBhaXIgJiYgcGFpci5sZW5ndGgpIHtcbiAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBwYWlyWzBdO1xuICAgIHBhaXIgPSBmbihwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91bmZvbGQuanMiLCJ2YXIgX2NvbmNhdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbmNhdCcpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBjb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG52YXIgdW5pcSA9IHJlcXVpcmUoJy4vdW5pcScpO1xuXG5cbi8qKlxuICogQ29tYmluZXMgdHdvIGxpc3RzIGludG8gYSBzZXQgKGkuZS4gbm8gZHVwbGljYXRlcykgY29tcG9zZWQgb2YgdGhlIGVsZW1lbnRzXG4gKiBvZiBlYWNoIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGFzIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gYnMgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmlvbihbMSwgMiwgM10sIFsyLCAzLCA0XSk7IC8vPT4gWzEsIDIsIDMsIDRdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5Mihjb21wb3NlKHVuaXEsIF9jb25jYXQpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3VuaW9uLmpzIiwidmFyIF9jb25jYXQgPSByZXF1aXJlKCcuL2ludGVybmFsL19jb25jYXQnKTtcbnZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgdW5pcVdpdGggPSByZXF1aXJlKCcuL3VuaXFXaXRoJyk7XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggbGlzdC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5XG4gKiBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIChhIC0+IGEgLT4gQm9vbGVhbikgLT4gWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gKiBAc2VlIFIudW5pb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbDEgPSBbe2E6IDF9LCB7YTogMn1dO1xuICogICAgICB2YXIgbDIgPSBbe2E6IDF9LCB7YTogNH1dO1xuICogICAgICBSLnVuaW9uV2l0aChSLmVxQnkoUi5wcm9wKCdhJykpLCBsMSwgbDIpOyAvLz0+IFt7YTogMX0sIHthOiAyfSwge2E6IDR9XVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gdW5pb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gdW5pcVdpdGgocHJlZCwgX2NvbmNhdChsaXN0MSwgbGlzdDIpKTtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdW5pb25XaXRoLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gKiB0aGUgcHJlZGljYXRlIGlzIG5vdCBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gKiBjYWxsaW5nIHRoZSBgd2hlbkZhbHNlRm5gIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgYXJndW1lbnQuIElmIHRoZSBwcmVkaWNhdGVcbiAqIGlzIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB3aGVuRmFsc2VGbiBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgcHJlZGAgZXZhbHVhdGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIGZhbHN5IHZhbHVlLlxuICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICAgQW4gb2JqZWN0IHRvIHRlc3Qgd2l0aCB0aGUgYHByZWRgIGZ1bmN0aW9uIGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyB0byBgd2hlbkZhbHNlRm5gIGlmIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5GYWxzZUZuYC5cbiAqIEBzZWUgUi5pZkVsc2UsIFIud2hlblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIGNvZXJjZUFycmF5IDo6IChhfFthXSkgLT4gW2FdXG4gKiAgICAgIHZhciBjb2VyY2VBcnJheSA9IFIudW5sZXNzKFIuaXNBcnJheUxpa2UsIFIub2YpO1xuICogICAgICBjb2VyY2VBcnJheShbMSwgMiwgM10pOyAvLz0+IFsxLCAyLCAzXVxuICogICAgICBjb2VyY2VBcnJheSgxKTsgICAgICAgICAvLz0+IFsxXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoZnVuY3Rpb24gdW5sZXNzKHByZWQsIHdoZW5GYWxzZUZuLCB4KSB7XG4gIHJldHVybiBwcmVkKHgpID8geCA6IHdoZW5GYWxzZUZuKHgpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy91bmxlc3MuanMiLCJ2YXIgX2lkZW50aXR5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faWRlbnRpdHknKTtcbnZhciBjaGFpbiA9IHJlcXVpcmUoJy4vY2hhaW4nKTtcblxuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgYFIuY2hhaW4oUi5pZGVudGl0eSlgLCB3aGljaCByZW1vdmVzIG9uZSBsZXZlbCBvZiBuZXN0aW5nIGZyb21cbiAqIGFueSBbQ2hhaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW4pLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgQ2hhaW4gYyA9PiBjIChjIGEpIC0+IGMgYVxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmZsYXR0ZW4sIFIuY2hhaW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVubmVzdChbMSwgWzJdLCBbWzNdXV0pOyAvLz0+IFsxLCAyLCBbM11dXG4gKiAgICAgIFIudW5uZXN0KFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdXSk7IC8vPT4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2hhaW4oX2lkZW50aXR5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3VubmVzdC5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSwgYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiwgYW5kIGFuIGluaXRpYWwgdmFsdWUsXG4gKiBhbmQgcmV0dXJucyBhIHZhbHVlIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBJdCBkb2VzIHNvIGJ5IGFwcGx5aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiB1bnRpbCB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCxcbiAqIGF0IHdoaWNoIHBvaW50IGl0IHJldHVybnMgdGhlIHNhdGlzZmFjdG9yeSB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gaW5pdCBJbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJuIHsqfSBGaW5hbCB2YWx1ZSB0aGF0IHNhdGlzZmllcyBwcmVkaWNhdGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVudGlsKFIuZ3QoUi5fXywgMTAwKSwgUi5tdWx0aXBseSgyKSkoMSkgLy8gPT4gMTI4XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhmdW5jdGlvbiB1bnRpbChwcmVkLCBmbiwgaW5pdCkge1xuICB2YXIgdmFsID0gaW5pdDtcbiAgd2hpbGUgKCFwcmVkKHZhbCkpIHtcbiAgICB2YWwgPSBmbih2YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3VudGlsLmpzIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgcHJvcGVydGllcywgaW5jbHVkaW5nIHByb3RvdHlwZSBwcm9wZXJ0aWVzLCBvZiB0aGVcbiAqIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFt2XVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgdmFsdWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QncyBvd24gYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBGID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9ICdYJzsgfTtcbiAqICAgICAgRi5wcm90b3R5cGUueSA9ICdZJztcbiAqICAgICAgdmFyIGYgPSBuZXcgRigpO1xuICogICAgICBSLnZhbHVlc0luKGYpOyAvLz0+IFsnWCcsICdZJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIHZhbHVlc0luKG9iaikge1xuICB2YXIgcHJvcDtcbiAgdmFyIHZzID0gW107XG4gIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICB2c1t2cy5sZW5ndGhdID0gb2JqW3Byb3BdO1xuICB9XG4gIHJldHVybiB2cztcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdmFsdWVzSW4uanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIFwidmlld1wiIG9mIHRoZSBnaXZlbiBkYXRhIHN0cnVjdHVyZSwgZGV0ZXJtaW5lZCBieSB0aGUgZ2l2ZW4gbGVucy5cbiAqIFRoZSBsZW5zJ3MgZm9jdXMgZGV0ZXJtaW5lcyB3aGljaCBwb3J0aW9uIG9mIHRoZSBkYXRhIHN0cnVjdHVyZSBpcyB2aXNpYmxlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIExlbnMgcyBhIC0+IHMgLT4gYVxuICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIucHJvcCwgUi5sZW5zSW5kZXgsIFIubGVuc1Byb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gKlxuICogICAgICBSLnZpZXcoeExlbnMsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IDFcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogNCwgeTogMn0pOyAgLy89PiA0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvLyBgQ29uc3RgIGlzIGEgZnVuY3RvciB0aGF0IGVmZmVjdGl2ZWx5IGlnbm9yZXMgdGhlIGZ1bmN0aW9uIGdpdmVuIHRvIGBtYXBgLlxuICB2YXIgQ29uc3QgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHt2YWx1ZTogeCwgbWFwOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH19O1xuICB9O1xuXG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIHZpZXcobGVucywgeCkge1xuICAgIC8vIFVzaW5nIGBDb25zdGAgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgc2V0dGVyIGZ1bmN0aW9uIG9mIHRoZSBgbGVuc2AsXG4gICAgLy8gbGVhdmluZyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiB1bm1vZGlmaWVkLlxuICAgIHJldHVybiBsZW5zKENvbnN0KSh4KS52YWx1ZTtcbiAgfSk7XG59KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvdmlldy5qcyIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBUZXN0cyB0aGUgZmluYWwgYXJndW1lbnQgYnkgcGFzc2luZyBpdCB0byB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLiBJZlxuICogdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAqIHRoZSBgd2hlblRydWVGbmAgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBhcmd1bWVudC4gSWYgdGhlIHByZWRpY2F0ZSBpcyBub3RcbiAqIHNhdGlzZmllZCwgdGhlIGFyZ3VtZW50IGlzIHJldHVybmVkIGFzIGlzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE4LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgICAgICAgQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHdoZW5UcnVlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlLlxuICogQHBhcmFtIHsqfSAgICAgICAgeCAgICAgICAgICBBbiBvYmplY3QgdG8gdGVzdCB3aXRoIHRoZSBgcHJlZGAgZnVuY3Rpb24gYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5UcnVlRm5gIGlmIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm4geyp9IEVpdGhlciBgeGAgb3IgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgeGAgdG8gYHdoZW5UcnVlRm5gLlxuICogQHNlZSBSLmlmRWxzZSwgUi51bmxlc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyB0cnVuY2F0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gKiAgICAgIHZhciB0cnVuY2F0ZSA9IFIud2hlbihcbiAqICAgICAgICBSLnByb3BTYXRpc2ZpZXMoUi5ndChSLl9fLCAxMCksICdsZW5ndGgnKSxcbiAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICogICAgICApO1xuICogICAgICB0cnVuY2F0ZSgnMTIzNDUnKTsgICAgICAgICAvLz0+ICcxMjM0NSdcbiAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHdoZW4ocHJlZCwgd2hlblRydWVGbiwgeCkge1xuICByZXR1cm4gcHJlZCh4KSA/IHdoZW5UcnVlRm4oeCkgOiB4O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy93aGVuLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xudmFyIG1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG52YXIgd2hlcmUgPSByZXF1aXJlKCcuL3doZXJlJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gKiB0aGUgc3BlYywgZmFsc2Ugb3RoZXJ3aXNlLiBBbiBvYmplY3Qgc2F0aXNmaWVzIHRoZSBzcGVjIGlmLCBmb3IgZWFjaCBvZiB0aGVcbiAqIHNwZWMncyBvd24gcHJvcGVydGllcywgYWNjZXNzaW5nIHRoYXQgcHJvcGVydHkgb2YgdGhlIG9iamVjdCBnaXZlcyB0aGUgc2FtZVxuICogdmFsdWUgKGluIGBSLmVxdWFsc2AgdGVybXMpIGFzIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBzcGVjLlxuICpcbiAqIGB3aGVyZUVxYCBpcyBhIHNwZWNpYWxpemF0aW9uIG9mIFtgd2hlcmVgXSgjd2hlcmUpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge1N0cmluZzogKn0gLT4ge1N0cmluZzogKn0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IHNwZWNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0T2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLndoZXJlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gcHJlZCA6OiBPYmplY3QgLT4gQm9vbGVhblxuICogICAgICB2YXIgcHJlZCA9IFIud2hlcmVFcSh7YTogMSwgYjogMn0pO1xuICpcbiAqICAgICAgcHJlZCh7YTogMX0pOyAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAxLCBiOiAyfSk7ICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgcHJlZCh7YTogMSwgYjogMiwgYzogM30pOyAgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6IDEsIGI6IDF9KTsgICAgICAgIC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHdoZXJlRXEoc3BlYywgdGVzdE9iaikge1xuICByZXR1cm4gd2hlcmUobWFwKGVxdWFscywgc3BlYyksIHRlc3RPYmopO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy93aGVyZUVxLmpzIiwidmFyIF9jb250YWlucyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbnRhaW5zJyk7XG52YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIGZsaXAgPSByZXF1aXJlKCcuL2ZsaXAnKTtcbnZhciByZWplY3QgPSByZXF1aXJlKCcuL3JlamVjdCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGhvdXQgdmFsdWVzIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIGBSLmVxdWFsc2AgaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgdmFsdWVzIHRvIGJlIHJlbW92ZWQgZnJvbSBgbGlzdDJgLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIGFycmF5IHRvIHJlbW92ZSB2YWx1ZXMgZnJvbS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGFycmF5IHdpdGhvdXQgdmFsdWVzIGluIGBsaXN0MWAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi53aXRob3V0KFsxLCAyXSwgWzEsIDIsIDEsIDMsIDRdKTsgLy89PiBbMywgNF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uKHhzLCBsaXN0KSB7XG4gIHJldHVybiByZWplY3QoZmxpcChfY29udGFpbnMpKHhzKSwgbGlzdCk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmFtZGEvc3JjL3dpdGhvdXQuanMiLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IGNyZWF0aW5nIGVhY2ggcG9zc2libGUgcGFpclxuICogZnJvbSB0aGUgbGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAqIEBwYXJhbSB7QXJyYXl9IGFzIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gYnMgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIGVhY2ggcG9zc2libGUgcGFpciBmcm9tXG4gKiAgICAgICAgIGBhc2AgYW5kIGBic2AgaW50byBwYWlycyAoYFthLCBiXWApLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIueHByb2QoWzEsIDJdLCBbJ2EnLCAnYiddKTsgLy89PiBbWzEsICdhJ10sIFsxLCAnYiddLCBbMiwgJ2EnXSwgWzIsICdiJ11dXG4gKiBAc3ltYiBSLnhwcm9kKFthLCBiXSwgW2MsIGRdKSA9IFtbYSwgY10sIFthLCBkXSwgW2IsIGNdLCBbYiwgZF1dXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiB4cHJvZChhLCBiKSB7IC8vID0geHByb2RXaXRoKHByZXBlbmQpOyAodGFrZXMgYWJvdXQgMyB0aW1lcyBhcyBsb25nLi4uKVxuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGlsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGo7XG4gIHZhciBqbGVuID0gYi5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICBqID0gMDtcbiAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IFthW2lkeF0sIGJbal1dO1xuICAgICAgaiArPSAxO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy94cHJvZC5qcyIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgb3V0IG9mIHRoZSB0d28gc3VwcGxpZWQgYnkgcGFpcmluZyB1cCBlcXVhbGx5LXBvc2l0aW9uZWRcbiAqIGl0ZW1zIGZyb20gYm90aCBsaXN0cy4gVGhlIHJldHVybmVkIGxpc3QgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBzaG9ydGVyIG9mIHRoZSB0d28gaW5wdXQgbGlzdHMuXG4gKiBOb3RlOiBgemlwYCBpcyBlcXVpdmFsZW50IHRvIGB6aXBXaXRoKGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIFthLCBiXSB9KWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBhcnJheSB0byBjb25zaWRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuemlwKFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTsgLy89PiBbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV1cbiAqIEBzeW1iIFIuemlwKFthLCBiLCBjXSwgW2QsIGUsIGZdKSA9IFtbYSwgZF0sIFtiLCBlXSwgW2MsIGZdXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBbYVtpZHhdLCBiW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiBydjtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvemlwLmpzIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IG91dCBvZiBhIGxpc3Qgb2Yga2V5cyBhbmQgYSBsaXN0IG9mIHZhbHVlcy5cbiAqIEtleS92YWx1ZSBwYWlyaW5nIGlzIHRydW5jYXRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBzaG9ydGVyIG9mIHRoZSB0d28gbGlzdHMuXG4gKiBOb3RlOiBgemlwT2JqYCBpcyBlcXVpdmFsZW50IHRvIGBwaXBlKHppcFdpdGgocGFpciksIGZyb21QYWlycylgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW1N0cmluZ10gLT4gWypdIC0+IHtTdHJpbmc6ICp9XG4gKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSB0aGF0IHdpbGwgYmUgcHJvcGVydGllcyBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgbGlzdCBvZiB2YWx1ZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvYmplY3QgbWFkZSBieSBwYWlyaW5nIHVwIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuemlwT2JqKFsnYScsICdiJywgJ2MnXSwgWzEsIDIsIDNdKTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHppcE9iaihrZXlzLCB2YWx1ZXMpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihrZXlzLmxlbmd0aCwgdmFsdWVzLmxlbmd0aCk7XG4gIHZhciBvdXQgPSB7fTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIG91dFtrZXlzW2lkeF1dID0gdmFsdWVzW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yYW1kYS9zcmMvemlwT2JqLmpzIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBvdXQgb2YgdGhlIHR3byBzdXBwbGllZCBieSBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG8gZWFjaFxuICogZXF1YWxseS1wb3NpdGlvbmVkIHBhaXIgaW4gdGhlIGxpc3RzLiBUaGUgcmV0dXJuZWQgbGlzdCBpcyB0cnVuY2F0ZWQgdG8gdGhlXG4gKiBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBpbnB1dCBsaXN0cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSxiIC0+IGMpIC0+IFthXSAtPiBbYl0gLT4gW2NdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21iaW5lIHRoZSB0d28gZWxlbWVudHMgaW50byBvbmUgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIHNhbWUtaW5kZXhlZCBlbGVtZW50cyBvZiBgbGlzdDFgIGFuZCBgbGlzdDJgXG4gKiAgICAgICAgIHVzaW5nIGBmbmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGYgPSAoeCwgeSkgPT4ge1xuICogICAgICAgIC8vIC4uLlxuICogICAgICB9O1xuICogICAgICBSLnppcFdpdGgoZiwgWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10pO1xuICogICAgICAvLz0+IFtmKDEsICdhJyksIGYoMiwgJ2InKSwgZigzLCAnYycpXVxuICogQHN5bWIgUi56aXBXaXRoKGZuLCBbYSwgYiwgY10sIFtkLCBlLCBmXSkgPSBbZm4oYSwgZCksIGZuKGIsIGUpLCBmbihjLCBmKV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHppcFdpdGgoZm4sIGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBmbihhW2lkeF0sIGJbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJ2O1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JhbWRhL3NyYy96aXBXaXRoLmpzIiwiLyoqXG4gKiBJZiBtaW4gc2luZ2xlIGxlc3MgdGhhbiBtaW4gdHJhdmVsY2FyZCBhbmQgbWF4IHNpbmdsZSBtb3JlIHRoYW4gbWF4IHRyYXZlbGNhcmQgLSBjYWxjdWxhdGVzIHdoaWNoZXZlciBpcyBjaGVhcGVyOlxuICogXHRlaXRoZXIgdHdvIHNwbGl0IHNpbmdsZXMgb3IgZnVsbCBmYXJlIHdpdGhvdXQgdHJhdmVsY2FyZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnN9IG1pbkNoYXJnZWRab25lIC0gdGhlIG1pbiB6b25lIHRoYXQgd2lsbCBjaGFyZ2UgYmV0d2VlbiB0aGlzIG1pbiBjaGFyZ2FibGUgem9uZSB0byBtaW4gdHJhdmVsY2FyZCAtIDEgKGFzIHNpbmdsZSkgYW5kICBtYXggY2hhcmdlYWJsZSB6b25lICh0byBjaGFyZ2UgYmV3ZWVuIG1heCB0cmF2ZWxjYXJkICsxIHRvIG1heCBjaGFyZ2VhYmxlIHpvbmUpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHJldHVybnMgdGhlIGNoZWFwZXN0IGZhcmVcbiAqIEBkZXNjcmlwdGlvblxuICovXG5cbmltcG9ydCB7XG5cdGdldFNpbmdsZUZhcmUsXG5cdG1pbk51bSxcbn0gZnJvbSAnLi4vdXRpbGl0eS9fdXRpbGl0eSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwbGl0T3JGdWxsRmFyZShcblx0bWluQ2hhcmdlZFpvbmUsIG1heFNpbmdsZSxcblx0bWluVHJhdmVsY2FyZCwgbWF4VHJhdmVsY2FyZCxcblx0c2luZ2xlRmFyZXMsIHR5cGUpIHtcblx0cmV0dXJuIG1pbk51bShbXG5cdFx0Z2V0U2luZ2xlRmFyZShbbWluQ2hhcmdlZFpvbmUsIG1heFNpbmdsZV0sIHNpbmdsZUZhcmVzLCB0eXBlKSxcblx0XHQoZ2V0U2luZ2xlRmFyZShbbWluQ2hhcmdlZFpvbmUsIChtaW5UcmF2ZWxjYXJkIC0gMSldLCBzaW5nbGVGYXJlcywgdHlwZSkgKyBnZXRTaW5nbGVGYXJlKFsobWF4VHJhdmVsY2FyZCArIDEpLCBtYXhTaW5nbGVdLCBzaW5nbGVGYXJlcywgdHlwZSkpXG5cdF0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9wYXJ0aWFscy9fc3BsaXRPckZ1bGxGYXJlLmpzIiwiaW1wb3J0IHtcblx0bWF4TnVtLFxuXHRtaW5OdW0sXG5cdGZsYXR0ZW4sXG5cdGdldERhaWx5Q2FwLFxuXHRnZXRTaW5nbGVGYXJlLFxuXHRnZXRDYXAsXG5cdG1ldCxcbn0gZnJvbSAnLi91dGlsaXR5L191dGlsaXR5JztcblxuaW1wb3J0IGdldERhdGEgZnJvbSAnLi91dGlsaXR5L19nZXREYXRhJztcbmltcG9ydCBnZXRTaW5nbGVKb3VybmV5Wm9uZXMgZnJvbSAnLi9wYXJ0aWFscy9fZ2V0U2luZ2xlSm91cm5leVpvbmVzJztcbmltcG9ydCBleHRlbnNpb25GYXJlcyBmcm9tICcuL3BhcnRpYWxzL19leHRlbnNpb25GYXJlcyc7XG5pbXBvcnQgb3lzdGVyRGF5VG90YWwgZnJvbSAnLi9wYXJ0aWFscy9fb3lzdGVyRGF5VG90YWwnO1xuXG4vLyBUTyBET1xuLy8gT2ZmIHBlYWsgdnMgb24gcGVhayBzaW5nbGVzIChlc3AgaW5jbHVkaW5nIG91dCBvZiB6b25lIDEgdG8gem9uZSAxIGluIGV2ZW5pbmcgaXMgb2ZmcGVhayBleGNlcHRpb24pXG4vLyBPZmZwZWFrIGRhaWx5IGNhcCBkaXNjb3VudHMgLSBrZWVwIHRyYWNrIHdoZW4gZGFpbHkgY2FwIHJlYWNoZWQgYnV0IG9ubHkgdHJhdmVsbGVkIG9mZiBwZWFrIChpZiBnb2luZyB0byBkbyBvZmYgcGVhayBveXN0ZXIgY3VtIHRvdGFscyB0aGVuIHdvdWxkIGtub3cgdGhpcylcbi8vIHBvc3NpYmlsaXR5IG9mIGFsdGVyaW5nIG95c3RlciBzbyByZWZsZWN0cyBvZmYgcGVhayAtLSB0aGVuIGNvdWxkIGFkZCAgdGhlIFJhaWxjYXJkIG9yIEdvbGQgY2FyZCBkaXNjb3VudCB0byB5b3VyIE95c3RlciBhbmQgMS04ICB6b25lcyBvciB0byA5IHdpdGhvdXQgd2F0Zm9yZFxuLy8gQ0FOIERPIEFQUFJFTlRJQ0UsIDE4KyBTVFVERU5ULCAxNisgWklQLCBKT0IgQ0VOVFJFIE9OIE9ZU1RFUiAtIGFzIG5vIGRpZmYgYncgb2ZmIHBlYWsgLyBvbiBwZWFrIGRhaWx5IGNhcHNcbi8vIE5CIFdlZWtseSBjYXBwaW5nIGlzIGFsd2F5cyBhbnl0aW1lICYgZGFpbHkgY2FwcGluZyBhbHdheXMgc3RhcnRzIGF0IHpvbmUgMVxuXG4vLyBnZXREYXRhLnN0YXRpb25zKCkudGhlbihmdW5jdGlvbiAoc3RhdGlvbnMpIHtcbi8vIFx0Z2V0U2luZ2xlSm91cm5leVpvbmVzKCcxMDAwMDI5JywgJzEwMDAxMzgnLCBzdGF0aW9ucykudGhlbigocmVzcCkgPT4ge1xuLy8gXHRcdC8vIGNvbnNvbGUubG9nKHJlc3ApO1xuLy8gXHR9KTtcbi8vIH0pO1xuXG5nZXREYXRhLmZhcmVzKCkudGhlbihmdW5jdGlvbihmYXJlRGF0YSkge1xuICBsZXQgc2luZ2xlRmFyZXMgPSBmYXJlRGF0YS5zaW5nbGVGYXJlcztcbiAgbGV0IGRhaWx5Q2FwcyA9IGZhcmVEYXRhLmRhaWx5Q2FwcztcblxuICBjb25zdCBqb3VybmV5cyA9IFtcbiAgICB7XG4gICAgICB6b25lczogWzEsIDJdLFxuICAgICAgZHVhbFpvbmVPdmVybGFwOiBmYWxzZSxcbiAgICAgIHR5cGU6IFwib2ZmUGVha1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgem9uZXM6IFsxLCAyXSxcbiAgICAgIGR1YWxab25lT3ZlcmxhcDogZmFsc2UsXG4gICAgICB0eXBlOiBcIm9mZlBlYWtcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHpvbmVzOiBbMSwgMl0sXG4gICAgICBkdWFsWm9uZU92ZXJsYXA6IGZhbHNlLFxuICAgICAgdHlwZTogXCJvZmZQZWFrXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB6b25lczogWzEsIDJdLFxuICAgICAgZHVhbFpvbmVPdmVybGFwOiBmYWxzZSxcbiAgICAgIHR5cGU6IFwib2ZmUGVha1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgem9uZXM6IFsxLCAyXSxcbiAgICAgIGR1YWxab25lT3ZlcmxhcDogZmFsc2UsXG4gICAgICB0eXBlOiBcImFueXRpbWVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHpvbmVzOiBbMSwgMl0sXG4gICAgICBkdWFsWm9uZU92ZXJsYXA6IGZhbHNlLFxuICAgICAgdHlwZTogXCJhbnl0aW1lXCIsXG4gICAgfSxcbiAgXTtcblxuXHRjb25zb2xlLmxvZyhcbiAgICAgIG95c3RlckRheVRvdGFsKHtcbiAgICBcdFx0bWluVHJhdmVsY2FyZDogMyxcbiAgICBcdFx0bWF4VHJhdmVsY2FyZDogNCxcbiAgICBcdH0sIHtcbiAgICAgICAgam91cm5leXMsXG4gICAgICAgIGRhaWx5Q2FwcywgLy9KU09OXG4gICAgICAgIHNpbmdsZUZhcmVzLFxuICAgICAgfSlcbiAgICApO1xufSk7XG4vLyAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gLy8gLSBDT05UQUNUTEVTUyBDaGVhcGVzdCBGYXJlID0gd2l0aCBkYWlseSBjYXBzXG4vLyBcdC8vVGhlIGFycmF5IG9mIGFsbCBjb21iaW5hdGlvbiBwcmljZXMgdG8gYmUgcmVkdWNlIHRvIGNoZWFwZXN0IG9uZVxuLy8gXHRsZXQgY29uQWxsRmFyZXMgPSBbXTtcblxuLy8gXHQvLyBmb3Igd2l0aG91dCBhbnkgZGFpbHkgY2Fwcywgb25seSBzaW5nbGVzIGFkZGVkIHRvZ2V0aGVyXG4vLyBcdGxldCBjb25GYXJlcyA9IG51bGw7XG4vLyBcdGpvdXJuZXlzLmZvckVhY2goZnVuY3Rpb24oam91cm5leSkge1xuLy8gXHRcdGNvbkZhcmVzICs9IGdldFNpbmdsZUZhcmUoam91cm5leS56b25lcywgc2luZ2xlRmFyZXMpO1xuLy8gXHR9KTtcbi8vIFx0Y29uQWxsRmFyZXMucHVzaChjb25GYXJlcyk7XG5cbi8vIFx0Ly8gXHRUaGVuIGZvciBlYWNoIFpvbmUgcmFuZ2UgKGZyb20gWm9uZSAxLTMgdW50aWwgWm9uZSAxIHRvIG1heCkgcmVwZWF0IHNhbWUgY2FsY3VsYXRpb24uXG4vLyBcdCBsZXQgY29uTWF4Wm9uZSA9IG1heE51bShmbGF0dGVuKGpvdXJuZXlzLm1hcChqID0+IGouem9uZXMpKSk7XG4vLyBcdCBmb3IgKGxldCBpID0gMjsgaSA8PSBjb25NYXhab25lOyBpKyspIHtcbi8vIFx0IFx0Ly9jb25zb2xlLmxvZygnZm9yIGRhaWx5IGNhcCAxIHRvICcgKyBpKTtcbi8vIFx0IFx0bGV0IGNvbkN1bVRvdGFsID0gZ2V0RGFpbHlDYXAoaSwgZGFpbHlDYXBzKTtcbi8vIFx0IFx0IGZvciAobGV0IHggPSAwOyB4IDwgam91cm5leXMubGVuZ3RoOyB4KyspIHtcbi8vIFx0IFx0IFx0Ly9hZGRpbmcgZXh0ZW5zaW9uIGZhcmVzIHRvIGN1bVRvdGFsXG4vLyBcdCBcdFx0Y29uQ3VtVG90YWwgKz0gZXh0ZW5zaW9uRmFyZXMoMSwgaSwgam91cm5leXNbeF1bMF0sIGpvdXJuZXlzW3hdWzFdLCBzaW5nbGVGYXJlcyk7XG4vLyBcdCBcdCB9O1xuLy8gXHQgXHRjb25BbGxGYXJlcy5wdXNoKGNvbkN1bVRvdGFsKTtcbi8vIFx0IH1cblxuLy8gXHQvLyBcdC0tLT4gQ29tcGFyZSBhbGwgdGhlIHBvc3NpYmlsaXRpZXMgYW5kIHNlbGVjdCB0aGUgY2hlYXBlc3QgKGluY2x1ZGluZyB0b3RhbCBzaW5nbGUpLlxuLy8gXHRyZXR1cm4gbWluTnVtKGNvbkFsbEZhcmVzKTtcbi8vIFx0Ly90aGlzIHJldHVybnMgdGhlIGZpbmFsIGNvbnRhY3RsZXNzIGRhaWx5IGZhcmVcbi8vIH0pO1xuXG4vL0NPTlRBQ1RMRVNTXG4vL0ZvciBqdXN0IGRhaWx5IGNhcHMgT1Igd2Vla2x5IGNhcCB3aXRob3V0IGRhaWx5IGNhcDogdXNlIGV4dGVuc2lvbiBmYXJlcyB3aXRob3V0IG1heCBkYWlseVxuLy9Gb3IgY29tYm8gb2YgZGFpbHkgY2FwIGFuZCB3ZWVrbHkgY2FwOiB1c2UgZXh0ZW5zaW9uIGZhcmVzIHdpdGggbWF4IGRhaWx5IGNhcFxuLy9cbi8vIE9GRiBQRUFLIERBSUxZIGFuZCBXRUVLTFk6IEZvciBvZmYgcGVhayBkYWlseSBjYXAgY29tYm9zOiBpZiBvZmYgcGVhaywgdXNlIGV4dGVuc2lvbiBmYXJlcyB0byBjYWxjdWxhdGUgdXNpbmcgYm90aCBkYWlseSBhbmQgd2Vla2x5IGNhcHNcbi8vIC0tLSB3aGlsc3QgaWYgcGVhayB0cmF2ZWwgdGhlbiB1c2UgZXh0ZW5zaW9uIGZhcmVzIHdpdGggb25seSB3ZWVrbHkgdHJhdmVsIGNhcmQgY2FwcyBhbmQgYWRkIHRvIHRvdGFsXG4vLyBBTllUSU1FIERBSUxZIGFuZCBXRUVLTFk6IHVzZSB0aGUgZXh0ZW5zaW9uIGZhcmUgdG8gY2FsY3VsYXRlIGFsbCBmYXJlcyB3aXRoIGRhaWx5IGFueXRpbWUgY2FwIGFuZCB3ZWVrbHkgY2FwIChjdXJyZW50IHNldCB1cClcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2FwcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=